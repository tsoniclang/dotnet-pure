// Generated by tsbindgen - Architecture
// Namespace: System.Threading.Tasks.Dataflow
// Assembly: System.Threading.Tasks.Dataflow

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { IAsyncEnumerable_1, IEnumerable_1, IList_1 } from "../../System.Collections.Generic/internal/index.js";
import type { Task, Task_1, TaskScheduler } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Boolean as ClrBoolean, Enum, Exception, Func_2, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int32, Int64, IObservable_1, IObserver_1, ISpanFormattable, Object as ClrObject, Predicate_1, String as ClrString, TimeSpan, Tuple_2, Tuple_3, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

export enum DataflowMessageStatus {
    Accepted = 0,
    Declined = 1,
    Postponed = 2,
    NotAvailable = 3,
    DecliningPermanently = 4
}


export interface IDataflowBlock$instance {
    readonly Completion: Task;
    Complete(): void;
    Fault(exception: Exception): void;
}


export type IDataflowBlock = IDataflowBlock$instance;

export interface IPropagatorBlock_2$instance<TInput, TOutput> extends ITargetBlock_1<TInput>, IDataflowBlock, ISourceBlock_1<TOutput> {
    readonly Completion: Task;
    Complete(): void;
    ConsumeMessage(messageHeader: DataflowMessageHeader, target: ITargetBlock_1<TOutput>, messageConsumed: boolean): TOutput;
    Fault(exception: Exception): void;
    LinkTo(target: ITargetBlock_1<TOutput>, linkOptions: DataflowLinkOptions): IDisposable;
    OfferMessage(messageHeader: DataflowMessageHeader, messageValue: TInput, source: ISourceBlock_1<TInput>, consumeToAccept: boolean): DataflowMessageStatus;
    ReleaseReservation(messageHeader: DataflowMessageHeader, target: ITargetBlock_1<TOutput>): void;
    ReserveMessage(messageHeader: DataflowMessageHeader, target: ITargetBlock_1<TOutput>): boolean;
}


export type IPropagatorBlock_2<TInput, TOutput> = IPropagatorBlock_2$instance<TInput, TOutput>;

export interface IReceivableSourceBlock_1$instance<TOutput> extends ISourceBlock_1<TOutput>, IDataflowBlock {
    readonly Completion: Task;
    Complete(): void;
    ConsumeMessage(messageHeader: DataflowMessageHeader, target: ITargetBlock_1<TOutput>, messageConsumed: boolean): TOutput;
    Fault(exception: Exception): void;
    LinkTo(target: ITargetBlock_1<TOutput>, linkOptions: DataflowLinkOptions): IDisposable;
    ReleaseReservation(messageHeader: DataflowMessageHeader, target: ITargetBlock_1<TOutput>): void;
    ReserveMessage(messageHeader: DataflowMessageHeader, target: ITargetBlock_1<TOutput>): boolean;
    TryReceive(filter: Predicate_1<TOutput>, item: TOutput): boolean;
    TryReceiveAll(items: IList_1<TOutput>): boolean;
}


export type IReceivableSourceBlock_1<TOutput> = IReceivableSourceBlock_1$instance<TOutput>;

export interface ISourceBlock_1$instance<TOutput> extends IDataflowBlock {
    readonly Completion: Task;
    Complete(): void;
    ConsumeMessage(messageHeader: DataflowMessageHeader, target: ITargetBlock_1<TOutput>, messageConsumed: boolean): TOutput;
    Fault(exception: Exception): void;
    LinkTo(target: ITargetBlock_1<TOutput>, linkOptions: DataflowLinkOptions): IDisposable;
    ReleaseReservation(messageHeader: DataflowMessageHeader, target: ITargetBlock_1<TOutput>): void;
    ReserveMessage(messageHeader: DataflowMessageHeader, target: ITargetBlock_1<TOutput>): boolean;
}


export interface ISourceBlock_1$instance<TOutput> extends IDataflowBlock$instance {}

export type ISourceBlock_1<TOutput> = ISourceBlock_1$instance<TOutput>;

export interface ITargetBlock_1$instance<TInput> extends IDataflowBlock {
    readonly Completion: Task;
    Complete(): void;
    Fault(exception: Exception): void;
    OfferMessage(messageHeader: DataflowMessageHeader, messageValue: TInput, source: ISourceBlock_1<TInput>, consumeToAccept: boolean): DataflowMessageStatus;
}


export interface ITargetBlock_1$instance<TInput> extends IDataflowBlock$instance {}

export type ITargetBlock_1<TInput> = ITargetBlock_1$instance<TInput>;

export interface DataflowMessageHeader$instance {
    readonly Id: long;
    readonly IsValid: boolean;
    Equals(other: DataflowMessageHeader): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const DataflowMessageHeader: {
    new(id: long): DataflowMessageHeader$instance;
};


export interface __DataflowMessageHeader$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<DataflowMessageHeader>;

    // Structural method bridges for numeric interface constraints
    Equals(other: DataflowMessageHeader): boolean;
}

export type DataflowMessageHeader = DataflowMessageHeader$instance & __DataflowMessageHeader$views;


export interface ActionBlock_1$instance<TInput> {
    readonly Completion: Task;
    readonly InputCount: int;
    Complete(): void;
    Post(item: TInput): boolean;
    ToString(): string;
}


export const ActionBlock_1: {
    new<TInput>(action: Action_1<TInput>): ActionBlock_1$instance<TInput>;
    new<TInput>(action: Action_1<TInput>, dataflowBlockOptions: ExecutionDataflowBlockOptions): ActionBlock_1$instance<TInput>;
    new<TInput>(action: Func_2<TInput, Task>): ActionBlock_1$instance<TInput>;
    new<TInput>(action: Func_2<TInput, Task>, dataflowBlockOptions: ExecutionDataflowBlockOptions): ActionBlock_1$instance<TInput>;
};


export interface __ActionBlock_1$views<TInput> {
    As_IDataflowBlock(): IDataflowBlock$instance;
    As_ITargetBlock_1(): ITargetBlock_1$instance<TInput>;
}

export type ActionBlock_1<TInput> = ActionBlock_1$instance<TInput> & __ActionBlock_1$views<TInput>;


export interface BatchBlock_1$instance<T> {
    readonly BatchSize: int;
    readonly Completion: Task;
    readonly OutputCount: int;
    Complete(): void;
    LinkTo(target: ITargetBlock_1<T[]>, linkOptions: DataflowLinkOptions): IDisposable;
    ToString(): string;
    TriggerBatch(): void;
    TryReceive(filter: Predicate_1<T[]>, item: T[]): boolean;
    TryReceiveAll(items: IList_1<T[]>): boolean;
}


export const BatchBlock_1: {
    new<T>(batchSize: int): BatchBlock_1$instance<T>;
    new<T>(batchSize: int, dataflowBlockOptions: GroupingDataflowBlockOptions): BatchBlock_1$instance<T>;
};


export interface __BatchBlock_1$views<T> {
    As_IDataflowBlock(): IDataflowBlock$instance;
    As_IReceivableSourceBlock_1(): IReceivableSourceBlock_1$instance<T[]>;
    As_ISourceBlock_1(): ISourceBlock_1$instance<T[]>;
    As_ITargetBlock_1(): ITargetBlock_1$instance<T>;
}

export type BatchBlock_1<T> = BatchBlock_1$instance<T> & __BatchBlock_1$views<T>;


export interface BatchedJoinBlock_2$instance<T1, T2> {
    readonly BatchSize: int;
    readonly Completion: Task;
    readonly OutputCount: int;
    readonly Target1: ITargetBlock_1<T1>;
    readonly Target2: ITargetBlock_1<T2>;
    Complete(): void;
    LinkTo(target: ITargetBlock_1<Tuple_2<IList_1<T1>, IList_1<T2>>>, linkOptions: DataflowLinkOptions): IDisposable;
    ToString(): string;
    TryReceive(filter: Predicate_1<Tuple_2<IList_1<T1>, IList_1<T2>>>, item: Tuple_2<IList_1<T1>, IList_1<T2>>): boolean;
    TryReceiveAll(items: IList_1<Tuple_2<IList_1<T1>, IList_1<T2>>>): boolean;
}


export const BatchedJoinBlock_2: {
    new<T1, T2>(batchSize: int): BatchedJoinBlock_2$instance<T1, T2>;
    new<T1, T2>(batchSize: int, dataflowBlockOptions: GroupingDataflowBlockOptions): BatchedJoinBlock_2$instance<T1, T2>;
};


export interface __BatchedJoinBlock_2$views<T1, T2> {
    As_IDataflowBlock(): IDataflowBlock$instance;
    As_IReceivableSourceBlock_1(): IReceivableSourceBlock_1$instance<Tuple_2<IList_1<T1>, IList_1<T2>>>;
    As_ISourceBlock_1(): ISourceBlock_1$instance<Tuple_2<IList_1<T1>, IList_1<T2>>>;
}

export type BatchedJoinBlock_2<T1, T2> = BatchedJoinBlock_2$instance<T1, T2> & __BatchedJoinBlock_2$views<T1, T2>;


export interface BatchedJoinBlock_3$instance<T1, T2, T3> {
    readonly BatchSize: int;
    readonly Completion: Task;
    readonly OutputCount: int;
    readonly Target1: ITargetBlock_1<T1>;
    readonly Target2: ITargetBlock_1<T2>;
    readonly Target3: ITargetBlock_1<T3>;
    Complete(): void;
    LinkTo(target: ITargetBlock_1<Tuple_3<IList_1<T1>, IList_1<T2>, IList_1<T3>>>, linkOptions: DataflowLinkOptions): IDisposable;
    ToString(): string;
    TryReceive(filter: Predicate_1<Tuple_3<IList_1<T1>, IList_1<T2>, IList_1<T3>>>, item: Tuple_3<IList_1<T1>, IList_1<T2>, IList_1<T3>>): boolean;
    TryReceiveAll(items: IList_1<Tuple_3<IList_1<T1>, IList_1<T2>, IList_1<T3>>>): boolean;
}


export const BatchedJoinBlock_3: {
    new<T1, T2, T3>(batchSize: int): BatchedJoinBlock_3$instance<T1, T2, T3>;
    new<T1, T2, T3>(batchSize: int, dataflowBlockOptions: GroupingDataflowBlockOptions): BatchedJoinBlock_3$instance<T1, T2, T3>;
};


export interface __BatchedJoinBlock_3$views<T1, T2, T3> {
    As_IDataflowBlock(): IDataflowBlock$instance;
    As_IReceivableSourceBlock_1(): IReceivableSourceBlock_1$instance<Tuple_3<IList_1<T1>, IList_1<T2>, IList_1<T3>>>;
    As_ISourceBlock_1(): ISourceBlock_1$instance<Tuple_3<IList_1<T1>, IList_1<T2>, IList_1<T3>>>;
}

export type BatchedJoinBlock_3<T1, T2, T3> = BatchedJoinBlock_3$instance<T1, T2, T3> & __BatchedJoinBlock_3$views<T1, T2, T3>;


export interface BroadcastBlock_1$instance<T> {
    readonly Completion: Task;
    Complete(): void;
    LinkTo(target: ITargetBlock_1<T>, linkOptions: DataflowLinkOptions): IDisposable;
    ToString(): string;
    TryReceive(filter: Predicate_1<T>, item: T): boolean;
}


export const BroadcastBlock_1: {
    new<T>(cloningFunction: Func_2<T, T>): BroadcastBlock_1$instance<T>;
    new<T>(cloningFunction: Func_2<T, T>, dataflowBlockOptions: DataflowBlockOptions): BroadcastBlock_1$instance<T>;
};


export interface __BroadcastBlock_1$views<T> {
    As_IDataflowBlock(): IDataflowBlock$instance;
    As_IReceivableSourceBlock_1(): IReceivableSourceBlock_1$instance<T>;
    As_ISourceBlock_1(): ISourceBlock_1$instance<T>;
    As_ITargetBlock_1(): ITargetBlock_1$instance<T>;
}

export type BroadcastBlock_1<T> = BroadcastBlock_1$instance<T> & __BroadcastBlock_1$views<T>;


export interface BufferBlock_1$instance<T> {
    readonly Completion: Task;
    readonly Count: int;
    Complete(): void;
    LinkTo(target: ITargetBlock_1<T>, linkOptions: DataflowLinkOptions): IDisposable;
    ToString(): string;
    TryReceive(filter: Predicate_1<T>, item: T): boolean;
    TryReceiveAll(items: IList_1<T>): boolean;
}


export const BufferBlock_1: {
    new<T>(): BufferBlock_1$instance<T>;
    new<T>(dataflowBlockOptions: DataflowBlockOptions): BufferBlock_1$instance<T>;
};


export interface __BufferBlock_1$views<T> {
    As_IDataflowBlock(): IDataflowBlock$instance;
    As_IReceivableSourceBlock_1(): IReceivableSourceBlock_1$instance<T>;
    As_ISourceBlock_1(): ISourceBlock_1$instance<T>;
    As_ITargetBlock_1(): ITargetBlock_1$instance<T>;
}

export type BufferBlock_1<T> = BufferBlock_1$instance<T> & __BufferBlock_1$views<T>;


export interface DataflowBlockOptions$instance {
    BoundedCapacity: int;
    CancellationToken: CancellationToken;
    EnsureOrdered: boolean;
    MaxMessagesPerTask: int;
    NameFormat: string;
    TaskScheduler: TaskScheduler;
}


export const DataflowBlockOptions: {
    new(): DataflowBlockOptions$instance;
    readonly Unbounded: int;
};


export type DataflowBlockOptions = DataflowBlockOptions$instance;

export interface DataflowLinkOptions$instance {
    Append: boolean;
    MaxMessages: int;
    PropagateCompletion: boolean;
}


export const DataflowLinkOptions: {
    new(): DataflowLinkOptions$instance;
};


export type DataflowLinkOptions = DataflowLinkOptions$instance;

export interface ExecutionDataflowBlockOptions$instance extends DataflowBlockOptions {
    MaxDegreeOfParallelism: int;
    SingleProducerConstrained: boolean;
}


export const ExecutionDataflowBlockOptions: {
    new(): ExecutionDataflowBlockOptions$instance;
};


export type ExecutionDataflowBlockOptions = ExecutionDataflowBlockOptions$instance;

export interface GroupingDataflowBlockOptions$instance extends DataflowBlockOptions {
    Greedy: boolean;
    MaxNumberOfGroups: long;
}


export const GroupingDataflowBlockOptions: {
    new(): GroupingDataflowBlockOptions$instance;
};


export type GroupingDataflowBlockOptions = GroupingDataflowBlockOptions$instance;

export interface JoinBlock_2$instance<T1, T2> {
    readonly Completion: Task;
    readonly OutputCount: int;
    readonly Target1: ITargetBlock_1<T1>;
    readonly Target2: ITargetBlock_1<T2>;
    Complete(): void;
    LinkTo(target: ITargetBlock_1<Tuple_2<T1, T2>>, linkOptions: DataflowLinkOptions): IDisposable;
    ToString(): string;
    TryReceive(filter: Predicate_1<Tuple_2<T1, T2>>, item: Tuple_2<T1, T2>): boolean;
    TryReceiveAll(items: IList_1<Tuple_2<T1, T2>>): boolean;
}


export const JoinBlock_2: {
    new<T1, T2>(): JoinBlock_2$instance<T1, T2>;
    new<T1, T2>(dataflowBlockOptions: GroupingDataflowBlockOptions): JoinBlock_2$instance<T1, T2>;
};


export interface __JoinBlock_2$views<T1, T2> {
    As_IDataflowBlock(): IDataflowBlock$instance;
    As_IReceivableSourceBlock_1(): IReceivableSourceBlock_1$instance<Tuple_2<T1, T2>>;
    As_ISourceBlock_1(): ISourceBlock_1$instance<Tuple_2<T1, T2>>;
}

export type JoinBlock_2<T1, T2> = JoinBlock_2$instance<T1, T2> & __JoinBlock_2$views<T1, T2>;


export interface JoinBlock_3$instance<T1, T2, T3> {
    readonly Completion: Task;
    readonly OutputCount: int;
    readonly Target1: ITargetBlock_1<T1>;
    readonly Target2: ITargetBlock_1<T2>;
    readonly Target3: ITargetBlock_1<T3>;
    Complete(): void;
    LinkTo(target: ITargetBlock_1<Tuple_3<T1, T2, T3>>, linkOptions: DataflowLinkOptions): IDisposable;
    ToString(): string;
    TryReceive(filter: Predicate_1<Tuple_3<T1, T2, T3>>, item: Tuple_3<T1, T2, T3>): boolean;
    TryReceiveAll(items: IList_1<Tuple_3<T1, T2, T3>>): boolean;
}


export const JoinBlock_3: {
    new<T1, T2, T3>(): JoinBlock_3$instance<T1, T2, T3>;
    new<T1, T2, T3>(dataflowBlockOptions: GroupingDataflowBlockOptions): JoinBlock_3$instance<T1, T2, T3>;
};


export interface __JoinBlock_3$views<T1, T2, T3> {
    As_IDataflowBlock(): IDataflowBlock$instance;
    As_IReceivableSourceBlock_1(): IReceivableSourceBlock_1$instance<Tuple_3<T1, T2, T3>>;
    As_ISourceBlock_1(): ISourceBlock_1$instance<Tuple_3<T1, T2, T3>>;
}

export type JoinBlock_3<T1, T2, T3> = JoinBlock_3$instance<T1, T2, T3> & __JoinBlock_3$views<T1, T2, T3>;


export interface TransformBlock_2$instance<TInput, TOutput> {
    readonly Completion: Task;
    readonly InputCount: int;
    readonly OutputCount: int;
    Complete(): void;
    LinkTo(target: ITargetBlock_1<TOutput>, linkOptions: DataflowLinkOptions): IDisposable;
    ToString(): string;
    TryReceive(filter: Predicate_1<TOutput>, item: TOutput): boolean;
    TryReceiveAll(items: IList_1<TOutput>): boolean;
}


export const TransformBlock_2: {
    new<TInput, TOutput>(transform: Func_2<TInput, TOutput>): TransformBlock_2$instance<TInput, TOutput>;
    new<TInput, TOutput>(transform: Func_2<TInput, TOutput>, dataflowBlockOptions: ExecutionDataflowBlockOptions): TransformBlock_2$instance<TInput, TOutput>;
};


export interface __TransformBlock_2$views<TInput, TOutput> {
    As_IDataflowBlock(): IDataflowBlock$instance;
    As_IReceivableSourceBlock_1(): IReceivableSourceBlock_1$instance<TOutput>;
    As_ISourceBlock_1(): ISourceBlock_1$instance<TOutput>;
    As_ITargetBlock_1(): ITargetBlock_1$instance<TInput>;
}

export type TransformBlock_2<TInput, TOutput> = TransformBlock_2$instance<TInput, TOutput> & __TransformBlock_2$views<TInput, TOutput>;


export interface TransformManyBlock_2$instance<TInput, TOutput> {
    readonly Completion: Task;
    readonly InputCount: int;
    readonly OutputCount: int;
    Complete(): void;
    LinkTo(target: ITargetBlock_1<TOutput>, linkOptions: DataflowLinkOptions): IDisposable;
    ToString(): string;
    TryReceive(filter: Predicate_1<TOutput>, item: TOutput): boolean;
    TryReceiveAll(items: IList_1<TOutput>): boolean;
}


export const TransformManyBlock_2: {
    new<TInput, TOutput>(transform: Func_2<TInput, IEnumerable_1<TOutput>>): TransformManyBlock_2$instance<TInput, TOutput>;
    new<TInput, TOutput>(transform: Func_2<TInput, IEnumerable_1<TOutput>>, dataflowBlockOptions: ExecutionDataflowBlockOptions): TransformManyBlock_2$instance<TInput, TOutput>;
};


export interface __TransformManyBlock_2$views<TInput, TOutput> {
    As_IDataflowBlock(): IDataflowBlock$instance;
    As_IReceivableSourceBlock_1(): IReceivableSourceBlock_1$instance<TOutput>;
    As_ISourceBlock_1(): ISourceBlock_1$instance<TOutput>;
    As_ITargetBlock_1(): ITargetBlock_1$instance<TInput>;
}

export type TransformManyBlock_2<TInput, TOutput> = TransformManyBlock_2$instance<TInput, TOutput> & __TransformManyBlock_2$views<TInput, TOutput>;


export interface WriteOnceBlock_1$instance<T> {
    readonly Completion: Task;
    Complete(): void;
    LinkTo(target: ITargetBlock_1<T>, linkOptions: DataflowLinkOptions): IDisposable;
    ToString(): string;
    TryReceive(filter: Predicate_1<T>, item: T): boolean;
}


export const WriteOnceBlock_1: {
    new<T>(cloningFunction: Func_2<T, T>): WriteOnceBlock_1$instance<T>;
    new<T>(cloningFunction: Func_2<T, T>, dataflowBlockOptions: DataflowBlockOptions): WriteOnceBlock_1$instance<T>;
};


export interface __WriteOnceBlock_1$views<T> {
    As_IDataflowBlock(): IDataflowBlock$instance;
    As_IReceivableSourceBlock_1(): IReceivableSourceBlock_1$instance<T>;
    As_ISourceBlock_1(): ISourceBlock_1$instance<T>;
    As_ITargetBlock_1(): ITargetBlock_1$instance<T>;
}

export type WriteOnceBlock_1<T> = WriteOnceBlock_1$instance<T> & __WriteOnceBlock_1$views<T>;


export abstract class DataflowBlock$instance {
    static AsObservable<TOutput>(source: ISourceBlock_1<TOutput>): IObservable_1<TOutput>;
    static AsObserver<TInput>(target: ITargetBlock_1<TInput>): IObserver_1<TInput>;
    static Choose<T1, T2, T3>(source1: ISourceBlock_1<T1>, action1: Action_1<T1>, source2: ISourceBlock_1<T2>, action2: Action_1<T2>, source3: ISourceBlock_1<T3>, action3: Action_1<T3>, dataflowBlockOptions: DataflowBlockOptions): Task_1<System_Internal.Int32>;
    static Choose<T1, T2, T3>(source1: ISourceBlock_1<T1>, action1: Action_1<T1>, source2: ISourceBlock_1<T2>, action2: Action_1<T2>, source3: ISourceBlock_1<T3>, action3: Action_1<T3>): Task_1<System_Internal.Int32>;
    static Choose<T1, T2>(source1: ISourceBlock_1<T1>, action1: Action_1<T1>, source2: ISourceBlock_1<T2>, action2: Action_1<T2>, dataflowBlockOptions: DataflowBlockOptions): Task_1<System_Internal.Int32>;
    static Choose<T1, T2>(source1: ISourceBlock_1<T1>, action1: Action_1<T1>, source2: ISourceBlock_1<T2>, action2: Action_1<T2>): Task_1<System_Internal.Int32>;
    static Encapsulate<TInput, TOutput>(target: ITargetBlock_1<TInput>, source: ISourceBlock_1<TOutput>): IPropagatorBlock_2<TInput, TOutput>;
    static LinkTo<TOutput>(source: ISourceBlock_1<TOutput>, target: ITargetBlock_1<TOutput>, predicate: Predicate_1<TOutput>): IDisposable;
    static LinkTo<TOutput>(source: ISourceBlock_1<TOutput>, target: ITargetBlock_1<TOutput>, linkOptions: DataflowLinkOptions, predicate: Predicate_1<TOutput>): IDisposable;
    static LinkTo<TOutput>(source: ISourceBlock_1<TOutput>, target: ITargetBlock_1<TOutput>): IDisposable;
    static NullTarget<TInput>(): ITargetBlock_1<TInput>;
    static OutputAvailableAsync<TOutput>(source: ISourceBlock_1<TOutput>, cancellationToken: CancellationToken): Task_1<System_Internal.Boolean>;
    static OutputAvailableAsync<TOutput>(source: ISourceBlock_1<TOutput>): Task_1<System_Internal.Boolean>;
    static Post<TInput>(target: ITargetBlock_1<TInput>, item: TInput): boolean;
    static Receive<TOutput>(source: ISourceBlock_1<TOutput>, cancellationToken: CancellationToken): TOutput;
    static Receive<TOutput>(source: ISourceBlock_1<TOutput>, timeout: TimeSpan, cancellationToken: CancellationToken): TOutput;
    static Receive<TOutput>(source: ISourceBlock_1<TOutput>, timeout: TimeSpan): TOutput;
    static Receive<TOutput>(source: ISourceBlock_1<TOutput>): TOutput;
    static ReceiveAllAsync<TOutput>(source: IReceivableSourceBlock_1<TOutput>, cancellationToken?: CancellationToken): IAsyncEnumerable_1<TOutput>;
    static ReceiveAsync<TOutput>(source: ISourceBlock_1<TOutput>, cancellationToken: CancellationToken): Task_1<TOutput>;
    static ReceiveAsync<TOutput>(source: ISourceBlock_1<TOutput>, timeout: TimeSpan, cancellationToken: CancellationToken): Task_1<TOutput>;
    static ReceiveAsync<TOutput>(source: ISourceBlock_1<TOutput>, timeout: TimeSpan): Task_1<TOutput>;
    static ReceiveAsync<TOutput>(source: ISourceBlock_1<TOutput>): Task_1<TOutput>;
    static SendAsync<TInput>(target: ITargetBlock_1<TInput>, item: TInput, cancellationToken: CancellationToken): Task_1<System_Internal.Boolean>;
    static SendAsync<TInput>(target: ITargetBlock_1<TInput>, item: TInput): Task_1<System_Internal.Boolean>;
    static TryReceive<TOutput>(source: IReceivableSourceBlock_1<TOutput>, item: TOutput): boolean;
}


export type DataflowBlock = DataflowBlock$instance;


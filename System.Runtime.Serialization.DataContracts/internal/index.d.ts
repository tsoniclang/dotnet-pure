// Generated by tsbindgen - Architecture
// Namespace: System.Runtime.Serialization.DataContracts
// Assembly: System.Private.DataContractSerialization

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { Dictionary_2, IEnumerable_1, List_1 } from "../../System.Collections.Generic/internal/index.js";
import type { ReadOnlyCollection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import type { Hashtable } from "../../System.Collections/internal/index.js";
import type { ISerializationSurrogateProvider } from "../../System.Runtime.Serialization/internal/index.js";
import type { XmlSchemaElement, XmlSchemaSet, XmlSchemaType } from "../../System.Xml.Schema/internal/index.js";
import type { XmlDictionaryString, XmlQualifiedName } from "../../System.Xml/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Int32, Int64, Nullable_1, Object as ClrObject, String as ClrString, Type, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface DataContract$instance {
    readonly BaseContract: DataContract;
    readonly ContractType: string;
    readonly DataMembers: ReadOnlyCollection_1<DataMember>;
    readonly IsBuiltInDataContract: boolean;
    readonly IsISerializable: boolean;
    readonly IsReference: boolean;
    readonly IsValueType: boolean;
    readonly KnownDataContracts: Dictionary_2<XmlQualifiedName, DataContract>;
    readonly OriginalUnderlyingType: Type;
    readonly TopLevelElementName: XmlDictionaryString;
    readonly TopLevelElementNamespace: XmlDictionaryString;
    readonly UnderlyingType: Type;
    readonly XmlName: XmlQualifiedName;
    Equals(obj: unknown): boolean;
    GetArrayTypeName(isNullable: boolean): XmlQualifiedName;
    GetHashCode(): int;
    IsDictionaryLike(keyName: { value: ref<string> }, valueName: { value: ref<string> }, itemName: { value: ref<string> }): boolean;
}


export const DataContract: {
    GetBuiltInDataContract(name: string, ns: string): DataContract;
    GetXmlName(type_: Type): XmlQualifiedName;
};


export type DataContract = DataContract$instance;

export interface DataContractSet$instance {
    readonly Contracts: Dictionary_2<XmlQualifiedName, DataContract>;
    readonly KnownTypesForObject: Dictionary_2<XmlQualifiedName, DataContract>;
    readonly ProcessedContracts: Dictionary_2<DataContract, unknown>;
    readonly SurrogateData: Hashtable;
    GetDataContract(type_: Type): DataContract;
    GetDataContract(key: XmlQualifiedName): DataContract;
    GetReferencedType(xmlName: XmlQualifiedName, dataContract: DataContract, referencedContract: { value: ref<DataContract> }, genericParameters: { value: ref<unknown[]> }, supportGenericTypes?: Nullable_1<CLROf<boolean>>): Type;
    ImportSchemaSet(schemaSet: XmlSchemaSet, typeNames: IEnumerable_1<XmlQualifiedName>, importXmlDataType: boolean): void;
    ImportSchemaSet(schemaSet: XmlSchemaSet, elements: IEnumerable_1<XmlSchemaElement>, importXmlDataType: boolean): List_1<XmlQualifiedName>;
}


export const DataContractSet: {
    new(dataContractSurrogate: ISerializationSurrogateProvider, referencedTypes: IEnumerable_1<Type>, referencedCollectionTypes: IEnumerable_1<Type>): DataContractSet$instance;
    new(dataContractSet: DataContractSet): DataContractSet$instance;
};


export type DataContractSet = DataContractSet$instance;

export interface DataMember$instance {
    readonly EmitDefaultValue: boolean;
    readonly IsNullable: boolean;
    readonly IsRequired: boolean;
    readonly MemberTypeContract: DataContract;
    readonly Name: string;
    readonly Order: long;
}


export const DataMember: {
    new(): DataMember$instance;
};


export type DataMember = DataMember$instance;

export interface XmlDataContract$instance extends DataContract {
    readonly ContractType: string;
    readonly HasRoot: boolean;
    readonly IsAnonymous: boolean;
    readonly IsBuiltInDataContract: boolean;
    readonly IsTopLevelElementNullable: boolean;
    IsTypeDefinedOnImport: boolean;
    IsValueType: boolean;
    readonly KnownDataContracts: Dictionary_2<XmlQualifiedName, DataContract>;
    readonly TopLevelElementName: XmlDictionaryString;
    readonly TopLevelElementNamespace: XmlDictionaryString;
    readonly XsdType: XmlSchemaType;
}


export const XmlDataContract: {
    new(): XmlDataContract$instance;
};


export type XmlDataContract = XmlDataContract$instance;


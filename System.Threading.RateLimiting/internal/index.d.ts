// Generated by tsbindgen - Architecture
// Namespace: System.Threading.RateLimiting
// Assembly: System.Threading.RateLimiting

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { IEnumerable_1, IEqualityComparer_1, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import type { ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Enum, Func_2, IAsyncDisposable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int32, Int64, ISpanFormattable, Nullable_1, Object as ClrObject, String as ClrString, TimeSpan, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

export enum QueueProcessingOrder {
    OldestFirst = 0,
    NewestFirst = 1
}


export interface RateLimitPartition_1$instance<TKey> {
    readonly Factory: Func_2<TKey, RateLimiter>;
    readonly PartitionKey: TKey;
}


export const RateLimitPartition_1: {
    new<TKey>(partitionKey: TKey, factory: Func_2<TKey, RateLimiter>): RateLimitPartition_1<TKey>;
};


export type RateLimitPartition_1<TKey> = RateLimitPartition_1$instance<TKey>;

export interface ConcurrencyLimiter$instance extends RateLimiter$instance {
    readonly IdleDuration: Nullable_1<TimeSpan>;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    GetStatistics(): RateLimiterStatistics | undefined;
}


export const ConcurrencyLimiter: {
    new(options: ConcurrencyLimiterOptions): ConcurrencyLimiter;
};


export interface __ConcurrencyLimiter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ConcurrencyLimiter = ConcurrencyLimiter$instance & __ConcurrencyLimiter$views;


export interface ConcurrencyLimiterOptions$instance {
    PermitLimit: int;
    QueueLimit: int;
    QueueProcessingOrder: QueueProcessingOrder;
}


export const ConcurrencyLimiterOptions: {
    new(): ConcurrencyLimiterOptions;
};


export type ConcurrencyLimiterOptions = ConcurrencyLimiterOptions$instance;

export interface FixedWindowRateLimiter$instance extends ReplenishingRateLimiter$instance {
    readonly IdleDuration: Nullable_1<TimeSpan>;
    readonly IsAutoReplenishing: boolean;
    readonly ReplenishmentPeriod: TimeSpan;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    GetStatistics(): RateLimiterStatistics | undefined;
    TryReplenish(): boolean;
}


export const FixedWindowRateLimiter: {
    new(options: FixedWindowRateLimiterOptions): FixedWindowRateLimiter;
};


export interface __FixedWindowRateLimiter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type FixedWindowRateLimiter = FixedWindowRateLimiter$instance & __FixedWindowRateLimiter$views;


export interface FixedWindowRateLimiterOptions$instance {
    AutoReplenishment: boolean;
    PermitLimit: int;
    QueueLimit: int;
    QueueProcessingOrder: QueueProcessingOrder;
    Window: TimeSpan;
}


export const FixedWindowRateLimiterOptions: {
    new(): FixedWindowRateLimiterOptions;
};


export type FixedWindowRateLimiterOptions = FixedWindowRateLimiterOptions$instance;

export interface MetadataName_1$instance<T> {
    readonly Name: string;
    Equals(obj: unknown): boolean;
    Equals(other: MetadataName_1<T>): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const MetadataName_1: {
    new<T>(name: string): MetadataName_1<T>;
};


export interface __MetadataName_1$views<T> {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<MetadataName_1<T>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: MetadataName_1<T>): boolean;
}

export type MetadataName_1<T> = MetadataName_1$instance<T> & __MetadataName_1$views<T>;


export interface PartitionedRateLimiter_1$instance<TResource> {
    AcquireAsync(resource: TResource, permitCount?: int, cancellationToken?: CancellationToken): ValueTask_1<RateLimitLease>;
    AttemptAcquire(resource: TResource, permitCount?: int): RateLimitLease;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    GetStatistics(resource: TResource): RateLimiterStatistics | undefined;
    WithTranslatedKey<TOuter>(keyAdapter: Func_2<TOuter, TResource>, leaveOpen: boolean): PartitionedRateLimiter_1<TOuter>;
}


export const PartitionedRateLimiter_1: {
};


export interface __PartitionedRateLimiter_1$views<TResource> {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface PartitionedRateLimiter_1$instance<TResource> extends System_Internal.IAsyncDisposable$instance, System_Internal.IDisposable$instance {}

export type PartitionedRateLimiter_1<TResource> = PartitionedRateLimiter_1$instance<TResource> & __PartitionedRateLimiter_1$views<TResource>;


export interface RateLimiter$instance {
    readonly IdleDuration: Nullable_1<TimeSpan>;
    AcquireAsync(permitCount?: int, cancellationToken?: CancellationToken): ValueTask_1<RateLimitLease>;
    AttemptAcquire(permitCount?: int): RateLimitLease;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    GetStatistics(): RateLimiterStatistics | undefined;
}


export const RateLimiter: {
    CreateChained(...limiters: RateLimiter[]): RateLimiter;
};


export interface __RateLimiter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface RateLimiter$instance extends System_Internal.IAsyncDisposable$instance, System_Internal.IDisposable$instance {}

export type RateLimiter = RateLimiter$instance & __RateLimiter$views;


export interface RateLimiterStatistics$instance {
    CurrentAvailablePermits: long;
    CurrentQueuedCount: long;
    TotalFailedLeases: long;
    TotalSuccessfulLeases: long;
}


export const RateLimiterStatistics: {
    new(): RateLimiterStatistics;
};


export type RateLimiterStatistics = RateLimiterStatistics$instance;

export interface RateLimitLease$instance {
    readonly IsAcquired: boolean;
    readonly MetadataNames: IEnumerable_1<System_Internal.String>;
    Dispose(): void;
    GetAllMetadata(): IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>;
    TryGetMetadata(metadataName: string, metadata: unknown): boolean;
    TryGetMetadata<T>(metadataName: MetadataName_1<T>, metadata: T): boolean;
}


export const RateLimitLease: {
};


export interface __RateLimitLease$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface RateLimitLease$instance extends System_Internal.IDisposable$instance {}

export type RateLimitLease = RateLimitLease$instance & __RateLimitLease$views;


export interface ReplenishingRateLimiter$instance extends RateLimiter$instance {
    readonly IsAutoReplenishing: boolean;
    readonly ReplenishmentPeriod: TimeSpan;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    TryReplenish(): boolean;
}


export const ReplenishingRateLimiter: {
};


export interface __ReplenishingRateLimiter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ReplenishingRateLimiter = ReplenishingRateLimiter$instance & __ReplenishingRateLimiter$views;


export interface SlidingWindowRateLimiter$instance extends ReplenishingRateLimiter$instance {
    readonly IdleDuration: Nullable_1<TimeSpan>;
    readonly IsAutoReplenishing: boolean;
    readonly ReplenishmentPeriod: TimeSpan;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    GetStatistics(): RateLimiterStatistics | undefined;
    TryReplenish(): boolean;
}


export const SlidingWindowRateLimiter: {
    new(options: SlidingWindowRateLimiterOptions): SlidingWindowRateLimiter;
};


export interface __SlidingWindowRateLimiter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type SlidingWindowRateLimiter = SlidingWindowRateLimiter$instance & __SlidingWindowRateLimiter$views;


export interface SlidingWindowRateLimiterOptions$instance {
    AutoReplenishment: boolean;
    PermitLimit: int;
    QueueLimit: int;
    QueueProcessingOrder: QueueProcessingOrder;
    SegmentsPerWindow: int;
    Window: TimeSpan;
}


export const SlidingWindowRateLimiterOptions: {
    new(): SlidingWindowRateLimiterOptions;
};


export type SlidingWindowRateLimiterOptions = SlidingWindowRateLimiterOptions$instance;

export interface TokenBucketRateLimiter$instance extends ReplenishingRateLimiter$instance {
    readonly IdleDuration: Nullable_1<TimeSpan>;
    readonly IsAutoReplenishing: boolean;
    readonly ReplenishmentPeriod: TimeSpan;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    GetStatistics(): RateLimiterStatistics | undefined;
    TryReplenish(): boolean;
}


export const TokenBucketRateLimiter: {
    new(options: TokenBucketRateLimiterOptions): TokenBucketRateLimiter;
};


export interface __TokenBucketRateLimiter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type TokenBucketRateLimiter = TokenBucketRateLimiter$instance & __TokenBucketRateLimiter$views;


export interface TokenBucketRateLimiterOptions$instance {
    AutoReplenishment: boolean;
    QueueLimit: int;
    QueueProcessingOrder: QueueProcessingOrder;
    ReplenishmentPeriod: TimeSpan;
    TokenLimit: int;
    TokensPerPeriod: int;
}


export const TokenBucketRateLimiterOptions: {
    new(): TokenBucketRateLimiterOptions;
};


export type TokenBucketRateLimiterOptions = TokenBucketRateLimiterOptions$instance;

export abstract class MetadataName$instance {
    static readonly RetryAfter: MetadataName_1<TimeSpan>;
    static readonly ReasonPhrase: MetadataName_1<System_Internal.String>;
    static Create<T>(name: string): MetadataName_1<T>;
}


export type MetadataName = MetadataName$instance;

export abstract class PartitionedRateLimiter$instance {
    static Create<TResource, TPartitionKey>(partitioner: Func_2<TResource, RateLimitPartition_1<TPartitionKey>>, equalityComparer?: IEqualityComparer_1<TPartitionKey>): PartitionedRateLimiter_1<TResource>;
    static CreateChained<TResource>(...limiters: PartitionedRateLimiter_1<TResource>[]): PartitionedRateLimiter_1<TResource>;
}


export type PartitionedRateLimiter = PartitionedRateLimiter$instance;

export abstract class RateLimitPartition$instance {
    static Get<TKey>(partitionKey: TKey, factory: Func_2<TKey, RateLimiter>): RateLimitPartition_1<TKey>;
    static GetConcurrencyLimiter<TKey>(partitionKey: TKey, factory: Func_2<TKey, ConcurrencyLimiterOptions>): RateLimitPartition_1<TKey>;
    static GetFixedWindowLimiter<TKey>(partitionKey: TKey, factory: Func_2<TKey, FixedWindowRateLimiterOptions>): RateLimitPartition_1<TKey>;
    static GetNoLimiter<TKey>(partitionKey: TKey): RateLimitPartition_1<TKey>;
    static GetSlidingWindowLimiter<TKey>(partitionKey: TKey, factory: Func_2<TKey, SlidingWindowRateLimiterOptions>): RateLimitPartition_1<TKey>;
    static GetTokenBucketLimiter<TKey>(partitionKey: TKey, factory: Func_2<TKey, TokenBucketRateLimiterOptions>): RateLimitPartition_1<TKey>;
}


export type RateLimitPartition = RateLimitPartition$instance;


// Generated by tsbindgen - Architecture
// Namespace: System.Text.RegularExpressions
// Assembly: System.Text.RegularExpressions

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IList_1, IReadOnlyCollection_1, IReadOnlyDictionary_2, IReadOnlyList_1, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import type { CustomAttributeBuilder } from "../../System.Reflection.Emit/internal/index.js";
import type { AssemblyName, MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { ArgumentException, Array as ClrArray, AsyncCallback, Attribute, Boolean as ClrBoolean, Char, Delegate, Enum, Exception, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, MulticastDelegate, Object as ClrObject, Range, ReadOnlySpan_1, String as ClrString, TimeoutException, TimeSpan, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

export enum RegexOptions {
    None = 0,
    IgnoreCase = 1,
    Multiline = 2,
    ExplicitCapture = 4,
    Compiled = 8,
    Singleline = 16,
    IgnorePatternWhitespace = 32,
    RightToLeft = 64,
    ECMAScript = 256,
    CultureInvariant = 512,
    NonBacktracking = 1024
}


export enum RegexParseError {
    Unknown = 0,
    AlternationHasTooManyConditions = 1,
    AlternationHasMalformedCondition = 2,
    InvalidUnicodePropertyEscape = 3,
    MalformedUnicodePropertyEscape = 4,
    UnrecognizedEscape = 5,
    UnrecognizedControlCharacter = 6,
    MissingControlCharacter = 7,
    InsufficientOrInvalidHexDigits = 8,
    QuantifierOrCaptureGroupOutOfRange = 9,
    UndefinedNamedReference = 10,
    UndefinedNumberedReference = 11,
    MalformedNamedReference = 12,
    UnescapedEndingBackslash = 13,
    UnterminatedComment = 14,
    InvalidGroupingConstruct = 15,
    AlternationHasNamedCapture = 16,
    AlternationHasComment = 17,
    AlternationHasMalformedReference = 18,
    AlternationHasUndefinedReference = 19,
    CaptureGroupNameInvalid = 20,
    CaptureGroupOfZero = 21,
    UnterminatedBracket = 22,
    ExclusionGroupNotLast = 23,
    ReversedCharacterRange = 24,
    ShorthandClassInCharacterRange = 25,
    InsufficientClosingParentheses = 26,
    ReversedQuantifierRange = 27,
    NestedQuantifiersNotParenthesized = 28,
    QuantifierAfterNothing = 29,
    InsufficientOpeningParentheses = 30,
    UnrecognizedUnicodeProperty = 31
}


export type MatchEvaluator = (match: Match) => string;


export interface Regex_ValueMatchEnumerator$instance {
    readonly Current: ValueMatch;
    GetEnumerator(): Regex_ValueMatchEnumerator;
    MoveNext(): boolean;
    Reset(): void;
}


export const Regex_ValueMatchEnumerator: {
    new(): Regex_ValueMatchEnumerator;
};


export interface __Regex_ValueMatchEnumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<ValueMatch>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type Regex_ValueMatchEnumerator = Regex_ValueMatchEnumerator$instance & __Regex_ValueMatchEnumerator$views;


export interface Regex_ValueSplitEnumerator$instance {
    readonly Current: Range;
    GetEnumerator(): Regex_ValueSplitEnumerator;
    MoveNext(): boolean;
    Reset(): void;
}


export const Regex_ValueSplitEnumerator: {
    new(): Regex_ValueSplitEnumerator;
};


export interface __Regex_ValueSplitEnumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<Range>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type Regex_ValueSplitEnumerator = Regex_ValueSplitEnumerator$instance & __Regex_ValueSplitEnumerator$views;


export interface ValueMatch$instance {
    readonly Index: int;
    readonly Length: int;
}


export const ValueMatch: {
    new(): ValueMatch;
};


export type ValueMatch = ValueMatch$instance;

export interface Capture$instance {
    readonly Index: int;
    readonly Length: int;
    readonly Value: string;
    readonly ValueSpan: ReadOnlySpan_1<System_Internal.Char>;
    ToString(): string;
}


export const Capture: {
    new(): Capture;
};


export type Capture = Capture$instance;

export interface CaptureCollection$instance {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    readonly Item: Capture;
    readonly SyncRoot: unknown;
    CopyTo(array: ClrArray, arrayIndex: int): void;
    CopyTo(array: Capture[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator;
}


export const CaptureCollection: {
    new(): CaptureCollection;
};


export interface __CaptureCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<Capture>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<Capture>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<Capture>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<Capture>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type CaptureCollection = CaptureCollection$instance & __CaptureCollection$views;


export interface GeneratedRegexAttribute$instance extends Attribute {
    readonly CultureName: string;
    readonly MatchTimeoutMilliseconds: int;
    readonly Options: RegexOptions;
    readonly Pattern: string;
}


export const GeneratedRegexAttribute: {
    new(pattern: string): GeneratedRegexAttribute;
    new(pattern: string, options: RegexOptions): GeneratedRegexAttribute;
    new(pattern: string, options: RegexOptions, cultureName: string): GeneratedRegexAttribute;
    new(pattern: string, options: RegexOptions, matchTimeoutMilliseconds: int): GeneratedRegexAttribute;
    new(pattern: string, options: RegexOptions, matchTimeoutMilliseconds: int, cultureName: string): GeneratedRegexAttribute;
};


export type GeneratedRegexAttribute = GeneratedRegexAttribute$instance;

export interface Group$instance extends Capture {
    readonly Captures: CaptureCollection;
    readonly Name: string;
    readonly Success: boolean;
}


export const Group: {
    new(): Group;
    Synchronized(inner: Group): Group;
};


export type Group = Group$instance;

export interface GroupCollection$instance {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    readonly Keys: IEnumerable_1<System_Internal.String>;
    readonly SyncRoot: unknown;
    readonly Values: IEnumerable_1<Group>;
    ContainsKey(key: string): boolean;
    CopyTo(array: ClrArray, arrayIndex: int): void;
    CopyTo(array: Group[], arrayIndex: int): void;
    get_Item(groupnum: int): Group;
    get_Item(groupname: string): Group;
    GetEnumerator(): IEnumerator;
    TryGetValue(key: string, value: Group | undefined): boolean;
}


export const GroupCollection: {
    new(): GroupCollection;
};


export interface __GroupCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<Group>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<Group>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<Group>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<Group>;
    As_IReadOnlyDictionary_2(): System_Collections_Generic_Internal.IReadOnlyDictionary_2$instance<System_Internal.String, Group>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type GroupCollection = GroupCollection$instance & __GroupCollection$views;


export interface Match$instance extends Group {
    readonly Groups: GroupCollection;
    NextMatch(): Match;
    Result(replacement: string): string;
}


export const Match: {
    new(): Match;
    readonly Empty: Match;
};


export type Match = Match$instance;

export interface MatchCollection$instance {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    readonly Item: Match;
    readonly SyncRoot: unknown;
    CopyTo(array: ClrArray, arrayIndex: int): void;
    CopyTo(array: Match[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator;
}


export const MatchCollection: {
    new(): MatchCollection;
};


export interface __MatchCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<Match>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<Match>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<Match>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<Match>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type MatchCollection = MatchCollection$instance & __MatchCollection$views;


export interface Regex$instance {
    readonly MatchTimeout: TimeSpan;
    readonly Options: RegexOptions;
    readonly RightToLeft: boolean;
    Count(input: string): int;
    Count(input: ReadOnlySpan_1<System_Internal.Char>): int;
    Count(input: ReadOnlySpan_1<System_Internal.Char>, startat: int): int;
    EnumerateMatches(input: ReadOnlySpan_1<System_Internal.Char>): Regex_ValueMatchEnumerator;
    EnumerateMatches(input: ReadOnlySpan_1<System_Internal.Char>, startat: int): Regex_ValueMatchEnumerator;
    EnumerateSplits(input: ReadOnlySpan_1<System_Internal.Char>): Regex_ValueSplitEnumerator;
    EnumerateSplits(input: ReadOnlySpan_1<System_Internal.Char>, count: int): Regex_ValueSplitEnumerator;
    EnumerateSplits(input: ReadOnlySpan_1<System_Internal.Char>, count: int, startat: int): Regex_ValueSplitEnumerator;
    GetGroupNames(): string[];
    GetGroupNumbers(): int[];
    GroupNameFromNumber(i: int): string;
    GroupNumberFromName(name: string): int;
    IsMatch(input: string): boolean;
    IsMatch(input: string, startat: int): boolean;
    IsMatch(input: ReadOnlySpan_1<System_Internal.Char>): boolean;
    IsMatch(input: ReadOnlySpan_1<System_Internal.Char>, startat: int): boolean;
    Match(input: string): Match;
    Match(input: string, startat: int): Match;
    Match(input: string, beginning: int, length: int): Match;
    Matches(input: string): MatchCollection;
    Matches(input: string, startat: int): MatchCollection;
    Replace(input: string, replacement: string): string;
    Replace(input: string, replacement: string, count: int): string;
    Replace(input: string, replacement: string, count: int, startat: int): string;
    Replace(input: string, evaluator: MatchEvaluator): string;
    Replace(input: string, evaluator: MatchEvaluator, count: int): string;
    Replace(input: string, evaluator: MatchEvaluator, count: int, startat: int): string;
    Split(input: string): string[];
    Split(input: string, count: int): string[];
    Split(input: string, count: int, startat: int): string[];
    ToString(): string;
}


export const Regex: {
    new(pattern: string): Regex;
    new(pattern: string, options: RegexOptions): Regex;
    new(pattern: string, options: RegexOptions, matchTimeout: TimeSpan): Regex;
    readonly InfiniteMatchTimeout: TimeSpan;
    CacheSize: int;
    CompileToAssembly(regexinfos: RegexCompilationInfo[], assemblyname: AssemblyName, attributes: CustomAttributeBuilder[] | undefined, resourceFile: string | undefined): void;
    CompileToAssembly(regexinfos: RegexCompilationInfo[], assemblyname: AssemblyName, attributes: CustomAttributeBuilder[] | undefined): void;
    CompileToAssembly(regexinfos: RegexCompilationInfo[], assemblyname: AssemblyName): void;
    Count(input: ReadOnlySpan_1<System_Internal.Char>, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): int;
    Count(input: ReadOnlySpan_1<System_Internal.Char>, pattern: string, options: RegexOptions): int;
    Count(input: ReadOnlySpan_1<System_Internal.Char>, pattern: string): int;
    Count(input: string, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): int;
    Count(input: string, pattern: string, options: RegexOptions): int;
    Count(input: string, pattern: string): int;
    EnumerateMatches(input: ReadOnlySpan_1<System_Internal.Char>, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): Regex_ValueMatchEnumerator;
    EnumerateMatches(input: ReadOnlySpan_1<System_Internal.Char>, pattern: string, options: RegexOptions): Regex_ValueMatchEnumerator;
    EnumerateMatches(input: ReadOnlySpan_1<System_Internal.Char>, pattern: string): Regex_ValueMatchEnumerator;
    EnumerateSplits(input: ReadOnlySpan_1<System_Internal.Char>, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): Regex_ValueSplitEnumerator;
    EnumerateSplits(input: ReadOnlySpan_1<System_Internal.Char>, pattern: string, options: RegexOptions): Regex_ValueSplitEnumerator;
    EnumerateSplits(input: ReadOnlySpan_1<System_Internal.Char>, pattern: string): Regex_ValueSplitEnumerator;
    Escape(str: string): string;
    IsMatch(input: ReadOnlySpan_1<System_Internal.Char>, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): boolean;
    IsMatch(input: ReadOnlySpan_1<System_Internal.Char>, pattern: string, options: RegexOptions): boolean;
    IsMatch(input: ReadOnlySpan_1<System_Internal.Char>, pattern: string): boolean;
    IsMatch(input: string, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): boolean;
    IsMatch(input: string, pattern: string, options: RegexOptions): boolean;
    IsMatch(input: string, pattern: string): boolean;
    Match(input: string, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): Match;
    Match(input: string, pattern: string, options: RegexOptions): Match;
    Match(input: string, pattern: string): Match;
    Matches(input: string, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): MatchCollection;
    Matches(input: string, pattern: string, options: RegexOptions): MatchCollection;
    Matches(input: string, pattern: string): MatchCollection;
    Replace(input: string, pattern: string, replacement: string, options: RegexOptions, matchTimeout: TimeSpan): string;
    Replace(input: string, pattern: string, replacement: string, options: RegexOptions): string;
    Replace(input: string, pattern: string, replacement: string): string;
    Replace(input: string, pattern: string, evaluator: MatchEvaluator, options: RegexOptions, matchTimeout: TimeSpan): string;
    Replace(input: string, pattern: string, evaluator: MatchEvaluator, options: RegexOptions): string;
    Replace(input: string, pattern: string, evaluator: MatchEvaluator): string;
    Split(input: string, pattern: string, options: RegexOptions, matchTimeout: TimeSpan): string[];
    Split(input: string, pattern: string, options: RegexOptions): string[];
    Split(input: string, pattern: string): string[];
    Unescape(str: string): string;
};


export interface __Regex$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Regex$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Regex = Regex$instance & __Regex$views;


export interface RegexCompilationInfo$instance {
    IsPublic: boolean;
    MatchTimeout: TimeSpan;
    Name: string;
    Namespace: string;
    Options: RegexOptions;
    Pattern: string;
}


export const RegexCompilationInfo: {
    new(pattern: string, options: RegexOptions, name: string, fullnamespace: string, ispublic: boolean): RegexCompilationInfo;
    new(pattern: string, options: RegexOptions, name: string, fullnamespace: string, ispublic: boolean, matchTimeout: TimeSpan): RegexCompilationInfo;
};


export type RegexCompilationInfo = RegexCompilationInfo$instance;

export interface RegexMatchTimeoutException$instance extends TimeoutException {
    readonly Input: string;
    readonly MatchTimeout: TimeSpan;
    readonly Pattern: string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const RegexMatchTimeoutException: {
    new(regexInput: string, regexPattern: string, matchTimeout: TimeSpan): RegexMatchTimeoutException;
    new(): RegexMatchTimeoutException;
    new(message: string): RegexMatchTimeoutException;
    new(message: string, inner: Exception): RegexMatchTimeoutException;
};


export interface __RegexMatchTimeoutException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type RegexMatchTimeoutException = RegexMatchTimeoutException$instance & __RegexMatchTimeoutException$views;


export interface RegexParseException$instance extends ArgumentException {
    readonly Error: RegexParseError;
    readonly Offset: int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const RegexParseException: {
    new(): RegexParseException;
};


export interface __RegexParseException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type RegexParseException = RegexParseException$instance & __RegexParseException$views;


export interface RegexRunner$instance {
}


export const RegexRunner: {
    CharInClass(ch: char, charClass: string): boolean;
};


export type RegexRunner = RegexRunner$instance;

export interface RegexRunnerFactory$instance {
}


export const RegexRunnerFactory: {
};


export type RegexRunnerFactory = RegexRunnerFactory$instance;


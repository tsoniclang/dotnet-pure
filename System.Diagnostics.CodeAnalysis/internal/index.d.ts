// Generated by tsbindgen - Architecture
// Namespace: System.Diagnostics.CodeAnalysis
// Assembly: System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import * as System_Internal from "../../System/internal/index.js";
import type { Attribute, Boolean as ClrBoolean, Enum, IComparable, IConvertible, IFormatProvider, IFormattable, Int32, ISpanFormattable, Object as ClrObject, String as ClrString, Type, TypeCode } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum DynamicallyAccessedMemberTypes {
    None = 0,
    PublicParameterlessConstructor = 1,
    PublicConstructors = 3,
    NonPublicConstructors = 4,
    PublicMethods = 8,
    NonPublicMethods = 16,
    PublicFields = 32,
    NonPublicFields = 64,
    PublicNestedTypes = 128,
    NonPublicNestedTypes = 256,
    PublicProperties = 512,
    NonPublicProperties = 1024,
    PublicEvents = 2048,
    NonPublicEvents = 4096,
    Interfaces = 8192,
    NonPublicConstructorsWithInherited = 16388,
    NonPublicMethodsWithInherited = 32784,
    NonPublicFieldsWithInherited = 65600,
    NonPublicNestedTypesWithInherited = 131328,
    NonPublicPropertiesWithInherited = 263168,
    NonPublicEventsWithInherited = 528384,
    PublicConstructorsWithInherited = 1048579,
    PublicNestedTypesWithInherited = 2097280,
    AllConstructors = 1064967,
    AllMethods = 32792,
    AllFields = 65632,
    AllNestedTypes = 2228608,
    AllProperties = 263680,
    AllEvents = 530432,
    All = -1
}


export interface AllowNullAttribute$instance extends Attribute {
}


export const AllowNullAttribute: {
    new(): AllowNullAttribute$instance;
};


export type AllowNullAttribute = AllowNullAttribute$instance;

export interface ConstantExpectedAttribute$instance extends Attribute {
    Max: unknown;
    Min: unknown;
}


export const ConstantExpectedAttribute: {
    new(): ConstantExpectedAttribute$instance;
};


export type ConstantExpectedAttribute = ConstantExpectedAttribute$instance;

export interface DisallowNullAttribute$instance extends Attribute {
}


export const DisallowNullAttribute: {
    new(): DisallowNullAttribute$instance;
};


export type DisallowNullAttribute = DisallowNullAttribute$instance;

export interface DoesNotReturnAttribute$instance extends Attribute {
}


export const DoesNotReturnAttribute: {
    new(): DoesNotReturnAttribute$instance;
};


export type DoesNotReturnAttribute = DoesNotReturnAttribute$instance;

export interface DoesNotReturnIfAttribute$instance extends Attribute {
    readonly ParameterValue: boolean;
}


export const DoesNotReturnIfAttribute: {
    new(parameterValue: boolean): DoesNotReturnIfAttribute$instance;
};


export type DoesNotReturnIfAttribute = DoesNotReturnIfAttribute$instance;

export interface DynamicallyAccessedMembersAttribute$instance extends Attribute {
    readonly MemberTypes: DynamicallyAccessedMemberTypes;
}


export const DynamicallyAccessedMembersAttribute: {
    new(memberTypes: DynamicallyAccessedMemberTypes): DynamicallyAccessedMembersAttribute$instance;
};


export type DynamicallyAccessedMembersAttribute = DynamicallyAccessedMembersAttribute$instance;

export interface DynamicDependencyAttribute$instance extends Attribute {
    readonly AssemblyName: string;
    Condition: string;
    readonly MemberSignature: string;
    readonly MemberTypes: DynamicallyAccessedMemberTypes;
    readonly Type: Type;
    readonly TypeName: string;
}


export const DynamicDependencyAttribute: {
    new(memberSignature: string): DynamicDependencyAttribute$instance;
    new(memberSignature: string, type_: Type): DynamicDependencyAttribute$instance;
    new(memberSignature: string, typeName: string, assemblyName: string): DynamicDependencyAttribute$instance;
    new(memberTypes: DynamicallyAccessedMemberTypes, type_: Type): DynamicDependencyAttribute$instance;
    new(memberTypes: DynamicallyAccessedMemberTypes, typeName: string, assemblyName: string): DynamicDependencyAttribute$instance;
};


export type DynamicDependencyAttribute = DynamicDependencyAttribute$instance;

export interface ExcludeFromCodeCoverageAttribute$instance extends Attribute {
    Justification: string;
}


export const ExcludeFromCodeCoverageAttribute: {
    new(): ExcludeFromCodeCoverageAttribute$instance;
};


export type ExcludeFromCodeCoverageAttribute = ExcludeFromCodeCoverageAttribute$instance;

export interface ExperimentalAttribute$instance extends Attribute {
    readonly DiagnosticId: string;
    Message: string;
    UrlFormat: string;
}


export const ExperimentalAttribute: {
    new(diagnosticId: string): ExperimentalAttribute$instance;
};


export type ExperimentalAttribute = ExperimentalAttribute$instance;

export interface FeatureGuardAttribute$instance extends Attribute {
    readonly FeatureType: Type;
}


export const FeatureGuardAttribute: {
    new(featureType: Type): FeatureGuardAttribute$instance;
};


export type FeatureGuardAttribute = FeatureGuardAttribute$instance;

export interface FeatureSwitchDefinitionAttribute$instance extends Attribute {
    readonly SwitchName: string;
}


export const FeatureSwitchDefinitionAttribute: {
    new(switchName: string): FeatureSwitchDefinitionAttribute$instance;
};


export type FeatureSwitchDefinitionAttribute = FeatureSwitchDefinitionAttribute$instance;

export interface MaybeNullAttribute$instance extends Attribute {
}


export const MaybeNullAttribute: {
    new(): MaybeNullAttribute$instance;
};


export type MaybeNullAttribute = MaybeNullAttribute$instance;

export interface MaybeNullWhenAttribute$instance extends Attribute {
    readonly ReturnValue: boolean;
}


export const MaybeNullWhenAttribute: {
    new(returnValue: boolean): MaybeNullWhenAttribute$instance;
};


export type MaybeNullWhenAttribute = MaybeNullWhenAttribute$instance;

export interface MemberNotNullAttribute$instance extends Attribute {
    readonly Members: string[];
}


export const MemberNotNullAttribute: {
    new(member: string): MemberNotNullAttribute$instance;
    new(members: string[]): MemberNotNullAttribute$instance;
};


export type MemberNotNullAttribute = MemberNotNullAttribute$instance;

export interface MemberNotNullWhenAttribute$instance extends Attribute {
    readonly Members: string[];
    readonly ReturnValue: boolean;
}


export const MemberNotNullWhenAttribute: {
    new(returnValue: boolean, member: string): MemberNotNullWhenAttribute$instance;
    new(returnValue: boolean, members: string[]): MemberNotNullWhenAttribute$instance;
};


export type MemberNotNullWhenAttribute = MemberNotNullWhenAttribute$instance;

export interface NotNullAttribute$instance extends Attribute {
}


export const NotNullAttribute: {
    new(): NotNullAttribute$instance;
};


export type NotNullAttribute = NotNullAttribute$instance;

export interface NotNullIfNotNullAttribute$instance extends Attribute {
    readonly ParameterName: string;
}


export const NotNullIfNotNullAttribute: {
    new(parameterName: string): NotNullIfNotNullAttribute$instance;
};


export type NotNullIfNotNullAttribute = NotNullIfNotNullAttribute$instance;

export interface NotNullWhenAttribute$instance extends Attribute {
    readonly ReturnValue: boolean;
}


export const NotNullWhenAttribute: {
    new(returnValue: boolean): NotNullWhenAttribute$instance;
};


export type NotNullWhenAttribute = NotNullWhenAttribute$instance;

export interface RequiresAssemblyFilesAttribute$instance extends Attribute {
    readonly Message: string;
    Url: string;
}


export const RequiresAssemblyFilesAttribute: {
    new(): RequiresAssemblyFilesAttribute$instance;
    new(message: string): RequiresAssemblyFilesAttribute$instance;
};


export type RequiresAssemblyFilesAttribute = RequiresAssemblyFilesAttribute$instance;

export interface RequiresDynamicCodeAttribute$instance extends Attribute {
    ExcludeStatics: boolean;
    readonly Message: string;
    Url: string;
}


export const RequiresDynamicCodeAttribute: {
    new(message: string): RequiresDynamicCodeAttribute$instance;
};


export type RequiresDynamicCodeAttribute = RequiresDynamicCodeAttribute$instance;

export interface RequiresUnreferencedCodeAttribute$instance extends Attribute {
    ExcludeStatics: boolean;
    readonly Message: string;
    Url: string;
}


export const RequiresUnreferencedCodeAttribute: {
    new(message: string): RequiresUnreferencedCodeAttribute$instance;
};


export type RequiresUnreferencedCodeAttribute = RequiresUnreferencedCodeAttribute$instance;

export interface SetsRequiredMembersAttribute$instance extends Attribute {
}


export const SetsRequiredMembersAttribute: {
    new(): SetsRequiredMembersAttribute$instance;
};


export type SetsRequiredMembersAttribute = SetsRequiredMembersAttribute$instance;

export interface StringSyntaxAttribute$instance extends Attribute {
    readonly Arguments: unknown[];
    readonly Syntax: string;
}


export const StringSyntaxAttribute: {
    new(syntax: string): StringSyntaxAttribute$instance;
    new(syntax: string, arguments: unknown[]): StringSyntaxAttribute$instance;
    readonly CompositeFormat: string;
    readonly DateOnlyFormat: string;
    readonly DateTimeFormat: string;
    readonly EnumFormat: string;
    readonly GuidFormat: string;
    readonly Json: string;
    readonly NumericFormat: string;
    readonly Regex: string;
    readonly TimeOnlyFormat: string;
    readonly TimeSpanFormat: string;
    readonly Uri: string;
    readonly Xml: string;
};


export type StringSyntaxAttribute = StringSyntaxAttribute$instance;

export interface SuppressMessageAttribute$instance extends Attribute {
    readonly Category: string;
    readonly CheckId: string;
    Justification: string;
    MessageId: string;
    Scope: string;
    Target: string;
}


export const SuppressMessageAttribute: {
    new(category: string, checkId: string): SuppressMessageAttribute$instance;
};


export type SuppressMessageAttribute = SuppressMessageAttribute$instance;

export interface UnconditionalSuppressMessageAttribute$instance extends Attribute {
    readonly Category: string;
    readonly CheckId: string;
    Justification: string;
    MessageId: string;
    Scope: string;
    Target: string;
}


export const UnconditionalSuppressMessageAttribute: {
    new(category: string, checkId: string): UnconditionalSuppressMessageAttribute$instance;
};


export type UnconditionalSuppressMessageAttribute = UnconditionalSuppressMessageAttribute$instance;

export interface UnscopedRefAttribute$instance extends Attribute {
}


export const UnscopedRefAttribute: {
    new(): UnscopedRefAttribute$instance;
};


export type UnscopedRefAttribute = UnscopedRefAttribute$instance;


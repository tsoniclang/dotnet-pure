// Generated by tsbindgen - Architecture
// Namespace: System.IO.Pipes
// Assembly: System.IO.Pipes, System.IO.Pipes.AccessControl

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { SafePipeHandle } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import * as System_IO_Internal from "../../System.IO/internal/index.js";
import type { HandleInheritability, SeekOrigin, Stream } from "../../System.IO/internal/index.js";
import type { MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Security_AccessControl_Internal from "../../System.Security.AccessControl/internal/index.js";
import type { AccessControlModification, AccessControlSections, AccessControlType, AccessRule, AuditFlags, AuditRule, AuthorizationRuleCollection, InheritanceFlags, NativeObjectSecurity, PropagationFlags } from "../../System.Security.AccessControl/internal/index.js";
import type { IdentityReference, TokenImpersonationLevel } from "../../System.Security.Principal/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { AsyncCallback, Boolean as ClrBoolean, Byte, Delegate, Enum, IAsyncDisposable, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, Int64, IntPtr, ISpanFormattable, Memory_1, MulticastDelegate, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, Span_1, String as ClrString, TimeSpan, Type, TypeCode, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum PipeAccessRights {
    ReadData = 1,
    WriteData = 2,
    ReadAttributes = 128,
    WriteAttributes = 256,
    ReadExtendedAttributes = 8,
    WriteExtendedAttributes = 16,
    CreateNewInstance = 4,
    Delete = 65536,
    ReadPermissions = 131072,
    ChangePermissions = 262144,
    TakeOwnership = 524288,
    Synchronize = 1048576,
    FullControl = 2032031,
    Read = 131209,
    Write = 274,
    ReadWrite = 131483,
    AccessSystemSecurity = 16777216
}


export enum PipeDirection {
    In = 1,
    Out = 2,
    InOut = 3
}


export enum PipeOptions {
    None = 0,
    WriteThrough = -2147483648,
    Asynchronous = 1073741824,
    CurrentUserOnly = 536870912,
    FirstPipeInstance = 524288
}


export enum PipeTransmissionMode {
    Byte = 0,
    Message = 1
}


export type PipeStreamImpersonationWorker = () => void;


export interface AnonymousPipeClientStream$instance extends PipeStream$instance {
    ReadMode: PipeTransmissionMode;
    readonly TransmissionMode: PipeTransmissionMode;
    Dispose(): void;
    DisposeAsync(): ValueTask;
}


export const AnonymousPipeClientStream: {
    new(pipeHandleAsString: string): AnonymousPipeClientStream$instance;
    new(direction: PipeDirection, pipeHandleAsString: string): AnonymousPipeClientStream$instance;
    new(direction: PipeDirection, safePipeHandle: SafePipeHandle): AnonymousPipeClientStream$instance;
};


export interface __AnonymousPipeClientStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type AnonymousPipeClientStream = AnonymousPipeClientStream$instance & __AnonymousPipeClientStream$views;


export interface AnonymousPipeServerStream$instance extends PipeStream$instance {
    readonly ClientSafePipeHandle: SafePipeHandle;
    ReadMode: PipeTransmissionMode;
    readonly TransmissionMode: PipeTransmissionMode;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    DisposeLocalCopyOfClientHandle(): void;
    GetClientHandleAsString(): string;
}


export const AnonymousPipeServerStream: {
    new(): AnonymousPipeServerStream$instance;
    new(direction: PipeDirection): AnonymousPipeServerStream$instance;
    new(direction: PipeDirection, inheritability: HandleInheritability): AnonymousPipeServerStream$instance;
    new(direction: PipeDirection, serverSafePipeHandle: SafePipeHandle, clientSafePipeHandle: SafePipeHandle): AnonymousPipeServerStream$instance;
    new(direction: PipeDirection, inheritability: HandleInheritability, bufferSize: int): AnonymousPipeServerStream$instance;
};


export interface __AnonymousPipeServerStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type AnonymousPipeServerStream = AnonymousPipeServerStream$instance & __AnonymousPipeServerStream$views;


export interface NamedPipeClientStream$instance extends PipeStream$instance {
    readonly InBufferSize: int;
    readonly NumberOfServerInstances: int;
    readonly OutBufferSize: int;
    Connect(): void;
    Connect(timeout: int): void;
    Connect(timeout: TimeSpan): void;
    ConnectAsync(): Task;
    ConnectAsync(timeout: int): Task;
    ConnectAsync(cancellationToken: CancellationToken): Task;
    ConnectAsync(timeout: int, cancellationToken: CancellationToken): Task;
    ConnectAsync(timeout: TimeSpan, cancellationToken?: CancellationToken): Task;
    Dispose(): void;
    DisposeAsync(): ValueTask;
}


export const NamedPipeClientStream: {
    new(pipeName: string): NamedPipeClientStream$instance;
    new(serverName: string, pipeName: string): NamedPipeClientStream$instance;
    new(serverName: string, pipeName: string, direction: PipeDirection): NamedPipeClientStream$instance;
    new(serverName: string, pipeName: string, direction: PipeDirection, options: PipeOptions): NamedPipeClientStream$instance;
    new(serverName: string, pipeName: string, direction: PipeDirection, options: PipeOptions, impersonationLevel: TokenImpersonationLevel): NamedPipeClientStream$instance;
    new(serverName: string, pipeName: string, direction: PipeDirection, options: PipeOptions, impersonationLevel: TokenImpersonationLevel, inheritability: HandleInheritability): NamedPipeClientStream$instance;
    new(direction: PipeDirection, isAsync: boolean, isConnected: boolean, safePipeHandle: SafePipeHandle): NamedPipeClientStream$instance;
    new(serverName: string, pipeName: string, desiredAccessRights: PipeAccessRights, options: PipeOptions, impersonationLevel: TokenImpersonationLevel, inheritability: HandleInheritability): NamedPipeClientStream$instance;
};


export interface __NamedPipeClientStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type NamedPipeClientStream = NamedPipeClientStream$instance & __NamedPipeClientStream$views;


export interface NamedPipeServerStream$instance extends PipeStream$instance {
    readonly InBufferSize: int;
    readonly OutBufferSize: int;
    BeginWaitForConnection(callback: AsyncCallback, state: unknown): IAsyncResult;
    Disconnect(): void;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    EndWaitForConnection(asyncResult: IAsyncResult): void;
    GetImpersonationUserName(): string;
    RunAsClient(impersonationWorker: PipeStreamImpersonationWorker): void;
    WaitForConnection(): void;
    WaitForConnectionAsync(): Task;
    WaitForConnectionAsync(cancellationToken: CancellationToken): Task;
}


export const NamedPipeServerStream: {
    new(pipeName: string): NamedPipeServerStream$instance;
    new(pipeName: string, direction: PipeDirection): NamedPipeServerStream$instance;
    new(pipeName: string, direction: PipeDirection, maxNumberOfServerInstances: int): NamedPipeServerStream$instance;
    new(pipeName: string, direction: PipeDirection, maxNumberOfServerInstances: int, transmissionMode: PipeTransmissionMode): NamedPipeServerStream$instance;
    new(pipeName: string, direction: PipeDirection, maxNumberOfServerInstances: int, transmissionMode: PipeTransmissionMode, options: PipeOptions): NamedPipeServerStream$instance;
    new(pipeName: string, direction: PipeDirection, maxNumberOfServerInstances: int, transmissionMode: PipeTransmissionMode, options: PipeOptions, inBufferSize: int, outBufferSize: int): NamedPipeServerStream$instance;
    new(direction: PipeDirection, isAsync: boolean, isConnected: boolean, safePipeHandle: SafePipeHandle): NamedPipeServerStream$instance;
    readonly MaxAllowedServerInstances: int;
};


export interface __NamedPipeServerStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type NamedPipeServerStream = NamedPipeServerStream$instance & __NamedPipeServerStream$views;


export interface PipeAccessRule$instance extends AccessRule {
    readonly PipeAccessRights: PipeAccessRights;
}


export const PipeAccessRule: {
    new(identity: IdentityReference, rights: PipeAccessRights, type_: AccessControlType): PipeAccessRule$instance;
    new(identity: string, rights: PipeAccessRights, type_: AccessControlType): PipeAccessRule$instance;
};


export type PipeAccessRule = PipeAccessRule$instance;

export interface PipeAuditRule$instance extends AuditRule {
    readonly PipeAccessRights: PipeAccessRights;
}


export const PipeAuditRule: {
    new(identity: IdentityReference, rights: PipeAccessRights, flags: AuditFlags): PipeAuditRule$instance;
    new(identity: string, rights: PipeAccessRights, flags: AuditFlags): PipeAuditRule$instance;
};


export type PipeAuditRule = PipeAuditRule$instance;

export interface PipeSecurity$instance extends NativeObjectSecurity {
    readonly AccessRightType: Type;
    readonly AccessRuleType: Type;
    readonly AuditRuleType: Type;
    AccessRuleFactory(identityReference: IdentityReference, accessMask: int, isInherited: boolean, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, type_: AccessControlType): AccessRule;
    AddAccessRule(rule: PipeAccessRule): void;
    AddAuditRule(rule: PipeAuditRule): void;
    AuditRuleFactory(identityReference: IdentityReference, accessMask: int, isInherited: boolean, inheritanceFlags: InheritanceFlags, propagationFlags: PropagationFlags, flags: AuditFlags): AuditRule;
    RemoveAccessRule(rule: PipeAccessRule): boolean;
    RemoveAccessRuleSpecific(rule: PipeAccessRule): void;
    RemoveAuditRule(rule: PipeAuditRule): boolean;
    RemoveAuditRuleAll(rule: PipeAuditRule): void;
    RemoveAuditRuleSpecific(rule: PipeAuditRule): void;
    ResetAccessRule(rule: PipeAccessRule): void;
    SetAccessRule(rule: PipeAccessRule): void;
    SetAuditRule(rule: PipeAuditRule): void;
}


export const PipeSecurity: {
    new(): PipeSecurity$instance;
};


export type PipeSecurity = PipeSecurity$instance;

export interface PipeStream$instance extends Stream {
    readonly CanRead: boolean;
    readonly CanSeek: boolean;
    readonly CanWrite: boolean;
    readonly InBufferSize: int;
    readonly IsAsync: boolean;
    readonly IsConnected: boolean;
    readonly IsMessageComplete: boolean;
    readonly Length: long;
    readonly OutBufferSize: int;
    Position: long;
    ReadMode: PipeTransmissionMode;
    readonly SafePipeHandle: SafePipeHandle;
    readonly TransmissionMode: PipeTransmissionMode;
    BeginRead(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginWrite(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    EndRead(asyncResult: IAsyncResult): int;
    EndWrite(asyncResult: IAsyncResult): void;
    Flush(): void;
    FlushAsync(cancellationToken: CancellationToken): Task;
    FlushAsync(): Task;
    Read(buffer: byte[], offset: int, count: int): int;
    Read(buffer: Span_1<CLROf<byte>>): int;
    Read(buffer: Span_1<CLROf<byte>>): int;
    ReadAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    ReadAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadAsync(buffer: byte[], offset: int, count: int): Task_1<CLROf<int>>;
    ReadAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    ReadAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadByte(): int;
    Seek(offset: long, origin: SeekOrigin): long;
    SetLength(value: long): void;
    WaitForPipeDrain(): void;
    Write(buffer: byte[], offset: int, count: int): void;
    Write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    Write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    WriteAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    WriteAsync(buffer: byte[], offset: int, count: int): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    WriteByte(value: byte): void;
}


export const PipeStream: {
};


export interface __PipeStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type PipeStream = PipeStream$instance & __PipeStream$views;


export abstract class AnonymousPipeServerStreamAcl$instance {
    static Create(direction: PipeDirection, inheritability: HandleInheritability, bufferSize: int, pipeSecurity: PipeSecurity): AnonymousPipeServerStream;
}


export type AnonymousPipeServerStreamAcl = AnonymousPipeServerStreamAcl$instance;

export abstract class NamedPipeServerStreamAcl$instance {
    static Create(pipeName: string, direction: PipeDirection, maxNumberOfServerInstances: int, transmissionMode: PipeTransmissionMode, options: PipeOptions, inBufferSize: int, outBufferSize: int, pipeSecurity: PipeSecurity, inheritability?: HandleInheritability, additionalAccessRights?: PipeAccessRights): NamedPipeServerStream;
}


export type NamedPipeServerStreamAcl = NamedPipeServerStreamAcl$instance;

export abstract class PipesAclExtensions$instance {
    static GetAccessControl(stream: PipeStream): PipeSecurity;
    static SetAccessControl(stream: PipeStream, pipeSecurity: PipeSecurity): void;
}


export type PipesAclExtensions = PipesAclExtensions$instance;


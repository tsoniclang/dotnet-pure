// Generated by tsbindgen - Architecture
// Namespace: System.Formats.Asn1
// Assembly: System.Formats.Asn1

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr } from "@tsonic/types";

// Import types from other namespaces
import type { BitArray, IDictionary } from "../../System.Collections/internal/index.js";
import type { BigInteger } from "../../System.Numerics/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_2, Boolean as ClrBoolean, Byte, Char, DateTimeOffset, Enum, Exception, Func_2, Func_3, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int32, Int64, ISpanFormattable, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, Span_1, String as ClrString, Type, TypeCode, UInt32, UInt64, ValueType, Void } from "../../System/internal/index.js";

export enum AsnEncodingRules {
    BER = 0,
    CER = 1,
    DER = 2
}


export enum TagClass {
    Universal = 0,
    Application = 64,
    ContextSpecific = 128,
    Private = 192
}


export enum UniversalTagNumber {
    EndOfContents = 0,
    Boolean = 1,
    Integer = 2,
    BitString = 3,
    OctetString = 4,
    Null = 5,
    ObjectIdentifier = 6,
    ObjectDescriptor = 7,
    External = 8,
    InstanceOf = 8,
    Real = 9,
    Enumerated = 10,
    Embedded = 11,
    UTF8String = 12,
    RelativeObjectIdentifier = 13,
    Time = 14,
    Sequence = 16,
    SequenceOf = 16,
    Set = 17,
    SetOf = 17,
    NumericString = 18,
    PrintableString = 19,
    TeletexString = 20,
    T61String = 20,
    VideotexString = 21,
    IA5String = 22,
    UtcTime = 23,
    GeneralizedTime = 24,
    GraphicString = 25,
    VisibleString = 26,
    ISO646String = 26,
    GeneralString = 27,
    UniversalString = 28,
    UnrestrictedCharacterString = 29,
    BMPString = 30,
    Date = 31,
    TimeOfDay = 32,
    DateTime = 33,
    Duration = 34,
    ObjectIdentifierIRI = 35,
    RelativeObjectIdentifierIRI = 36
}


export interface Asn1Tag$instance {
    readonly IsConstructed: boolean;
    readonly TagClass: TagClass;
    readonly TagValue: int;
    AsConstructed(): Asn1Tag;
    AsPrimitive(): Asn1Tag;
    CalculateEncodedSize(): int;
    Encode(destination: Span_1<System_Internal.Byte>): int;
    Equals(other: Asn1Tag): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    HasSameClassAndValue(other: Asn1Tag): boolean;
    ToString(): string;
    TryEncode(destination: Span_1<System_Internal.Byte>, bytesWritten: int): boolean;
}


export const Asn1Tag: {
    new(universalTagNumber: UniversalTagNumber, isConstructed: boolean): Asn1Tag$instance;
    new(tagClass: TagClass, tagValue: int, isConstructed: boolean): Asn1Tag$instance;
    readonly Boolean: Asn1Tag;
    readonly Integer: Asn1Tag;
    readonly PrimitiveBitString: Asn1Tag;
    readonly ConstructedBitString: Asn1Tag;
    readonly PrimitiveOctetString: Asn1Tag;
    readonly ConstructedOctetString: Asn1Tag;
    readonly Null: Asn1Tag;
    readonly ObjectIdentifier: Asn1Tag;
    readonly Enumerated: Asn1Tag;
    readonly Sequence: Asn1Tag;
    readonly SetOf: Asn1Tag;
    readonly UtcTime: Asn1Tag;
    readonly GeneralizedTime: Asn1Tag;
    Decode(source: ReadOnlySpan_1<System_Internal.Byte>, bytesConsumed: int): Asn1Tag;
    TryDecode(source: ReadOnlySpan_1<System_Internal.Byte>, tag: Asn1Tag, bytesConsumed: int): boolean;
};


export interface __Asn1Tag$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Asn1Tag>;

    // Structural method bridges for numeric interface constraints
    equals(other: Asn1Tag): boolean;
}

export type Asn1Tag = Asn1Tag$instance & __Asn1Tag$views;


export interface AsnReaderOptions$instance {
    SkipSetSortOrderVerification: boolean;
    UtcTimeTwoDigitYearMax: int;
}


export const AsnReaderOptions: {
    new(): AsnReaderOptions$instance;
};


export type AsnReaderOptions = AsnReaderOptions$instance;

export interface AsnWriter_Scope$instance {
    Dispose(): void;
}


export const AsnWriter_Scope: {
    new(): AsnWriter_Scope$instance;
};


export interface __AsnWriter_Scope$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface AsnWriter_Scope$instance extends System_Internal.IDisposable$instance {}

export type AsnWriter_Scope = AsnWriter_Scope$instance & __AsnWriter_Scope$views;


export interface AsnContentException$instance extends Exception {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const AsnContentException: {
    new(): AsnContentException$instance;
    new(message: string): AsnContentException$instance;
    new(message: string, inner: Exception): AsnContentException$instance;
};


export interface __AsnContentException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AsnContentException = AsnContentException$instance & __AsnContentException$views;


export interface AsnReader$instance {
    readonly HasData: boolean;
    readonly RuleSet: AsnEncodingRules;
    Clone(): AsnReader;
    PeekContentBytes(): ReadOnlyMemory_1<System_Internal.Byte>;
    PeekEncodedValue(): ReadOnlyMemory_1<System_Internal.Byte>;
    PeekTag(): Asn1Tag;
    ReadBitString(unusedBitCount: int, expectedTag?: Nullable_1<Asn1Tag>): byte[];
    ReadBoolean(expectedTag?: Nullable_1<Asn1Tag>): boolean;
    ReadCharacterString(encodingType: UniversalTagNumber, expectedTag?: Nullable_1<Asn1Tag>): string;
    ReadEncodedValue(): ReadOnlyMemory_1<System_Internal.Byte>;
    ReadEnumeratedBytes(expectedTag?: Nullable_1<Asn1Tag>): ReadOnlyMemory_1<System_Internal.Byte>;
    ReadEnumeratedValue<TEnum extends number>(expectedTag?: Nullable_1<Asn1Tag>): TEnum;
    ReadEnumeratedValue(enumType: Type, expectedTag?: Nullable_1<Asn1Tag>): number;
    ReadGeneralizedTime(expectedTag?: Nullable_1<Asn1Tag>): DateTimeOffset;
    ReadInteger(expectedTag?: Nullable_1<Asn1Tag>): BigInteger;
    ReadIntegerBytes(expectedTag?: Nullable_1<Asn1Tag>): ReadOnlyMemory_1<System_Internal.Byte>;
    ReadNamedBitList(expectedTag?: Nullable_1<Asn1Tag>): BitArray;
    ReadNamedBitListValue<TFlagsEnum extends number>(expectedTag?: Nullable_1<Asn1Tag>): TFlagsEnum;
    ReadNamedBitListValue(flagsEnumType: Type, expectedTag?: Nullable_1<Asn1Tag>): number;
    ReadNull(expectedTag?: Nullable_1<Asn1Tag>): void;
    ReadObjectIdentifier(expectedTag?: Nullable_1<Asn1Tag>): string;
    ReadOctetString(expectedTag?: Nullable_1<Asn1Tag>): byte[];
    ReadSequence(expectedTag?: Nullable_1<Asn1Tag>): AsnReader;
    ReadSetOf(expectedTag?: Nullable_1<Asn1Tag>): AsnReader;
    ReadSetOf(skipSortOrderValidation: boolean, expectedTag?: Nullable_1<Asn1Tag>): AsnReader;
    ReadUtcTime(expectedTag?: Nullable_1<Asn1Tag>): DateTimeOffset;
    ReadUtcTime(twoDigitYearMax: int, expectedTag?: Nullable_1<Asn1Tag>): DateTimeOffset;
    ThrowIfNotEmpty(): void;
    TryReadBitString(destination: Span_1<System_Internal.Byte>, unusedBitCount: int, bytesWritten: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    TryReadCharacterString(destination: Span_1<System_Internal.Char>, encodingType: UniversalTagNumber, charsWritten: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    TryReadCharacterStringBytes(destination: Span_1<System_Internal.Byte>, expectedTag: Asn1Tag, bytesWritten: int): boolean;
    TryReadInt32(value: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    TryReadInt64(value: long, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    TryReadOctetString(destination: Span_1<System_Internal.Byte>, bytesWritten: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    TryReadPrimitiveBitString(unusedBitCount: int, value: ReadOnlyMemory_1<System_Internal.Byte>, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    TryReadPrimitiveCharacterStringBytes(expectedTag: Asn1Tag, contents: ReadOnlyMemory_1<System_Internal.Byte>): boolean;
    TryReadPrimitiveOctetString(contents: ReadOnlyMemory_1<System_Internal.Byte>, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    TryReadUInt32(value: uint, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    TryReadUInt64(value: ulong, expectedTag?: Nullable_1<Asn1Tag>): boolean;
}


export const AsnReader: {
    new(data: ReadOnlyMemory_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, options: AsnReaderOptions): AsnReader$instance;
};


export type AsnReader = AsnReader$instance;

export interface AsnWriter$instance {
    readonly RuleSet: AsnEncodingRules;
    CopyTo(destination: AsnWriter): void;
    Encode(destination: Span_1<System_Internal.Byte>): int;
    Encode(): byte[];
    Encode<TReturn>(encodeCallback: Func_2<ReadOnlySpan_1<System_Internal.Byte>, TReturn>): TReturn;
    Encode<TState, TReturn>(state: TState, encodeCallback: Func_3<TState, ReadOnlySpan_1<System_Internal.Byte>, TReturn>): TReturn;
    Encode<TState>(state: TState, encodeCallback: Action_2<TState, ReadOnlySpan_1<System_Internal.Byte>>): void;
    EncodedValueEquals(other: ReadOnlySpan_1<System_Internal.Byte>): boolean;
    EncodedValueEquals(other: AsnWriter): boolean;
    GetEncodedLength(): int;
    PopOctetString(tag?: Nullable_1<Asn1Tag>): void;
    PopSequence(tag?: Nullable_1<Asn1Tag>): void;
    PopSetOf(tag?: Nullable_1<Asn1Tag>): void;
    PushOctetString(tag?: Nullable_1<Asn1Tag>): AsnWriter_Scope;
    PushSequence(tag?: Nullable_1<Asn1Tag>): AsnWriter_Scope;
    PushSetOf(tag?: Nullable_1<Asn1Tag>): AsnWriter_Scope;
    Reset(): void;
    TryEncode(destination: Span_1<System_Internal.Byte>, bytesWritten: int): boolean;
    WriteBitString(value: ReadOnlySpan_1<System_Internal.Byte>, unusedBitCount?: int, tag?: Nullable_1<Asn1Tag>): void;
    WriteBoolean(value: boolean, tag?: Nullable_1<Asn1Tag>): void;
    WriteCharacterString(encodingType: UniversalTagNumber, value: string, tag?: Nullable_1<Asn1Tag>): void;
    WriteCharacterString(encodingType: UniversalTagNumber, str: ReadOnlySpan_1<System_Internal.Char>, tag?: Nullable_1<Asn1Tag>): void;
    WriteEncodedValue(value: ReadOnlySpan_1<System_Internal.Byte>): void;
    WriteEnumeratedValue(value: number, tag?: Nullable_1<Asn1Tag>): void;
    WriteEnumeratedValue<TEnum extends number>(value: TEnum, tag?: Nullable_1<Asn1Tag>): void;
    WriteGeneralizedTime(value: DateTimeOffset, omitFractionalSeconds?: boolean, tag?: Nullable_1<Asn1Tag>): void;
    WriteInteger(value: long, tag?: Nullable_1<Asn1Tag>): void;
    WriteInteger(value: ulong, tag?: Nullable_1<Asn1Tag>): void;
    WriteInteger(value: BigInteger, tag?: Nullable_1<Asn1Tag>): void;
    WriteInteger(value: ReadOnlySpan_1<System_Internal.Byte>, tag?: Nullable_1<Asn1Tag>): void;
    WriteIntegerUnsigned(value: ReadOnlySpan_1<System_Internal.Byte>, tag?: Nullable_1<Asn1Tag>): void;
    WriteNamedBitList(value: number, tag?: Nullable_1<Asn1Tag>): void;
    WriteNamedBitList<TEnum extends number>(value: TEnum, tag?: Nullable_1<Asn1Tag>): void;
    WriteNamedBitList(value: BitArray, tag?: Nullable_1<Asn1Tag>): void;
    WriteNull(tag?: Nullable_1<Asn1Tag>): void;
    WriteObjectIdentifier(oidValue: string, tag?: Nullable_1<Asn1Tag>): void;
    WriteObjectIdentifier(oidValue: ReadOnlySpan_1<System_Internal.Char>, tag?: Nullable_1<Asn1Tag>): void;
    WriteOctetString(value: ReadOnlySpan_1<System_Internal.Byte>, tag?: Nullable_1<Asn1Tag>): void;
    WriteUtcTime(value: DateTimeOffset, tag?: Nullable_1<Asn1Tag>): void;
    WriteUtcTime(value: DateTimeOffset, twoDigitYearMax: int, tag?: Nullable_1<Asn1Tag>): void;
}


export const AsnWriter: {
    new(ruleSet: AsnEncodingRules): AsnWriter$instance;
    new(ruleSet: AsnEncodingRules, initialCapacity: int): AsnWriter$instance;
};


export type AsnWriter = AsnWriter$instance;

export abstract class AsnDecoder$instance {
    static DecodeLength(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int): Nullable_1<System_Internal.Int32>;
    static ReadBitString(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, unusedBitCount: int, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): byte[];
    static ReadBoolean(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static ReadCharacterString(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, encodingType: UniversalTagNumber, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): string;
    static ReadEncodedValue(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, contentOffset: int, contentLength: int, bytesConsumed: int): Asn1Tag;
    static ReadEnumeratedBytes(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): ReadOnlySpan_1<System_Internal.Byte>;
    static ReadEnumeratedValue<TEnum extends number>(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): TEnum;
    static ReadEnumeratedValue(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, enumType: Type, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): number;
    static ReadGeneralizedTime(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): DateTimeOffset;
    static ReadInteger(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): BigInteger;
    static ReadIntegerBytes(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): ReadOnlySpan_1<System_Internal.Byte>;
    static ReadNamedBitList(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): BitArray;
    static ReadNamedBitListValue<TFlagsEnum extends number>(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): TFlagsEnum;
    static ReadNamedBitListValue(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, flagsEnumType: Type, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): number;
    static ReadNull(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): void;
    static ReadObjectIdentifier(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): string;
    static ReadOctetString(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): byte[];
    static ReadSequence(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, contentOffset: int, contentLength: int, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): void;
    static ReadSetOf(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, contentOffset: int, contentLength: int, bytesConsumed: int, skipSortOrderValidation?: boolean, expectedTag?: Nullable_1<Asn1Tag>): void;
    static ReadUtcTime(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int, twoDigitYearMax?: int, expectedTag?: Nullable_1<Asn1Tag>): DateTimeOffset;
    static TryDecodeLength(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, decodedLength: Nullable_1<System_Internal.Int32>, bytesConsumed: int): boolean;
    static TryReadBitString(source: ReadOnlySpan_1<System_Internal.Byte>, destination: Span_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, unusedBitCount: int, bytesConsumed: int, bytesWritten: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static TryReadCharacterString(source: ReadOnlySpan_1<System_Internal.Byte>, destination: Span_1<System_Internal.Char>, ruleSet: AsnEncodingRules, encodingType: UniversalTagNumber, bytesConsumed: int, charsWritten: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static TryReadCharacterStringBytes(source: ReadOnlySpan_1<System_Internal.Byte>, destination: Span_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, expectedTag: Asn1Tag, bytesConsumed: int, bytesWritten: int): boolean;
    static TryReadEncodedValue(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, tag: Asn1Tag, contentOffset: int, contentLength: int, bytesConsumed: int): boolean;
    static TryReadInt32(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, value: int, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static TryReadInt64(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, value: long, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static TryReadOctetString(source: ReadOnlySpan_1<System_Internal.Byte>, destination: Span_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, bytesConsumed: int, bytesWritten: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static TryReadPrimitiveBitString(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, unusedBitCount: int, value: ReadOnlySpan_1<System_Internal.Byte>, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static TryReadPrimitiveCharacterStringBytes(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, expectedTag: Asn1Tag, value: ReadOnlySpan_1<System_Internal.Byte>, bytesConsumed: int): boolean;
    static TryReadPrimitiveOctetString(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, value: ReadOnlySpan_1<System_Internal.Byte>, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static TryReadUInt32(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, value: uint, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
    static TryReadUInt64(source: ReadOnlySpan_1<System_Internal.Byte>, ruleSet: AsnEncodingRules, value: ulong, bytesConsumed: int, expectedTag?: Nullable_1<Asn1Tag>): boolean;
}


export type AsnDecoder = AsnDecoder$instance;


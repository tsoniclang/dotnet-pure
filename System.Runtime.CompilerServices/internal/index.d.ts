// Generated by tsbindgen - Architecture
// Namespace: System.Runtime.CompilerServices
// Assembly: System.Linq.Expressions, System.Private.CoreLib, System.Runtime.CompilerServices.VisualC, System.Runtime.InteropServices

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IList_1, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import type { ReadOnlyCollection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import type { ContractFailureKind } from "../../System.Diagnostics.Contracts/internal/index.js";
import type { ExpandoObject } from "../../System.Dynamic/internal/index.js";
import type { DebugInfoExpression, Expression, LabelTarget, LambdaExpression, ParameterExpression } from "../../System.Linq.Expressions/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action, Array as ClrArray, AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Char, Decimal, Delegate, Enum, Exception, FormattableString, Func_2, Func_3, IAsyncResult, ICloneable, IComparable, IConvertible, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, InvalidOperationException, ISpanFormattable, ModuleHandle, MulticastDelegate, Object as ClrObject, Range, ReadOnlySpan_1, RuntimeFieldHandle, RuntimeMethodHandle, RuntimeTypeHandle, Span_1, String as ClrString, Type, TypeCode, UInt32, UIntPtr, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum CompilationRelaxations {
    NoStringInterning = 8
}


export enum LoadHint {
    Default = 0,
    Always = 1,
    Sometimes = 2
}


export enum MethodCodeType {
    IL = 0,
    Native = 1,
    OPTIL = 2,
    Runtime = 3
}


export enum MethodImplOptions {
    Unmanaged = 4,
    NoInlining = 8,
    ForwardRef = 16,
    Synchronized = 32,
    NoOptimization = 64,
    PreserveSig = 128,
    AggressiveInlining = 256,
    AggressiveOptimization = 512,
    Async = 8192,
    InternalCall = 4096
}


export enum UnsafeAccessorKind {
    Constructor = 0,
    Method = 1,
    StaticMethod = 2,
    Field = 3,
    StaticField = 4
}


export type ConditionalWeakTable_2_CreateValueCallback<TKey, TValue> = (key: TKey) => TValue;


export type RuntimeHelpers_CleanupCode = (userData: unknown, exceptionThrown: boolean) => void;


export type RuntimeHelpers_TryCode = (userData: unknown) => void;


export interface IAsyncStateMachine$instance {
    MoveNext(): void;
    SetStateMachine(stateMachine: IAsyncStateMachine): void;
}


export type IAsyncStateMachine = IAsyncStateMachine$instance;

export interface ICriticalNotifyCompletion$instance extends INotifyCompletion {
    UnsafeOnCompleted(continuation: Action): void;
    OnCompleted(continuation: Action): void;
}


export interface ICriticalNotifyCompletion$instance extends INotifyCompletion$instance {}

export type ICriticalNotifyCompletion = ICriticalNotifyCompletion$instance;

export interface INotifyCompletion$instance {
    OnCompleted(continuation: Action): void;
}


export type INotifyCompletion = INotifyCompletion$instance;

export interface IRuntimeVariables$instance {
    readonly Count: int;
    Item: unknown;
}


export type IRuntimeVariables = IRuntimeVariables$instance;

export interface IStrongBox$instance {
    Value: unknown;
}


export type IStrongBox = IStrongBox$instance;

export interface ITuple$instance {
    readonly Length: int;
    readonly Item: unknown;
}


export type ITuple = ITuple$instance;

export interface AsyncIteratorMethodBuilder$instance {
    AwaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    AwaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    Complete(): void;
    MoveNext<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
}


export const AsyncIteratorMethodBuilder: {
    new(): AsyncIteratorMethodBuilder$instance;
    Create(): AsyncIteratorMethodBuilder;
};


export type AsyncIteratorMethodBuilder = AsyncIteratorMethodBuilder$instance;

export interface AsyncTaskMethodBuilder$instance {
    readonly Task: Task;
    AwaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    AwaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    SetException(exception: Exception): void;
    SetResult(): void;
    SetStateMachine(stateMachine: IAsyncStateMachine): void;
    Start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
}


export const AsyncTaskMethodBuilder: {
    new(): AsyncTaskMethodBuilder$instance;
    Create(): AsyncTaskMethodBuilder;
};


export type AsyncTaskMethodBuilder = AsyncTaskMethodBuilder$instance;

export interface AsyncTaskMethodBuilder_1$instance<TResult> {
    readonly Task: Task_1<TResult>;
    AwaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    AwaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    SetException(exception: Exception): void;
    SetResult(result: TResult): void;
    SetStateMachine(stateMachine: IAsyncStateMachine): void;
    Start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
}


export const AsyncTaskMethodBuilder_1: {
    new<TResult>(): AsyncTaskMethodBuilder_1$instance<TResult>;
    Create<TResult>(): AsyncTaskMethodBuilder_1<TResult>;
};


export type AsyncTaskMethodBuilder_1<TResult> = AsyncTaskMethodBuilder_1$instance<TResult>;

export interface AsyncValueTaskMethodBuilder$instance {
    readonly Task: ValueTask;
    AwaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    AwaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    SetException(exception: Exception): void;
    SetResult(): void;
    SetStateMachine(stateMachine: IAsyncStateMachine): void;
    Start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
}


export const AsyncValueTaskMethodBuilder: {
    new(): AsyncValueTaskMethodBuilder$instance;
    Create(): AsyncValueTaskMethodBuilder;
};


export type AsyncValueTaskMethodBuilder = AsyncValueTaskMethodBuilder$instance;

export interface AsyncValueTaskMethodBuilder_1$instance<TResult> {
    readonly Task: ValueTask_1<TResult>;
    AwaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    AwaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    SetException(exception: Exception): void;
    SetResult(result: TResult): void;
    SetStateMachine(stateMachine: IAsyncStateMachine): void;
    Start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
}


export const AsyncValueTaskMethodBuilder_1: {
    new<TResult>(): AsyncValueTaskMethodBuilder_1$instance<TResult>;
    Create<TResult>(): AsyncValueTaskMethodBuilder_1<TResult>;
};


export type AsyncValueTaskMethodBuilder_1<TResult> = AsyncValueTaskMethodBuilder_1$instance<TResult>;

export interface AsyncVoidMethodBuilder$instance {
    AwaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    AwaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    SetException(exception: Exception): void;
    SetResult(): void;
    SetStateMachine(stateMachine: IAsyncStateMachine): void;
    Start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
}


export const AsyncVoidMethodBuilder: {
    new(): AsyncVoidMethodBuilder$instance;
    Create(): AsyncVoidMethodBuilder;
};


export type AsyncVoidMethodBuilder = AsyncVoidMethodBuilder$instance;

export interface ConfiguredAsyncDisposable$instance {
    DisposeAsync(): ConfiguredValueTaskAwaitable;
}


export const ConfiguredAsyncDisposable: {
    new(): ConfiguredAsyncDisposable$instance;
};


export type ConfiguredAsyncDisposable = ConfiguredAsyncDisposable$instance;

export interface ConfiguredCancelableAsyncEnumerable_1$instance<T> {
    ConfigureAwait(continueOnCapturedContext: boolean): ConfiguredCancelableAsyncEnumerable_1<T>;
    GetAsyncEnumerator(): ConfiguredCancelableAsyncEnumerable_1_Enumerator<T>;
    WithCancellation(cancellationToken: CancellationToken): ConfiguredCancelableAsyncEnumerable_1<T>;
}


export const ConfiguredCancelableAsyncEnumerable_1: {
    new<T>(): ConfiguredCancelableAsyncEnumerable_1$instance<T>;
};


export type ConfiguredCancelableAsyncEnumerable_1<T> = ConfiguredCancelableAsyncEnumerable_1$instance<T>;

export interface ConfiguredCancelableAsyncEnumerable_1_Enumerator$instance<T> {
    readonly Current: T;
    DisposeAsync(): ConfiguredValueTaskAwaitable;
    MoveNextAsync(): ConfiguredValueTaskAwaitable_1<CLROf<boolean>>;
}


export const ConfiguredCancelableAsyncEnumerable_1_Enumerator: {
    new<T>(): ConfiguredCancelableAsyncEnumerable_1_Enumerator$instance<T>;
};


export type ConfiguredCancelableAsyncEnumerable_1_Enumerator<T> = ConfiguredCancelableAsyncEnumerable_1_Enumerator$instance<T>;

export interface ConfiguredTaskAwaitable$instance {
    GetAwaiter(): ConfiguredTaskAwaitable_ConfiguredTaskAwaiter;
}


export const ConfiguredTaskAwaitable: {
    new(): ConfiguredTaskAwaitable$instance;
};


export type ConfiguredTaskAwaitable = ConfiguredTaskAwaitable$instance;

export interface ConfiguredTaskAwaitable_1$instance<TResult> {
    GetAwaiter(): ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter<TResult>;
}


export const ConfiguredTaskAwaitable_1: {
    new<TResult>(): ConfiguredTaskAwaitable_1$instance<TResult>;
};


export type ConfiguredTaskAwaitable_1<TResult> = ConfiguredTaskAwaitable_1$instance<TResult>;

export interface ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter$instance<TResult> extends ICriticalNotifyCompletion {
    readonly IsCompleted: boolean;
    GetResult(): TResult;
    OnCompleted(continuation: Action): void;
    UnsafeOnCompleted(continuation: Action): void;
}


export const ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter: {
    new<TResult>(): ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter$instance<TResult>;
};


export interface __ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter$views<TResult> {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter$instance<TResult> extends ICriticalNotifyCompletion$instance {}

export type ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter<TResult> = ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter$instance<TResult> & __ConfiguredTaskAwaitable_1_ConfiguredTaskAwaiter$views<TResult>;


export interface ConfiguredTaskAwaitable_ConfiguredTaskAwaiter$instance extends ICriticalNotifyCompletion {
    readonly IsCompleted: boolean;
    GetResult(): void;
    OnCompleted(continuation: Action): void;
    UnsafeOnCompleted(continuation: Action): void;
}


export const ConfiguredTaskAwaitable_ConfiguredTaskAwaiter: {
    new(): ConfiguredTaskAwaitable_ConfiguredTaskAwaiter$instance;
};


export interface __ConfiguredTaskAwaitable_ConfiguredTaskAwaiter$views {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface ConfiguredTaskAwaitable_ConfiguredTaskAwaiter$instance extends ICriticalNotifyCompletion$instance {}

export type ConfiguredTaskAwaitable_ConfiguredTaskAwaiter = ConfiguredTaskAwaitable_ConfiguredTaskAwaiter$instance & __ConfiguredTaskAwaitable_ConfiguredTaskAwaiter$views;


export interface ConfiguredValueTaskAwaitable$instance {
    GetAwaiter(): ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter;
}


export const ConfiguredValueTaskAwaitable: {
    new(): ConfiguredValueTaskAwaitable$instance;
};


export type ConfiguredValueTaskAwaitable = ConfiguredValueTaskAwaitable$instance;

export interface ConfiguredValueTaskAwaitable_1$instance<TResult> {
    GetAwaiter(): ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter<TResult>;
}


export const ConfiguredValueTaskAwaitable_1: {
    new<TResult>(): ConfiguredValueTaskAwaitable_1$instance<TResult>;
};


export type ConfiguredValueTaskAwaitable_1<TResult> = ConfiguredValueTaskAwaitable_1$instance<TResult>;

export interface ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter$instance<TResult> extends ICriticalNotifyCompletion {
    readonly IsCompleted: boolean;
    GetResult(): TResult;
    OnCompleted(continuation: Action): void;
    UnsafeOnCompleted(continuation: Action): void;
}


export const ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter: {
    new<TResult>(): ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter$instance<TResult>;
};


export interface __ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter$views<TResult> {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter$instance<TResult> extends ICriticalNotifyCompletion$instance {}

export type ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter<TResult> = ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter$instance<TResult> & __ConfiguredValueTaskAwaitable_1_ConfiguredValueTaskAwaiter$views<TResult>;


export interface ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter$instance extends ICriticalNotifyCompletion {
    readonly IsCompleted: boolean;
    GetResult(): void;
    OnCompleted(continuation: Action): void;
    UnsafeOnCompleted(continuation: Action): void;
}


export const ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter: {
    new(): ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter$instance;
};


export interface __ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter$views {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter$instance extends ICriticalNotifyCompletion$instance {}

export type ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter = ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter$instance & __ConfiguredValueTaskAwaitable_ConfiguredValueTaskAwaiter$views;


export interface DefaultInterpolatedStringHandler$instance {
    readonly Text: ReadOnlySpan_1<CLROf<char>>;
    AppendFormatted<T>(value: T): void;
    AppendFormatted<T>(value: T, format: string): void;
    AppendFormatted<T>(value: T, alignment: int): void;
    AppendFormatted<T>(value: T, alignment: int, format: string): void;
    AppendFormatted(value: ReadOnlySpan_1<CLROf<char>>): void;
    AppendFormatted(value: ReadOnlySpan_1<CLROf<char>>, alignment?: int, format?: string): void;
    AppendFormatted(value: string): void;
    AppendFormatted(value: string, alignment?: int, format?: string): void;
    AppendFormatted(value: unknown, alignment?: int, format?: string): void;
    AppendLiteral(value: string): void;
    Clear(): void;
    ToString(): string;
    ToStringAndClear(): string;
}


export const DefaultInterpolatedStringHandler: {
    new(literalLength: int, formattedCount: int): DefaultInterpolatedStringHandler$instance;
    new(literalLength: int, formattedCount: int, provider: IFormatProvider): DefaultInterpolatedStringHandler$instance;
    new(literalLength: int, formattedCount: int, provider: IFormatProvider, initialBuffer: Span_1<CLROf<char>>): DefaultInterpolatedStringHandler$instance;
};


export type DefaultInterpolatedStringHandler = DefaultInterpolatedStringHandler$instance;

export interface InlineArray10_1$instance<T> {
}


export const InlineArray10_1: {
    new<T>(): InlineArray10_1$instance<T>;
};


export type InlineArray10_1<T> = InlineArray10_1$instance<T>;

export interface InlineArray11_1$instance<T> {
}


export const InlineArray11_1: {
    new<T>(): InlineArray11_1$instance<T>;
};


export type InlineArray11_1<T> = InlineArray11_1$instance<T>;

export interface InlineArray12_1$instance<T> {
}


export const InlineArray12_1: {
    new<T>(): InlineArray12_1$instance<T>;
};


export type InlineArray12_1<T> = InlineArray12_1$instance<T>;

export interface InlineArray13_1$instance<T> {
}


export const InlineArray13_1: {
    new<T>(): InlineArray13_1$instance<T>;
};


export type InlineArray13_1<T> = InlineArray13_1$instance<T>;

export interface InlineArray14_1$instance<T> {
}


export const InlineArray14_1: {
    new<T>(): InlineArray14_1$instance<T>;
};


export type InlineArray14_1<T> = InlineArray14_1$instance<T>;

export interface InlineArray15_1$instance<T> {
}


export const InlineArray15_1: {
    new<T>(): InlineArray15_1$instance<T>;
};


export type InlineArray15_1<T> = InlineArray15_1$instance<T>;

export interface InlineArray16_1$instance<T> {
}


export const InlineArray16_1: {
    new<T>(): InlineArray16_1$instance<T>;
};


export type InlineArray16_1<T> = InlineArray16_1$instance<T>;

export interface InlineArray2_1$instance<T> {
}


export const InlineArray2_1: {
    new<T>(): InlineArray2_1$instance<T>;
};


export type InlineArray2_1<T> = InlineArray2_1$instance<T>;

export interface InlineArray3_1$instance<T> {
}


export const InlineArray3_1: {
    new<T>(): InlineArray3_1$instance<T>;
};


export type InlineArray3_1<T> = InlineArray3_1$instance<T>;

export interface InlineArray4_1$instance<T> {
}


export const InlineArray4_1: {
    new<T>(): InlineArray4_1$instance<T>;
};


export type InlineArray4_1<T> = InlineArray4_1$instance<T>;

export interface InlineArray5_1$instance<T> {
}


export const InlineArray5_1: {
    new<T>(): InlineArray5_1$instance<T>;
};


export type InlineArray5_1<T> = InlineArray5_1$instance<T>;

export interface InlineArray6_1$instance<T> {
}


export const InlineArray6_1: {
    new<T>(): InlineArray6_1$instance<T>;
};


export type InlineArray6_1<T> = InlineArray6_1$instance<T>;

export interface InlineArray7_1$instance<T> {
}


export const InlineArray7_1: {
    new<T>(): InlineArray7_1$instance<T>;
};


export type InlineArray7_1<T> = InlineArray7_1$instance<T>;

export interface InlineArray8_1$instance<T> {
}


export const InlineArray8_1: {
    new<T>(): InlineArray8_1$instance<T>;
};


export type InlineArray8_1<T> = InlineArray8_1$instance<T>;

export interface InlineArray9_1$instance<T> {
}


export const InlineArray9_1: {
    new<T>(): InlineArray9_1$instance<T>;
};


export type InlineArray9_1<T> = InlineArray9_1$instance<T>;

export interface PoolingAsyncValueTaskMethodBuilder$instance {
    readonly Task: ValueTask;
    AwaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    AwaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    SetException(exception: Exception): void;
    SetResult(): void;
    SetStateMachine(stateMachine: IAsyncStateMachine): void;
    Start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
}


export const PoolingAsyncValueTaskMethodBuilder: {
    new(): PoolingAsyncValueTaskMethodBuilder$instance;
    Create(): PoolingAsyncValueTaskMethodBuilder;
};


export type PoolingAsyncValueTaskMethodBuilder = PoolingAsyncValueTaskMethodBuilder$instance;

export interface PoolingAsyncValueTaskMethodBuilder_1$instance<TResult> {
    readonly Task: ValueTask_1<TResult>;
    AwaitOnCompleted<TAwaiter extends INotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    AwaitUnsafeOnCompleted<TAwaiter extends ICriticalNotifyCompletion, TStateMachine extends IAsyncStateMachine>(awaiter: { value: ref<TAwaiter> }, stateMachine: { value: ref<TStateMachine> }): void;
    SetException(exception: Exception): void;
    SetResult(result: TResult): void;
    SetStateMachine(stateMachine: IAsyncStateMachine): void;
    Start<TStateMachine extends IAsyncStateMachine>(stateMachine: { value: ref<TStateMachine> }): void;
}


export const PoolingAsyncValueTaskMethodBuilder_1: {
    new<TResult>(): PoolingAsyncValueTaskMethodBuilder_1$instance<TResult>;
    Create<TResult>(): PoolingAsyncValueTaskMethodBuilder_1<TResult>;
};


export type PoolingAsyncValueTaskMethodBuilder_1<TResult> = PoolingAsyncValueTaskMethodBuilder_1$instance<TResult>;

export interface TaskAwaiter$instance extends ICriticalNotifyCompletion {
    readonly IsCompleted: boolean;
    GetResult(): void;
    OnCompleted(continuation: Action): void;
    UnsafeOnCompleted(continuation: Action): void;
}


export const TaskAwaiter: {
    new(): TaskAwaiter$instance;
};


export interface __TaskAwaiter$views {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface TaskAwaiter$instance extends ICriticalNotifyCompletion$instance {}

export type TaskAwaiter = TaskAwaiter$instance & __TaskAwaiter$views;


export interface TaskAwaiter_1$instance<TResult> extends ICriticalNotifyCompletion {
    readonly IsCompleted: boolean;
    GetResult(): TResult;
    OnCompleted(continuation: Action): void;
    UnsafeOnCompleted(continuation: Action): void;
}


export const TaskAwaiter_1: {
    new<TResult>(): TaskAwaiter_1$instance<TResult>;
};


export interface __TaskAwaiter_1$views<TResult> {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface TaskAwaiter_1$instance<TResult> extends ICriticalNotifyCompletion$instance {}

export type TaskAwaiter_1<TResult> = TaskAwaiter_1$instance<TResult> & __TaskAwaiter_1$views<TResult>;


export interface ValueTaskAwaiter$instance extends ICriticalNotifyCompletion {
    readonly IsCompleted: boolean;
    GetResult(): void;
    OnCompleted(continuation: Action): void;
    UnsafeOnCompleted(continuation: Action): void;
}


export const ValueTaskAwaiter: {
    new(): ValueTaskAwaiter$instance;
};


export interface __ValueTaskAwaiter$views {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface ValueTaskAwaiter$instance extends ICriticalNotifyCompletion$instance {}

export type ValueTaskAwaiter = ValueTaskAwaiter$instance & __ValueTaskAwaiter$views;


export interface ValueTaskAwaiter_1$instance<TResult> extends ICriticalNotifyCompletion {
    readonly IsCompleted: boolean;
    GetResult(): TResult;
    OnCompleted(continuation: Action): void;
    UnsafeOnCompleted(continuation: Action): void;
}


export const ValueTaskAwaiter_1: {
    new<TResult>(): ValueTaskAwaiter_1$instance<TResult>;
};


export interface __ValueTaskAwaiter_1$views<TResult> {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface ValueTaskAwaiter_1$instance<TResult> extends ICriticalNotifyCompletion$instance {}

export type ValueTaskAwaiter_1<TResult> = ValueTaskAwaiter_1$instance<TResult> & __ValueTaskAwaiter_1$views<TResult>;


export interface YieldAwaitable$instance {
    GetAwaiter(): YieldAwaitable_YieldAwaiter;
}


export const YieldAwaitable: {
    new(): YieldAwaitable$instance;
};


export type YieldAwaitable = YieldAwaitable$instance;

export interface YieldAwaitable_YieldAwaiter$instance extends ICriticalNotifyCompletion {
    readonly IsCompleted: boolean;
    GetResult(): void;
    OnCompleted(continuation: Action): void;
    UnsafeOnCompleted(continuation: Action): void;
}


export const YieldAwaitable_YieldAwaiter: {
    new(): YieldAwaitable_YieldAwaiter$instance;
};


export interface __YieldAwaitable_YieldAwaiter$views {
    As_INotifyCompletion(): INotifyCompletion$instance;
}

export interface YieldAwaitable_YieldAwaiter$instance extends ICriticalNotifyCompletion$instance {}

export type YieldAwaitable_YieldAwaiter = YieldAwaitable_YieldAwaiter$instance & __YieldAwaitable_YieldAwaiter$views;


export interface AccessedThroughPropertyAttribute$instance extends Attribute {
    readonly PropertyName: string;
}


export const AccessedThroughPropertyAttribute: {
    new(propertyName: string): AccessedThroughPropertyAttribute$instance;
};


export type AccessedThroughPropertyAttribute = AccessedThroughPropertyAttribute$instance;

export interface AsyncIteratorStateMachineAttribute$instance extends StateMachineAttribute {
}


export const AsyncIteratorStateMachineAttribute: {
    new(stateMachineType: Type): AsyncIteratorStateMachineAttribute$instance;
};


export type AsyncIteratorStateMachineAttribute = AsyncIteratorStateMachineAttribute$instance;

export interface AsyncMethodBuilderAttribute$instance extends Attribute {
    readonly BuilderType: Type;
}


export const AsyncMethodBuilderAttribute: {
    new(builderType: Type): AsyncMethodBuilderAttribute$instance;
};


export type AsyncMethodBuilderAttribute = AsyncMethodBuilderAttribute$instance;

export interface AsyncStateMachineAttribute$instance extends StateMachineAttribute {
}


export const AsyncStateMachineAttribute: {
    new(stateMachineType: Type): AsyncStateMachineAttribute$instance;
};


export type AsyncStateMachineAttribute = AsyncStateMachineAttribute$instance;

export interface CallConvCdecl$instance {
}


export const CallConvCdecl: {
    new(): CallConvCdecl$instance;
};


export type CallConvCdecl = CallConvCdecl$instance;

export interface CallConvFastcall$instance {
}


export const CallConvFastcall: {
    new(): CallConvFastcall$instance;
};


export type CallConvFastcall = CallConvFastcall$instance;

export interface CallConvMemberFunction$instance {
}


export const CallConvMemberFunction: {
    new(): CallConvMemberFunction$instance;
};


export type CallConvMemberFunction = CallConvMemberFunction$instance;

export interface CallConvStdcall$instance {
}


export const CallConvStdcall: {
    new(): CallConvStdcall$instance;
};


export type CallConvStdcall = CallConvStdcall$instance;

export interface CallConvSuppressGCTransition$instance {
}


export const CallConvSuppressGCTransition: {
    new(): CallConvSuppressGCTransition$instance;
};


export type CallConvSuppressGCTransition = CallConvSuppressGCTransition$instance;

export interface CallConvSwift$instance {
}


export const CallConvSwift: {
    new(): CallConvSwift$instance;
};


export type CallConvSwift = CallConvSwift$instance;

export interface CallConvThiscall$instance {
}


export const CallConvThiscall: {
    new(): CallConvThiscall$instance;
};


export type CallConvThiscall = CallConvThiscall$instance;

export interface CallerArgumentExpressionAttribute$instance extends Attribute {
    readonly ParameterName: string;
}


export const CallerArgumentExpressionAttribute: {
    new(parameterName: string): CallerArgumentExpressionAttribute$instance;
};


export type CallerArgumentExpressionAttribute = CallerArgumentExpressionAttribute$instance;

export interface CallerFilePathAttribute$instance extends Attribute {
}


export const CallerFilePathAttribute: {
    new(): CallerFilePathAttribute$instance;
};


export type CallerFilePathAttribute = CallerFilePathAttribute$instance;

export interface CallerLineNumberAttribute$instance extends Attribute {
}


export const CallerLineNumberAttribute: {
    new(): CallerLineNumberAttribute$instance;
};


export type CallerLineNumberAttribute = CallerLineNumberAttribute$instance;

export interface CallerMemberNameAttribute$instance extends Attribute {
}


export const CallerMemberNameAttribute: {
    new(): CallerMemberNameAttribute$instance;
};


export type CallerMemberNameAttribute = CallerMemberNameAttribute$instance;

export interface CallSite$instance {
    readonly Binder: CallSiteBinder;
}


export const CallSite: {
    new(): CallSite$instance;
    Create(delegateType: Type, binder: CallSiteBinder): CallSite;
};


export type CallSite = CallSite$instance;

export interface CallSite_1$instance<T> extends CallSite {
    Target: T;
    readonly Update: T;
}


export const CallSite_1: {
    new<T>(): CallSite_1$instance<T>;
};


export type CallSite_1<T> = CallSite_1$instance<T>;

export interface CallSiteBinder$instance {
    Bind(args: unknown[], parameters: ReadOnlyCollection_1<ParameterExpression>, returnLabel: LabelTarget): Expression;
    BindDelegate<T>(site: CallSite_1<T>, args: unknown[]): T;
}


export const CallSiteBinder: {
    readonly UpdateLabel: LabelTarget;
};


export type CallSiteBinder = CallSiteBinder$instance;

export interface Closure$instance {
    readonly Constants: unknown[];
    readonly Locals: unknown[];
}


export const Closure: {
    new(constants: unknown[], locals: unknown[]): Closure$instance;
};


export type Closure = Closure$instance;

export interface CollectionBuilderAttribute$instance extends Attribute {
    readonly BuilderType: Type;
    readonly MethodName: string;
}


export const CollectionBuilderAttribute: {
    new(builderType: Type, methodName: string): CollectionBuilderAttribute$instance;
};


export type CollectionBuilderAttribute = CollectionBuilderAttribute$instance;

export interface CompilationRelaxationsAttribute$instance extends Attribute {
    readonly CompilationRelaxations: int;
}


export const CompilationRelaxationsAttribute: {
    new(relaxations: int): CompilationRelaxationsAttribute$instance;
    new(relaxations: CompilationRelaxations): CompilationRelaxationsAttribute$instance;
};


export type CompilationRelaxationsAttribute = CompilationRelaxationsAttribute$instance;

export interface CompilerFeatureRequiredAttribute$instance extends Attribute {
    readonly FeatureName: string;
    IsOptional: boolean;
}


export const CompilerFeatureRequiredAttribute: {
    new(featureName: string): CompilerFeatureRequiredAttribute$instance;
    readonly RefStructs: string;
    readonly RequiredMembers: string;
};


export type CompilerFeatureRequiredAttribute = CompilerFeatureRequiredAttribute$instance;

export interface CompilerGeneratedAttribute$instance extends Attribute {
}


export const CompilerGeneratedAttribute: {
    new(): CompilerGeneratedAttribute$instance;
};


export type CompilerGeneratedAttribute = CompilerGeneratedAttribute$instance;

export interface CompilerGlobalScopeAttribute$instance extends Attribute {
}


export const CompilerGlobalScopeAttribute: {
    new(): CompilerGlobalScopeAttribute$instance;
};


export type CompilerGlobalScopeAttribute = CompilerGlobalScopeAttribute$instance;

export interface CompilerLoweringPreserveAttribute$instance extends Attribute {
}


export const CompilerLoweringPreserveAttribute: {
    new(): CompilerLoweringPreserveAttribute$instance;
};


export type CompilerLoweringPreserveAttribute = CompilerLoweringPreserveAttribute$instance;

export interface ConditionalWeakTable_2$instance<TKey, TValue> {
    Add(key: TKey, value: TValue): void;
    AddOrUpdate(key: TKey, value: TValue): void;
    Clear(): void;
    GetOrAdd(key: TKey, value: TValue): TValue;
    GetOrAdd(key: TKey, valueFactory: Func_2<TKey, TValue>): TValue;
    GetOrAdd<TArg>(key: TKey, valueFactory: Func_3<TKey, TArg, TValue>, factoryArgument: TArg): TValue;
    GetOrCreateValue(key: TKey): TValue;
    GetValue(key: TKey, createValueCallback: ConditionalWeakTable_2_CreateValueCallback<TKey, TValue>): TValue;
    Remove(key: TKey): boolean;
    Remove(key: TKey, value: { value: ref<TValue> }): boolean;
    TryAdd(key: TKey, value: TValue): boolean;
    TryGetValue(key: TKey, value: { value: ref<TValue> }): boolean;
}


export const ConditionalWeakTable_2: {
    new<TKey, TValue>(): ConditionalWeakTable_2$instance<TKey, TValue>;
};


export interface __ConditionalWeakTable_2$views<TKey, TValue> {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export interface ConditionalWeakTable_2$instance<TKey, TValue> extends System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>> {}

export type ConditionalWeakTable_2<TKey, TValue> = ConditionalWeakTable_2$instance<TKey, TValue> & __ConditionalWeakTable_2$views<TKey, TValue>;


export interface CppInlineNamespaceAttribute$instance extends Attribute {
}


export const CppInlineNamespaceAttribute: {
    new(dottedName: string): CppInlineNamespaceAttribute$instance;
};


export type CppInlineNamespaceAttribute = CppInlineNamespaceAttribute$instance;

export interface CreateNewOnMetadataUpdateAttribute$instance extends Attribute {
}


export const CreateNewOnMetadataUpdateAttribute: {
    new(): CreateNewOnMetadataUpdateAttribute$instance;
};


export type CreateNewOnMetadataUpdateAttribute = CreateNewOnMetadataUpdateAttribute$instance;

export interface CustomConstantAttribute$instance extends Attribute {
    readonly Value: unknown;
}


export const CustomConstantAttribute: {
};


export type CustomConstantAttribute = CustomConstantAttribute$instance;

export interface DateTimeConstantAttribute$instance extends CustomConstantAttribute {
    readonly Value: unknown;
}


export const DateTimeConstantAttribute: {
    new(ticks: long): DateTimeConstantAttribute$instance;
};


export type DateTimeConstantAttribute = DateTimeConstantAttribute$instance;

export interface DebugInfoGenerator$instance {
    MarkSequencePoint(method: LambdaExpression, ilOffset: int, sequencePoint: DebugInfoExpression): void;
}


export const DebugInfoGenerator: {
    CreatePdbGenerator(): DebugInfoGenerator;
};


export type DebugInfoGenerator = DebugInfoGenerator$instance;

export interface DecimalConstantAttribute$instance extends Attribute {
    readonly Value: decimal;
}


export const DecimalConstantAttribute: {
    new(scale: byte, sign: byte, hi: uint, mid: uint, low: uint): DecimalConstantAttribute$instance;
    new(scale: byte, sign: byte, hi: int, mid: int, low: int): DecimalConstantAttribute$instance;
};


export type DecimalConstantAttribute = DecimalConstantAttribute$instance;

export interface DefaultDependencyAttribute$instance extends Attribute {
    readonly LoadHint: LoadHint;
}


export const DefaultDependencyAttribute: {
    new(loadHintArgument: LoadHint): DefaultDependencyAttribute$instance;
};


export type DefaultDependencyAttribute = DefaultDependencyAttribute$instance;

export interface DependencyAttribute$instance extends Attribute {
    readonly DependentAssembly: string;
    readonly LoadHint: LoadHint;
}


export const DependencyAttribute: {
    new(dependentAssemblyArgument: string, loadHintArgument: LoadHint): DependencyAttribute$instance;
};


export type DependencyAttribute = DependencyAttribute$instance;

export interface DisablePrivateReflectionAttribute$instance extends Attribute {
}


export const DisablePrivateReflectionAttribute: {
    new(): DisablePrivateReflectionAttribute$instance;
};


export type DisablePrivateReflectionAttribute = DisablePrivateReflectionAttribute$instance;

export interface DisableRuntimeMarshallingAttribute$instance extends Attribute {
}


export const DisableRuntimeMarshallingAttribute: {
    new(): DisableRuntimeMarshallingAttribute$instance;
};


export type DisableRuntimeMarshallingAttribute = DisableRuntimeMarshallingAttribute$instance;

export interface DiscardableAttribute$instance extends Attribute {
}


export const DiscardableAttribute: {
    new(): DiscardableAttribute$instance;
};


export type DiscardableAttribute = DiscardableAttribute$instance;

export interface DynamicAttribute$instance extends Attribute {
    readonly TransformFlags: IList_1<CLROf<boolean>>;
}


export const DynamicAttribute: {
    new(): DynamicAttribute$instance;
    new(transformFlags: boolean[]): DynamicAttribute$instance;
};


export type DynamicAttribute = DynamicAttribute$instance;

export interface EnumeratorCancellationAttribute$instance extends Attribute {
}


export const EnumeratorCancellationAttribute: {
    new(): EnumeratorCancellationAttribute$instance;
};


export type EnumeratorCancellationAttribute = EnumeratorCancellationAttribute$instance;

export interface ExtensionAttribute$instance extends Attribute {
}


export const ExtensionAttribute: {
    new(): ExtensionAttribute$instance;
};


export type ExtensionAttribute = ExtensionAttribute$instance;

export interface ExtensionMarkerAttribute$instance extends Attribute {
    readonly Name: string;
}


export const ExtensionMarkerAttribute: {
    new(name: string): ExtensionMarkerAttribute$instance;
};


export type ExtensionMarkerAttribute = ExtensionMarkerAttribute$instance;

export interface FixedAddressValueTypeAttribute$instance extends Attribute {
}


export const FixedAddressValueTypeAttribute: {
    new(): FixedAddressValueTypeAttribute$instance;
};


export type FixedAddressValueTypeAttribute = FixedAddressValueTypeAttribute$instance;

export interface FixedBufferAttribute$instance extends Attribute {
    readonly ElementType: Type;
    readonly Length: int;
}


export const FixedBufferAttribute: {
    new(elementType: Type, length: int): FixedBufferAttribute$instance;
};


export type FixedBufferAttribute = FixedBufferAttribute$instance;

export interface HasCopySemanticsAttribute$instance extends Attribute {
}


export const HasCopySemanticsAttribute: {
    new(): HasCopySemanticsAttribute$instance;
};


export type HasCopySemanticsAttribute = HasCopySemanticsAttribute$instance;

export interface IDispatchConstantAttribute$instance extends CustomConstantAttribute {
    readonly Value: unknown;
}


export const IDispatchConstantAttribute: {
    new(): IDispatchConstantAttribute$instance;
};


export type IDispatchConstantAttribute = IDispatchConstantAttribute$instance;

export interface IndexerNameAttribute$instance extends Attribute {
}


export const IndexerNameAttribute: {
    new(indexerName: string): IndexerNameAttribute$instance;
};


export type IndexerNameAttribute = IndexerNameAttribute$instance;

export interface InlineArrayAttribute$instance extends Attribute {
    readonly Length: int;
}


export const InlineArrayAttribute: {
    new(length: int): InlineArrayAttribute$instance;
};


export type InlineArrayAttribute = InlineArrayAttribute$instance;

export interface InternalsVisibleToAttribute$instance extends Attribute {
    AllInternalsVisible: boolean;
    readonly AssemblyName: string;
}


export const InternalsVisibleToAttribute: {
    new(assemblyName: string): InternalsVisibleToAttribute$instance;
};


export type InternalsVisibleToAttribute = InternalsVisibleToAttribute$instance;

export interface InterpolatedStringHandlerArgumentAttribute$instance extends Attribute {
    readonly Arguments: string[];
}


export const InterpolatedStringHandlerArgumentAttribute: {
    new(argument: string): InterpolatedStringHandlerArgumentAttribute$instance;
    new(arguments: string[]): InterpolatedStringHandlerArgumentAttribute$instance;
};


export type InterpolatedStringHandlerArgumentAttribute = InterpolatedStringHandlerArgumentAttribute$instance;

export interface InterpolatedStringHandlerAttribute$instance extends Attribute {
}


export const InterpolatedStringHandlerAttribute: {
    new(): InterpolatedStringHandlerAttribute$instance;
};


export type InterpolatedStringHandlerAttribute = InterpolatedStringHandlerAttribute$instance;

export interface IsByRefLikeAttribute$instance extends Attribute {
}


export const IsByRefLikeAttribute: {
    new(): IsByRefLikeAttribute$instance;
};


export type IsByRefLikeAttribute = IsByRefLikeAttribute$instance;

export interface IsReadOnlyAttribute$instance extends Attribute {
}


export const IsReadOnlyAttribute: {
    new(): IsReadOnlyAttribute$instance;
};


export type IsReadOnlyAttribute = IsReadOnlyAttribute$instance;

export interface IsUnmanagedAttribute$instance extends Attribute {
}


export const IsUnmanagedAttribute: {
    new(): IsUnmanagedAttribute$instance;
};


export type IsUnmanagedAttribute = IsUnmanagedAttribute$instance;

export interface IteratorStateMachineAttribute$instance extends StateMachineAttribute {
}


export const IteratorStateMachineAttribute: {
    new(stateMachineType: Type): IteratorStateMachineAttribute$instance;
};


export type IteratorStateMachineAttribute = IteratorStateMachineAttribute$instance;

export interface IUnknownConstantAttribute$instance extends CustomConstantAttribute {
    readonly Value: unknown;
}


export const IUnknownConstantAttribute: {
    new(): IUnknownConstantAttribute$instance;
};


export type IUnknownConstantAttribute = IUnknownConstantAttribute$instance;

export interface MetadataUpdateDeletedAttribute$instance extends Attribute {
}


export const MetadataUpdateDeletedAttribute: {
    new(): MetadataUpdateDeletedAttribute$instance;
};


export type MetadataUpdateDeletedAttribute = MetadataUpdateDeletedAttribute$instance;

export interface MetadataUpdateOriginalTypeAttribute$instance extends Attribute {
    readonly OriginalType: Type;
}


export const MetadataUpdateOriginalTypeAttribute: {
    new(originalType: Type): MetadataUpdateOriginalTypeAttribute$instance;
};


export type MetadataUpdateOriginalTypeAttribute = MetadataUpdateOriginalTypeAttribute$instance;

export interface MethodImplAttribute$instance extends Attribute {
    MethodCodeType: MethodCodeType;
    readonly Value: MethodImplOptions;
}


export const MethodImplAttribute: {
    new(methodImplOptions: MethodImplOptions): MethodImplAttribute$instance;
    new(value: short): MethodImplAttribute$instance;
    new(): MethodImplAttribute$instance;
};


export type MethodImplAttribute = MethodImplAttribute$instance;

export interface ModuleInitializerAttribute$instance extends Attribute {
}


export const ModuleInitializerAttribute: {
    new(): ModuleInitializerAttribute$instance;
};


export type ModuleInitializerAttribute = ModuleInitializerAttribute$instance;

export interface NativeCppClassAttribute$instance extends Attribute {
}


export const NativeCppClassAttribute: {
    new(): NativeCppClassAttribute$instance;
};


export type NativeCppClassAttribute = NativeCppClassAttribute$instance;

export interface NullableAttribute$instance extends Attribute {
    readonly NullableFlags: byte[];
}


export const NullableAttribute: {
    new(value: byte): NullableAttribute$instance;
    new(value: byte[]): NullableAttribute$instance;
};


export type NullableAttribute = NullableAttribute$instance;

export interface NullableContextAttribute$instance extends Attribute {
    readonly Flag: byte;
}


export const NullableContextAttribute: {
    new(value: byte): NullableContextAttribute$instance;
};


export type NullableContextAttribute = NullableContextAttribute$instance;

export interface NullablePublicOnlyAttribute$instance extends Attribute {
    readonly IncludesInternals: boolean;
}


export const NullablePublicOnlyAttribute: {
    new(value: boolean): NullablePublicOnlyAttribute$instance;
};


export type NullablePublicOnlyAttribute = NullablePublicOnlyAttribute$instance;

export interface OverloadResolutionPriorityAttribute$instance extends Attribute {
    readonly Priority: int;
}


export const OverloadResolutionPriorityAttribute: {
    new(priority: int): OverloadResolutionPriorityAttribute$instance;
};


export type OverloadResolutionPriorityAttribute = OverloadResolutionPriorityAttribute$instance;

export interface ParamCollectionAttribute$instance extends Attribute {
}


export const ParamCollectionAttribute: {
    new(): ParamCollectionAttribute$instance;
};


export type ParamCollectionAttribute = ParamCollectionAttribute$instance;

export interface PreserveBaseOverridesAttribute$instance extends Attribute {
}


export const PreserveBaseOverridesAttribute: {
    new(): PreserveBaseOverridesAttribute$instance;
};


export type PreserveBaseOverridesAttribute = PreserveBaseOverridesAttribute$instance;

export interface ReadOnlyCollectionBuilder_1$instance<T> {
    Capacity: int;
    readonly Count: int;
    Item: T;
    Add(item: T): void;
    Clear(): void;
    Contains(item: T): boolean;
    CopyTo(array: T[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator_1<T>;
    IndexOf(item: T): int;
    Insert(index: int, item: T): void;
    Remove(item: T): boolean;
    RemoveAt(index: int): void;
    Reverse(): void;
    Reverse(index: int, count: int): void;
    ToArray(): T[];
    ToReadOnlyCollection(): ReadOnlyCollection_1<T>;
}


export const ReadOnlyCollectionBuilder_1: {
    new<T>(): ReadOnlyCollectionBuilder_1$instance<T>;
    new<T>(capacity: int): ReadOnlyCollectionBuilder_1$instance<T>;
    new<T>(collection: IEnumerable_1<T>): ReadOnlyCollectionBuilder_1$instance<T>;
};


export interface __ReadOnlyCollectionBuilder_1$views<T> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type ReadOnlyCollectionBuilder_1<T> = ReadOnlyCollectionBuilder_1$instance<T> & __ReadOnlyCollectionBuilder_1$views<T>;


export interface ReferenceAssemblyAttribute$instance extends Attribute {
    readonly Description: string;
}


export const ReferenceAssemblyAttribute: {
    new(): ReferenceAssemblyAttribute$instance;
    new(description: string): ReferenceAssemblyAttribute$instance;
};


export type ReferenceAssemblyAttribute = ReferenceAssemblyAttribute$instance;

export interface RefSafetyRulesAttribute$instance extends Attribute {
    readonly Version: int;
}


export const RefSafetyRulesAttribute: {
    new(version: int): RefSafetyRulesAttribute$instance;
};


export type RefSafetyRulesAttribute = RefSafetyRulesAttribute$instance;

export interface RequiredAttributeAttribute$instance extends Attribute {
    readonly RequiredContract: Type;
}


export const RequiredAttributeAttribute: {
    new(requiredContract: Type): RequiredAttributeAttribute$instance;
};


export type RequiredAttributeAttribute = RequiredAttributeAttribute$instance;

export interface RequiredMemberAttribute$instance extends Attribute {
}


export const RequiredMemberAttribute: {
    new(): RequiredMemberAttribute$instance;
};


export type RequiredMemberAttribute = RequiredMemberAttribute$instance;

export interface RequiresLocationAttribute$instance extends Attribute {
}


export const RequiresLocationAttribute: {
    new(): RequiresLocationAttribute$instance;
};


export type RequiresLocationAttribute = RequiresLocationAttribute$instance;

export interface RuleCache_1$instance<T> {
}


export const RuleCache_1: {
    new<T>(): RuleCache_1$instance<T>;
};


export type RuleCache_1<T> = RuleCache_1$instance<T>;

export interface RuntimeCompatibilityAttribute$instance extends Attribute {
    WrapNonExceptionThrows: boolean;
}


export const RuntimeCompatibilityAttribute: {
    new(): RuntimeCompatibilityAttribute$instance;
};


export type RuntimeCompatibilityAttribute = RuntimeCompatibilityAttribute$instance;

export interface RuntimeWrappedException$instance extends Exception {
    readonly WrappedException: unknown;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const RuntimeWrappedException: {
    new(thrownObject: unknown): RuntimeWrappedException$instance;
};


export interface __RuntimeWrappedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type RuntimeWrappedException = RuntimeWrappedException$instance & __RuntimeWrappedException$views;


export interface ScopedRefAttribute$instance extends Attribute {
}


export const ScopedRefAttribute: {
    new(): ScopedRefAttribute$instance;
};


export type ScopedRefAttribute = ScopedRefAttribute$instance;

export interface ScopelessEnumAttribute$instance extends Attribute {
}


export const ScopelessEnumAttribute: {
    new(): ScopelessEnumAttribute$instance;
};


export type ScopelessEnumAttribute = ScopelessEnumAttribute$instance;

export interface SkipLocalsInitAttribute$instance extends Attribute {
}


export const SkipLocalsInitAttribute: {
    new(): SkipLocalsInitAttribute$instance;
};


export type SkipLocalsInitAttribute = SkipLocalsInitAttribute$instance;

export interface SpecialNameAttribute$instance extends Attribute {
}


export const SpecialNameAttribute: {
    new(): SpecialNameAttribute$instance;
};


export type SpecialNameAttribute = SpecialNameAttribute$instance;

export interface StateMachineAttribute$instance extends Attribute {
    readonly StateMachineType: Type;
}


export const StateMachineAttribute: {
    new(stateMachineType: Type): StateMachineAttribute$instance;
};


export type StateMachineAttribute = StateMachineAttribute$instance;

export interface StringFreezingAttribute$instance extends Attribute {
}


export const StringFreezingAttribute: {
    new(): StringFreezingAttribute$instance;
};


export type StringFreezingAttribute = StringFreezingAttribute$instance;

export interface StrongBox_1$instance<T> {
    Value: T;
}


export const StrongBox_1: {
    new<T>(): StrongBox_1$instance<T>;
    new<T>(value: T): StrongBox_1$instance<T>;
};


export interface __StrongBox_1$views<T> {
    As_IStrongBox(): IStrongBox$instance;
}

export interface StrongBox_1$instance<T> extends IStrongBox$instance {}

export type StrongBox_1<T> = StrongBox_1$instance<T> & __StrongBox_1$views<T>;


export interface SuppressIldasmAttribute$instance extends Attribute {
}


export const SuppressIldasmAttribute: {
    new(): SuppressIldasmAttribute$instance;
};


export type SuppressIldasmAttribute = SuppressIldasmAttribute$instance;

export interface SwitchExpressionException$instance extends InvalidOperationException {
    readonly Message: string;
    readonly UnmatchedValue: unknown;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SwitchExpressionException: {
    new(): SwitchExpressionException$instance;
    new(innerException: Exception): SwitchExpressionException$instance;
    new(unmatchedValue: unknown): SwitchExpressionException$instance;
    new(message: string): SwitchExpressionException$instance;
    new(message: string, innerException: Exception): SwitchExpressionException$instance;
};


export interface __SwitchExpressionException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SwitchExpressionException = SwitchExpressionException$instance & __SwitchExpressionException$views;


export interface TupleElementNamesAttribute$instance extends Attribute {
    readonly TransformNames: IList_1<CLROf<string>>;
}


export const TupleElementNamesAttribute: {
    new(transformNames: string[]): TupleElementNamesAttribute$instance;
};


export type TupleElementNamesAttribute = TupleElementNamesAttribute$instance;

export interface TypeForwardedFromAttribute$instance extends Attribute {
    readonly AssemblyFullName: string;
}


export const TypeForwardedFromAttribute: {
    new(assemblyFullName: string): TypeForwardedFromAttribute$instance;
};


export type TypeForwardedFromAttribute = TypeForwardedFromAttribute$instance;

export interface TypeForwardedToAttribute$instance extends Attribute {
    readonly Destination: Type;
}


export const TypeForwardedToAttribute: {
    new(destination: Type): TypeForwardedToAttribute$instance;
};


export type TypeForwardedToAttribute = TypeForwardedToAttribute$instance;

export interface UnsafeAccessorAttribute$instance extends Attribute {
    readonly Kind: UnsafeAccessorKind;
    Name: string;
}


export const UnsafeAccessorAttribute: {
    new(kind: UnsafeAccessorKind): UnsafeAccessorAttribute$instance;
};


export type UnsafeAccessorAttribute = UnsafeAccessorAttribute$instance;

export interface UnsafeAccessorTypeAttribute$instance extends Attribute {
    readonly TypeName: string;
}


export const UnsafeAccessorTypeAttribute: {
    new(typeName: string): UnsafeAccessorTypeAttribute$instance;
};


export type UnsafeAccessorTypeAttribute = UnsafeAccessorTypeAttribute$instance;

export interface UnsafeValueTypeAttribute$instance extends Attribute {
}


export const UnsafeValueTypeAttribute: {
    new(): UnsafeValueTypeAttribute$instance;
};


export type UnsafeValueTypeAttribute = UnsafeValueTypeAttribute$instance;

export abstract class AsyncHelpers$instance {
    static Await<T>(configuredAwaitable: ConfiguredTaskAwaitable_1<T>): T;
    static Await<T>(configuredAwaitable: ConfiguredValueTaskAwaitable_1<T>): T;
    static Await(configuredAwaitable: ConfiguredTaskAwaitable): void;
    static Await(configuredAwaitable: ConfiguredValueTaskAwaitable): void;
    static Await(task: Task): void;
    static Await(task: ValueTask): void;
    static Await<T>(task: Task_1<T>): T;
    static Await<T>(task: ValueTask_1<T>): T;
    static AwaitAwaiter<TAwaiter extends INotifyCompletion>(awaiter: TAwaiter): void;
    static UnsafeAwaitAwaiter<TAwaiter extends ICriticalNotifyCompletion>(awaiter: TAwaiter): void;
}


export type AsyncHelpers = AsyncHelpers$instance;

export abstract class CallSiteHelpers$instance {
    static IsInternalFrame(mb: MethodBase): boolean;
}


export type CallSiteHelpers = CallSiteHelpers$instance;

export abstract class CallSiteOps$instance {
    static AddRule<T>(site: CallSite_1<T>, rule: T): void;
    static Bind<T>(binder: CallSiteBinder, site: CallSite_1<T>, args: unknown[]): T;
    static ClearMatch(site: CallSite): void;
    static CreateMatchmaker<T>(site: CallSite_1<T>): CallSite_1<T>;
    static GetCachedRules<T>(cache: RuleCache_1<T>): T[];
    static GetMatch(site: CallSite): boolean;
    static GetRuleCache<T>(site: CallSite_1<T>): RuleCache_1<T>;
    static GetRules<T>(site: CallSite_1<T>): T[];
    static MoveRule<T>(cache: RuleCache_1<T>, rule: T, i: int): void;
    static SetNotMatched(site: CallSite): boolean;
    static UpdateRules<T>(this_: CallSite_1<T>, matched: int): void;
}


export type CallSiteOps = CallSiteOps$instance;

export abstract class CompilerMarshalOverride$instance {
}


export type CompilerMarshalOverride = CompilerMarshalOverride$instance;

export abstract class ContractHelper$instance {
    static RaiseContractFailedEvent(failureKind: ContractFailureKind, userMessage: string, conditionText: string, innerException: Exception): string;
    static TriggerFailure(kind: ContractFailureKind, displayMessage: string, userMessage: string, conditionText: string, innerException: Exception): void;
}


export type ContractHelper = ContractHelper$instance;

export abstract class FormattableStringFactory$instance {
    static Create(format: string, ...arguments: unknown[]): FormattableString;
}


export type FormattableStringFactory = FormattableStringFactory$instance;

export abstract class IsBoxed$instance {
}


export type IsBoxed = IsBoxed$instance;

export abstract class IsByValue$instance {
}


export type IsByValue = IsByValue$instance;

export abstract class IsConst$instance {
}


export type IsConst = IsConst$instance;

export abstract class IsCopyConstructed$instance {
}


export type IsCopyConstructed = IsCopyConstructed$instance;

export abstract class IsExplicitlyDereferenced$instance {
}


export type IsExplicitlyDereferenced = IsExplicitlyDereferenced$instance;

export abstract class IsExternalInit$instance {
}


export type IsExternalInit = IsExternalInit$instance;

export abstract class IsImplicitlyDereferenced$instance {
}


export type IsImplicitlyDereferenced = IsImplicitlyDereferenced$instance;

export abstract class IsJitIntrinsic$instance {
}


export type IsJitIntrinsic = IsJitIntrinsic$instance;

export abstract class IsLong$instance {
}


export type IsLong = IsLong$instance;

export abstract class IsPinned$instance {
}


export type IsPinned = IsPinned$instance;

export abstract class IsSignUnspecifiedByte$instance {
}


export type IsSignUnspecifiedByte = IsSignUnspecifiedByte$instance;

export abstract class IsUdtReturn$instance {
}


export type IsUdtReturn = IsUdtReturn$instance;

export abstract class IsVolatile$instance {
}


export type IsVolatile = IsVolatile$instance;

export abstract class RuntimeFeature$instance {
    static readonly PortablePdb: string;
    static readonly DefaultImplementationsOfInterfaces: string;
    static readonly UnmanagedSignatureCallingConvention: string;
    static readonly CovariantReturnsOfClasses: string;
    static readonly ByRefFields: string;
    static readonly ByRefLikeGenerics: string;
    static readonly VirtualStaticsInInterfaces: string;
    static readonly NumericIntPtr: string;
    static readonly IsDynamicCodeSupported: boolean;
    static readonly IsDynamicCodeCompiled: boolean;
    static IsSupported(feature: string): boolean;
}


export type RuntimeFeature = RuntimeFeature$instance;

export abstract class RuntimeHelpers$instance {
    static readonly OffsetToStringData: int;
    static AllocateTypeAssociatedMemory(type_: Type, size: int): nint;
    static Box(target: { value: ref<byte> }, type_: RuntimeTypeHandle): unknown;
    static CreateSpan<T>(fldHandle: RuntimeFieldHandle): ReadOnlySpan_1<T>;
    static EnsureSufficientExecutionStack(): void;
    static Equals(o1: unknown, o2: unknown): boolean;
    static ExecuteCodeWithGuaranteedCleanup(code: RuntimeHelpers_TryCode, backoutCode: RuntimeHelpers_CleanupCode, userData: unknown): void;
    static GetHashCode(o: unknown): int;
    static GetObjectValue(obj: unknown): unknown;
    static GetSubArray<T>(array: T[], range: Range): T[];
    static GetUninitializedObject(type_: Type): unknown;
    static InitializeArray(array: ClrArray, fldHandle: RuntimeFieldHandle): void;
    static IsReferenceOrContainsReferences<T>(): boolean;
    static PrepareConstrainedRegions(): void;
    static PrepareConstrainedRegionsNoOP(): void;
    static PrepareContractedDelegate(d: Function): void;
    static PrepareDelegate(d: Function): void;
    static PrepareMethod(method: RuntimeMethodHandle, instantiation: RuntimeTypeHandle[]): void;
    static PrepareMethod(method: RuntimeMethodHandle): void;
    static ProbeForSufficientStack(): void;
    static RunClassConstructor(type_: RuntimeTypeHandle): void;
    static RunModuleConstructor(module_: ModuleHandle): void;
    static SizeOf(type_: RuntimeTypeHandle): int;
    static TryEnsureSufficientExecutionStack(): boolean;
}


export type RuntimeHelpers = RuntimeHelpers$instance;

export abstract class RuntimeOps$instance {
    static CreateRuntimeVariables(): IRuntimeVariables;
    static CreateRuntimeVariables(data: unknown[], indexes: long[]): IRuntimeVariables;
    static ExpandoCheckVersion(expando: ExpandoObject, version: unknown): boolean;
    static ExpandoPromoteClass(expando: ExpandoObject, oldClass: unknown, newClass: unknown): void;
    static ExpandoTryDeleteValue(expando: ExpandoObject, indexClass: unknown, index: int, name: string, ignoreCase: boolean): boolean;
    static ExpandoTryGetValue(expando: ExpandoObject, indexClass: unknown, index: int, name: string, ignoreCase: boolean, value: { value: ref<unknown> }): boolean;
    static ExpandoTrySetValue(expando: ExpandoObject, indexClass: unknown, index: int, value: unknown, name: string, ignoreCase: boolean): unknown;
    static MergeRuntimeVariables(first: IRuntimeVariables, second: IRuntimeVariables, indexes: int[]): IRuntimeVariables;
    static Quote(expression: Expression, hoistedLocals: unknown, locals: unknown[]): Expression;
}


export type RuntimeOps = RuntimeOps$instance;

export abstract class Unsafe$instance {
    static Add<T>(source: ptr<void>, elementOffset: int): ptr<void>;
    static Add<T>(source: { value: ref<T> }, elementOffset: int): ref<T>;
    static Add<T>(source: { value: ref<T> }, elementOffset: nint): ref<T>;
    static Add<T>(source: { value: ref<T> }, elementOffset: nuint): ref<T>;
    static AddByteOffset<T>(source: { value: ref<T> }, byteOffset: nint): ref<T>;
    static AddByteOffset<T>(source: { value: ref<T> }, byteOffset: nuint): ref<T>;
    static AreSame<T>(left: { value: ref<T> }, right: { value: ref<T> }): boolean;
    static As<T>(o: unknown): T;
    static As<TFrom, TTo>(source: { value: ref<TFrom> }): ref<TTo>;
    static AsPointer<T>(value: { value: ref<T> }): ptr<void>;
    static AsRef<T>(source: ptr<void>): ref<T>;
    static AsRef<T>(source: { value: ref<T> }): ref<T>;
    static BitCast<TFrom, TTo>(source: TFrom): TTo;
    static ByteOffset<T>(origin: { value: ref<T> }, target: { value: ref<T> }): nint;
    static Copy<T>(destination: ptr<void>, source: { value: ref<T> }): void;
    static Copy<T>(destination: { value: ref<T> }, source: ptr<void>): void;
    static CopyBlock(destination: { value: ref<byte> }, source: { value: ref<byte> }, byteCount: uint): void;
    static CopyBlock(destination: ptr<void>, source: ptr<void>, byteCount: uint): void;
    static CopyBlockUnaligned(destination: { value: ref<byte> }, source: { value: ref<byte> }, byteCount: uint): void;
    static CopyBlockUnaligned(destination: ptr<void>, source: ptr<void>, byteCount: uint): void;
    static InitBlock(startAddress: { value: ref<byte> }, value: byte, byteCount: uint): void;
    static InitBlock(startAddress: ptr<void>, value: byte, byteCount: uint): void;
    static InitBlockUnaligned(startAddress: { value: ref<byte> }, value: byte, byteCount: uint): void;
    static InitBlockUnaligned(startAddress: ptr<void>, value: byte, byteCount: uint): void;
    static IsAddressGreaterThan<T>(left: { value: ref<T> }, right: { value: ref<T> }): boolean;
    static IsAddressGreaterThanOrEqualTo<T>(left: { value: ref<T> }, right: { value: ref<T> }): boolean;
    static IsAddressLessThan<T>(left: { value: ref<T> }, right: { value: ref<T> }): boolean;
    static IsAddressLessThanOrEqualTo<T>(left: { value: ref<T> }, right: { value: ref<T> }): boolean;
    static IsNullRef<T>(source: { value: ref<T> }): boolean;
    static NullRef<T>(): ref<T>;
    static Read<T>(source: ptr<void>): T;
    static ReadUnaligned<T>(source: { value: ref<byte> }): T;
    static ReadUnaligned<T>(source: ptr<void>): T;
    static SizeOf<T>(): int;
    static SkipInit<T>(value: { value: ref<T> }): void;
    static Subtract<T>(source: ptr<void>, elementOffset: int): ptr<void>;
    static Subtract<T>(source: { value: ref<T> }, elementOffset: int): ref<T>;
    static Subtract<T>(source: { value: ref<T> }, elementOffset: nint): ref<T>;
    static Subtract<T>(source: { value: ref<T> }, elementOffset: nuint): ref<T>;
    static SubtractByteOffset<T>(source: { value: ref<T> }, byteOffset: nint): ref<T>;
    static SubtractByteOffset<T>(source: { value: ref<T> }, byteOffset: nuint): ref<T>;
    static Unbox<T extends unknown>(box: unknown): ref<T>;
    static Write<T>(destination: ptr<void>, value: T): void;
    static WriteUnaligned<T>(destination: { value: ref<byte> }, value: T): void;
    static WriteUnaligned<T>(destination: ptr<void>, value: T): void;
}


export type Unsafe = Unsafe$instance;


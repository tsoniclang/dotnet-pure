// Generated by tsbindgen - Architecture
// Namespace: System.Buffers
// Assembly: System.Memory, System.Private.CoreLib

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { MethodInfo } from "../../System.Reflection/internal/index.js";
import type { GCHandle } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { AsyncCallback, Boolean as ClrBoolean, Byte, Char, Delegate, Enum, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, Memory_1, MulticastDelegate, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, SequencePosition, Span_1, String as ClrString, StringComparison, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

export enum OperationStatus {
    Done = 0,
    DestinationTooSmall = 1,
    NeedMoreData = 2,
    InvalidData = 3
}


export type ReadOnlySpanAction_2<T, TArg> = (span: ReadOnlySpan_1<T>, arg: TArg) => void;


export type SpanAction_2<T, TArg> = (span: Span_1<T>, arg: TArg) => void;


export interface IBufferWriter_1$instance<T> {
    Advance(count: int): void;
    GetMemory(sizeHint?: int): Memory_1<T>;
    GetSpan(sizeHint?: int): Span_1<T>;
}


export type IBufferWriter_1<T> = IBufferWriter_1$instance<T>;

export interface IMemoryOwner_1$instance<T> extends IDisposable {
    readonly Memory: Memory_1<T>;
    Dispose(): void;
}


export interface IMemoryOwner_1$instance<T> extends System_Internal.IDisposable$instance {}

export type IMemoryOwner_1<T> = IMemoryOwner_1$instance<T>;

export interface IPinnable$instance {
    Pin(elementIndex: int): MemoryHandle;
    Unpin(): void;
}


export type IPinnable = IPinnable$instance;

export interface MemoryHandle$instance {
    readonly Pointer: ptr<void>;
    Dispose(): void;
}


export const MemoryHandle: {
    new(pointer: ptr<void>, handle: GCHandle, pinnable: IPinnable | undefined): MemoryHandle;
};


export interface __MemoryHandle$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MemoryHandle$instance extends System_Internal.IDisposable$instance {}

export type MemoryHandle = MemoryHandle$instance & __MemoryHandle$views;


export interface ReadOnlySequence_1$instance<T> {
    readonly End: SequencePosition;
    readonly First: ReadOnlyMemory_1<T>;
    readonly FirstSpan: ReadOnlySpan_1<T>;
    readonly IsEmpty: boolean;
    readonly IsSingleSegment: boolean;
    readonly Length: long;
    readonly Start: SequencePosition;
    GetEnumerator(): ReadOnlySequence_1_Enumerator<T>;
    GetOffset(position: SequencePosition): long;
    GetPosition(offset: long): SequencePosition;
    GetPosition(offset: long, origin: SequencePosition): SequencePosition;
    Slice(start: long, length: long): ReadOnlySequence_1<T>;
    Slice(start: long, end: SequencePosition): ReadOnlySequence_1<T>;
    Slice(start: SequencePosition, length: long): ReadOnlySequence_1<T>;
    Slice(start: int, length: int): ReadOnlySequence_1<T>;
    Slice(start: int, end: SequencePosition): ReadOnlySequence_1<T>;
    Slice(start: SequencePosition, length: int): ReadOnlySequence_1<T>;
    Slice(start: SequencePosition, end: SequencePosition): ReadOnlySequence_1<T>;
    Slice(start: SequencePosition): ReadOnlySequence_1<T>;
    Slice(start: long): ReadOnlySequence_1<T>;
    ToString(): string;
    TryGet(position: SequencePosition, memory: ReadOnlyMemory_1<T>, advance?: boolean): boolean;
}


export const ReadOnlySequence_1: {
    new<T>(startSegment: ReadOnlySequenceSegment_1<T>, startIndex: int, endSegment: ReadOnlySequenceSegment_1<T>, endIndex: int): ReadOnlySequence_1<T>;
    new<T>(array: T[]): ReadOnlySequence_1<T>;
    new<T>(array: T[], start: int, length: int): ReadOnlySequence_1<T>;
    new<T>(memory: ReadOnlyMemory_1<T>): ReadOnlySequence_1<T>;
    readonly Empty: unknown;
};


export type ReadOnlySequence_1<T> = ReadOnlySequence_1$instance<T>;

export interface ReadOnlySequence_1_Enumerator$instance<T> {
    readonly Current: ReadOnlyMemory_1<T>;
    MoveNext(): boolean;
}


export const ReadOnlySequence_1_Enumerator: {
    new<T>(sequence: ReadOnlySequence_1<T>): ReadOnlySequence_1_Enumerator<T>;
};


export type ReadOnlySequence_1_Enumerator<T> = ReadOnlySequence_1_Enumerator$instance<T>;

export interface SequenceReader_1$instance<T extends (IEquatable_1<T> | number | string | boolean)> {
    readonly Consumed: long;
    readonly CurrentSpan: ReadOnlySpan_1<T>;
    readonly CurrentSpanIndex: int;
    readonly End: boolean;
    readonly Length: long;
    readonly Position: SequencePosition;
    readonly Remaining: long;
    readonly Sequence: ReadOnlySequence_1<T>;
    readonly UnreadSequence: ReadOnlySequence_1<T>;
    readonly UnreadSpan: ReadOnlySpan_1<T>;
    Advance(count: long): void;
    AdvancePast(value: T): long;
    AdvancePastAny(values: ReadOnlySpan_1<T>): long;
    AdvancePastAny(value0: T, value1: T, value2: T, value3: T): long;
    AdvancePastAny(value0: T, value1: T, value2: T): long;
    AdvancePastAny(value0: T, value1: T): long;
    AdvanceToEnd(): void;
    IsNext(next: T, advancePast?: boolean): boolean;
    IsNext(next: ReadOnlySpan_1<T>, advancePast?: boolean): boolean;
    Rewind(count: long): void;
    TryAdvanceTo(delimiter: T, advancePastDelimiter?: boolean): boolean;
    TryAdvanceToAny(delimiters: ReadOnlySpan_1<T>, advancePastDelimiter?: boolean): boolean;
    TryCopyTo(destination: Span_1<T>): boolean;
    TryPeek(value: T): boolean;
    TryPeek(offset: long, value: T): boolean;
    TryRead(value: T): boolean;
    TryReadExact(count: int, sequence: ReadOnlySequence_1<T>): boolean;
    TryReadTo(span: ReadOnlySpan_1<T>, delimiter: T, advancePastDelimiter?: boolean): boolean;
    TryReadTo(span: ReadOnlySpan_1<T>, delimiter: T, delimiterEscape: T, advancePastDelimiter?: boolean): boolean;
    TryReadTo(sequence: ReadOnlySequence_1<T>, delimiter: T, advancePastDelimiter?: boolean): boolean;
    TryReadTo(sequence: ReadOnlySequence_1<T>, delimiter: T, delimiterEscape: T, advancePastDelimiter?: boolean): boolean;
    TryReadTo(span: ReadOnlySpan_1<T>, delimiter: ReadOnlySpan_1<T>, advancePastDelimiter?: boolean): boolean;
    TryReadTo(sequence: ReadOnlySequence_1<T>, delimiter: ReadOnlySpan_1<T>, advancePastDelimiter?: boolean): boolean;
    TryReadToAny(span: ReadOnlySpan_1<T>, delimiters: ReadOnlySpan_1<T>, advancePastDelimiter?: boolean): boolean;
    TryReadToAny(sequence: ReadOnlySequence_1<T>, delimiters: ReadOnlySpan_1<T>, advancePastDelimiter?: boolean): boolean;
}


export const SequenceReader_1: {
    new<T extends (IEquatable_1<T> | number | string | boolean)>(sequence: ReadOnlySequence_1<T>): SequenceReader_1<T>;
};


export type SequenceReader_1<T extends (IEquatable_1<T> | number | string | boolean)> = SequenceReader_1$instance<T>;

export interface StandardFormat$instance {
    readonly HasPrecision: boolean;
    readonly IsDefault: boolean;
    readonly Precision: byte;
    readonly Symbol: char;
    Equals(obj: unknown): boolean;
    Equals(other: StandardFormat): boolean;
    GetHashCode(): int;
    ToString(): string | undefined;
}


export const StandardFormat: {
    new(symbol_: char, precision: byte): StandardFormat;
    readonly NoPrecision: byte;
    readonly MaxPrecision: byte;
    Parse(format: ReadOnlySpan_1<System_Internal.Char>): StandardFormat;
    Parse(format: string): StandardFormat;
    TryParse(format: ReadOnlySpan_1<System_Internal.Char>, result: StandardFormat): boolean;
};


export interface __StandardFormat$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<StandardFormat>;

    // Structural method bridges for numeric interface constraints
    Equals(other: StandardFormat): boolean;
}

export type StandardFormat = StandardFormat$instance & __StandardFormat$views;


export interface ArrayBufferWriter_1$instance<T> {
    readonly Capacity: int;
    readonly FreeCapacity: int;
    readonly WrittenCount: int;
    readonly WrittenMemory: ReadOnlyMemory_1<T>;
    readonly WrittenSpan: ReadOnlySpan_1<T>;
    Advance(count: int): void;
    Clear(): void;
    GetMemory(sizeHint?: int): Memory_1<T>;
    GetSpan(sizeHint?: int): Span_1<T>;
    ResetWrittenCount(): void;
}


export const ArrayBufferWriter_1: {
    new<T>(): ArrayBufferWriter_1<T>;
    new<T>(initialCapacity: int): ArrayBufferWriter_1<T>;
};


export interface __ArrayBufferWriter_1$views<T> {
    As_IBufferWriter_1(): IBufferWriter_1$instance<T>;
}

export interface ArrayBufferWriter_1$instance<T> extends IBufferWriter_1$instance<T> {}

export type ArrayBufferWriter_1<T> = ArrayBufferWriter_1$instance<T> & __ArrayBufferWriter_1$views<T>;


export interface ArrayPool_1$instance<T> {
    Rent(minimumLength: int): T[];
    Return(array: T[], clearArray?: boolean): void;
}


export const ArrayPool_1: {
    readonly Shared: unknown;
    Create<T>(): ArrayPool_1<T>;
    Create<T>(maxArrayLength: int, maxArraysPerBucket: int): ArrayPool_1<T>;
};


export type ArrayPool_1<T> = ArrayPool_1$instance<T>;

export interface MemoryManager_1$instance<T> {
    readonly Memory: Memory_1<T>;
    GetSpan(): Span_1<T>;
    Pin(elementIndex?: int): MemoryHandle;
    Unpin(): void;
}


export const MemoryManager_1: {
};


export interface __MemoryManager_1$views<T> {
    As_IMemoryOwner_1(): IMemoryOwner_1$instance<T>;
    As_IPinnable(): IPinnable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MemoryManager_1$instance<T> extends IMemoryOwner_1$instance<T> {}

export type MemoryManager_1<T> = MemoryManager_1$instance<T> & __MemoryManager_1$views<T>;


export interface MemoryPool_1$instance<T> {
    readonly MaxBufferSize: int;
    Dispose(): void;
    Rent(minBufferSize?: int): IMemoryOwner_1<T>;
}


export const MemoryPool_1: {
    readonly Shared: unknown;
};


export interface __MemoryPool_1$views<T> {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MemoryPool_1$instance<T> extends System_Internal.IDisposable$instance {}

export type MemoryPool_1<T> = MemoryPool_1$instance<T> & __MemoryPool_1$views<T>;


export interface ReadOnlySequenceSegment_1$instance<T> {
    readonly Memory: ReadOnlyMemory_1<T>;
    readonly Next: ReadOnlySequenceSegment_1<T> | undefined;
    readonly RunningIndex: long;
}


export const ReadOnlySequenceSegment_1: {
};


export type ReadOnlySequenceSegment_1<T> = ReadOnlySequenceSegment_1$instance<T>;

export interface SearchValues_1$instance<T extends (IEquatable_1<T> | number | string | boolean)> {
    Contains(value: T): boolean;
}


export const SearchValues_1: {
    new<T extends (IEquatable_1<T> | number | string | boolean)>(): SearchValues_1<T>;
};


export type SearchValues_1<T extends (IEquatable_1<T> | number | string | boolean)> = SearchValues_1$instance<T>;

export abstract class BuffersExtensions$instance {
    static CopyTo<T>(source: ReadOnlySequence_1<T>, destination: Span_1<T>): void;
    static PositionOf<T extends IEquatable_1<T>>(source: ReadOnlySequence_1<T>, value: T): Nullable_1<SequencePosition>;
    static ToArray<T>(sequence: ReadOnlySequence_1<T>): T[];
    static Write<T>(writer: IBufferWriter_1<T>, value: ReadOnlySpan_1<T>): void;
}


export type BuffersExtensions = BuffersExtensions$instance;

export abstract class SearchValues$instance {
    static Create(values: ReadOnlySpan_1<System_Internal.Byte>): SearchValues_1<System_Internal.Byte>;
    static Create(values: ReadOnlySpan_1<System_Internal.Char>): SearchValues_1<System_Internal.Char>;
    static Create(values: ReadOnlySpan_1<System_Internal.String>, comparisonType: StringComparison): SearchValues_1<System_Internal.String>;
}


export type SearchValues = SearchValues$instance;

export abstract class SequenceReaderExtensions$instance {
    static TryReadBigEndian(reader: SequenceReader_1<System_Internal.Byte>, value: short): boolean;
    static TryReadBigEndian(reader: SequenceReader_1<System_Internal.Byte>, value: int): boolean;
    static TryReadBigEndian(reader: SequenceReader_1<System_Internal.Byte>, value: long): boolean;
    static TryReadLittleEndian(reader: SequenceReader_1<System_Internal.Byte>, value: short): boolean;
    static TryReadLittleEndian(reader: SequenceReader_1<System_Internal.Byte>, value: int): boolean;
    static TryReadLittleEndian(reader: SequenceReader_1<System_Internal.Byte>, value: long): boolean;
}


export type SequenceReaderExtensions = SequenceReaderExtensions$instance;


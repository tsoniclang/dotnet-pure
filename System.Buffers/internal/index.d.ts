// Generated by tsbindgen - Architecture
// Namespace: System.Buffers
// Assembly: System.Memory, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { MethodInfo } from "../../System.Reflection/internal/index.js";
import type { GCHandle } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { AsyncCallback, Boolean as ClrBoolean, Byte, Char, Delegate, Enum, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, Memory_1, MulticastDelegate, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, SequencePosition, Span_1, String as ClrString, StringComparison, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum OperationStatus {
    Done = 0,
    DestinationTooSmall = 1,
    NeedMoreData = 2,
    InvalidData = 3
}


export type ReadOnlySpanAction_2<T, TArg> = (span: ReadOnlySpan_1<T>, arg: TArg) => void;


export type SpanAction_2<T, TArg> = (span: Span_1<T>, arg: TArg) => void;


export interface IBufferWriter_1$instance<T> {
    Advance(count: int): void;
    GetMemory(sizeHint?: int): Memory_1<T>;
    GetSpan(sizeHint?: int): Span_1<T>;
}


export type IBufferWriter_1<T> = IBufferWriter_1$instance<T>;

export interface IMemoryOwner_1$instance<T> extends IDisposable {
    readonly Memory: Memory_1<T>;
    Dispose(): void;
}


export interface IMemoryOwner_1$instance<T> extends System_Internal.IDisposable$instance {}

export type IMemoryOwner_1<T> = IMemoryOwner_1$instance<T>;

export interface IPinnable$instance {
    Pin(elementIndex: int): MemoryHandle;
    Unpin(): void;
}


export type IPinnable = IPinnable$instance;

export interface MemoryHandle$instance {
    readonly Pointer: ptr<void>;
    Dispose(): void;
}


export const MemoryHandle: {
    new(pointer: ptr<void>, handle: GCHandle, pinnable: IPinnable): MemoryHandle$instance;
};


export interface __MemoryHandle$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MemoryHandle$instance extends System_Internal.IDisposable$instance {}

export type MemoryHandle = MemoryHandle$instance & __MemoryHandle$views;


export interface ReadOnlySequence_1$instance<T> {
    readonly End: SequencePosition;
    readonly First: ReadOnlyMemory_1<T>;
    readonly FirstSpan: ReadOnlySpan_1<T>;
    readonly IsEmpty: boolean;
    readonly IsSingleSegment: boolean;
    readonly Length: long;
    readonly Start: SequencePosition;
    GetEnumerator(): ReadOnlySequence_1_Enumerator<T>;
    GetOffset(position: SequencePosition): long;
    GetPosition(offset: long): SequencePosition;
    GetPosition(offset: long, origin: SequencePosition): SequencePosition;
    Slice(start: long, length: long): ReadOnlySequence_1<T>;
    Slice(start: long, end: SequencePosition): ReadOnlySequence_1<T>;
    Slice(start: SequencePosition, length: long): ReadOnlySequence_1<T>;
    Slice(start: int, length: int): ReadOnlySequence_1<T>;
    Slice(start: int, end: SequencePosition): ReadOnlySequence_1<T>;
    Slice(start: SequencePosition, length: int): ReadOnlySequence_1<T>;
    Slice(start: SequencePosition, end: SequencePosition): ReadOnlySequence_1<T>;
    Slice(start: SequencePosition): ReadOnlySequence_1<T>;
    Slice(start: long): ReadOnlySequence_1<T>;
    ToString(): string;
    TryGet(position: { value: ref<SequencePosition> }, memory: { value: ref<ReadOnlyMemory_1<T>> }, advance?: boolean): boolean;
}


export const ReadOnlySequence_1: {
    new<T>(startSegment: ReadOnlySequenceSegment_1<T>, startIndex: int, endSegment: ReadOnlySequenceSegment_1<T>, endIndex: int): ReadOnlySequence_1$instance<T>;
    new<T>(array: T[]): ReadOnlySequence_1$instance<T>;
    new<T>(array: T[], start: int, length: int): ReadOnlySequence_1$instance<T>;
    new<T>(memory: ReadOnlyMemory_1<T>): ReadOnlySequence_1$instance<T>;
    readonly Empty: unknown;
};


export type ReadOnlySequence_1<T> = ReadOnlySequence_1$instance<T>;

export interface ReadOnlySequence_1_Enumerator$instance<T> {
    readonly Current: ReadOnlyMemory_1<T>;
    MoveNext(): boolean;
}


export const ReadOnlySequence_1_Enumerator: {
    new<T>(sequence: ref<ReadOnlySequence_1<T>>): ReadOnlySequence_1_Enumerator$instance<T>;
};


export type ReadOnlySequence_1_Enumerator<T> = ReadOnlySequence_1_Enumerator$instance<T>;

export interface SequenceReader_1$instance<T extends (IEquatable_1<T> | number | string | boolean)> {
    readonly Consumed: long;
    readonly CurrentSpan: ReadOnlySpan_1<T>;
    readonly CurrentSpanIndex: int;
    readonly End: boolean;
    readonly Length: long;
    readonly Position: SequencePosition;
    readonly Remaining: long;
    readonly Sequence: ReadOnlySequence_1<T>;
    readonly UnreadSequence: ReadOnlySequence_1<T>;
    readonly UnreadSpan: ReadOnlySpan_1<T>;
    Advance(count: long): void;
    AdvancePast(value: T): long;
    AdvancePastAny(values: ReadOnlySpan_1<T>): long;
    AdvancePastAny(value0: T, value1: T, value2: T, value3: T): long;
    AdvancePastAny(value0: T, value1: T, value2: T): long;
    AdvancePastAny(value0: T, value1: T): long;
    AdvanceToEnd(): void;
    IsNext(next: T, advancePast?: boolean): boolean;
    IsNext(next: ReadOnlySpan_1<T>, advancePast?: boolean): boolean;
    Rewind(count: long): void;
    TryAdvanceTo(delimiter: T, advancePastDelimiter?: boolean): boolean;
    TryAdvanceToAny(delimiters: ReadOnlySpan_1<T>, advancePastDelimiter?: boolean): boolean;
    TryCopyTo(destination: Span_1<T>): boolean;
    TryPeek(value: { value: ref<T> }): boolean;
    TryPeek(offset: long, value: { value: ref<T> }): boolean;
    TryRead(value: { value: ref<T> }): boolean;
    TryReadExact(count: int, sequence: { value: ref<ReadOnlySequence_1<T>> }): boolean;
    TryReadTo(span: { value: ref<ReadOnlySpan_1<T>> }, delimiter: T, advancePastDelimiter?: boolean): boolean;
    TryReadTo(span: { value: ref<ReadOnlySpan_1<T>> }, delimiter: T, delimiterEscape: T, advancePastDelimiter?: boolean): boolean;
    TryReadTo(sequence: { value: ref<ReadOnlySequence_1<T>> }, delimiter: T, advancePastDelimiter?: boolean): boolean;
    TryReadTo(sequence: { value: ref<ReadOnlySequence_1<T>> }, delimiter: T, delimiterEscape: T, advancePastDelimiter?: boolean): boolean;
    TryReadTo(span: { value: ref<ReadOnlySpan_1<T>> }, delimiter: ReadOnlySpan_1<T>, advancePastDelimiter?: boolean): boolean;
    TryReadTo(sequence: { value: ref<ReadOnlySequence_1<T>> }, delimiter: ReadOnlySpan_1<T>, advancePastDelimiter?: boolean): boolean;
    TryReadToAny(span: { value: ref<ReadOnlySpan_1<T>> }, delimiters: ReadOnlySpan_1<T>, advancePastDelimiter?: boolean): boolean;
    TryReadToAny(sequence: { value: ref<ReadOnlySequence_1<T>> }, delimiters: ReadOnlySpan_1<T>, advancePastDelimiter?: boolean): boolean;
}


export const SequenceReader_1: {
    new<T extends (IEquatable_1<T> | number | string | boolean)>(sequence: ReadOnlySequence_1<T>): SequenceReader_1$instance<T>;
};


export type SequenceReader_1<T extends (IEquatable_1<T> | number | string | boolean)> = SequenceReader_1$instance<T>;

export interface StandardFormat$instance {
    readonly HasPrecision: boolean;
    readonly IsDefault: boolean;
    readonly Precision: byte;
    readonly Symbol: char;
    Equals(obj: unknown): boolean;
    Equals(other: StandardFormat): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const StandardFormat: {
    new(symbol_: char, precision: byte): StandardFormat$instance;
    readonly NoPrecision: byte;
    readonly MaxPrecision: byte;
    Parse(format: ReadOnlySpan_1<CLROf<char>>): StandardFormat;
    Parse(format: string): StandardFormat;
    TryParse(format: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<StandardFormat> }): boolean;
};


export interface __StandardFormat$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<StandardFormat>;

    // Structural method bridges for numeric interface constraints
    equals(other: StandardFormat): boolean;
}

export type StandardFormat = StandardFormat$instance & __StandardFormat$views;


export interface ArrayBufferWriter_1$instance<T> {
    readonly Capacity: int;
    readonly FreeCapacity: int;
    readonly WrittenCount: int;
    readonly WrittenMemory: ReadOnlyMemory_1<T>;
    readonly WrittenSpan: ReadOnlySpan_1<T>;
    Advance(count: int): void;
    Clear(): void;
    GetMemory(sizeHint?: int): Memory_1<T>;
    GetSpan(sizeHint?: int): Span_1<T>;
    ResetWrittenCount(): void;
}


export const ArrayBufferWriter_1: {
    new<T>(): ArrayBufferWriter_1$instance<T>;
    new<T>(initialCapacity: int): ArrayBufferWriter_1$instance<T>;
};


export interface __ArrayBufferWriter_1$views<T> {
    As_IBufferWriter_1(): IBufferWriter_1$instance<T>;
}

export interface ArrayBufferWriter_1$instance<T> extends IBufferWriter_1$instance<T> {}

export type ArrayBufferWriter_1<T> = ArrayBufferWriter_1$instance<T> & __ArrayBufferWriter_1$views<T>;


export interface ArrayPool_1$instance<T> {
    Rent(minimumLength: int): T[];
    Return(array: T[], clearArray?: boolean): void;
}


export const ArrayPool_1: {
    readonly Shared: unknown;
    Create<T>(): ArrayPool_1<T>;
    Create<T>(maxArrayLength: int, maxArraysPerBucket: int): ArrayPool_1<T>;
};


export type ArrayPool_1<T> = ArrayPool_1$instance<T>;

export interface MemoryManager_1$instance<T> {
    readonly Memory: Memory_1<T>;
    GetSpan(): Span_1<T>;
    Pin(elementIndex?: int): MemoryHandle;
    Unpin(): void;
}


export const MemoryManager_1: {
};


export interface __MemoryManager_1$views<T> {
    As_IMemoryOwner_1(): IMemoryOwner_1$instance<T>;
    As_IPinnable(): IPinnable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MemoryManager_1$instance<T> extends IMemoryOwner_1$instance<T> {}

export type MemoryManager_1<T> = MemoryManager_1$instance<T> & __MemoryManager_1$views<T>;


export interface MemoryPool_1$instance<T> {
    readonly MaxBufferSize: int;
    Dispose(): void;
    Rent(minBufferSize?: int): IMemoryOwner_1<T>;
}


export const MemoryPool_1: {
    readonly Shared: unknown;
};


export interface __MemoryPool_1$views<T> {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MemoryPool_1$instance<T> extends System_Internal.IDisposable$instance {}

export type MemoryPool_1<T> = MemoryPool_1$instance<T> & __MemoryPool_1$views<T>;


export interface ReadOnlySequenceSegment_1$instance<T> {
    readonly Memory: ReadOnlyMemory_1<T>;
    readonly Next: ReadOnlySequenceSegment_1<T>;
    readonly RunningIndex: long;
}


export const ReadOnlySequenceSegment_1: {
};


export type ReadOnlySequenceSegment_1<T> = ReadOnlySequenceSegment_1$instance<T>;

export interface SearchValues_1$instance<T extends (IEquatable_1<T> | number | string | boolean)> {
    Contains(value: T): boolean;
}


export const SearchValues_1: {
    new<T extends (IEquatable_1<T> | number | string | boolean)>(): SearchValues_1$instance<T>;
};


export type SearchValues_1<T extends (IEquatable_1<T> | number | string | boolean)> = SearchValues_1$instance<T>;

export abstract class BuffersExtensions$instance {
    static CopyTo<T>(source: { value: ref<ReadOnlySequence_1<T>> }, destination: Span_1<T>): void;
    static PositionOf<T extends IEquatable_1<T>>(source: { value: ref<ReadOnlySequence_1<T>> }, value: T): Nullable_1<SequencePosition>;
    static ToArray<T>(sequence: { value: ref<ReadOnlySequence_1<T>> }): T[];
    static Write<T>(writer: IBufferWriter_1<T>, value: ReadOnlySpan_1<T>): void;
}


export type BuffersExtensions = BuffersExtensions$instance;

export abstract class SearchValues$instance {
    static Create(values: ReadOnlySpan_1<CLROf<byte>>): SearchValues_1<CLROf<byte>>;
    static Create(values: ReadOnlySpan_1<CLROf<char>>): SearchValues_1<CLROf<char>>;
    static Create(values: ReadOnlySpan_1<CLROf<string>>, comparisonType: StringComparison): SearchValues_1<CLROf<string>>;
}


export type SearchValues = SearchValues$instance;

export abstract class SequenceReaderExtensions$instance {
    static TryReadBigEndian(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<short> }): boolean;
    static TryReadBigEndian(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<int> }): boolean;
    static TryReadBigEndian(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<long> }): boolean;
    static TryReadLittleEndian(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<short> }): boolean;
    static TryReadLittleEndian(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<int> }): boolean;
    static TryReadLittleEndian(reader: { value: ref<SequenceReader_1<CLROf<byte>>> }, value: { value: ref<long> }): boolean;
}


export type SequenceReaderExtensions = SequenceReaderExtensions$instance;


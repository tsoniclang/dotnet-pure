// Generated by tsbindgen - Architecture
// Namespace: System.Net.NetworkInformation
// Assembly: System.Net.NetworkInformation, System.Net.Ping, System.Net.Primitives

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { AsyncCompletedEventArgs, Component, IComponent, IContainer, ISite, Win32Exception } from "../../System.ComponentModel/internal/index.js";
import * as System_Net_Internal from "../../System.Net/internal/index.js";
import type { IPAddress, IPEndPoint } from "../../System.Net/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { Task_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { AsyncCallback, Boolean as ClrBoolean, Byte, Char, Delegate, Enum, EventArgs, Exception, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, Int64, IntPtr, InvalidOperationException, ISpanFormattable, MulticastDelegate, Object as ClrObject, ReadOnlySpan_1, String as ClrString, TimeSpan, Type, TypeCode, Void } from "../../System/internal/index.js";

export enum DuplicateAddressDetectionState {
    Invalid = 0,
    Tentative = 1,
    Duplicate = 2,
    Deprecated = 3,
    Preferred = 4
}


export enum IPStatus {
    Success = 0,
    DestinationNetworkUnreachable = 11002,
    DestinationHostUnreachable = 11003,
    DestinationProtocolUnreachable = 11004,
    DestinationPortUnreachable = 11005,
    DestinationProhibited = 11004,
    NoResources = 11006,
    BadOption = 11007,
    HardwareError = 11008,
    PacketTooBig = 11009,
    TimedOut = 11010,
    BadRoute = 11012,
    TtlExpired = 11013,
    TtlReassemblyTimeExceeded = 11014,
    ParameterProblem = 11015,
    SourceQuench = 11016,
    BadDestination = 11018,
    DestinationUnreachable = 11040,
    TimeExceeded = 11041,
    BadHeader = 11042,
    UnrecognizedNextHeader = 11043,
    IcmpError = 11044,
    DestinationScopeMismatch = 11045,
    Unknown = -1
}


export enum NetBiosNodeType {
    Unknown = 0,
    Broadcast = 1,
    Peer2Peer = 2,
    Mixed = 4,
    Hybrid = 8
}


export enum NetworkInterfaceComponent {
    IPv4 = 0,
    IPv6 = 1
}


export enum NetworkInterfaceType {
    Unknown = 1,
    Ethernet = 6,
    TokenRing = 9,
    Fddi = 15,
    BasicIsdn = 20,
    PrimaryIsdn = 21,
    Ppp = 23,
    Loopback = 24,
    Ethernet3Megabit = 26,
    Slip = 28,
    Atm = 37,
    GenericModem = 48,
    FastEthernetT = 62,
    Isdn = 63,
    FastEthernetFx = 69,
    Wireless80211 = 71,
    AsymmetricDsl = 94,
    RateAdaptDsl = 95,
    SymmetricDsl = 96,
    VeryHighSpeedDsl = 97,
    IPOverAtm = 114,
    GigabitEthernet = 117,
    Tunnel = 131,
    MultiRateSymmetricDsl = 143,
    HighPerformanceSerialBus = 144,
    Wman = 237,
    Wwanpp = 243,
    Wwanpp2 = 244
}


export enum OperationalStatus {
    Up = 1,
    Down = 2,
    Testing = 3,
    Unknown = 4,
    Dormant = 5,
    NotPresent = 6,
    LowerLayerDown = 7
}


export enum PrefixOrigin {
    Other = 0,
    Manual = 1,
    WellKnown = 2,
    Dhcp = 3,
    RouterAdvertisement = 4
}


export enum ScopeLevel {
    None = 0,
    Interface = 1,
    Link = 2,
    Subnet = 3,
    Admin = 4,
    Site = 5,
    Organization = 8,
    Global = 14
}


export enum SuffixOrigin {
    Other = 0,
    Manual = 1,
    WellKnown = 2,
    OriginDhcp = 3,
    LinkLayerAddress = 4,
    Random = 5
}


export enum TcpState {
    Unknown = 0,
    Closed = 1,
    Listen = 2,
    SynSent = 3,
    SynReceived = 4,
    Established = 5,
    FinWait1 = 6,
    FinWait2 = 7,
    CloseWait = 8,
    Closing = 9,
    LastAck = 10,
    TimeWait = 11,
    DeleteTcb = 12
}


export type NetworkAddressChangedEventHandler = (sender: unknown | undefined, e: EventArgs) => void;


export type NetworkAvailabilityChangedEventHandler = (sender: unknown | undefined, e: NetworkAvailabilityEventArgs) => void;


export type PingCompletedEventHandler = (sender: unknown, e: PingCompletedEventArgs) => void;


export interface GatewayIPAddressInformation$instance {
    readonly Address: IPAddress;
}


export const GatewayIPAddressInformation: {
};


export type GatewayIPAddressInformation = GatewayIPAddressInformation$instance;

export interface GatewayIPAddressInformationCollection$instance {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    readonly Item: GatewayIPAddressInformation;
    Add(address: GatewayIPAddressInformation): void;
    Clear(): void;
    Contains(address: GatewayIPAddressInformation): boolean;
    CopyTo(array: GatewayIPAddressInformation[], offset: int): void;
    GetEnumerator(): IEnumerator_1<GatewayIPAddressInformation>;
    Remove(address: GatewayIPAddressInformation): boolean;
}


export const GatewayIPAddressInformationCollection: {
    new(): GatewayIPAddressInformationCollection;
};


export interface __GatewayIPAddressInformationCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<GatewayIPAddressInformation>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<GatewayIPAddressInformation>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type GatewayIPAddressInformationCollection = GatewayIPAddressInformationCollection$instance & __GatewayIPAddressInformationCollection$views;


export interface IcmpV4Statistics$instance {
    readonly AddressMaskRepliesReceived: long;
    readonly AddressMaskRepliesSent: long;
    readonly AddressMaskRequestsReceived: long;
    readonly AddressMaskRequestsSent: long;
    readonly DestinationUnreachableMessagesReceived: long;
    readonly DestinationUnreachableMessagesSent: long;
    readonly EchoRepliesReceived: long;
    readonly EchoRepliesSent: long;
    readonly EchoRequestsReceived: long;
    readonly EchoRequestsSent: long;
    readonly ErrorsReceived: long;
    readonly ErrorsSent: long;
    readonly MessagesReceived: long;
    readonly MessagesSent: long;
    readonly ParameterProblemsReceived: long;
    readonly ParameterProblemsSent: long;
    readonly RedirectsReceived: long;
    readonly RedirectsSent: long;
    readonly SourceQuenchesReceived: long;
    readonly SourceQuenchesSent: long;
    readonly TimeExceededMessagesReceived: long;
    readonly TimeExceededMessagesSent: long;
    readonly TimestampRepliesReceived: long;
    readonly TimestampRepliesSent: long;
    readonly TimestampRequestsReceived: long;
    readonly TimestampRequestsSent: long;
}


export const IcmpV4Statistics: {
};


export type IcmpV4Statistics = IcmpV4Statistics$instance;

export interface IcmpV6Statistics$instance {
    readonly DestinationUnreachableMessagesReceived: long;
    readonly DestinationUnreachableMessagesSent: long;
    readonly EchoRepliesReceived: long;
    readonly EchoRepliesSent: long;
    readonly EchoRequestsReceived: long;
    readonly EchoRequestsSent: long;
    readonly ErrorsReceived: long;
    readonly ErrorsSent: long;
    readonly MembershipQueriesReceived: long;
    readonly MembershipQueriesSent: long;
    readonly MembershipReductionsReceived: long;
    readonly MembershipReductionsSent: long;
    readonly MembershipReportsReceived: long;
    readonly MembershipReportsSent: long;
    readonly MessagesReceived: long;
    readonly MessagesSent: long;
    readonly NeighborAdvertisementsReceived: long;
    readonly NeighborAdvertisementsSent: long;
    readonly NeighborSolicitsReceived: long;
    readonly NeighborSolicitsSent: long;
    readonly PacketTooBigMessagesReceived: long;
    readonly PacketTooBigMessagesSent: long;
    readonly ParameterProblemsReceived: long;
    readonly ParameterProblemsSent: long;
    readonly RedirectsReceived: long;
    readonly RedirectsSent: long;
    readonly RouterAdvertisementsReceived: long;
    readonly RouterAdvertisementsSent: long;
    readonly RouterSolicitsReceived: long;
    readonly RouterSolicitsSent: long;
    readonly TimeExceededMessagesReceived: long;
    readonly TimeExceededMessagesSent: long;
}


export const IcmpV6Statistics: {
};


export type IcmpV6Statistics = IcmpV6Statistics$instance;

export interface IPAddressCollection$instance {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    readonly Item: IPAddress;
    Add(address: IPAddress): void;
    Clear(): void;
    Contains(address: IPAddress): boolean;
    CopyTo(array: IPAddress[], offset: int): void;
    GetEnumerator(): IEnumerator_1<IPAddress>;
    Remove(address: IPAddress): boolean;
}


export const IPAddressCollection: {
    new(): IPAddressCollection;
};


export interface __IPAddressCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<IPAddress>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<IPAddress>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type IPAddressCollection = IPAddressCollection$instance & __IPAddressCollection$views;


export interface IPAddressInformation$instance {
    readonly Address: IPAddress;
    readonly IsDnsEligible: boolean;
    readonly IsTransient: boolean;
}


export const IPAddressInformation: {
};


export type IPAddressInformation = IPAddressInformation$instance;

export interface IPAddressInformationCollection$instance {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    readonly Item: IPAddressInformation;
    Add(address: IPAddressInformation): void;
    Clear(): void;
    Contains(address: IPAddressInformation): boolean;
    CopyTo(array: IPAddressInformation[], offset: int): void;
    GetEnumerator(): IEnumerator_1<IPAddressInformation>;
    Remove(address: IPAddressInformation): boolean;
}


export const IPAddressInformationCollection: {
    new(): IPAddressInformationCollection;
};


export interface __IPAddressInformationCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<IPAddressInformation>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<IPAddressInformation>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type IPAddressInformationCollection = IPAddressInformationCollection$instance & __IPAddressInformationCollection$views;


export interface IPGlobalProperties$instance {
    readonly DhcpScopeName: string;
    readonly DomainName: string;
    readonly HostName: string;
    readonly IsWinsProxy: boolean;
    readonly NodeType: NetBiosNodeType;
    BeginGetUnicastAddresses(callback: AsyncCallback, state: unknown): IAsyncResult;
    EndGetUnicastAddresses(asyncResult: IAsyncResult): UnicastIPAddressInformationCollection;
    GetActiveTcpConnections(): TcpConnectionInformation[];
    GetActiveTcpListeners(): IPEndPoint[];
    GetActiveUdpListeners(): IPEndPoint[];
    GetIcmpV4Statistics(): IcmpV4Statistics;
    GetIcmpV6Statistics(): IcmpV6Statistics;
    GetIPv4GlobalStatistics(): IPGlobalStatistics;
    GetIPv6GlobalStatistics(): IPGlobalStatistics;
    GetTcpIPv4Statistics(): TcpStatistics;
    GetTcpIPv6Statistics(): TcpStatistics;
    GetUdpIPv4Statistics(): UdpStatistics;
    GetUdpIPv6Statistics(): UdpStatistics;
    GetUnicastAddresses(): UnicastIPAddressInformationCollection;
    GetUnicastAddressesAsync(): Task_1<UnicastIPAddressInformationCollection>;
}


export const IPGlobalProperties: {
    GetIPGlobalProperties(): IPGlobalProperties;
};


export type IPGlobalProperties = IPGlobalProperties$instance;

export interface IPGlobalStatistics$instance {
    readonly DefaultTtl: int;
    readonly ForwardingEnabled: boolean;
    readonly NumberOfInterfaces: int;
    readonly NumberOfIPAddresses: int;
    readonly NumberOfRoutes: int;
    readonly OutputPacketRequests: long;
    readonly OutputPacketRoutingDiscards: long;
    readonly OutputPacketsDiscarded: long;
    readonly OutputPacketsWithNoRoute: long;
    readonly PacketFragmentFailures: long;
    readonly PacketReassembliesRequired: long;
    readonly PacketReassemblyFailures: long;
    readonly PacketReassemblyTimeout: long;
    readonly PacketsFragmented: long;
    readonly PacketsReassembled: long;
    readonly ReceivedPackets: long;
    readonly ReceivedPacketsDelivered: long;
    readonly ReceivedPacketsDiscarded: long;
    readonly ReceivedPacketsForwarded: long;
    readonly ReceivedPacketsWithAddressErrors: long;
    readonly ReceivedPacketsWithHeadersErrors: long;
    readonly ReceivedPacketsWithUnknownProtocol: long;
}


export const IPGlobalStatistics: {
};


export type IPGlobalStatistics = IPGlobalStatistics$instance;

export interface IPInterfaceProperties$instance {
    readonly AnycastAddresses: IPAddressInformationCollection;
    readonly DhcpServerAddresses: IPAddressCollection;
    readonly DnsAddresses: IPAddressCollection;
    readonly DnsSuffix: string;
    readonly GatewayAddresses: GatewayIPAddressInformationCollection;
    readonly IsDnsEnabled: boolean;
    readonly IsDynamicDnsEnabled: boolean;
    readonly MulticastAddresses: MulticastIPAddressInformationCollection;
    readonly UnicastAddresses: UnicastIPAddressInformationCollection;
    readonly WinsServersAddresses: IPAddressCollection;
    GetIPv4Properties(): IPv4InterfaceProperties;
    GetIPv6Properties(): IPv6InterfaceProperties;
}


export const IPInterfaceProperties: {
};


export type IPInterfaceProperties = IPInterfaceProperties$instance;

export interface IPInterfaceStatistics$instance {
    readonly BytesReceived: long;
    readonly BytesSent: long;
    readonly IncomingPacketsDiscarded: long;
    readonly IncomingPacketsWithErrors: long;
    readonly IncomingUnknownProtocolPackets: long;
    readonly NonUnicastPacketsReceived: long;
    readonly NonUnicastPacketsSent: long;
    readonly OutgoingPacketsDiscarded: long;
    readonly OutgoingPacketsWithErrors: long;
    readonly OutputQueueLength: long;
    readonly UnicastPacketsReceived: long;
    readonly UnicastPacketsSent: long;
}


export const IPInterfaceStatistics: {
};


export type IPInterfaceStatistics = IPInterfaceStatistics$instance;

export interface IPv4InterfaceProperties$instance {
    readonly Index: int;
    readonly IsAutomaticPrivateAddressingActive: boolean;
    readonly IsAutomaticPrivateAddressingEnabled: boolean;
    readonly IsDhcpEnabled: boolean;
    readonly IsForwardingEnabled: boolean;
    readonly Mtu: int;
    readonly UsesWins: boolean;
}


export const IPv4InterfaceProperties: {
};


export type IPv4InterfaceProperties = IPv4InterfaceProperties$instance;

export interface IPv4InterfaceStatistics$instance {
    readonly BytesReceived: long;
    readonly BytesSent: long;
    readonly IncomingPacketsDiscarded: long;
    readonly IncomingPacketsWithErrors: long;
    readonly IncomingUnknownProtocolPackets: long;
    readonly NonUnicastPacketsReceived: long;
    readonly NonUnicastPacketsSent: long;
    readonly OutgoingPacketsDiscarded: long;
    readonly OutgoingPacketsWithErrors: long;
    readonly OutputQueueLength: long;
    readonly UnicastPacketsReceived: long;
    readonly UnicastPacketsSent: long;
}


export const IPv4InterfaceStatistics: {
};


export type IPv4InterfaceStatistics = IPv4InterfaceStatistics$instance;

export interface IPv6InterfaceProperties$instance {
    readonly Index: int;
    readonly Mtu: int;
    GetScopeId(scopeLevel: ScopeLevel): long;
}


export const IPv6InterfaceProperties: {
};


export type IPv6InterfaceProperties = IPv6InterfaceProperties$instance;

export interface MulticastIPAddressInformation$instance extends IPAddressInformation {
    readonly AddressPreferredLifetime: long;
    readonly AddressValidLifetime: long;
    readonly DhcpLeaseLifetime: long;
    readonly DuplicateAddressDetectionState: DuplicateAddressDetectionState;
    readonly PrefixOrigin: PrefixOrigin;
    readonly SuffixOrigin: SuffixOrigin;
}


export const MulticastIPAddressInformation: {
};


export type MulticastIPAddressInformation = MulticastIPAddressInformation$instance;

export interface MulticastIPAddressInformationCollection$instance {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    readonly Item: MulticastIPAddressInformation;
    Add(address: MulticastIPAddressInformation): void;
    Clear(): void;
    Contains(address: MulticastIPAddressInformation): boolean;
    CopyTo(array: MulticastIPAddressInformation[], offset: int): void;
    GetEnumerator(): IEnumerator_1<MulticastIPAddressInformation>;
    Remove(address: MulticastIPAddressInformation): boolean;
}


export const MulticastIPAddressInformationCollection: {
    new(): MulticastIPAddressInformationCollection;
};


export interface __MulticastIPAddressInformationCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<MulticastIPAddressInformation>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<MulticastIPAddressInformation>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type MulticastIPAddressInformationCollection = MulticastIPAddressInformationCollection$instance & __MulticastIPAddressInformationCollection$views;


export interface NetworkAvailabilityEventArgs$instance extends EventArgs {
    readonly IsAvailable: boolean;
}


export const NetworkAvailabilityEventArgs: {
    new(): NetworkAvailabilityEventArgs;
};


export type NetworkAvailabilityEventArgs = NetworkAvailabilityEventArgs$instance;

export interface NetworkChange$instance {
}


export const NetworkChange: {
    new(): NetworkChange;
    RegisterNetworkChange(nc: NetworkChange | undefined): void;
};


export type NetworkChange = NetworkChange$instance;

export interface NetworkInformationException$instance extends Win32Exception {
    readonly ErrorCode: int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const NetworkInformationException: {
    new(): NetworkInformationException;
    new(errorCode: int): NetworkInformationException;
};


export interface __NetworkInformationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type NetworkInformationException = NetworkInformationException$instance & __NetworkInformationException$views;


export interface NetworkInterface$instance {
    readonly Description: string;
    readonly Id: string;
    readonly IsReceiveOnly: boolean;
    readonly Name: string;
    readonly NetworkInterfaceType: NetworkInterfaceType;
    readonly OperationalStatus: OperationalStatus;
    readonly Speed: long;
    readonly SupportsMulticast: boolean;
    GetIPProperties(): IPInterfaceProperties;
    GetIPStatistics(): IPInterfaceStatistics;
    GetIPv4Statistics(): IPv4InterfaceStatistics;
    GetPhysicalAddress(): PhysicalAddress;
    Supports(networkInterfaceComponent: NetworkInterfaceComponent): boolean;
}


export const NetworkInterface: {
    readonly IPv6LoopbackInterfaceIndex: int;
    readonly LoopbackInterfaceIndex: int;
    GetAllNetworkInterfaces(): NetworkInterface[];
    GetIsNetworkAvailable(): boolean;
};


export type NetworkInterface = NetworkInterface$instance;

export interface PhysicalAddress$instance {
    Equals(comparand: unknown): boolean;
    GetAddressBytes(): byte[];
    GetHashCode(): int;
    ToString(): string;
}


export const PhysicalAddress: {
    new(address: byte[]): PhysicalAddress;
    readonly None: PhysicalAddress;
    Parse(address: ReadOnlySpan_1<System_Internal.Char>): PhysicalAddress;
    Parse(address: string | undefined): PhysicalAddress;
    TryParse(address: ReadOnlySpan_1<System_Internal.Char>, value: PhysicalAddress | undefined): boolean;
    TryParse(address: string, value: PhysicalAddress): boolean;
};


export type PhysicalAddress = PhysicalAddress$instance;

export interface Ping$instance extends Component {
    Dispose(): void;
    Send(hostNameOrAddress: string): PingReply;
    Send(hostNameOrAddress: string, timeout: int): PingReply;
    Send(address: IPAddress): PingReply;
    Send(address: IPAddress, timeout: int): PingReply;
    Send(hostNameOrAddress: string, timeout: int, buffer: byte[]): PingReply;
    Send(address: IPAddress, timeout: int, buffer: byte[]): PingReply;
    Send(hostNameOrAddress: string, timeout: int, buffer: byte[], options: PingOptions | undefined): PingReply;
    Send(address: IPAddress, timeout: int, buffer: byte[], options: PingOptions | undefined): PingReply;
    Send(address: IPAddress, timeout: TimeSpan, buffer?: byte[] | undefined, options?: PingOptions | undefined): PingReply;
    Send(hostNameOrAddress: string, timeout: TimeSpan, buffer?: byte[] | undefined, options?: PingOptions | undefined): PingReply;
    SendAsync(hostNameOrAddress: string, userToken: unknown | undefined): void;
    SendAsync(hostNameOrAddress: string, timeout: int, userToken: unknown | undefined): void;
    SendAsync(address: IPAddress, userToken: unknown | undefined): void;
    SendAsync(address: IPAddress, timeout: int, userToken: unknown | undefined): void;
    SendAsync(hostNameOrAddress: string, timeout: int, buffer: byte[], userToken: unknown | undefined): void;
    SendAsync(address: IPAddress, timeout: int, buffer: byte[], userToken: unknown | undefined): void;
    SendAsync(hostNameOrAddress: string, timeout: int, buffer: byte[], options: PingOptions | undefined, userToken: unknown | undefined): void;
    SendAsync(address: IPAddress, timeout: int, buffer: byte[], options: PingOptions | undefined, userToken: unknown | undefined): void;
    SendAsyncCancel(): void;
    SendPingAsync(address: IPAddress): Task_1<PingReply>;
    SendPingAsync(hostNameOrAddress: string): Task_1<PingReply>;
    SendPingAsync(address: IPAddress, timeout: int): Task_1<PingReply>;
    SendPingAsync(hostNameOrAddress: string, timeout: int): Task_1<PingReply>;
    SendPingAsync(address: IPAddress, timeout: int, buffer: byte[]): Task_1<PingReply>;
    SendPingAsync(hostNameOrAddress: string, timeout: int, buffer: byte[]): Task_1<PingReply>;
    SendPingAsync(address: IPAddress, timeout: int, buffer: byte[], options: PingOptions | undefined): Task_1<PingReply>;
    SendPingAsync(address: IPAddress, timeout: TimeSpan, buffer?: byte[] | undefined, options?: PingOptions | undefined, cancellationToken?: CancellationToken): Task_1<PingReply>;
    SendPingAsync(hostNameOrAddress: string, timeout: int, buffer: byte[], options: PingOptions | undefined): Task_1<PingReply>;
    SendPingAsync(hostNameOrAddress: string, timeout: TimeSpan, buffer?: byte[] | undefined, options?: PingOptions | undefined, cancellationToken?: CancellationToken): Task_1<PingReply>;
}


export const Ping: {
    new(): Ping;
};


export interface __Ping$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Ping$instance extends System_ComponentModel_Internal.IComponent$instance {}

export type Ping = Ping$instance & __Ping$views;


export interface PingCompletedEventArgs$instance extends AsyncCompletedEventArgs {
    readonly Reply: PingReply | undefined;
}


export const PingCompletedEventArgs: {
    new(): PingCompletedEventArgs;
};


export type PingCompletedEventArgs = PingCompletedEventArgs$instance;

export interface PingException$instance extends InvalidOperationException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const PingException: {
    new(message: string | undefined): PingException;
    new(message: string | undefined, innerException: Exception | undefined): PingException;
};


export interface __PingException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type PingException = PingException$instance & __PingException$views;


export interface PingOptions$instance {
    DontFragment: boolean;
    Ttl: int;
}


export const PingOptions: {
    new(): PingOptions;
    new(ttl: int, dontFragment: boolean): PingOptions;
};


export type PingOptions = PingOptions$instance;

export interface PingReply$instance {
    readonly Address: IPAddress;
    readonly Buffer: byte[];
    readonly Options: PingOptions;
    readonly RoundtripTime: long;
    readonly Status: IPStatus;
}


export const PingReply: {
    new(): PingReply;
};


export type PingReply = PingReply$instance;

export interface TcpConnectionInformation$instance {
    readonly LocalEndPoint: IPEndPoint;
    readonly RemoteEndPoint: IPEndPoint;
    readonly State: TcpState;
}


export const TcpConnectionInformation: {
};


export type TcpConnectionInformation = TcpConnectionInformation$instance;

export interface TcpStatistics$instance {
    readonly ConnectionsAccepted: long;
    readonly ConnectionsInitiated: long;
    readonly CumulativeConnections: long;
    readonly CurrentConnections: long;
    readonly ErrorsReceived: long;
    readonly FailedConnectionAttempts: long;
    readonly MaximumConnections: long;
    readonly MaximumTransmissionTimeout: long;
    readonly MinimumTransmissionTimeout: long;
    readonly ResetConnections: long;
    readonly ResetsSent: long;
    readonly SegmentsReceived: long;
    readonly SegmentsResent: long;
    readonly SegmentsSent: long;
}


export const TcpStatistics: {
};


export type TcpStatistics = TcpStatistics$instance;

export interface UdpStatistics$instance {
    readonly DatagramsReceived: long;
    readonly DatagramsSent: long;
    readonly IncomingDatagramsDiscarded: long;
    readonly IncomingDatagramsWithErrors: long;
    readonly UdpListeners: int;
}


export const UdpStatistics: {
};


export type UdpStatistics = UdpStatistics$instance;

export interface UnicastIPAddressInformation$instance extends IPAddressInformation {
    readonly AddressPreferredLifetime: long;
    readonly AddressValidLifetime: long;
    readonly DhcpLeaseLifetime: long;
    readonly DuplicateAddressDetectionState: DuplicateAddressDetectionState;
    readonly IPv4Mask: IPAddress;
    readonly PrefixLength: int;
    readonly PrefixOrigin: PrefixOrigin;
    readonly SuffixOrigin: SuffixOrigin;
}


export const UnicastIPAddressInformation: {
};


export type UnicastIPAddressInformation = UnicastIPAddressInformation$instance;

export interface UnicastIPAddressInformationCollection$instance {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    readonly Item: UnicastIPAddressInformation;
    Add(address: UnicastIPAddressInformation): void;
    Clear(): void;
    Contains(address: UnicastIPAddressInformation): boolean;
    CopyTo(array: UnicastIPAddressInformation[], offset: int): void;
    GetEnumerator(): IEnumerator_1<UnicastIPAddressInformation>;
    Remove(address: UnicastIPAddressInformation): boolean;
}


export const UnicastIPAddressInformationCollection: {
    new(): UnicastIPAddressInformationCollection;
};


export interface __UnicastIPAddressInformationCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<UnicastIPAddressInformation>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<UnicastIPAddressInformation>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type UnicastIPAddressInformationCollection = UnicastIPAddressInformationCollection$instance & __UnicastIPAddressInformationCollection$views;



// Generated by tsbindgen - Architecture
// Namespace: System.Linq.Expressions
// Assembly: System.Linq.Expressions

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { IEnumerable_1 } from "../../System.Collections.Generic/internal/index.js";
import type { ReadOnlyCollection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import type { ConstructorInfo, FieldInfo, MemberInfo, MethodInfo, PropertyInfo } from "../../System.Reflection/internal/index.js";
import type { CallSiteBinder, DebugInfoGenerator } from "../../System.Runtime.CompilerServices/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Delegate, Enum, Func_2, Guid, IComparable, IConvertible, IFormatProvider, IFormattable, Int32, ISpanFormattable, Object as ClrObject, String as ClrString, Type, TypeCode } from "../../System/internal/index.js";

export enum ExpressionType {
    Add = 0,
    AddChecked = 1,
    And = 2,
    AndAlso = 3,
    ArrayLength = 4,
    ArrayIndex = 5,
    Call = 6,
    Coalesce = 7,
    Conditional = 8,
    Constant = 9,
    Convert = 10,
    ConvertChecked = 11,
    Divide = 12,
    Equal = 13,
    ExclusiveOr = 14,
    GreaterThan = 15,
    GreaterThanOrEqual = 16,
    Invoke = 17,
    Lambda = 18,
    LeftShift = 19,
    LessThan = 20,
    LessThanOrEqual = 21,
    ListInit = 22,
    MemberAccess = 23,
    MemberInit = 24,
    Modulo = 25,
    Multiply = 26,
    MultiplyChecked = 27,
    Negate = 28,
    UnaryPlus = 29,
    NegateChecked = 30,
    New = 31,
    NewArrayInit = 32,
    NewArrayBounds = 33,
    Not = 34,
    NotEqual = 35,
    Or = 36,
    OrElse = 37,
    Parameter = 38,
    Power = 39,
    Quote = 40,
    RightShift = 41,
    Subtract = 42,
    SubtractChecked = 43,
    TypeAs = 44,
    TypeIs = 45,
    Assign = 46,
    Block = 47,
    DebugInfo = 48,
    Decrement = 49,
    Dynamic = 50,
    Default = 51,
    Extension = 52,
    Goto = 53,
    Increment = 54,
    Index = 55,
    Label = 56,
    RuntimeVariables = 57,
    Loop = 58,
    Switch = 59,
    Throw = 60,
    Try = 61,
    Unbox = 62,
    AddAssign = 63,
    AndAssign = 64,
    DivideAssign = 65,
    ExclusiveOrAssign = 66,
    LeftShiftAssign = 67,
    ModuloAssign = 68,
    MultiplyAssign = 69,
    OrAssign = 70,
    PowerAssign = 71,
    RightShiftAssign = 72,
    SubtractAssign = 73,
    AddAssignChecked = 74,
    MultiplyAssignChecked = 75,
    SubtractAssignChecked = 76,
    PreIncrementAssign = 77,
    PreDecrementAssign = 78,
    PostIncrementAssign = 79,
    PostDecrementAssign = 80,
    TypeEqual = 81,
    OnesComplement = 82,
    IsTrue = 83,
    IsFalse = 84
}


export enum GotoExpressionKind {
    Goto = 0,
    Return = 1,
    Break = 2,
    Continue = 3
}


export enum MemberBindingType {
    Assignment = 0,
    MemberBinding = 1,
    ListBinding = 2
}


export interface IArgumentProvider$instance {
    readonly ArgumentCount: int;
    GetArgument(index: int): Expression;
}


export type IArgumentProvider = IArgumentProvider$instance;

export interface IDynamicExpression$instance extends IArgumentProvider {
    readonly DelegateType: Type;
    readonly ArgumentCount: int;
    CreateCallSite(): unknown;
    GetArgument(index: int): Expression;
    Rewrite(args: Expression[]): Expression;
}


export interface IDynamicExpression$instance extends IArgumentProvider$instance {}

export type IDynamicExpression = IDynamicExpression$instance;

export interface BinaryExpression$instance extends Expression {
    readonly CanReduce: boolean;
    readonly Conversion: LambdaExpression | undefined;
    readonly IsLifted: boolean;
    readonly IsLiftedToNull: boolean;
    readonly Left: Expression;
    readonly Method: MethodInfo;
    readonly Right: Expression;
    Reduce(): Expression;
    Update(left: Expression, conversion: LambdaExpression | undefined, right: Expression): BinaryExpression;
}


export const BinaryExpression: {
    new(): BinaryExpression;
};


export type BinaryExpression = BinaryExpression$instance;

export interface BlockExpression$instance extends Expression {
    readonly Expressions: ReadOnlyCollection_1<Expression>;
    readonly NodeType: ExpressionType;
    readonly Result: Expression;
    readonly Type: Type;
    readonly Variables: ReadOnlyCollection_1<ParameterExpression>;
    Update(variables: IEnumerable_1<ParameterExpression> | undefined, expressions: IEnumerable_1<Expression>): BlockExpression;
}


export const BlockExpression: {
    new(): BlockExpression;
};


export type BlockExpression = BlockExpression$instance;

export interface CatchBlock$instance {
    readonly Body: Expression;
    readonly Filter: Expression;
    readonly Test: Type;
    readonly Variable: ParameterExpression | undefined;
    ToString(): string;
    Update(variable: ParameterExpression | undefined, filter: Expression | undefined, body: Expression): CatchBlock;
}


export const CatchBlock: {
    new(): CatchBlock;
};


export type CatchBlock = CatchBlock$instance;

export interface ConditionalExpression$instance extends Expression {
    readonly IfFalse: Expression;
    readonly IfTrue: Expression;
    readonly NodeType: ExpressionType;
    readonly Test: Expression;
    readonly Type: Type;
    Update(test: Expression, ifTrue: Expression, ifFalse: Expression): ConditionalExpression;
}


export const ConditionalExpression: {
    new(): ConditionalExpression;
};


export type ConditionalExpression = ConditionalExpression$instance;

export interface ConstantExpression$instance extends Expression {
    readonly NodeType: ExpressionType;
    readonly Type: Type;
    readonly Value: unknown;
}


export const ConstantExpression: {
    new(): ConstantExpression;
};


export type ConstantExpression = ConstantExpression$instance;

export interface DebugInfoExpression$instance extends Expression {
    readonly Document: SymbolDocumentInfo;
    readonly EndColumn: int;
    readonly EndLine: int;
    readonly IsClear: boolean;
    readonly NodeType: ExpressionType;
    readonly StartColumn: int;
    readonly StartLine: int;
    readonly Type: Type;
}


export const DebugInfoExpression: {
    new(): DebugInfoExpression;
};


export type DebugInfoExpression = DebugInfoExpression$instance;

export interface DefaultExpression$instance extends Expression {
    readonly NodeType: ExpressionType;
    readonly Type: Type;
}


export const DefaultExpression: {
    new(): DefaultExpression;
};


export type DefaultExpression = DefaultExpression$instance;

export interface DynamicExpression$instance extends Expression {
    readonly Arguments: ReadOnlyCollection_1<Expression>;
    readonly Binder: CallSiteBinder;
    readonly CanReduce: boolean;
    readonly DelegateType: Type;
    readonly NodeType: ExpressionType;
    readonly Type: Type;
    Reduce(): Expression;
    Update(arguments: IEnumerable_1<Expression> | undefined): DynamicExpression;
}


export const DynamicExpression: {
    new(): DynamicExpression;
    Dynamic(binder: CallSiteBinder, returnType: Type, arguments: IEnumerable_1<Expression>): DynamicExpression;
    Dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): DynamicExpression;
    Dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression, arg2: Expression): DynamicExpression;
    Dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression): DynamicExpression;
    Dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression): DynamicExpression;
    Dynamic(binder: CallSiteBinder, returnType: Type, ...arguments: Expression[]): DynamicExpression;
    MakeDynamic(delegateType: Type, binder: CallSiteBinder, arguments: IEnumerable_1<Expression> | undefined): DynamicExpression;
    MakeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): DynamicExpression;
    MakeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression): DynamicExpression;
    MakeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression): DynamicExpression;
    MakeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression): DynamicExpression;
    MakeDynamic(delegateType: Type, binder: CallSiteBinder, ...arguments: Expression[]): DynamicExpression;
};


export interface __DynamicExpression$views {
    As_IArgumentProvider(): IArgumentProvider$instance;
    As_IDynamicExpression(): IDynamicExpression$instance;
}

export interface DynamicExpression$instance extends IDynamicExpression$instance {}

export type DynamicExpression = DynamicExpression$instance & __DynamicExpression$views;


export interface DynamicExpressionVisitor$instance extends ExpressionVisitor {
}


export const DynamicExpressionVisitor: {
    new(): DynamicExpressionVisitor;
};


export type DynamicExpressionVisitor = DynamicExpressionVisitor$instance;

export interface ElementInit$instance {
    readonly AddMethod: MethodInfo;
    readonly ArgumentCount: int;
    readonly Arguments: ReadOnlyCollection_1<Expression>;
    GetArgument(index: int): Expression;
    ToString(): string;
    Update(arguments: IEnumerable_1<Expression>): ElementInit;
}


export const ElementInit: {
    new(): ElementInit;
};


export interface __ElementInit$views {
    As_IArgumentProvider(): IArgumentProvider$instance;
}

export interface ElementInit$instance extends IArgumentProvider$instance {}

export type ElementInit = ElementInit$instance & __ElementInit$views;


export interface Expression$instance {
    readonly CanReduce: boolean;
    readonly NodeType: ExpressionType;
    readonly Type: Type;
    Reduce(): Expression;
    ReduceAndCheck(): Expression;
    ReduceExtensions(): Expression;
    ToString(): string;
}


export const Expression: {
    Add(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    Add(left: Expression, right: Expression): BinaryExpression;
    AddAssign(left: Expression, right: Expression, method: MethodInfo | undefined, conversion: LambdaExpression | undefined): BinaryExpression;
    AddAssign(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    AddAssign(left: Expression, right: Expression): BinaryExpression;
    AddAssignChecked(left: Expression, right: Expression, method: MethodInfo | undefined, conversion: LambdaExpression | undefined): BinaryExpression;
    AddAssignChecked(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    AddAssignChecked(left: Expression, right: Expression): BinaryExpression;
    AddChecked(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    AddChecked(left: Expression, right: Expression): BinaryExpression;
    And(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    And(left: Expression, right: Expression): BinaryExpression;
    AndAlso(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    AndAlso(left: Expression, right: Expression): BinaryExpression;
    AndAssign(left: Expression, right: Expression, method: MethodInfo | undefined, conversion: LambdaExpression | undefined): BinaryExpression;
    AndAssign(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    AndAssign(left: Expression, right: Expression): BinaryExpression;
    ArrayAccess(array: Expression, indexes: IEnumerable_1<Expression> | undefined): IndexExpression;
    ArrayAccess(array: Expression, ...indexes: Expression[]): IndexExpression;
    ArrayIndex(array: Expression, indexes: IEnumerable_1<Expression>): MethodCallExpression;
    ArrayIndex(array: Expression, index: Expression): BinaryExpression;
    ArrayIndex(array: Expression, ...indexes: Expression[]): MethodCallExpression;
    ArrayLength(array: Expression): UnaryExpression;
    Assign(left: Expression, right: Expression): BinaryExpression;
    Bind(member: MemberInfo, expression: Expression): MemberAssignment;
    Bind(propertyAccessor: MethodInfo, expression: Expression): MemberAssignment;
    Block(expressions: IEnumerable_1<Expression>): BlockExpression;
    Block(variables: IEnumerable_1<ParameterExpression> | undefined, expressions: IEnumerable_1<Expression>): BlockExpression;
    Block(variables: IEnumerable_1<ParameterExpression> | undefined, ...expressions: Expression[]): BlockExpression;
    Block(arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression, arg4: Expression): BlockExpression;
    Block(arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): BlockExpression;
    Block(arg0: Expression, arg1: Expression, arg2: Expression): BlockExpression;
    Block(arg0: Expression, arg1: Expression): BlockExpression;
    Block(...expressions: Expression[]): BlockExpression;
    Block(type_: Type, expressions: IEnumerable_1<Expression>): BlockExpression;
    Block(type_: Type, variables: IEnumerable_1<ParameterExpression> | undefined, expressions: IEnumerable_1<Expression>): BlockExpression;
    Block(type_: Type, variables: IEnumerable_1<ParameterExpression> | undefined, ...expressions: Expression[]): BlockExpression;
    Block(type_: Type, ...expressions: Expression[]): BlockExpression;
    Break(target: LabelTarget, value: Expression | undefined, type_: Type): GotoExpression;
    Break(target: LabelTarget, value: Expression | undefined): GotoExpression;
    Break(target: LabelTarget, type_: Type): GotoExpression;
    Break(target: LabelTarget): GotoExpression;
    Call(instance: Expression | undefined, method: MethodInfo, arguments: IEnumerable_1<Expression> | undefined): MethodCallExpression;
    Call(instance: Expression | undefined, method: MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression): MethodCallExpression;
    Call(instance: Expression | undefined, method: MethodInfo, arg0: Expression, arg1: Expression): MethodCallExpression;
    Call(instance: Expression | undefined, method: MethodInfo, ...arguments: Expression[]): MethodCallExpression;
    Call(instance: Expression | undefined, method: MethodInfo): MethodCallExpression;
    Call(instance: Expression, methodName: string, typeArguments: Type[] | undefined, ...arguments: Expression[]): MethodCallExpression;
    Call(method: MethodInfo, arguments: IEnumerable_1<Expression> | undefined): MethodCallExpression;
    Call(method: MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression, arg4: Expression): MethodCallExpression;
    Call(method: MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): MethodCallExpression;
    Call(method: MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression): MethodCallExpression;
    Call(method: MethodInfo, arg0: Expression, arg1: Expression): MethodCallExpression;
    Call(method: MethodInfo, arg0: Expression): MethodCallExpression;
    Call(method: MethodInfo, ...arguments: Expression[]): MethodCallExpression;
    Call(type_: Type, methodName: string, typeArguments: Type[] | undefined, ...arguments: Expression[]): MethodCallExpression;
    Catch(variable: ParameterExpression, body: Expression, filter: Expression | undefined): CatchBlock;
    Catch(variable: ParameterExpression, body: Expression): CatchBlock;
    Catch(type_: Type, body: Expression, filter: Expression | undefined): CatchBlock;
    Catch(type_: Type, body: Expression): CatchBlock;
    ClearDebugInfo(document: SymbolDocumentInfo): DebugInfoExpression;
    Coalesce(left: Expression, right: Expression, conversion: LambdaExpression | undefined): BinaryExpression;
    Coalesce(left: Expression, right: Expression): BinaryExpression;
    Condition(test: Expression, ifTrue: Expression, ifFalse: Expression, type_: Type): ConditionalExpression;
    Condition(test: Expression, ifTrue: Expression, ifFalse: Expression): ConditionalExpression;
    Constant(value: unknown | undefined, type_: Type): ConstantExpression;
    Constant(value: unknown | undefined): ConstantExpression;
    Continue(target: LabelTarget, type_: Type): GotoExpression;
    Continue(target: LabelTarget): GotoExpression;
    Convert(expression: Expression, type_: Type, method: MethodInfo | undefined): UnaryExpression;
    Convert(expression: Expression, type_: Type): UnaryExpression;
    ConvertChecked(expression: Expression, type_: Type, method: MethodInfo | undefined): UnaryExpression;
    ConvertChecked(expression: Expression, type_: Type): UnaryExpression;
    DebugInfo(document: SymbolDocumentInfo, startLine: int, startColumn: int, endLine: int, endColumn: int): DebugInfoExpression;
    Decrement(expression: Expression, method: MethodInfo | undefined): UnaryExpression;
    Decrement(expression: Expression): UnaryExpression;
    Default(type_: Type): DefaultExpression;
    Divide(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    Divide(left: Expression, right: Expression): BinaryExpression;
    DivideAssign(left: Expression, right: Expression, method: MethodInfo | undefined, conversion: LambdaExpression | undefined): BinaryExpression;
    DivideAssign(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    DivideAssign(left: Expression, right: Expression): BinaryExpression;
    Dynamic(binder: CallSiteBinder, returnType: Type, arguments: IEnumerable_1<Expression>): DynamicExpression;
    Dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): DynamicExpression;
    Dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression, arg2: Expression): DynamicExpression;
    Dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression, arg1: Expression): DynamicExpression;
    Dynamic(binder: CallSiteBinder, returnType: Type, arg0: Expression): DynamicExpression;
    Dynamic(binder: CallSiteBinder, returnType: Type, ...arguments: Expression[]): DynamicExpression;
    ElementInit(addMethod: MethodInfo, arguments: IEnumerable_1<Expression>): ElementInit;
    ElementInit(addMethod: MethodInfo, ...arguments: Expression[]): ElementInit;
    Empty(): DefaultExpression;
    Equal(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo | undefined): BinaryExpression;
    Equal(left: Expression, right: Expression): BinaryExpression;
    ExclusiveOr(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    ExclusiveOr(left: Expression, right: Expression): BinaryExpression;
    ExclusiveOrAssign(left: Expression, right: Expression, method: MethodInfo | undefined, conversion: LambdaExpression | undefined): BinaryExpression;
    ExclusiveOrAssign(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    ExclusiveOrAssign(left: Expression, right: Expression): BinaryExpression;
    Field(expression: Expression | undefined, field: FieldInfo): MemberExpression;
    Field(expression: Expression, fieldName: string): MemberExpression;
    Field(expression: Expression | undefined, type_: Type, fieldName: string): MemberExpression;
    GetActionType(...typeArgs: Type[]): Type;
    GetDelegateType(...typeArgs: Type[]): Type;
    GetFuncType(...typeArgs: Type[]): Type;
    Goto(target: LabelTarget, value: Expression | undefined, type_: Type): GotoExpression;
    Goto(target: LabelTarget, value: Expression | undefined): GotoExpression;
    Goto(target: LabelTarget, type_: Type): GotoExpression;
    Goto(target: LabelTarget): GotoExpression;
    GreaterThan(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo | undefined): BinaryExpression;
    GreaterThan(left: Expression, right: Expression): BinaryExpression;
    GreaterThanOrEqual(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo | undefined): BinaryExpression;
    GreaterThanOrEqual(left: Expression, right: Expression): BinaryExpression;
    IfThen(test: Expression, ifTrue: Expression): ConditionalExpression;
    IfThenElse(test: Expression, ifTrue: Expression, ifFalse: Expression): ConditionalExpression;
    Increment(expression: Expression, method: MethodInfo | undefined): UnaryExpression;
    Increment(expression: Expression): UnaryExpression;
    Invoke(expression: Expression, arguments: IEnumerable_1<Expression> | undefined): InvocationExpression;
    Invoke(expression: Expression, ...arguments: Expression[]): InvocationExpression;
    IsFalse(expression: Expression, method: MethodInfo | undefined): UnaryExpression;
    IsFalse(expression: Expression): UnaryExpression;
    IsTrue(expression: Expression, method: MethodInfo | undefined): UnaryExpression;
    IsTrue(expression: Expression): UnaryExpression;
    Label(): LabelTarget;
    Label(target: LabelTarget, defaultValue: Expression | undefined): LabelExpression;
    Label(target: LabelTarget): LabelExpression;
    Label(name: string | undefined): LabelTarget;
    Label(type_: Type, name: string | undefined): LabelTarget;
    Label(type_: Type): LabelTarget;
    Lambda<TDelegate>(body: Expression, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression> | undefined): Expression_1<TDelegate>;
    Lambda(body: Expression, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression> | undefined): LambdaExpression;
    Lambda<TDelegate>(body: Expression, tailCall: boolean, ...parameters: ParameterExpression[]): Expression_1<TDelegate>;
    Lambda(body: Expression, tailCall: boolean, ...parameters: ParameterExpression[]): LambdaExpression;
    Lambda<TDelegate>(body: Expression, parameters: IEnumerable_1<ParameterExpression> | undefined): Expression_1<TDelegate>;
    Lambda(body: Expression, parameters: IEnumerable_1<ParameterExpression> | undefined): LambdaExpression;
    Lambda<TDelegate>(body: Expression, ...parameters: ParameterExpression[]): Expression_1<TDelegate>;
    Lambda(body: Expression, ...parameters: ParameterExpression[]): LambdaExpression;
    Lambda<TDelegate>(body: Expression, name: string | undefined, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression> | undefined): Expression_1<TDelegate>;
    Lambda(body: Expression, name: string | undefined, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression> | undefined): LambdaExpression;
    Lambda<TDelegate>(body: Expression, name: string | undefined, parameters: IEnumerable_1<ParameterExpression> | undefined): Expression_1<TDelegate>;
    Lambda(body: Expression, name: string | undefined, parameters: IEnumerable_1<ParameterExpression> | undefined): LambdaExpression;
    Lambda(delegateType: Type, body: Expression, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression> | undefined): LambdaExpression;
    Lambda(delegateType: Type, body: Expression, tailCall: boolean, ...parameters: ParameterExpression[]): LambdaExpression;
    Lambda(delegateType: Type, body: Expression, parameters: IEnumerable_1<ParameterExpression> | undefined): LambdaExpression;
    Lambda(delegateType: Type, body: Expression, ...parameters: ParameterExpression[]): LambdaExpression;
    Lambda(delegateType: Type, body: Expression, name: string | undefined, tailCall: boolean, parameters: IEnumerable_1<ParameterExpression> | undefined): LambdaExpression;
    Lambda(delegateType: Type, body: Expression, name: string | undefined, parameters: IEnumerable_1<ParameterExpression> | undefined): LambdaExpression;
    LeftShift(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    LeftShift(left: Expression, right: Expression): BinaryExpression;
    LeftShiftAssign(left: Expression, right: Expression, method: MethodInfo | undefined, conversion: LambdaExpression | undefined): BinaryExpression;
    LeftShiftAssign(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    LeftShiftAssign(left: Expression, right: Expression): BinaryExpression;
    LessThan(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo | undefined): BinaryExpression;
    LessThan(left: Expression, right: Expression): BinaryExpression;
    LessThanOrEqual(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo | undefined): BinaryExpression;
    LessThanOrEqual(left: Expression, right: Expression): BinaryExpression;
    ListBind(member: MemberInfo, initializers: IEnumerable_1<ElementInit>): MemberListBinding;
    ListBind(member: MemberInfo, ...initializers: ElementInit[]): MemberListBinding;
    ListBind(propertyAccessor: MethodInfo, initializers: IEnumerable_1<ElementInit>): MemberListBinding;
    ListBind(propertyAccessor: MethodInfo, ...initializers: ElementInit[]): MemberListBinding;
    ListInit(newExpression: NewExpression, initializers: IEnumerable_1<ElementInit>): ListInitExpression;
    ListInit(newExpression: NewExpression, initializers: IEnumerable_1<Expression>): ListInitExpression;
    ListInit(newExpression: NewExpression, ...initializers: ElementInit[]): ListInitExpression;
    ListInit(newExpression: NewExpression, ...initializers: Expression[]): ListInitExpression;
    ListInit(newExpression: NewExpression, addMethod: MethodInfo | undefined, initializers: IEnumerable_1<Expression>): ListInitExpression;
    ListInit(newExpression: NewExpression, addMethod: MethodInfo | undefined, ...initializers: Expression[]): ListInitExpression;
    Loop(body: Expression, break_: LabelTarget | undefined, continue_: LabelTarget | undefined): LoopExpression;
    Loop(body: Expression, break_: LabelTarget | undefined): LoopExpression;
    Loop(body: Expression): LoopExpression;
    MakeBinary(binaryType: ExpressionType, left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo | undefined, conversion: LambdaExpression | undefined): BinaryExpression;
    MakeBinary(binaryType: ExpressionType, left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo | undefined): BinaryExpression;
    MakeBinary(binaryType: ExpressionType, left: Expression, right: Expression): BinaryExpression;
    MakeCatchBlock(type_: Type, variable: ParameterExpression | undefined, body: Expression, filter: Expression | undefined): CatchBlock;
    MakeDynamic(delegateType: Type, binder: CallSiteBinder, arguments: IEnumerable_1<Expression> | undefined): DynamicExpression;
    MakeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression): DynamicExpression;
    MakeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression): DynamicExpression;
    MakeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression, arg1: Expression): DynamicExpression;
    MakeDynamic(delegateType: Type, binder: CallSiteBinder, arg0: Expression): DynamicExpression;
    MakeDynamic(delegateType: Type, binder: CallSiteBinder, ...arguments: Expression[]): DynamicExpression;
    MakeGoto(kind: GotoExpressionKind, target: LabelTarget, value: Expression | undefined, type_: Type): GotoExpression;
    MakeIndex(instance: Expression, indexer: PropertyInfo | undefined, arguments: IEnumerable_1<Expression> | undefined): IndexExpression;
    MakeMemberAccess(expression: Expression | undefined, member: MemberInfo): MemberExpression;
    MakeTry(type_: Type | undefined, body: Expression, finally_: Expression | undefined, fault: Expression | undefined, handlers: IEnumerable_1<CatchBlock> | undefined): TryExpression;
    MakeUnary(unaryType: ExpressionType, operand: Expression, type_: Type, method: MethodInfo | undefined): UnaryExpression;
    MakeUnary(unaryType: ExpressionType, operand: Expression, type_: Type): UnaryExpression;
    MemberBind(member: MemberInfo, bindings: IEnumerable_1<MemberBinding>): MemberMemberBinding;
    MemberBind(member: MemberInfo, ...bindings: MemberBinding[]): MemberMemberBinding;
    MemberBind(propertyAccessor: MethodInfo, bindings: IEnumerable_1<MemberBinding>): MemberMemberBinding;
    MemberBind(propertyAccessor: MethodInfo, ...bindings: MemberBinding[]): MemberMemberBinding;
    MemberInit(newExpression: NewExpression, bindings: IEnumerable_1<MemberBinding>): MemberInitExpression;
    MemberInit(newExpression: NewExpression, ...bindings: MemberBinding[]): MemberInitExpression;
    Modulo(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    Modulo(left: Expression, right: Expression): BinaryExpression;
    ModuloAssign(left: Expression, right: Expression, method: MethodInfo | undefined, conversion: LambdaExpression | undefined): BinaryExpression;
    ModuloAssign(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    ModuloAssign(left: Expression, right: Expression): BinaryExpression;
    Multiply(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    Multiply(left: Expression, right: Expression): BinaryExpression;
    MultiplyAssign(left: Expression, right: Expression, method: MethodInfo | undefined, conversion: LambdaExpression | undefined): BinaryExpression;
    MultiplyAssign(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    MultiplyAssign(left: Expression, right: Expression): BinaryExpression;
    MultiplyAssignChecked(left: Expression, right: Expression, method: MethodInfo | undefined, conversion: LambdaExpression | undefined): BinaryExpression;
    MultiplyAssignChecked(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    MultiplyAssignChecked(left: Expression, right: Expression): BinaryExpression;
    MultiplyChecked(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    MultiplyChecked(left: Expression, right: Expression): BinaryExpression;
    Negate(expression: Expression, method: MethodInfo | undefined): UnaryExpression;
    Negate(expression: Expression): UnaryExpression;
    NegateChecked(expression: Expression, method: MethodInfo | undefined): UnaryExpression;
    NegateChecked(expression: Expression): UnaryExpression;
    New(constructor_: ConstructorInfo, arguments: IEnumerable_1<Expression> | undefined, members: IEnumerable_1<MemberInfo> | undefined): NewExpression;
    New(constructor_: ConstructorInfo, arguments: IEnumerable_1<Expression> | undefined, ...members: MemberInfo[]): NewExpression;
    New(constructor_: ConstructorInfo, arguments: IEnumerable_1<Expression> | undefined): NewExpression;
    New(constructor_: ConstructorInfo, ...arguments: Expression[]): NewExpression;
    New(constructor_: ConstructorInfo): NewExpression;
    New(type_: Type): NewExpression;
    NewArrayBounds(type_: Type, bounds: IEnumerable_1<Expression>): NewArrayExpression;
    NewArrayBounds(type_: Type, ...bounds: Expression[]): NewArrayExpression;
    NewArrayInit(type_: Type, initializers: IEnumerable_1<Expression>): NewArrayExpression;
    NewArrayInit(type_: Type, ...initializers: Expression[]): NewArrayExpression;
    Not(expression: Expression, method: MethodInfo | undefined): UnaryExpression;
    Not(expression: Expression): UnaryExpression;
    NotEqual(left: Expression, right: Expression, liftToNull: boolean, method: MethodInfo | undefined): BinaryExpression;
    NotEqual(left: Expression, right: Expression): BinaryExpression;
    OnesComplement(expression: Expression, method: MethodInfo | undefined): UnaryExpression;
    OnesComplement(expression: Expression): UnaryExpression;
    Or(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    Or(left: Expression, right: Expression): BinaryExpression;
    OrAssign(left: Expression, right: Expression, method: MethodInfo | undefined, conversion: LambdaExpression | undefined): BinaryExpression;
    OrAssign(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    OrAssign(left: Expression, right: Expression): BinaryExpression;
    OrElse(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    OrElse(left: Expression, right: Expression): BinaryExpression;
    Parameter(type_: Type, name: string | undefined): ParameterExpression;
    Parameter(type_: Type): ParameterExpression;
    PostDecrementAssign(expression: Expression, method: MethodInfo | undefined): UnaryExpression;
    PostDecrementAssign(expression: Expression): UnaryExpression;
    PostIncrementAssign(expression: Expression, method: MethodInfo | undefined): UnaryExpression;
    PostIncrementAssign(expression: Expression): UnaryExpression;
    Power(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    Power(left: Expression, right: Expression): BinaryExpression;
    PowerAssign(left: Expression, right: Expression, method: MethodInfo | undefined, conversion: LambdaExpression | undefined): BinaryExpression;
    PowerAssign(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    PowerAssign(left: Expression, right: Expression): BinaryExpression;
    PreDecrementAssign(expression: Expression, method: MethodInfo | undefined): UnaryExpression;
    PreDecrementAssign(expression: Expression): UnaryExpression;
    PreIncrementAssign(expression: Expression, method: MethodInfo | undefined): UnaryExpression;
    PreIncrementAssign(expression: Expression): UnaryExpression;
    Property(expression: Expression | undefined, propertyAccessor: MethodInfo): MemberExpression;
    Property(instance: Expression | undefined, indexer: PropertyInfo, arguments: IEnumerable_1<Expression> | undefined): IndexExpression;
    Property(instance: Expression | undefined, indexer: PropertyInfo, ...arguments: Expression[]): IndexExpression;
    Property(expression: Expression | undefined, property: PropertyInfo): MemberExpression;
    Property(instance: Expression, propertyName: string, ...arguments: Expression[]): IndexExpression;
    Property(expression: Expression, propertyName: string): MemberExpression;
    Property(expression: Expression | undefined, type_: Type, propertyName: string): MemberExpression;
    PropertyOrField(expression: Expression, propertyOrFieldName: string): MemberExpression;
    Quote(expression: Expression): UnaryExpression;
    ReferenceEqual(left: Expression, right: Expression): BinaryExpression;
    ReferenceNotEqual(left: Expression, right: Expression): BinaryExpression;
    Rethrow(): UnaryExpression;
    Rethrow(type_: Type): UnaryExpression;
    Return(target: LabelTarget, value: Expression | undefined, type_: Type): GotoExpression;
    Return(target: LabelTarget, value: Expression | undefined): GotoExpression;
    Return(target: LabelTarget, type_: Type): GotoExpression;
    Return(target: LabelTarget): GotoExpression;
    RightShift(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    RightShift(left: Expression, right: Expression): BinaryExpression;
    RightShiftAssign(left: Expression, right: Expression, method: MethodInfo | undefined, conversion: LambdaExpression | undefined): BinaryExpression;
    RightShiftAssign(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    RightShiftAssign(left: Expression, right: Expression): BinaryExpression;
    RuntimeVariables(variables: IEnumerable_1<ParameterExpression>): RuntimeVariablesExpression;
    RuntimeVariables(...variables: ParameterExpression[]): RuntimeVariablesExpression;
    Subtract(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    Subtract(left: Expression, right: Expression): BinaryExpression;
    SubtractAssign(left: Expression, right: Expression, method: MethodInfo | undefined, conversion: LambdaExpression | undefined): BinaryExpression;
    SubtractAssign(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    SubtractAssign(left: Expression, right: Expression): BinaryExpression;
    SubtractAssignChecked(left: Expression, right: Expression, method: MethodInfo | undefined, conversion: LambdaExpression | undefined): BinaryExpression;
    SubtractAssignChecked(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    SubtractAssignChecked(left: Expression, right: Expression): BinaryExpression;
    SubtractChecked(left: Expression, right: Expression, method: MethodInfo | undefined): BinaryExpression;
    SubtractChecked(left: Expression, right: Expression): BinaryExpression;
    Switch(switchValue: Expression, defaultBody: Expression | undefined, ...cases: SwitchCase[]): SwitchExpression;
    Switch(switchValue: Expression, defaultBody: Expression | undefined, comparison: MethodInfo | undefined, cases: IEnumerable_1<SwitchCase> | undefined): SwitchExpression;
    Switch(switchValue: Expression, defaultBody: Expression | undefined, comparison: MethodInfo | undefined, ...cases: SwitchCase[]): SwitchExpression;
    Switch(switchValue: Expression, ...cases: SwitchCase[]): SwitchExpression;
    Switch(type_: Type | undefined, switchValue: Expression, defaultBody: Expression | undefined, comparison: MethodInfo | undefined, cases: IEnumerable_1<SwitchCase> | undefined): SwitchExpression;
    Switch(type_: Type | undefined, switchValue: Expression, defaultBody: Expression | undefined, comparison: MethodInfo | undefined, ...cases: SwitchCase[]): SwitchExpression;
    SwitchCase(body: Expression, testValues: IEnumerable_1<Expression>): SwitchCase;
    SwitchCase(body: Expression, ...testValues: Expression[]): SwitchCase;
    SymbolDocument(fileName: string, language: Guid, languageVendor: Guid, documentType: Guid): SymbolDocumentInfo;
    SymbolDocument(fileName: string, language: Guid, languageVendor: Guid): SymbolDocumentInfo;
    SymbolDocument(fileName: string, language: Guid): SymbolDocumentInfo;
    SymbolDocument(fileName: string): SymbolDocumentInfo;
    Throw(value: Expression | undefined, type_: Type): UnaryExpression;
    Throw(value: Expression | undefined): UnaryExpression;
    TryCatch(body: Expression, ...handlers: CatchBlock[]): TryExpression;
    TryCatchFinally(body: Expression, finally_: Expression | undefined, ...handlers: CatchBlock[]): TryExpression;
    TryFault(body: Expression, fault: Expression | undefined): TryExpression;
    TryFinally(body: Expression, finally_: Expression | undefined): TryExpression;
    TryGetActionType(typeArgs: Type[], actionType: Type | undefined): boolean;
    TryGetFuncType(typeArgs: Type[], funcType: Type | undefined): boolean;
    TypeAs(expression: Expression, type_: Type): UnaryExpression;
    TypeEqual(expression: Expression, type_: Type): TypeBinaryExpression;
    TypeIs(expression: Expression, type_: Type): TypeBinaryExpression;
    UnaryPlus(expression: Expression, method: MethodInfo | undefined): UnaryExpression;
    UnaryPlus(expression: Expression): UnaryExpression;
    Unbox(expression: Expression, type_: Type): UnaryExpression;
    Variable(type_: Type, name: string | undefined): ParameterExpression;
    Variable(type_: Type): ParameterExpression;
};


export type Expression = Expression$instance;

export interface Expression_1$instance<TDelegate> extends LambdaExpression {
    Compile(): TDelegate;
    Compile(preferInterpretation: boolean): TDelegate;
    Compile(debugInfoGenerator: DebugInfoGenerator): TDelegate;
    Compile(): Function;
    Compile(preferInterpretation: boolean): Function;
    Compile(debugInfoGenerator: DebugInfoGenerator): Function;
    Update(body: Expression, parameters: IEnumerable_1<ParameterExpression> | undefined): Expression_1<TDelegate>;
}


export const Expression_1: {
    new<TDelegate>(): Expression_1<TDelegate>;
};


export type Expression_1<TDelegate> = Expression_1$instance<TDelegate>;

export interface ExpressionVisitor$instance {
    Visit(node: Expression | undefined): Expression | undefined;
    Visit(nodes: ReadOnlyCollection_1<Expression>): ReadOnlyCollection_1<Expression>;
    VisitAndConvert<T extends Expression>(node: T | undefined, callerName: string | undefined): T | undefined;
    VisitAndConvert<T extends Expression>(nodes: ReadOnlyCollection_1<T>, callerName: string | undefined): ReadOnlyCollection_1<T>;
}


export const ExpressionVisitor: {
    Visit<T>(nodes: ReadOnlyCollection_1<T>, elementVisitor: Func_2<T, T>): ReadOnlyCollection_1<T>;
};


export type ExpressionVisitor = ExpressionVisitor$instance;

export interface GotoExpression$instance extends Expression {
    readonly Kind: GotoExpressionKind;
    readonly NodeType: ExpressionType;
    readonly Target: LabelTarget;
    readonly Type: Type;
    readonly Value: Expression;
    Update(target: LabelTarget, value: Expression | undefined): GotoExpression;
}


export const GotoExpression: {
    new(): GotoExpression;
};


export type GotoExpression = GotoExpression$instance;

export interface IndexExpression$instance extends Expression {
    readonly ArgumentCount: int;
    readonly Arguments: ReadOnlyCollection_1<Expression>;
    readonly Indexer: PropertyInfo | undefined;
    readonly NodeType: ExpressionType;
    readonly Object: Expression | undefined;
    readonly Type: Type;
    GetArgument(index: int): Expression;
    Update(object_: Expression, arguments: IEnumerable_1<Expression> | undefined): IndexExpression;
}


export const IndexExpression: {
    new(): IndexExpression;
};


export interface __IndexExpression$views {
    As_IArgumentProvider(): IArgumentProvider$instance;
}

export interface IndexExpression$instance extends IArgumentProvider$instance {}

export type IndexExpression = IndexExpression$instance & __IndexExpression$views;


export interface InvocationExpression$instance extends Expression {
    readonly ArgumentCount: int;
    readonly Arguments: ReadOnlyCollection_1<Expression>;
    readonly Expression: Expression;
    readonly NodeType: ExpressionType;
    readonly Type: Type;
    GetArgument(index: int): Expression;
    Update(expression: Expression, arguments: IEnumerable_1<Expression> | undefined): InvocationExpression;
}


export const InvocationExpression: {
    new(): InvocationExpression;
};


export interface __InvocationExpression$views {
    As_IArgumentProvider(): IArgumentProvider$instance;
}

export interface InvocationExpression$instance extends IArgumentProvider$instance {}

export type InvocationExpression = InvocationExpression$instance & __InvocationExpression$views;


export interface LabelExpression$instance extends Expression {
    readonly DefaultValue: Expression;
    readonly NodeType: ExpressionType;
    readonly Target: LabelTarget;
    readonly Type: Type;
    Update(target: LabelTarget, defaultValue: Expression | undefined): LabelExpression;
}


export const LabelExpression: {
    new(): LabelExpression;
};


export type LabelExpression = LabelExpression$instance;

export interface LabelTarget$instance {
    readonly Name: string;
    readonly Type: Type;
    ToString(): string;
}


export const LabelTarget: {
    new(): LabelTarget;
};


export type LabelTarget = LabelTarget$instance;

export interface LambdaExpression$instance extends Expression {
    readonly Body: Expression;
    readonly Name: string;
    readonly NodeType: ExpressionType;
    readonly Parameters: ReadOnlyCollection_1<ParameterExpression>;
    readonly ReturnType: Type;
    readonly TailCall: boolean;
    readonly Type: Type;
    Compile(): Function;
    Compile(preferInterpretation: boolean): Function;
    Compile(debugInfoGenerator: DebugInfoGenerator): Function;
}


export const LambdaExpression: {
    readonly CanCompileToIL: boolean;
    readonly CanInterpret: boolean;
};


export type LambdaExpression = LambdaExpression$instance;

export interface ListInitExpression$instance extends Expression {
    readonly CanReduce: boolean;
    readonly Initializers: ReadOnlyCollection_1<ElementInit>;
    readonly NewExpression: NewExpression;
    readonly NodeType: ExpressionType;
    readonly Type: Type;
    Reduce(): Expression;
    Update(newExpression: NewExpression, initializers: IEnumerable_1<ElementInit>): ListInitExpression;
}


export const ListInitExpression: {
    new(): ListInitExpression;
};


export type ListInitExpression = ListInitExpression$instance;

export interface LoopExpression$instance extends Expression {
    readonly Body: Expression;
    readonly BreakLabel: LabelTarget | undefined;
    readonly ContinueLabel: LabelTarget | undefined;
    readonly NodeType: ExpressionType;
    readonly Type: Type;
    Update(breakLabel: LabelTarget | undefined, continueLabel: LabelTarget | undefined, body: Expression): LoopExpression;
}


export const LoopExpression: {
    new(): LoopExpression;
};


export type LoopExpression = LoopExpression$instance;

export interface MemberAssignment$instance extends MemberBinding {
    readonly Expression: Expression;
    Update(expression: Expression): MemberAssignment;
}


export const MemberAssignment: {
    new(): MemberAssignment;
};


export type MemberAssignment = MemberAssignment$instance;

export interface MemberBinding$instance {
    readonly BindingType: MemberBindingType;
    readonly Member: MemberInfo;
    ToString(): string;
}


export const MemberBinding: {
};


export type MemberBinding = MemberBinding$instance;

export interface MemberExpression$instance extends Expression {
    readonly Expression: Expression;
    readonly Member: MemberInfo;
    readonly NodeType: ExpressionType;
    Update(expression: Expression | undefined): MemberExpression;
}


export const MemberExpression: {
    new(): MemberExpression;
};


export type MemberExpression = MemberExpression$instance;

export interface MemberInitExpression$instance extends Expression {
    readonly Bindings: ReadOnlyCollection_1<MemberBinding>;
    readonly CanReduce: boolean;
    readonly NewExpression: NewExpression;
    readonly NodeType: ExpressionType;
    readonly Type: Type;
    Reduce(): Expression;
    Update(newExpression: NewExpression, bindings: IEnumerable_1<MemberBinding>): MemberInitExpression;
}


export const MemberInitExpression: {
    new(): MemberInitExpression;
};


export type MemberInitExpression = MemberInitExpression$instance;

export interface MemberListBinding$instance extends MemberBinding {
    readonly Initializers: ReadOnlyCollection_1<ElementInit>;
    Update(initializers: IEnumerable_1<ElementInit>): MemberListBinding;
}


export const MemberListBinding: {
    new(): MemberListBinding;
};


export type MemberListBinding = MemberListBinding$instance;

export interface MemberMemberBinding$instance extends MemberBinding {
    readonly Bindings: ReadOnlyCollection_1<MemberBinding>;
    Update(bindings: IEnumerable_1<MemberBinding>): MemberMemberBinding;
}


export const MemberMemberBinding: {
    new(): MemberMemberBinding;
};


export type MemberMemberBinding = MemberMemberBinding$instance;

export interface MethodCallExpression$instance extends Expression {
    readonly ArgumentCount: int;
    readonly Arguments: ReadOnlyCollection_1<Expression>;
    readonly Method: MethodInfo;
    readonly NodeType: ExpressionType;
    readonly Object: Expression | undefined;
    readonly Type: Type;
    GetArgument(index: int): Expression;
    Update(object_: Expression | undefined, arguments: IEnumerable_1<Expression> | undefined): MethodCallExpression;
}


export const MethodCallExpression: {
    new(): MethodCallExpression;
};


export interface __MethodCallExpression$views {
    As_IArgumentProvider(): IArgumentProvider$instance;
}

export interface MethodCallExpression$instance extends IArgumentProvider$instance {}

export type MethodCallExpression = MethodCallExpression$instance & __MethodCallExpression$views;


export interface NewArrayExpression$instance extends Expression {
    readonly Expressions: ReadOnlyCollection_1<Expression>;
    readonly Type: Type;
    Update(expressions: IEnumerable_1<Expression>): NewArrayExpression;
}


export const NewArrayExpression: {
    new(): NewArrayExpression;
};


export type NewArrayExpression = NewArrayExpression$instance;

export interface NewExpression$instance extends Expression {
    readonly ArgumentCount: int;
    readonly Arguments: ReadOnlyCollection_1<Expression>;
    readonly Constructor: ConstructorInfo;
    readonly Members: ReadOnlyCollection_1<MemberInfo>;
    readonly NodeType: ExpressionType;
    readonly Type: Type;
    GetArgument(index: int): Expression;
    Update(arguments: IEnumerable_1<Expression> | undefined): NewExpression;
}


export const NewExpression: {
    new(): NewExpression;
};


export interface __NewExpression$views {
    As_IArgumentProvider(): IArgumentProvider$instance;
}

export interface NewExpression$instance extends IArgumentProvider$instance {}

export type NewExpression = NewExpression$instance & __NewExpression$views;


export interface ParameterExpression$instance extends Expression {
    readonly IsByRef: boolean;
    readonly Name: string;
    readonly NodeType: ExpressionType;
    readonly Type: Type;
}


export const ParameterExpression: {
    new(): ParameterExpression;
};


export type ParameterExpression = ParameterExpression$instance;

export interface RuntimeVariablesExpression$instance extends Expression {
    readonly NodeType: ExpressionType;
    readonly Type: Type;
    readonly Variables: ReadOnlyCollection_1<ParameterExpression>;
    Update(variables: IEnumerable_1<ParameterExpression>): RuntimeVariablesExpression;
}


export const RuntimeVariablesExpression: {
    new(): RuntimeVariablesExpression;
};


export type RuntimeVariablesExpression = RuntimeVariablesExpression$instance;

export interface SwitchCase$instance {
    readonly Body: Expression;
    readonly TestValues: ReadOnlyCollection_1<Expression>;
    ToString(): string;
    Update(testValues: IEnumerable_1<Expression>, body: Expression): SwitchCase;
}


export const SwitchCase: {
    new(): SwitchCase;
};


export type SwitchCase = SwitchCase$instance;

export interface SwitchExpression$instance extends Expression {
    readonly Cases: ReadOnlyCollection_1<SwitchCase>;
    readonly Comparison: MethodInfo | undefined;
    readonly DefaultBody: Expression | undefined;
    readonly NodeType: ExpressionType;
    readonly SwitchValue: Expression;
    readonly Type: Type;
    Update(switchValue: Expression, cases: IEnumerable_1<SwitchCase> | undefined, defaultBody: Expression | undefined): SwitchExpression;
}


export const SwitchExpression: {
    new(): SwitchExpression;
};


export type SwitchExpression = SwitchExpression$instance;

export interface SymbolDocumentInfo$instance {
    readonly DocumentType: Guid;
    readonly FileName: string;
    readonly Language: Guid;
    readonly LanguageVendor: Guid;
}


export const SymbolDocumentInfo: {
    new(): SymbolDocumentInfo;
};


export type SymbolDocumentInfo = SymbolDocumentInfo$instance;

export interface TryExpression$instance extends Expression {
    readonly Body: Expression;
    readonly Fault: Expression | undefined;
    readonly Finally: Expression | undefined;
    readonly Handlers: ReadOnlyCollection_1<CatchBlock>;
    readonly NodeType: ExpressionType;
    readonly Type: Type;
    Update(body: Expression, handlers: IEnumerable_1<CatchBlock> | undefined, finally_: Expression | undefined, fault: Expression | undefined): TryExpression;
}


export const TryExpression: {
    new(): TryExpression;
};


export type TryExpression = TryExpression$instance;

export interface TypeBinaryExpression$instance extends Expression {
    readonly Expression: Expression;
    readonly NodeType: ExpressionType;
    readonly Type: Type;
    readonly TypeOperand: Type;
    Update(expression: Expression): TypeBinaryExpression;
}


export const TypeBinaryExpression: {
    new(): TypeBinaryExpression;
};


export type TypeBinaryExpression = TypeBinaryExpression$instance;

export interface UnaryExpression$instance extends Expression {
    readonly CanReduce: boolean;
    readonly IsLifted: boolean;
    readonly IsLiftedToNull: boolean;
    readonly Method: MethodInfo;
    readonly NodeType: ExpressionType;
    readonly Operand: Expression;
    readonly Type: Type;
    Reduce(): Expression;
    Update(operand: Expression): UnaryExpression;
}


export const UnaryExpression: {
    new(): UnaryExpression;
};


export type UnaryExpression = UnaryExpression$instance;


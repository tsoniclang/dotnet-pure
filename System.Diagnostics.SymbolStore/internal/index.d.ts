// Generated by tsbindgen - Architecture
// Namespace: System.Diagnostics.SymbolStore
// Assembly: System.Diagnostics.StackTrace, System.Private.CoreLib

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import type { FieldAttributes, ParameterAttributes } from "../../System.Reflection/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Byte, Enum, Guid, IComparable, IConvertible, IEquatable_1, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, Object as ClrObject, String as ClrString, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

export enum SymAddressKind {
    ILOffset = 1,
    NativeRVA = 2,
    NativeRegister = 3,
    NativeRegisterRelative = 4,
    NativeOffset = 5,
    NativeRegisterRegister = 6,
    NativeRegisterStack = 7,
    NativeStackRegister = 8,
    BitField = 9,
    NativeSectionOffset = 10
}


export interface ISymbolBinder$instance {
    GetReader(importer: int, filename: string, searchPath: string): ISymbolReader | undefined;
}


export type ISymbolBinder = ISymbolBinder$instance;

export interface ISymbolBinder1$instance {
    GetReader(importer: nint, filename: string, searchPath: string): ISymbolReader | undefined;
}


export type ISymbolBinder1 = ISymbolBinder1$instance;

export interface ISymbolDocument$instance {
    readonly URL: string;
    readonly DocumentType: Guid;
    readonly Language: Guid;
    readonly LanguageVendor: Guid;
    readonly CheckSumAlgorithmId: Guid;
    readonly HasEmbeddedSource: boolean;
    readonly SourceLength: int;
    FindClosestLine(line: int): int;
    GetCheckSum(): byte[];
    GetSourceRange(startLine: int, startColumn: int, endLine: int, endColumn: int): byte[];
}


export type ISymbolDocument = ISymbolDocument$instance;

export interface ISymbolDocumentWriter$instance {
    SetCheckSum(algorithmId: Guid, checkSum: byte[]): void;
    SetSource(source: byte[]): void;
}


export type ISymbolDocumentWriter = ISymbolDocumentWriter$instance;

export interface ISymbolMethod$instance {
    readonly Token: SymbolToken;
    readonly SequencePointCount: int;
    readonly RootScope: ISymbolScope;
    GetNamespace(): ISymbolNamespace;
    GetOffset(document: ISymbolDocument, line: int, column: int): int;
    GetParameters(): ISymbolVariable[];
    GetRanges(document: ISymbolDocument, line: int, column: int): int[];
    GetScope(offset: int): ISymbolScope;
    GetSequencePoints(offsets: int[] | undefined, documents: ISymbolDocument[] | undefined, lines: int[] | undefined, columns: int[] | undefined, endLines: int[] | undefined, endColumns: int[] | undefined): void;
    GetSourceStartEnd(docs: ISymbolDocument[] | undefined, lines: int[] | undefined, columns: int[] | undefined): boolean;
}


export type ISymbolMethod = ISymbolMethod$instance;

export interface ISymbolNamespace$instance {
    readonly Name: string;
    GetNamespaces(): ISymbolNamespace[];
    GetVariables(): ISymbolVariable[];
}


export type ISymbolNamespace = ISymbolNamespace$instance;

export interface ISymbolReader$instance {
    readonly UserEntryPoint: SymbolToken;
    GetDocument(url: string, language: Guid, languageVendor: Guid, documentType: Guid): ISymbolDocument | undefined;
    GetDocuments(): ISymbolDocument[];
    GetGlobalVariables(): ISymbolVariable[];
    GetMethod(method: SymbolToken, version: int): ISymbolMethod | undefined;
    GetMethod(method: SymbolToken): ISymbolMethod | undefined;
    GetMethodFromDocumentPosition(document: ISymbolDocument, line: int, column: int): ISymbolMethod;
    GetNamespaces(): ISymbolNamespace[];
    GetSymAttribute(parent: SymbolToken, name: string): byte[];
    GetVariables(parent: SymbolToken): ISymbolVariable[];
}


export type ISymbolReader = ISymbolReader$instance;

export interface ISymbolScope$instance {
    readonly Method: ISymbolMethod;
    readonly Parent: ISymbolScope;
    readonly StartOffset: int;
    readonly EndOffset: int;
    GetChildren(): ISymbolScope[];
    GetLocals(): ISymbolVariable[];
    GetNamespaces(): ISymbolNamespace[];
}


export type ISymbolScope = ISymbolScope$instance;

export interface ISymbolVariable$instance {
    readonly Name: string;
    readonly Attributes: unknown;
    readonly AddressKind: SymAddressKind;
    readonly AddressField1: int;
    readonly AddressField2: int;
    readonly AddressField3: int;
    readonly StartOffset: int;
    readonly EndOffset: int;
    GetSignature(): byte[];
}


export type ISymbolVariable = ISymbolVariable$instance;

export interface ISymbolWriter$instance {
    CloseMethod(): void;
    CloseScope(endOffset: int): void;
    DefineDocument(url: string, language: Guid, languageVendor: Guid, documentType: Guid): ISymbolDocumentWriter;
    DefineField(parent: SymbolToken, name: string, attributes: FieldAttributes, signature: byte[], addrKind: SymAddressKind, addr1: int, addr2: int, addr3: int): void;
    DefineGlobalVariable(name: string, attributes: FieldAttributes, signature: byte[], addrKind: SymAddressKind, addr1: int, addr2: int, addr3: int): void;
    DefineLocalVariable(name: string, attributes: FieldAttributes, signature: byte[], addrKind: SymAddressKind, addr1: int, addr2: int, addr3: int, startOffset: int, endOffset: int): void;
    DefineParameter(name: string, attributes: ParameterAttributes, sequence: int, addrKind: SymAddressKind, addr1: int, addr2: int, addr3: int): void;
    DefineSequencePoints(document: ISymbolDocumentWriter, offsets: int[], lines: int[], columns: int[], endLines: int[], endColumns: int[]): void;
    Initialize(emitter: nint, filename: string, fFullBuild: boolean): void;
    OpenNamespace(name: string): void;
    OpenScope(startOffset: int): int;
    SetMethodSourceRange(startDoc: ISymbolDocumentWriter, startLine: int, startColumn: int, endDoc: ISymbolDocumentWriter, endLine: int, endColumn: int): void;
    SetScopeRange(scopeID: int, startOffset: int, endOffset: int): void;
    SetSymAttribute(parent: SymbolToken, name: string, data: byte[]): void;
    SetUnderlyingWriter(underlyingWriter: nint): void;
    SetUserEntryPoint(entryMethod: SymbolToken): void;
}


export type ISymbolWriter = ISymbolWriter$instance;

export interface SymbolToken$instance {
    Equals(obj: unknown | undefined): boolean;
    Equals(obj: SymbolToken): boolean;
    GetHashCode(): int;
    GetToken(): int;
}


export const SymbolToken: {
    new(val: int): SymbolToken;
};


export interface __SymbolToken$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SymbolToken>;

    // Structural method bridges for numeric interface constraints
    Equals(other: SymbolToken): boolean;
}

export type SymbolToken = SymbolToken$instance & __SymbolToken$views;


export interface SymDocumentType$instance {
}


export const SymDocumentType: {
    new(): SymDocumentType;
    readonly Text: Guid;
};


export type SymDocumentType = SymDocumentType$instance;

export interface SymLanguageType$instance {
}


export const SymLanguageType: {
    new(): SymLanguageType;
    readonly C: Guid;
    readonly CPlusPlus: Guid;
    readonly CSharp: Guid;
    readonly Basic: Guid;
    readonly Java: Guid;
    readonly Cobol: Guid;
    readonly Pascal: Guid;
    readonly ILAssembly: Guid;
    readonly JScript: Guid;
    readonly SMC: Guid;
    readonly MCPlusPlus: Guid;
};


export type SymLanguageType = SymLanguageType$instance;

export interface SymLanguageVendor$instance {
}


export const SymLanguageVendor: {
    new(): SymLanguageVendor;
    readonly Microsoft: Guid;
};


export type SymLanguageVendor = SymLanguageVendor$instance;


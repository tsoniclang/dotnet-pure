// Generated by tsbindgen - Architecture
// Namespace: System.Diagnostics.SymbolStore
// Assembly: System.Diagnostics.StackTrace, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { FieldAttributes, ParameterAttributes } from "../../System.Reflection/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Byte, Enum, Guid, IComparable, IConvertible, IEquatable_1, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, Object as ClrObject, String as ClrString, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum SymAddressKind {
    ILOffset = 1,
    NativeRVA = 2,
    NativeRegister = 3,
    NativeRegisterRelative = 4,
    NativeOffset = 5,
    NativeRegisterRegister = 6,
    NativeRegisterStack = 7,
    NativeStackRegister = 8,
    BitField = 9,
    NativeSectionOffset = 10
}


export interface ISymbolBinder$instance {
    GetReader(importer: int, filename: string, searchPath: string): ISymbolReader;
}


export type ISymbolBinder = ISymbolBinder$instance;

export interface ISymbolBinder1$instance {
    GetReader(importer: nint, filename: string, searchPath: string): ISymbolReader;
}


export type ISymbolBinder1 = ISymbolBinder1$instance;

export interface ISymbolDocument$instance {
    readonly URL: string;
    readonly DocumentType: Guid;
    readonly Language: Guid;
    readonly LanguageVendor: Guid;
    readonly CheckSumAlgorithmId: Guid;
    readonly HasEmbeddedSource: boolean;
    readonly SourceLength: int;
    FindClosestLine(line: int): int;
    GetCheckSum(): byte[];
    GetSourceRange(startLine: int, startColumn: int, endLine: int, endColumn: int): byte[];
}


export type ISymbolDocument = ISymbolDocument$instance;

export interface ISymbolDocumentWriter$instance {
    SetCheckSum(algorithmId: Guid, checkSum: byte[]): void;
    SetSource(source: byte[]): void;
}


export type ISymbolDocumentWriter = ISymbolDocumentWriter$instance;

export interface ISymbolMethod$instance {
    readonly Token: SymbolToken;
    readonly SequencePointCount: int;
    readonly RootScope: ISymbolScope;
    GetNamespace(): ISymbolNamespace;
    GetOffset(document: ISymbolDocument, line: int, column: int): int;
    GetParameters(): ISymbolVariable[];
    GetRanges(document: ISymbolDocument, line: int, column: int): int[];
    GetScope(offset: int): ISymbolScope;
    GetSequencePoints(offsets: int[], documents: ISymbolDocument[], lines: int[], columns: int[], endLines: int[], endColumns: int[]): void;
    GetSourceStartEnd(docs: ISymbolDocument[], lines: int[], columns: int[]): boolean;
}


export type ISymbolMethod = ISymbolMethod$instance;

export interface ISymbolNamespace$instance {
    readonly Name: string;
    GetNamespaces(): ISymbolNamespace[];
    GetVariables(): ISymbolVariable[];
}


export type ISymbolNamespace = ISymbolNamespace$instance;

export interface ISymbolReader$instance {
    readonly UserEntryPoint: SymbolToken;
    GetDocument(url: string, language: Guid, languageVendor: Guid, documentType: Guid): ISymbolDocument;
    GetDocuments(): ISymbolDocument[];
    GetGlobalVariables(): ISymbolVariable[];
    GetMethod(method: SymbolToken, version: int): ISymbolMethod;
    GetMethod(method: SymbolToken): ISymbolMethod;
    GetMethodFromDocumentPosition(document: ISymbolDocument, line: int, column: int): ISymbolMethod;
    GetNamespaces(): ISymbolNamespace[];
    GetSymAttribute(parent: SymbolToken, name: string): byte[];
    GetVariables(parent: SymbolToken): ISymbolVariable[];
}


export type ISymbolReader = ISymbolReader$instance;

export interface ISymbolScope$instance {
    readonly Method: ISymbolMethod;
    readonly Parent: ISymbolScope;
    readonly StartOffset: int;
    readonly EndOffset: int;
    GetChildren(): ISymbolScope[];
    GetLocals(): ISymbolVariable[];
    GetNamespaces(): ISymbolNamespace[];
}


export type ISymbolScope = ISymbolScope$instance;

export interface ISymbolVariable$instance {
    readonly Name: string;
    readonly Attributes: unknown;
    readonly AddressKind: SymAddressKind;
    readonly AddressField1: int;
    readonly AddressField2: int;
    readonly AddressField3: int;
    readonly StartOffset: int;
    readonly EndOffset: int;
    GetSignature(): byte[];
}


export type ISymbolVariable = ISymbolVariable$instance;

export interface ISymbolWriter$instance {
    CloseMethod(): void;
    CloseScope(endOffset: int): void;
    DefineDocument(url: string, language: Guid, languageVendor: Guid, documentType: Guid): ISymbolDocumentWriter;
    DefineField(parent: SymbolToken, name: string, attributes: FieldAttributes, signature: byte[], addrKind: SymAddressKind, addr1: int, addr2: int, addr3: int): void;
    DefineGlobalVariable(name: string, attributes: FieldAttributes, signature: byte[], addrKind: SymAddressKind, addr1: int, addr2: int, addr3: int): void;
    DefineLocalVariable(name: string, attributes: FieldAttributes, signature: byte[], addrKind: SymAddressKind, addr1: int, addr2: int, addr3: int, startOffset: int, endOffset: int): void;
    DefineParameter(name: string, attributes: ParameterAttributes, sequence: int, addrKind: SymAddressKind, addr1: int, addr2: int, addr3: int): void;
    DefineSequencePoints(document: ISymbolDocumentWriter, offsets: int[], lines: int[], columns: int[], endLines: int[], endColumns: int[]): void;
    Initialize(emitter: nint, filename: string, fFullBuild: boolean): void;
    OpenNamespace(name: string): void;
    OpenScope(startOffset: int): int;
    SetMethodSourceRange(startDoc: ISymbolDocumentWriter, startLine: int, startColumn: int, endDoc: ISymbolDocumentWriter, endLine: int, endColumn: int): void;
    SetScopeRange(scopeID: int, startOffset: int, endOffset: int): void;
    SetSymAttribute(parent: SymbolToken, name: string, data: byte[]): void;
    SetUnderlyingWriter(underlyingWriter: nint): void;
    SetUserEntryPoint(entryMethod: SymbolToken): void;
}


export type ISymbolWriter = ISymbolWriter$instance;

export interface SymbolToken$instance {
    Equals(obj: unknown): boolean;
    Equals(obj: SymbolToken): boolean;
    GetHashCode(): int;
    GetToken(): int;
}


export const SymbolToken: {
    new(val: int): SymbolToken$instance;
};


export interface __SymbolToken$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SymbolToken>;

    // Structural method bridges for numeric interface constraints
    equals(other: SymbolToken): boolean;
}

export type SymbolToken = SymbolToken$instance & __SymbolToken$views;


export interface SymDocumentType$instance {
}


export const SymDocumentType: {
    new(): SymDocumentType$instance;
    readonly Text: Guid;
};


export type SymDocumentType = SymDocumentType$instance;

export interface SymLanguageType$instance {
}


export const SymLanguageType: {
    new(): SymLanguageType$instance;
    readonly C: Guid;
    readonly CPlusPlus: Guid;
    readonly CSharp: Guid;
    readonly Basic: Guid;
    readonly Java: Guid;
    readonly Cobol: Guid;
    readonly Pascal: Guid;
    readonly ILAssembly: Guid;
    readonly JScript: Guid;
    readonly SMC: Guid;
    readonly MCPlusPlus: Guid;
};


export type SymLanguageType = SymLanguageType$instance;

export interface SymLanguageVendor$instance {
}


export const SymLanguageVendor: {
    new(): SymLanguageVendor$instance;
    readonly Microsoft: Guid;
};


export type SymLanguageVendor = SymLanguageVendor$instance;


// Generated by tsbindgen - Architecture
// Namespace: System.Net.Sockets
// Assembly: System.Net.Primitives, System.Net.Sockets

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as Microsoft_Win32_SafeHandles_Internal from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import type { SafeHandleMinusOneIsInvalid } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import type { IList_1 } from "../../System.Collections.Generic/internal/index.js";
import type { IDictionary, IList } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { Win32Exception } from "../../System.ComponentModel/internal/index.js";
import * as System_IO_Internal from "../../System.IO/internal/index.js";
import type { FileAccess, FileStream, SeekOrigin, Stream } from "../../System.IO/internal/index.js";
import * as System_Net_Internal from "../../System.Net/internal/index.js";
import type { EndPoint, IPAddress, IPEndPoint, SocketAddress } from "../../System.Net/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { ArraySegment_1, AsyncCallback, Boolean as ClrBoolean, Byte, Enum, EventArgs, EventHandler_1, Exception, IAsyncDisposable, IAsyncResult, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, Memory_1, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, Span_1, String as ClrString, TimeSpan, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum AddressFamily {
    Unknown = -1,
    Unspecified = 0,
    Unix = 1,
    InterNetwork = 2,
    ImpLink = 3,
    Pup = 4,
    Chaos = 5,
    NS = 6,
    Ipx = 6,
    Iso = 7,
    Osi = 7,
    Ecma = 8,
    DataKit = 9,
    Ccitt = 10,
    Sna = 11,
    DecNet = 12,
    DataLink = 13,
    Lat = 14,
    HyperChannel = 15,
    AppleTalk = 16,
    NetBios = 17,
    VoiceView = 18,
    FireFox = 19,
    Banyan = 21,
    Atm = 22,
    InterNetworkV6 = 23,
    Cluster = 24,
    Ieee12844 = 25,
    Irda = 26,
    NetworkDesigners = 28,
    Max = 29,
    Packet = 65536,
    ControllerAreaNetwork = 65537
}


export enum IOControlCode {
    AsyncIO = 2147772029,
    NonBlockingIO = 2147772030,
    DataToRead = 1074030207,
    OobDataRead = 1074033415,
    AssociateHandle = 2281701377,
    EnableCircularQueuing = 671088642,
    Flush = 671088644,
    GetBroadcastAddress = 1207959557,
    GetExtensionFunctionPointer = 3355443206,
    GetQos = 3355443207,
    GetGroupQos = 3355443208,
    MultipointLoopback = 2281701385,
    MulticastScope = 2281701386,
    SetQos = 2281701387,
    SetGroupQos = 2281701388,
    TranslateHandle = 3355443213,
    RoutingInterfaceQuery = 3355443220,
    RoutingInterfaceChange = 2281701397,
    AddressListQuery = 1207959574,
    AddressListChange = 671088663,
    QueryTargetPnpHandle = 1207959576,
    NamespaceChange = 2281701401,
    AddressListSort = 3355443225,
    ReceiveAll = 2550136833,
    ReceiveAllMulticast = 2550136834,
    ReceiveAllIgmpMulticast = 2550136835,
    KeepAliveValues = 2550136836,
    AbsorbRouterAlert = 2550136837,
    UnicastInterface = 2550136838,
    LimitBroadcasts = 2550136839,
    BindToInterface = 2550136840,
    MulticastInterface = 2550136841,
    AddMulticastGroupOnInterface = 2550136842,
    DeleteMulticastGroupFromInterface = 2550136843
}


export enum IPProtectionLevel {
    Unspecified = -1,
    Unrestricted = 10,
    EdgeRestricted = 20,
    Restricted = 30
}


export enum ProtocolFamily {
    Unknown = -1,
    Unspecified = 0,
    Unix = 1,
    InterNetwork = 2,
    ImpLink = 3,
    Pup = 4,
    Chaos = 5,
    NS = 6,
    Ipx = 6,
    Iso = 7,
    Osi = 7,
    Ecma = 8,
    DataKit = 9,
    Ccitt = 10,
    Sna = 11,
    DecNet = 12,
    DataLink = 13,
    Lat = 14,
    HyperChannel = 15,
    AppleTalk = 16,
    NetBios = 17,
    VoiceView = 18,
    FireFox = 19,
    Banyan = 21,
    Atm = 22,
    InterNetworkV6 = 23,
    Cluster = 24,
    Ieee12844 = 25,
    Irda = 26,
    NetworkDesigners = 28,
    Max = 29,
    Packet = 65536,
    ControllerAreaNetwork = 65537
}


export enum ProtocolType {
    IP = 0,
    IPv6HopByHopOptions = 0,
    Icmp = 1,
    Igmp = 2,
    Ggp = 3,
    IPv4 = 4,
    Tcp = 6,
    Pup = 12,
    Udp = 17,
    Idp = 22,
    IPv6 = 41,
    IPv6RoutingHeader = 43,
    IPv6FragmentHeader = 44,
    IPSecEncapsulatingSecurityPayload = 50,
    IPSecAuthenticationHeader = 51,
    IcmpV6 = 58,
    IPv6NoNextHeader = 59,
    IPv6DestinationOptions = 60,
    ND = 77,
    Raw = 255,
    Unspecified = 0,
    Ipx = 1000,
    Spx = 1256,
    SpxII = 1257,
    Unknown = -1
}


export enum SelectMode {
    SelectRead = 0,
    SelectWrite = 1,
    SelectError = 2
}


export enum SocketAsyncOperation {
    None = 0,
    Accept = 1,
    Connect = 2,
    Disconnect = 3,
    Receive = 4,
    ReceiveFrom = 5,
    ReceiveMessageFrom = 6,
    Send = 7,
    SendPackets = 8,
    SendTo = 9
}


export enum SocketError {
    Success = 0,
    SocketError = -1,
    Interrupted = 10004,
    AccessDenied = 10013,
    Fault = 10014,
    InvalidArgument = 10022,
    TooManyOpenSockets = 10024,
    WouldBlock = 10035,
    InProgress = 10036,
    AlreadyInProgress = 10037,
    NotSocket = 10038,
    DestinationAddressRequired = 10039,
    MessageSize = 10040,
    ProtocolType = 10041,
    ProtocolOption = 10042,
    ProtocolNotSupported = 10043,
    SocketNotSupported = 10044,
    OperationNotSupported = 10045,
    ProtocolFamilyNotSupported = 10046,
    AddressFamilyNotSupported = 10047,
    AddressAlreadyInUse = 10048,
    AddressNotAvailable = 10049,
    NetworkDown = 10050,
    NetworkUnreachable = 10051,
    NetworkReset = 10052,
    ConnectionAborted = 10053,
    ConnectionReset = 10054,
    NoBufferSpaceAvailable = 10055,
    IsConnected = 10056,
    NotConnected = 10057,
    Shutdown = 10058,
    TimedOut = 10060,
    ConnectionRefused = 10061,
    HostDown = 10064,
    HostUnreachable = 10065,
    ProcessLimit = 10067,
    SystemNotReady = 10091,
    VersionNotSupported = 10092,
    NotInitialized = 10093,
    Disconnecting = 10101,
    TypeNotFound = 10109,
    HostNotFound = 11001,
    TryAgain = 11002,
    NoRecovery = 11003,
    NoData = 11004,
    IOPending = 997,
    OperationAborted = 995
}


export enum SocketFlags {
    None = 0,
    OutOfBand = 1,
    Peek = 2,
    DontRoute = 4,
    Truncated = 256,
    ControlDataTruncated = 512,
    Broadcast = 1024,
    Multicast = 2048,
    Partial = 32768
}


export enum SocketInformationOptions {
    NonBlocking = 1,
    Connected = 2,
    Listening = 4,
    UseOnlyOverlappedIO = 8
}


export enum SocketOptionLevel {
    Socket = 65535,
    IP = 0,
    IPv6 = 41,
    Tcp = 6,
    Udp = 17
}


export enum SocketOptionName {
    Debug = 1,
    AcceptConnection = 2,
    ReuseAddress = 4,
    KeepAlive = 8,
    DontRoute = 16,
    Broadcast = 32,
    UseLoopback = 64,
    Linger = 128,
    OutOfBandInline = 256,
    DontLinger = -129,
    ExclusiveAddressUse = -5,
    SendBuffer = 4097,
    ReceiveBuffer = 4098,
    SendLowWater = 4099,
    ReceiveLowWater = 4100,
    SendTimeout = 4101,
    ReceiveTimeout = 4102,
    Error = 4103,
    Type = 4104,
    ReuseUnicastPort = 12295,
    MaxConnections = 2147483647,
    IPOptions = 1,
    HeaderIncluded = 2,
    TypeOfService = 3,
    IpTimeToLive = 4,
    MulticastInterface = 9,
    MulticastTimeToLive = 10,
    MulticastLoopback = 11,
    AddMembership = 12,
    DropMembership = 13,
    DontFragment = 14,
    AddSourceMembership = 15,
    DropSourceMembership = 16,
    BlockSource = 17,
    UnblockSource = 18,
    PacketInformation = 19,
    HopLimit = 21,
    IPProtectionLevel = 23,
    IPv6Only = 27,
    NoDelay = 1,
    BsdUrgent = 2,
    Expedited = 2,
    FastOpen = 15,
    TcpKeepAliveRetryCount = 16,
    TcpKeepAliveTime = 3,
    TcpKeepAliveInterval = 17,
    NoChecksum = 1,
    ChecksumCoverage = 20,
    UpdateAcceptContext = 28683,
    UpdateConnectContext = 28688
}


export enum SocketShutdown {
    Receive = 0,
    Send = 1,
    Both = 2
}


export enum SocketType {
    Stream = 1,
    Dgram = 2,
    Raw = 3,
    Rdm = 4,
    Seqpacket = 5,
    Unknown = -1
}


export enum TransmitFileOptions {
    UseDefaultWorkerThread = 0,
    Disconnect = 1,
    ReuseSocket = 2,
    WriteBehind = 4,
    UseSystemThread = 16,
    UseKernelApc = 32
}


export interface IPPacketInformation$instance {
    readonly Address: IPAddress;
    readonly Interface: int;
    Equals(comparand: unknown): boolean;
    Equals(other: IPPacketInformation): boolean;
    GetHashCode(): int;
}


export const IPPacketInformation: {
    new(): IPPacketInformation$instance;
};


export interface __IPPacketInformation$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<IPPacketInformation>;

    // Structural method bridges for numeric interface constraints
    equals(other: IPPacketInformation): boolean;
}

export type IPPacketInformation = IPPacketInformation$instance & __IPPacketInformation$views;


export interface SocketInformation$instance {
    Options: SocketInformationOptions;
    ProtocolInformation: byte[];
}


export const SocketInformation: {
    new(): SocketInformation$instance;
};


export type SocketInformation = SocketInformation$instance;

export interface SocketReceiveFromResult$instance {
    ReceivedBytes: int;
    RemoteEndPoint: EndPoint;
}


export const SocketReceiveFromResult: {
    new(): SocketReceiveFromResult$instance;
};


export type SocketReceiveFromResult = SocketReceiveFromResult$instance;

export interface SocketReceiveMessageFromResult$instance {
    ReceivedBytes: int;
    SocketFlags: SocketFlags;
    RemoteEndPoint: EndPoint;
    PacketInformation: IPPacketInformation;
}


export const SocketReceiveMessageFromResult: {
    new(): SocketReceiveMessageFromResult$instance;
};


export type SocketReceiveMessageFromResult = SocketReceiveMessageFromResult$instance;

export interface UdpReceiveResult$instance {
    readonly Buffer: byte[];
    readonly RemoteEndPoint: IPEndPoint;
    Equals(obj: unknown): boolean;
    Equals(other: UdpReceiveResult): boolean;
    GetHashCode(): int;
}


export const UdpReceiveResult: {
    new(buffer: byte[], remoteEndPoint: IPEndPoint): UdpReceiveResult$instance;
};


export interface __UdpReceiveResult$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<UdpReceiveResult>;

    // Structural method bridges for numeric interface constraints
    equals(other: UdpReceiveResult): boolean;
}

export type UdpReceiveResult = UdpReceiveResult$instance & __UdpReceiveResult$views;


export interface IPv6MulticastOption$instance {
    Group: IPAddress;
    InterfaceIndex: long;
}


export const IPv6MulticastOption: {
    new(group: IPAddress, ifindex: long): IPv6MulticastOption$instance;
    new(group: IPAddress): IPv6MulticastOption$instance;
};


export type IPv6MulticastOption = IPv6MulticastOption$instance;

export interface LingerOption$instance {
    Enabled: boolean;
    LingerTime: int;
    Equals(comparand: unknown): boolean;
    GetHashCode(): int;
}


export const LingerOption: {
    new(enable: boolean, seconds: int): LingerOption$instance;
};


export type LingerOption = LingerOption$instance;

export interface MulticastOption$instance {
    Group: IPAddress;
    InterfaceIndex: int;
    LocalAddress: IPAddress;
}


export const MulticastOption: {
    new(group: IPAddress, mcint: IPAddress): MulticastOption$instance;
    new(group: IPAddress, interfaceIndex: int): MulticastOption$instance;
    new(group: IPAddress): MulticastOption$instance;
};


export type MulticastOption = MulticastOption$instance;

export interface NetworkStream$instance extends Stream {
    readonly CanRead: boolean;
    readonly CanSeek: boolean;
    readonly CanTimeout: boolean;
    readonly CanWrite: boolean;
    readonly DataAvailable: boolean;
    readonly Length: long;
    Position: long;
    ReadTimeout: int;
    readonly Socket: Socket;
    WriteTimeout: int;
    BeginRead(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginWrite(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    Close(timeout: TimeSpan): void;
    Close(): void;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    EndRead(asyncResult: IAsyncResult): int;
    EndWrite(asyncResult: IAsyncResult): void;
    Flush(): void;
    FlushAsync(cancellationToken: CancellationToken): Task;
    FlushAsync(): Task;
    Read(buffer: byte[], offset: int, count: int): int;
    Read(buffer: Span_1<CLROf<byte>>): int;
    Read(buffer: Span_1<CLROf<byte>>): int;
    ReadAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    ReadAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadAsync(buffer: byte[], offset: int, count: int): Task_1<CLROf<int>>;
    ReadAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    ReadAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadByte(): int;
    Seek(offset: long, origin: SeekOrigin): long;
    SetLength(value: long): void;
    Write(buffer: byte[], offset: int, count: int): void;
    Write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    Write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    WriteAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    WriteAsync(buffer: byte[], offset: int, count: int): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    WriteByte(value: byte): void;
}


export const NetworkStream: {
    new(socket: Socket): NetworkStream$instance;
    new(socket: Socket, ownsSocket: boolean): NetworkStream$instance;
    new(socket: Socket, access: FileAccess): NetworkStream$instance;
    new(socket: Socket, access: FileAccess, ownsSocket: boolean): NetworkStream$instance;
};


export interface __NetworkStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type NetworkStream = NetworkStream$instance & __NetworkStream$views;


export interface SafeSocketHandle$instance extends SafeHandleMinusOneIsInvalid {
    readonly IsInvalid: boolean;
    Dispose(): void;
}


export const SafeSocketHandle: {
    new(): SafeSocketHandle$instance;
    new(preexistingHandle: nint, ownsHandle: boolean): SafeSocketHandle$instance;
};


export interface __SafeSocketHandle$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type SafeSocketHandle = SafeSocketHandle$instance & __SafeSocketHandle$views;


export interface SendPacketsElement$instance {
    readonly Buffer: byte[];
    readonly Count: int;
    readonly EndOfPacket: boolean;
    readonly FilePath: string;
    readonly FileStream: FileStream;
    readonly MemoryBuffer: Nullable_1<ReadOnlyMemory_1<CLROf<byte>>>;
    readonly Offset: int;
    readonly OffsetLong: long;
}


export const SendPacketsElement: {
    new(filepath: string): SendPacketsElement$instance;
    new(filepath: string, offset: int, count: int): SendPacketsElement$instance;
    new(filepath: string, offset: int, count: int, endOfPacket: boolean): SendPacketsElement$instance;
    new(filepath: string, offset: long, count: int): SendPacketsElement$instance;
    new(filepath: string, offset: long, count: int, endOfPacket: boolean): SendPacketsElement$instance;
    new(fileStream: FileStream): SendPacketsElement$instance;
    new(fileStream: FileStream, offset: long, count: int): SendPacketsElement$instance;
    new(fileStream: FileStream, offset: long, count: int, endOfPacket: boolean): SendPacketsElement$instance;
    new(buffer: byte[]): SendPacketsElement$instance;
    new(buffer: byte[], offset: int, count: int): SendPacketsElement$instance;
    new(buffer: byte[], offset: int, count: int, endOfPacket: boolean): SendPacketsElement$instance;
    new(buffer: ReadOnlyMemory_1<CLROf<byte>>): SendPacketsElement$instance;
    new(buffer: ReadOnlyMemory_1<CLROf<byte>>, endOfPacket: boolean): SendPacketsElement$instance;
};


export type SendPacketsElement = SendPacketsElement$instance;

export interface Socket$instance {
    readonly AddressFamily: AddressFamily;
    readonly Available: int;
    Blocking: boolean;
    readonly Connected: boolean;
    DontFragment: boolean;
    DualMode: boolean;
    EnableBroadcast: boolean;
    ExclusiveAddressUse: boolean;
    readonly Handle: nint;
    readonly IsBound: boolean;
    LingerState: LingerOption;
    readonly LocalEndPoint: EndPoint;
    MulticastLoopback: boolean;
    NoDelay: boolean;
    readonly ProtocolType: ProtocolType;
    ReceiveBufferSize: int;
    ReceiveTimeout: int;
    readonly RemoteEndPoint: EndPoint;
    readonly SafeHandle: SafeSocketHandle;
    SendBufferSize: int;
    SendTimeout: int;
    readonly SocketType: SocketType;
    Ttl: short;
    UseOnlyOverlappedIO: boolean;
    Accept(): Socket;
    AcceptAsync(e: SocketAsyncEventArgs): boolean;
    AcceptAsync(): Task_1<Socket>;
    AcceptAsync(cancellationToken: CancellationToken): ValueTask_1<Socket>;
    AcceptAsync(acceptSocket: Socket): Task_1<Socket>;
    AcceptAsync(acceptSocket: Socket, cancellationToken: CancellationToken): ValueTask_1<Socket>;
    BeginAccept(callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginAccept(receiveSize: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginAccept(acceptSocket: Socket, receiveSize: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginConnect(remoteEP: EndPoint, callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginConnect(host: string, port: int, requestCallback: AsyncCallback, state: unknown): IAsyncResult;
    BeginConnect(address: IPAddress, port: int, requestCallback: AsyncCallback, state: unknown): IAsyncResult;
    BeginConnect(addresses: IPAddress[], port: int, requestCallback: AsyncCallback, state: unknown): IAsyncResult;
    BeginDisconnect(reuseSocket: boolean, callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginReceive(buffer: byte[], offset: int, size: int, socketFlags: SocketFlags, callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginReceive(buffer: byte[], offset: int, size: int, socketFlags: SocketFlags, errorCode: { value: ref<SocketError> }, callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginReceive(buffers: IList_1<ArraySegment_1<CLROf<byte>>>, socketFlags: SocketFlags, callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginReceive(buffers: IList_1<ArraySegment_1<CLROf<byte>>>, socketFlags: SocketFlags, errorCode: { value: ref<SocketError> }, callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginReceiveFrom(buffer: byte[], offset: int, size: int, socketFlags: SocketFlags, remoteEP: { value: ref<EndPoint> }, callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginReceiveMessageFrom(buffer: byte[], offset: int, size: int, socketFlags: SocketFlags, remoteEP: { value: ref<EndPoint> }, callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginSend(buffer: byte[], offset: int, size: int, socketFlags: SocketFlags, callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginSend(buffer: byte[], offset: int, size: int, socketFlags: SocketFlags, errorCode: { value: ref<SocketError> }, callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginSend(buffers: IList_1<ArraySegment_1<CLROf<byte>>>, socketFlags: SocketFlags, callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginSend(buffers: IList_1<ArraySegment_1<CLROf<byte>>>, socketFlags: SocketFlags, errorCode: { value: ref<SocketError> }, callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginSendFile(fileName: string, callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginSendFile(fileName: string, preBuffer: byte[], postBuffer: byte[], flags: TransmitFileOptions, callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginSendTo(buffer: byte[], offset: int, size: int, socketFlags: SocketFlags, remoteEP: EndPoint, callback: AsyncCallback, state: unknown): IAsyncResult;
    Bind(localEP: EndPoint): void;
    Close(): void;
    Close(timeout: int): void;
    Connect(remoteEP: EndPoint): void;
    Connect(address: IPAddress, port: int): void;
    Connect(host: string, port: int): void;
    Connect(addresses: IPAddress[], port: int): void;
    ConnectAsync(e: SocketAsyncEventArgs): boolean;
    ConnectAsync(remoteEP: EndPoint): Task;
    ConnectAsync(remoteEP: EndPoint, cancellationToken: CancellationToken): ValueTask;
    ConnectAsync(address: IPAddress, port: int): Task;
    ConnectAsync(address: IPAddress, port: int, cancellationToken: CancellationToken): ValueTask;
    ConnectAsync(addresses: IPAddress[], port: int): Task;
    ConnectAsync(addresses: IPAddress[], port: int, cancellationToken: CancellationToken): ValueTask;
    ConnectAsync(host: string, port: int): Task;
    ConnectAsync(host: string, port: int, cancellationToken: CancellationToken): ValueTask;
    Disconnect(reuseSocket: boolean): void;
    DisconnectAsync(e: SocketAsyncEventArgs): boolean;
    DisconnectAsync(reuseSocket: boolean, cancellationToken?: CancellationToken): ValueTask;
    Dispose(): void;
    DuplicateAndClose(targetProcessId: int): SocketInformation;
    EndAccept(asyncResult: IAsyncResult): Socket;
    EndAccept(buffer: { value: ref<byte[]> }, asyncResult: IAsyncResult): Socket;
    EndAccept(buffer: { value: ref<byte[]> }, bytesTransferred: { value: ref<int> }, asyncResult: IAsyncResult): Socket;
    EndConnect(asyncResult: IAsyncResult): void;
    EndDisconnect(asyncResult: IAsyncResult): void;
    EndReceive(asyncResult: IAsyncResult): int;
    EndReceive(asyncResult: IAsyncResult, errorCode: { value: ref<SocketError> }): int;
    EndReceiveFrom(asyncResult: IAsyncResult, endPoint: { value: ref<EndPoint> }): int;
    EndReceiveMessageFrom(asyncResult: IAsyncResult, socketFlags: { value: ref<SocketFlags> }, endPoint: { value: ref<EndPoint> }, ipPacketInformation: { value: ref<IPPacketInformation> }): int;
    EndSend(asyncResult: IAsyncResult): int;
    EndSend(asyncResult: IAsyncResult, errorCode: { value: ref<SocketError> }): int;
    EndSendFile(asyncResult: IAsyncResult): void;
    EndSendTo(asyncResult: IAsyncResult): int;
    GetRawSocketOption(optionLevel: int, optionName: int, optionValue: Span_1<CLROf<byte>>): int;
    GetSocketOption(optionLevel: SocketOptionLevel, optionName: SocketOptionName): unknown;
    GetSocketOption(optionLevel: SocketOptionLevel, optionName: SocketOptionName, optionValue: byte[]): void;
    GetSocketOption(optionLevel: SocketOptionLevel, optionName: SocketOptionName, optionLength: int): byte[];
    IOControl(ioControlCode: int, optionInValue: byte[], optionOutValue: byte[]): int;
    IOControl(ioControlCode: IOControlCode, optionInValue: byte[], optionOutValue: byte[]): int;
    Listen(): void;
    Listen(backlog: int): void;
    Poll(microSeconds: int, mode: SelectMode): boolean;
    Poll(timeout: TimeSpan, mode: SelectMode): boolean;
    Receive(buffer: byte[], size: int, socketFlags: SocketFlags): int;
    Receive(buffer: byte[], socketFlags: SocketFlags): int;
    Receive(buffer: byte[]): int;
    Receive(buffer: byte[], offset: int, size: int, socketFlags: SocketFlags): int;
    Receive(buffer: byte[], offset: int, size: int, socketFlags: SocketFlags, errorCode: { value: ref<SocketError> }): int;
    Receive(buffer: Span_1<CLROf<byte>>): int;
    Receive(buffer: Span_1<CLROf<byte>>, socketFlags: SocketFlags): int;
    Receive(buffer: Span_1<CLROf<byte>>, socketFlags: SocketFlags, errorCode: { value: ref<SocketError> }): int;
    Receive(buffers: IList_1<ArraySegment_1<CLROf<byte>>>): int;
    Receive(buffers: IList_1<ArraySegment_1<CLROf<byte>>>, socketFlags: SocketFlags): int;
    Receive(buffers: IList_1<ArraySegment_1<CLROf<byte>>>, socketFlags: SocketFlags, errorCode: { value: ref<SocketError> }): int;
    ReceiveAsync(e: SocketAsyncEventArgs): boolean;
    ReceiveAsync(buffer: ArraySegment_1<CLROf<byte>>): Task_1<CLROf<int>>;
    ReceiveAsync(buffer: ArraySegment_1<CLROf<byte>>, socketFlags: SocketFlags): Task_1<CLROf<int>>;
    ReceiveAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReceiveAsync(buffer: Memory_1<CLROf<byte>>, socketFlags: SocketFlags, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReceiveAsync(buffers: IList_1<ArraySegment_1<CLROf<byte>>>): Task_1<CLROf<int>>;
    ReceiveAsync(buffers: IList_1<ArraySegment_1<CLROf<byte>>>, socketFlags: SocketFlags): Task_1<CLROf<int>>;
    ReceiveFrom(buffer: byte[], offset: int, size: int, socketFlags: SocketFlags, remoteEP: { value: ref<EndPoint> }): int;
    ReceiveFrom(buffer: byte[], size: int, socketFlags: SocketFlags, remoteEP: { value: ref<EndPoint> }): int;
    ReceiveFrom(buffer: byte[], socketFlags: SocketFlags, remoteEP: { value: ref<EndPoint> }): int;
    ReceiveFrom(buffer: byte[], remoteEP: { value: ref<EndPoint> }): int;
    ReceiveFrom(buffer: Span_1<CLROf<byte>>, remoteEP: { value: ref<EndPoint> }): int;
    ReceiveFrom(buffer: Span_1<CLROf<byte>>, socketFlags: SocketFlags, remoteEP: { value: ref<EndPoint> }): int;
    ReceiveFrom(buffer: Span_1<CLROf<byte>>, socketFlags: SocketFlags, receivedAddress: SocketAddress): int;
    ReceiveFromAsync(e: SocketAsyncEventArgs): boolean;
    ReceiveFromAsync(buffer: ArraySegment_1<CLROf<byte>>, remoteEndPoint: EndPoint): Task_1<SocketReceiveFromResult>;
    ReceiveFromAsync(buffer: ArraySegment_1<CLROf<byte>>, socketFlags: SocketFlags, remoteEndPoint: EndPoint): Task_1<SocketReceiveFromResult>;
    ReceiveFromAsync(buffer: Memory_1<CLROf<byte>>, remoteEndPoint: EndPoint, cancellationToken?: CancellationToken): ValueTask_1<SocketReceiveFromResult>;
    ReceiveFromAsync(buffer: Memory_1<CLROf<byte>>, socketFlags: SocketFlags, remoteEndPoint: EndPoint, cancellationToken?: CancellationToken): ValueTask_1<SocketReceiveFromResult>;
    ReceiveFromAsync(buffer: Memory_1<CLROf<byte>>, socketFlags: SocketFlags, receivedAddress: SocketAddress, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReceiveMessageFrom(buffer: byte[], offset: int, size: int, socketFlags: { value: ref<SocketFlags> }, remoteEP: { value: ref<EndPoint> }, ipPacketInformation: { value: ref<IPPacketInformation> }): int;
    ReceiveMessageFrom(buffer: Span_1<CLROf<byte>>, socketFlags: { value: ref<SocketFlags> }, remoteEP: { value: ref<EndPoint> }, ipPacketInformation: { value: ref<IPPacketInformation> }): int;
    ReceiveMessageFromAsync(e: SocketAsyncEventArgs): boolean;
    ReceiveMessageFromAsync(buffer: ArraySegment_1<CLROf<byte>>, remoteEndPoint: EndPoint): Task_1<SocketReceiveMessageFromResult>;
    ReceiveMessageFromAsync(buffer: ArraySegment_1<CLROf<byte>>, socketFlags: SocketFlags, remoteEndPoint: EndPoint): Task_1<SocketReceiveMessageFromResult>;
    ReceiveMessageFromAsync(buffer: Memory_1<CLROf<byte>>, remoteEndPoint: EndPoint, cancellationToken?: CancellationToken): ValueTask_1<SocketReceiveMessageFromResult>;
    ReceiveMessageFromAsync(buffer: Memory_1<CLROf<byte>>, socketFlags: SocketFlags, remoteEndPoint: EndPoint, cancellationToken?: CancellationToken): ValueTask_1<SocketReceiveMessageFromResult>;
    Send(buffer: byte[], size: int, socketFlags: SocketFlags): int;
    Send(buffer: byte[], socketFlags: SocketFlags): int;
    Send(buffer: byte[]): int;
    Send(buffers: IList_1<ArraySegment_1<CLROf<byte>>>): int;
    Send(buffers: IList_1<ArraySegment_1<CLROf<byte>>>, socketFlags: SocketFlags): int;
    Send(buffers: IList_1<ArraySegment_1<CLROf<byte>>>, socketFlags: SocketFlags, errorCode: { value: ref<SocketError> }): int;
    Send(buffer: byte[], offset: int, size: int, socketFlags: SocketFlags): int;
    Send(buffer: byte[], offset: int, size: int, socketFlags: SocketFlags, errorCode: { value: ref<SocketError> }): int;
    Send(buffer: ReadOnlySpan_1<CLROf<byte>>): int;
    Send(buffer: ReadOnlySpan_1<CLROf<byte>>, socketFlags: SocketFlags): int;
    Send(buffer: ReadOnlySpan_1<CLROf<byte>>, socketFlags: SocketFlags, errorCode: { value: ref<SocketError> }): int;
    SendAsync(e: SocketAsyncEventArgs): boolean;
    SendAsync(buffer: ArraySegment_1<CLROf<byte>>): Task_1<CLROf<int>>;
    SendAsync(buffer: ArraySegment_1<CLROf<byte>>, socketFlags: SocketFlags): Task_1<CLROf<int>>;
    SendAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    SendAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, socketFlags: SocketFlags, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    SendAsync(buffers: IList_1<ArraySegment_1<CLROf<byte>>>): Task_1<CLROf<int>>;
    SendAsync(buffers: IList_1<ArraySegment_1<CLROf<byte>>>, socketFlags: SocketFlags): Task_1<CLROf<int>>;
    SendFile(fileName: string): void;
    SendFile(fileName: string, preBuffer: byte[], postBuffer: byte[], flags: TransmitFileOptions): void;
    SendFile(fileName: string, preBuffer: ReadOnlySpan_1<CLROf<byte>>, postBuffer: ReadOnlySpan_1<CLROf<byte>>, flags: TransmitFileOptions): void;
    SendFileAsync(fileName: string, cancellationToken?: CancellationToken): ValueTask;
    SendFileAsync(fileName: string, preBuffer: ReadOnlyMemory_1<CLROf<byte>>, postBuffer: ReadOnlyMemory_1<CLROf<byte>>, flags: TransmitFileOptions, cancellationToken?: CancellationToken): ValueTask;
    SendPacketsAsync(e: SocketAsyncEventArgs): boolean;
    SendTo(buffer: byte[], offset: int, size: int, socketFlags: SocketFlags, remoteEP: EndPoint): int;
    SendTo(buffer: byte[], size: int, socketFlags: SocketFlags, remoteEP: EndPoint): int;
    SendTo(buffer: byte[], socketFlags: SocketFlags, remoteEP: EndPoint): int;
    SendTo(buffer: byte[], remoteEP: EndPoint): int;
    SendTo(buffer: ReadOnlySpan_1<CLROf<byte>>, remoteEP: EndPoint): int;
    SendTo(buffer: ReadOnlySpan_1<CLROf<byte>>, socketFlags: SocketFlags, remoteEP: EndPoint): int;
    SendTo(buffer: ReadOnlySpan_1<CLROf<byte>>, socketFlags: SocketFlags, socketAddress: SocketAddress): int;
    SendToAsync(e: SocketAsyncEventArgs): boolean;
    SendToAsync(buffer: ArraySegment_1<CLROf<byte>>, remoteEP: EndPoint): Task_1<CLROf<int>>;
    SendToAsync(buffer: ArraySegment_1<CLROf<byte>>, socketFlags: SocketFlags, remoteEP: EndPoint): Task_1<CLROf<int>>;
    SendToAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, remoteEP: EndPoint, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    SendToAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, socketFlags: SocketFlags, remoteEP: EndPoint, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    SendToAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, socketFlags: SocketFlags, socketAddress: SocketAddress, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    SetIPProtectionLevel(level: IPProtectionLevel): void;
    SetRawSocketOption(optionLevel: int, optionName: int, optionValue: ReadOnlySpan_1<CLROf<byte>>): void;
    SetSocketOption(optionLevel: SocketOptionLevel, optionName: SocketOptionName, optionValue: int): void;
    SetSocketOption(optionLevel: SocketOptionLevel, optionName: SocketOptionName, optionValue: byte[]): void;
    SetSocketOption(optionLevel: SocketOptionLevel, optionName: SocketOptionName, optionValue: boolean): void;
    SetSocketOption(optionLevel: SocketOptionLevel, optionName: SocketOptionName, optionValue: unknown): void;
    Shutdown(how: SocketShutdown): void;
}


export const Socket: {
    new(socketType: SocketType, protocolType: ProtocolType): Socket$instance;
    new(addressFamily: AddressFamily, socketType: SocketType, protocolType: ProtocolType): Socket$instance;
    new(handle: SafeSocketHandle): Socket$instance;
    new(socketInformation: SocketInformation): Socket$instance;
    readonly SupportsIPv4: boolean;
    readonly SupportsIPv6: boolean;
    readonly OSSupportsIPv4: boolean;
    readonly OSSupportsIPv6: boolean;
    readonly OSSupportsUnixDomainSockets: boolean;
    CancelConnectAsync(e: SocketAsyncEventArgs): void;
    ConnectAsync(socketType: SocketType, protocolType: ProtocolType, e: SocketAsyncEventArgs): boolean;
    Select(checkRead: IList, checkWrite: IList, checkError: IList, microSeconds: int): void;
    Select(checkRead: IList, checkWrite: IList, checkError: IList, timeout: TimeSpan): void;
};


export interface __Socket$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Socket$instance extends System_Internal.IDisposable$instance {}

export type Socket = Socket$instance & __Socket$views;


export interface SocketAsyncEventArgs$instance extends EventArgs {
    AcceptSocket: Socket;
    readonly Buffer: byte[];
    BufferList: IList_1<ArraySegment_1<CLROf<byte>>>;
    readonly BytesTransferred: int;
    readonly ConnectByNameError: Exception;
    readonly ConnectSocket: Socket;
    readonly Count: int;
    DisconnectReuseSocket: boolean;
    readonly LastOperation: SocketAsyncOperation;
    readonly MemoryBuffer: Memory_1<CLROf<byte>>;
    readonly Offset: int;
    readonly ReceiveMessageFromPacketInfo: IPPacketInformation;
    RemoteEndPoint: EndPoint;
    SendPacketsElements: SendPacketsElement[];
    SendPacketsFlags: TransmitFileOptions;
    SendPacketsSendSize: int;
    SocketError: SocketError;
    SocketFlags: SocketFlags;
    UserToken: unknown;
    Dispose(): void;
    SetBuffer(offset: int, count: int): void;
    SetBuffer(buffer: byte[], offset: int, count: int): void;
    SetBuffer(buffer: Memory_1<CLROf<byte>>): void;
}


export const SocketAsyncEventArgs: {
    new(): SocketAsyncEventArgs$instance;
    new(unsafeSuppressExecutionContextFlow: boolean): SocketAsyncEventArgs$instance;
};


export interface __SocketAsyncEventArgs$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface SocketAsyncEventArgs$instance extends System_Internal.IDisposable$instance {}

export type SocketAsyncEventArgs = SocketAsyncEventArgs$instance & __SocketAsyncEventArgs$views;


export interface SocketException$instance extends Win32Exception {
    readonly ErrorCode: int;
    readonly Message: string;
    readonly SocketErrorCode: SocketError;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SocketException: {
    new(errorCode: int): SocketException$instance;
    new(errorCode: int, message: string): SocketException$instance;
    new(): SocketException$instance;
};


export interface __SocketException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SocketException = SocketException$instance & __SocketException$views;


export interface TcpClient$instance {
    readonly Available: int;
    Client: Socket;
    readonly Connected: boolean;
    ExclusiveAddressUse: boolean;
    LingerState: LingerOption;
    NoDelay: boolean;
    ReceiveBufferSize: int;
    ReceiveTimeout: int;
    SendBufferSize: int;
    SendTimeout: int;
    BeginConnect(address: IPAddress, port: int, requestCallback: AsyncCallback, state: unknown): IAsyncResult;
    BeginConnect(host: string, port: int, requestCallback: AsyncCallback, state: unknown): IAsyncResult;
    BeginConnect(addresses: IPAddress[], port: int, requestCallback: AsyncCallback, state: unknown): IAsyncResult;
    Close(): void;
    Connect(hostname: string, port: int): void;
    Connect(address: IPAddress, port: int): void;
    Connect(remoteEP: IPEndPoint): void;
    Connect(ipAddresses: IPAddress[], port: int): void;
    ConnectAsync(address: IPAddress, port: int): Task;
    ConnectAsync(host: string, port: int): Task;
    ConnectAsync(addresses: IPAddress[], port: int): Task;
    ConnectAsync(remoteEP: IPEndPoint): Task;
    ConnectAsync(address: IPAddress, port: int, cancellationToken: CancellationToken): ValueTask;
    ConnectAsync(host: string, port: int, cancellationToken: CancellationToken): ValueTask;
    ConnectAsync(addresses: IPAddress[], port: int, cancellationToken: CancellationToken): ValueTask;
    ConnectAsync(remoteEP: IPEndPoint, cancellationToken: CancellationToken): ValueTask;
    Dispose(): void;
    EndConnect(asyncResult: IAsyncResult): void;
    GetStream(): NetworkStream;
}


export const TcpClient: {
    new(): TcpClient$instance;
    new(family: AddressFamily): TcpClient$instance;
    new(localEP: IPEndPoint): TcpClient$instance;
    new(hostname: string, port: int): TcpClient$instance;
};


export interface __TcpClient$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface TcpClient$instance extends System_Internal.IDisposable$instance {}

export type TcpClient = TcpClient$instance & __TcpClient$views;


export interface TcpListener$instance {
    ExclusiveAddressUse: boolean;
    readonly LocalEndpoint: EndPoint;
    readonly Server: Socket;
    AcceptSocket(): Socket;
    AcceptSocketAsync(): Task_1<Socket>;
    AcceptSocketAsync(cancellationToken: CancellationToken): ValueTask_1<Socket>;
    AcceptTcpClient(): TcpClient;
    AcceptTcpClientAsync(): Task_1<TcpClient>;
    AcceptTcpClientAsync(cancellationToken: CancellationToken): ValueTask_1<TcpClient>;
    AllowNatTraversal(allowed: boolean): void;
    BeginAcceptSocket(callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginAcceptTcpClient(callback: AsyncCallback, state: unknown): IAsyncResult;
    Dispose(): void;
    EndAcceptSocket(asyncResult: IAsyncResult): Socket;
    EndAcceptTcpClient(asyncResult: IAsyncResult): TcpClient;
    Pending(): boolean;
    Start(): void;
    Start(backlog: int): void;
    Stop(): void;
}


export const TcpListener: {
    new(localEP: IPEndPoint): TcpListener$instance;
    new(localaddr: IPAddress, port: int): TcpListener$instance;
    new(port: int): TcpListener$instance;
    Create(port: int): TcpListener;
};


export interface __TcpListener$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface TcpListener$instance extends System_Internal.IDisposable$instance {}

export type TcpListener = TcpListener$instance & __TcpListener$views;


export interface UdpClient$instance {
    readonly Available: int;
    Client: Socket;
    DontFragment: boolean;
    EnableBroadcast: boolean;
    ExclusiveAddressUse: boolean;
    MulticastLoopback: boolean;
    Ttl: short;
    AllowNatTraversal(allowed: boolean): void;
    BeginReceive(requestCallback: AsyncCallback, state: unknown): IAsyncResult;
    BeginSend(datagram: byte[], bytes: int, requestCallback: AsyncCallback, state: unknown): IAsyncResult;
    BeginSend(datagram: byte[], bytes: int, hostname: string, port: int, requestCallback: AsyncCallback, state: unknown): IAsyncResult;
    BeginSend(datagram: byte[], bytes: int, endPoint: IPEndPoint, requestCallback: AsyncCallback, state: unknown): IAsyncResult;
    Close(): void;
    Connect(hostname: string, port: int): void;
    Connect(addr: IPAddress, port: int): void;
    Connect(endPoint: IPEndPoint): void;
    Dispose(): void;
    DropMulticastGroup(multicastAddr: IPAddress): void;
    DropMulticastGroup(multicastAddr: IPAddress, ifindex: int): void;
    EndReceive(asyncResult: IAsyncResult, remoteEP: { value: ref<IPEndPoint> }): byte[];
    EndSend(asyncResult: IAsyncResult): int;
    JoinMulticastGroup(multicastAddr: IPAddress): void;
    JoinMulticastGroup(multicastAddr: IPAddress, localAddress: IPAddress): void;
    JoinMulticastGroup(ifindex: int, multicastAddr: IPAddress): void;
    JoinMulticastGroup(multicastAddr: IPAddress, timeToLive: int): void;
    Receive(remoteEP: { value: ref<IPEndPoint> }): byte[];
    ReceiveAsync(): Task_1<UdpReceiveResult>;
    ReceiveAsync(cancellationToken: CancellationToken): ValueTask_1<UdpReceiveResult>;
    Send(dgram: byte[], bytes: int, endPoint: IPEndPoint): int;
    Send(datagram: ReadOnlySpan_1<CLROf<byte>>, endPoint: IPEndPoint): int;
    Send(dgram: byte[], bytes: int, hostname: string, port: int): int;
    Send(datagram: ReadOnlySpan_1<CLROf<byte>>, hostname: string, port: int): int;
    Send(dgram: byte[], bytes: int): int;
    Send(datagram: ReadOnlySpan_1<CLROf<byte>>): int;
    SendAsync(datagram: byte[], bytes: int): Task_1<CLROf<int>>;
    SendAsync(datagram: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    SendAsync(datagram: byte[], bytes: int, hostname: string, port: int): Task_1<CLROf<int>>;
    SendAsync(datagram: ReadOnlyMemory_1<CLROf<byte>>, hostname: string, port: int, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    SendAsync(datagram: byte[], bytes: int, endPoint: IPEndPoint): Task_1<CLROf<int>>;
    SendAsync(datagram: ReadOnlyMemory_1<CLROf<byte>>, endPoint: IPEndPoint, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
}


export const UdpClient: {
    new(): UdpClient$instance;
    new(family: AddressFamily): UdpClient$instance;
    new(port: int): UdpClient$instance;
    new(port: int, family: AddressFamily): UdpClient$instance;
    new(localEP: IPEndPoint): UdpClient$instance;
    new(hostname: string, port: int): UdpClient$instance;
};


export interface __UdpClient$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface UdpClient$instance extends System_Internal.IDisposable$instance {}

export type UdpClient = UdpClient$instance & __UdpClient$views;


export interface UnixDomainSocketEndPoint$instance extends EndPoint {
    readonly AddressFamily: AddressFamily;
    Create(socketAddress: SocketAddress): EndPoint;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    Serialize(): SocketAddress;
    ToString(): string;
}


export const UnixDomainSocketEndPoint: {
    new(path: string): UnixDomainSocketEndPoint$instance;
};


export type UnixDomainSocketEndPoint = UnixDomainSocketEndPoint$instance;

export abstract class SocketTaskExtensions$instance {
    static AcceptAsync(socket: Socket, acceptSocket: Socket): Task_1<Socket>;
    static AcceptAsync(socket: Socket): Task_1<Socket>;
    static ConnectAsync(socket: Socket, remoteEP: EndPoint, cancellationToken: CancellationToken): ValueTask;
    static ConnectAsync(socket: Socket, remoteEP: EndPoint): Task;
    static ConnectAsync(socket: Socket, address: IPAddress, port: int, cancellationToken: CancellationToken): ValueTask;
    static ConnectAsync(socket: Socket, address: IPAddress, port: int): Task;
    static ConnectAsync(socket: Socket, addresses: IPAddress[], port: int, cancellationToken: CancellationToken): ValueTask;
    static ConnectAsync(socket: Socket, addresses: IPAddress[], port: int): Task;
    static ConnectAsync(socket: Socket, host: string, port: int, cancellationToken: CancellationToken): ValueTask;
    static ConnectAsync(socket: Socket, host: string, port: int): Task;
    static ReceiveAsync(socket: Socket, buffer: ArraySegment_1<CLROf<byte>>, socketFlags: SocketFlags): Task_1<CLROf<int>>;
    static ReceiveAsync(socket: Socket, buffers: IList_1<ArraySegment_1<CLROf<byte>>>, socketFlags: SocketFlags): Task_1<CLROf<int>>;
    static ReceiveAsync(socket: Socket, buffer: Memory_1<CLROf<byte>>, socketFlags: SocketFlags, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static ReceiveFromAsync(socket: Socket, buffer: ArraySegment_1<CLROf<byte>>, socketFlags: SocketFlags, remoteEndPoint: EndPoint): Task_1<SocketReceiveFromResult>;
    static ReceiveMessageFromAsync(socket: Socket, buffer: ArraySegment_1<CLROf<byte>>, socketFlags: SocketFlags, remoteEndPoint: EndPoint): Task_1<SocketReceiveMessageFromResult>;
    static SendAsync(socket: Socket, buffer: ArraySegment_1<CLROf<byte>>, socketFlags: SocketFlags): Task_1<CLROf<int>>;
    static SendAsync(socket: Socket, buffers: IList_1<ArraySegment_1<CLROf<byte>>>, socketFlags: SocketFlags): Task_1<CLROf<int>>;
    static SendAsync(socket: Socket, buffer: ReadOnlyMemory_1<CLROf<byte>>, socketFlags: SocketFlags, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static SendToAsync(socket: Socket, buffer: ArraySegment_1<CLROf<byte>>, socketFlags: SocketFlags, remoteEP: EndPoint): Task_1<CLROf<int>>;
}


export type SocketTaskExtensions = SocketTaskExtensions$instance;


// Generated by tsbindgen - Architecture
// Namespace: System.Numerics
// Assembly: System.Private.CoreLib, System.Runtime.Numerics

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { IComparer_1, IEqualityComparer_1 } from "../../System.Collections.Generic/internal/index.js";
import type { NumberStyles } from "../../System.Globalization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Byte, Char, Decimal, Double, IComparable, IComparable_1, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, IParsable_1, ISpanFormattable, ISpanParsable_1, IUtf8SpanFormattable, IUtf8SpanParsable_1, MidpointRounding, Object as ClrObject, ReadOnlySpan_1, SByte, Single, Span_1, String as ClrString, Type, UInt16, UInt32, UInt64, UIntPtr, ValueTuple_2, ValueType, Void } from "../../System/internal/index.js";

export interface IAdditionOperators_3$instance<TSelf extends IAdditionOperators_3<TSelf, TOther, TResult>, TOther, TResult> {
}


export type IAdditionOperators_3<TSelf extends IAdditionOperators_3<TSelf, TOther, TResult>, TOther, TResult> = IAdditionOperators_3$instance<TSelf, TOther, TResult>;

export interface IAdditiveIdentity_2$instance<TSelf extends IAdditiveIdentity_2<TSelf, TResult>, TResult> {
}


export type IAdditiveIdentity_2<TSelf extends IAdditiveIdentity_2<TSelf, TResult>, TResult> = IAdditiveIdentity_2$instance<TSelf, TResult>;

export interface IBinaryFloatingPointIeee754_1$instance<TSelf extends IBinaryFloatingPointIeee754_1<TSelf>> extends IBinaryNumber_1<TSelf>, IBitwiseOperators_3<TSelf, TSelf, TSelf>, INumber_1<TSelf>, IComparable, IComparable_1<TSelf>, IComparisonOperators_3<TSelf, TSelf, System_Internal.Boolean>, IEqualityOperators_3<TSelf, TSelf, System_Internal.Boolean>, IModulusOperators_3<TSelf, TSelf, TSelf>, INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf>, IFloatingPointIeee754_1<TSelf>, IExponentialFunctions_1<TSelf>, IFloatingPointConstants_1<TSelf>, IFloatingPoint_1<TSelf>, ISignedNumber_1<TSelf>, IHyperbolicFunctions_1<TSelf>, ILogarithmicFunctions_1<TSelf>, IPowerFunctions_1<TSelf>, IRootFunctions_1<TSelf>, ITrigonometricFunctions_1<TSelf> {
    CompareTo(obj: unknown | undefined): int;
    CompareTo(other: TSelf): int;
    GetExponentByteCount(): int;
    ToString(format: string | undefined, formatProvider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<System_Internal.Char>, charsWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<System_Internal.Byte>, bytesWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    TryWriteExponentBigEndian(destination: Span_1<System_Internal.Byte>, bytesWritten: int): boolean;
    WriteExponentBigEndian(destination: byte[], startIndex: int): int;
    WriteExponentBigEndian(destination: byte[]): int;
    WriteExponentBigEndian(destination: Span_1<System_Internal.Byte>): int;
    Equals(other: TSelf): boolean;
}


export type IBinaryFloatingPointIeee754_1<TSelf extends IBinaryFloatingPointIeee754_1<TSelf>> = IBinaryFloatingPointIeee754_1$instance<TSelf>;

export interface IBinaryInteger_1$instance<TSelf extends IBinaryInteger_1<TSelf>> extends IBinaryNumber_1<TSelf>, IBitwiseOperators_3<TSelf, TSelf, TSelf>, INumber_1<TSelf>, IComparable, IComparable_1<TSelf>, IComparisonOperators_3<TSelf, TSelf, System_Internal.Boolean>, IEqualityOperators_3<TSelf, TSelf, System_Internal.Boolean>, IModulusOperators_3<TSelf, TSelf, TSelf>, INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf>, IShiftOperators_3<TSelf, System_Internal.Int32, TSelf> {
    CompareTo(obj: unknown | undefined): int;
    CompareTo(other: TSelf): int;
    GetByteCount(): int;
    ToString(format: string | undefined, formatProvider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<System_Internal.Char>, charsWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<System_Internal.Byte>, bytesWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    TryWriteBigEndian(destination: Span_1<System_Internal.Byte>, bytesWritten: int): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<System_Internal.Byte>): int;
    Equals(other: TSelf): boolean;
}


export interface IBinaryInteger_1$instance<TSelf extends IBinaryInteger_1<TSelf>> extends IShiftOperators_3$instance<TSelf, System_Internal.Int32, TSelf> {}

export type IBinaryInteger_1<TSelf extends IBinaryInteger_1<TSelf>> = IBinaryInteger_1$instance<TSelf>;

export interface IBinaryNumber_1$instance<TSelf extends IBinaryNumber_1<TSelf>> extends IBitwiseOperators_3<TSelf, TSelf, TSelf>, INumber_1<TSelf>, IComparable, IComparable_1<TSelf>, IComparisonOperators_3<TSelf, TSelf, System_Internal.Boolean>, IEqualityOperators_3<TSelf, TSelf, System_Internal.Boolean>, IModulusOperators_3<TSelf, TSelf, TSelf>, INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf> {
    CompareTo(obj: unknown | undefined): int;
    CompareTo(other: TSelf): int;
    ToString(format: string | undefined, formatProvider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<System_Internal.Char>, charsWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<System_Internal.Byte>, bytesWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    Equals(other: TSelf): boolean;
}


export interface IBinaryNumber_1$instance<TSelf extends IBinaryNumber_1<TSelf>> extends IBitwiseOperators_3$instance<TSelf, TSelf, TSelf> {}

export type IBinaryNumber_1<TSelf extends IBinaryNumber_1<TSelf>> = IBinaryNumber_1$instance<TSelf>;

export interface IBitwiseOperators_3$instance<TSelf extends IBitwiseOperators_3<TSelf, TOther, TResult>, TOther, TResult> {
}


export type IBitwiseOperators_3<TSelf extends IBitwiseOperators_3<TSelf, TOther, TResult>, TOther, TResult> = IBitwiseOperators_3$instance<TSelf, TOther, TResult>;

export interface IComparisonOperators_3$instance<TSelf extends IComparisonOperators_3<TSelf, TOther, TResult>, TOther, TResult> extends IEqualityOperators_3<TSelf, TOther, TResult> {
}


export interface IComparisonOperators_3$instance<TSelf extends IComparisonOperators_3<TSelf, TOther, TResult>, TOther, TResult> extends IEqualityOperators_3$instance<TSelf, TOther, TResult> {}

export type IComparisonOperators_3<TSelf extends IComparisonOperators_3<TSelf, TOther, TResult>, TOther, TResult> = IComparisonOperators_3$instance<TSelf, TOther, TResult>;

export interface IDecrementOperators_1$instance<TSelf extends IDecrementOperators_1<TSelf>> {
}


export type IDecrementOperators_1<TSelf extends IDecrementOperators_1<TSelf>> = IDecrementOperators_1$instance<TSelf>;

export interface IDivisionOperators_3$instance<TSelf extends IDivisionOperators_3<TSelf, TOther, TResult>, TOther, TResult> {
}


export type IDivisionOperators_3<TSelf extends IDivisionOperators_3<TSelf, TOther, TResult>, TOther, TResult> = IDivisionOperators_3$instance<TSelf, TOther, TResult>;

export interface IEqualityOperators_3$instance<TSelf extends IEqualityOperators_3<TSelf, TOther, TResult>, TOther, TResult> {
}


export type IEqualityOperators_3<TSelf extends IEqualityOperators_3<TSelf, TOther, TResult>, TOther, TResult> = IEqualityOperators_3$instance<TSelf, TOther, TResult>;

export interface IExponentialFunctions_1$instance<TSelf extends IExponentialFunctions_1<TSelf>> extends IFloatingPointConstants_1<TSelf>, INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IEqualityOperators_3<TSelf, TSelf, System_Internal.Boolean>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf> {
    ToString(format: string | undefined, formatProvider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<System_Internal.Char>, charsWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<System_Internal.Byte>, bytesWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    Equals(other: TSelf): boolean;
}


export type IExponentialFunctions_1<TSelf extends IExponentialFunctions_1<TSelf>> = IExponentialFunctions_1$instance<TSelf>;

export interface IFloatingPoint_1$instance<TSelf extends IFloatingPoint_1<TSelf>> extends IFloatingPointConstants_1<TSelf>, INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IEqualityOperators_3<TSelf, TSelf, System_Internal.Boolean>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf>, INumber_1<TSelf>, IComparable, IComparable_1<TSelf>, IComparisonOperators_3<TSelf, TSelf, System_Internal.Boolean>, IModulusOperators_3<TSelf, TSelf, TSelf>, ISignedNumber_1<TSelf> {
    CompareTo(obj: unknown | undefined): int;
    CompareTo(other: TSelf): int;
    GetExponentByteCount(): int;
    ToString(format: string | undefined, formatProvider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<System_Internal.Char>, charsWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<System_Internal.Byte>, bytesWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    TryWriteExponentBigEndian(destination: Span_1<System_Internal.Byte>, bytesWritten: int): boolean;
    WriteExponentBigEndian(destination: byte[], startIndex: int): int;
    WriteExponentBigEndian(destination: byte[]): int;
    WriteExponentBigEndian(destination: Span_1<System_Internal.Byte>): int;
    Equals(other: TSelf): boolean;
}


export type IFloatingPoint_1<TSelf extends IFloatingPoint_1<TSelf>> = IFloatingPoint_1$instance<TSelf>;

export interface IFloatingPointConstants_1$instance<TSelf extends IFloatingPointConstants_1<TSelf>> extends INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IEqualityOperators_3<TSelf, TSelf, System_Internal.Boolean>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf> {
    ToString(format: string | undefined, formatProvider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<System_Internal.Char>, charsWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<System_Internal.Byte>, bytesWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    Equals(other: TSelf): boolean;
}


export type IFloatingPointConstants_1<TSelf extends IFloatingPointConstants_1<TSelf>> = IFloatingPointConstants_1$instance<TSelf>;

export interface IFloatingPointIeee754_1$instance<TSelf extends IFloatingPointIeee754_1<TSelf>> extends IExponentialFunctions_1<TSelf>, IFloatingPointConstants_1<TSelf>, INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IEqualityOperators_3<TSelf, TSelf, System_Internal.Boolean>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf>, IFloatingPoint_1<TSelf>, INumber_1<TSelf>, IComparable, IComparable_1<TSelf>, IComparisonOperators_3<TSelf, TSelf, System_Internal.Boolean>, IModulusOperators_3<TSelf, TSelf, TSelf>, ISignedNumber_1<TSelf>, IHyperbolicFunctions_1<TSelf>, ILogarithmicFunctions_1<TSelf>, IPowerFunctions_1<TSelf>, IRootFunctions_1<TSelf>, ITrigonometricFunctions_1<TSelf> {
    CompareTo(obj: unknown | undefined): int;
    CompareTo(other: TSelf): int;
    GetExponentByteCount(): int;
    ToString(format: string | undefined, formatProvider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<System_Internal.Char>, charsWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<System_Internal.Byte>, bytesWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    TryWriteExponentBigEndian(destination: Span_1<System_Internal.Byte>, bytesWritten: int): boolean;
    WriteExponentBigEndian(destination: byte[], startIndex: int): int;
    WriteExponentBigEndian(destination: byte[]): int;
    WriteExponentBigEndian(destination: Span_1<System_Internal.Byte>): int;
    Equals(other: TSelf): boolean;
}


export type IFloatingPointIeee754_1<TSelf extends IFloatingPointIeee754_1<TSelf>> = IFloatingPointIeee754_1$instance<TSelf>;

export interface IHyperbolicFunctions_1$instance<TSelf extends IHyperbolicFunctions_1<TSelf>> extends IFloatingPointConstants_1<TSelf>, INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IEqualityOperators_3<TSelf, TSelf, System_Internal.Boolean>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf> {
    ToString(format: string | undefined, formatProvider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<System_Internal.Char>, charsWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<System_Internal.Byte>, bytesWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    Equals(other: TSelf): boolean;
}


export type IHyperbolicFunctions_1<TSelf extends IHyperbolicFunctions_1<TSelf>> = IHyperbolicFunctions_1$instance<TSelf>;

export interface IIncrementOperators_1$instance<TSelf extends IIncrementOperators_1<TSelf>> {
}


export type IIncrementOperators_1<TSelf extends IIncrementOperators_1<TSelf>> = IIncrementOperators_1$instance<TSelf>;

export interface ILogarithmicFunctions_1$instance<TSelf extends ILogarithmicFunctions_1<TSelf>> extends IFloatingPointConstants_1<TSelf>, INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IEqualityOperators_3<TSelf, TSelf, System_Internal.Boolean>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf> {
    ToString(format: string | undefined, formatProvider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<System_Internal.Char>, charsWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<System_Internal.Byte>, bytesWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    Equals(other: TSelf): boolean;
}


export type ILogarithmicFunctions_1<TSelf extends ILogarithmicFunctions_1<TSelf>> = ILogarithmicFunctions_1$instance<TSelf>;

export interface IMinMaxValue_1$instance<TSelf extends IMinMaxValue_1<TSelf>> {
}


export type IMinMaxValue_1<TSelf extends IMinMaxValue_1<TSelf>> = IMinMaxValue_1$instance<TSelf>;

export interface IModulusOperators_3$instance<TSelf extends IModulusOperators_3<TSelf, TOther, TResult>, TOther, TResult> {
}


export type IModulusOperators_3<TSelf extends IModulusOperators_3<TSelf, TOther, TResult>, TOther, TResult> = IModulusOperators_3$instance<TSelf, TOther, TResult>;

export interface IMultiplicativeIdentity_2$instance<TSelf extends IMultiplicativeIdentity_2<TSelf, TResult>, TResult> {
}


export type IMultiplicativeIdentity_2<TSelf extends IMultiplicativeIdentity_2<TSelf, TResult>, TResult> = IMultiplicativeIdentity_2$instance<TSelf, TResult>;

export interface IMultiplyOperators_3$instance<TSelf extends IMultiplyOperators_3<TSelf, TOther, TResult>, TOther, TResult> {
}


export type IMultiplyOperators_3<TSelf extends IMultiplyOperators_3<TSelf, TOther, TResult>, TOther, TResult> = IMultiplyOperators_3$instance<TSelf, TOther, TResult>;

export interface INumber_1$instance<TSelf extends INumber_1<TSelf>> extends IComparable, IComparable_1<TSelf>, IComparisonOperators_3<TSelf, TSelf, System_Internal.Boolean>, IEqualityOperators_3<TSelf, TSelf, System_Internal.Boolean>, IModulusOperators_3<TSelf, TSelf, TSelf>, INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf> {
    CompareTo(obj: unknown | undefined): int;
    CompareTo(other: TSelf): int;
    ToString(format: string | undefined, formatProvider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<System_Internal.Char>, charsWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<System_Internal.Byte>, bytesWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    Equals(other: TSelf): boolean;
}


export interface INumber_1$instance<TSelf extends INumber_1<TSelf>> extends System_Internal.IComparable$instance, IComparisonOperators_3$instance<TSelf, TSelf, System_Internal.Boolean>, IModulusOperators_3$instance<TSelf, TSelf, TSelf> {}

export type INumber_1<TSelf extends INumber_1<TSelf>> = INumber_1$instance<TSelf>;

export interface INumberBase_1$instance<TSelf extends INumberBase_1<TSelf>> extends IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IEqualityOperators_3<TSelf, TSelf, System_Internal.Boolean>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf> {
    Equals(other: TSelf): boolean;
    ToString(format: string | undefined, formatProvider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<System_Internal.Char>, charsWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<System_Internal.Byte>, bytesWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
}


export interface INumberBase_1$instance<TSelf extends INumberBase_1<TSelf>> extends System_Internal.IEquatable_1$instance<TSelf>, System_Internal.ISpanParsable_1$instance<TSelf>, IAdditionOperators_3$instance<TSelf, TSelf, TSelf>, IAdditiveIdentity_2$instance<TSelf, TSelf>, IDecrementOperators_1$instance<TSelf>, IDivisionOperators_3$instance<TSelf, TSelf, TSelf>, IEqualityOperators_3$instance<TSelf, TSelf, System_Internal.Boolean>, IIncrementOperators_1$instance<TSelf>, IMultiplicativeIdentity_2$instance<TSelf, TSelf>, IMultiplyOperators_3$instance<TSelf, TSelf, TSelf>, ISubtractionOperators_3$instance<TSelf, TSelf, TSelf>, IUnaryNegationOperators_2$instance<TSelf, TSelf>, IUnaryPlusOperators_2$instance<TSelf, TSelf> {}

export type INumberBase_1<TSelf extends INumberBase_1<TSelf>> = INumberBase_1$instance<TSelf>;

export interface IPowerFunctions_1$instance<TSelf extends IPowerFunctions_1<TSelf>> extends INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IEqualityOperators_3<TSelf, TSelf, System_Internal.Boolean>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf> {
    ToString(format: string | undefined, formatProvider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<System_Internal.Char>, charsWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<System_Internal.Byte>, bytesWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    Equals(other: TSelf): boolean;
}


export type IPowerFunctions_1<TSelf extends IPowerFunctions_1<TSelf>> = IPowerFunctions_1$instance<TSelf>;

export interface IRootFunctions_1$instance<TSelf extends IRootFunctions_1<TSelf>> extends IFloatingPointConstants_1<TSelf>, INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IEqualityOperators_3<TSelf, TSelf, System_Internal.Boolean>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf> {
    ToString(format: string | undefined, formatProvider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<System_Internal.Char>, charsWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<System_Internal.Byte>, bytesWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    Equals(other: TSelf): boolean;
}


export type IRootFunctions_1<TSelf extends IRootFunctions_1<TSelf>> = IRootFunctions_1$instance<TSelf>;

export interface IShiftOperators_3$instance<TSelf extends IShiftOperators_3<TSelf, TOther, TResult>, TOther, TResult> {
}


export type IShiftOperators_3<TSelf extends IShiftOperators_3<TSelf, TOther, TResult>, TOther, TResult> = IShiftOperators_3$instance<TSelf, TOther, TResult>;

export interface ISignedNumber_1$instance<TSelf extends ISignedNumber_1<TSelf>> extends INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IEqualityOperators_3<TSelf, TSelf, System_Internal.Boolean>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf> {
    ToString(format: string | undefined, formatProvider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<System_Internal.Char>, charsWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<System_Internal.Byte>, bytesWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    Equals(other: TSelf): boolean;
}


export type ISignedNumber_1<TSelf extends ISignedNumber_1<TSelf>> = ISignedNumber_1$instance<TSelf>;

export interface ISubtractionOperators_3$instance<TSelf extends ISubtractionOperators_3<TSelf, TOther, TResult>, TOther, TResult> {
}


export type ISubtractionOperators_3<TSelf extends ISubtractionOperators_3<TSelf, TOther, TResult>, TOther, TResult> = ISubtractionOperators_3$instance<TSelf, TOther, TResult>;

export interface ITrigonometricFunctions_1$instance<TSelf extends ITrigonometricFunctions_1<TSelf>> extends IFloatingPointConstants_1<TSelf>, INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IEqualityOperators_3<TSelf, TSelf, System_Internal.Boolean>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf> {
    ToString(format: string | undefined, formatProvider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<System_Internal.Char>, charsWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<System_Internal.Byte>, bytesWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    Equals(other: TSelf): boolean;
}


export type ITrigonometricFunctions_1<TSelf extends ITrigonometricFunctions_1<TSelf>> = ITrigonometricFunctions_1$instance<TSelf>;

export interface IUnaryNegationOperators_2$instance<TSelf extends IUnaryNegationOperators_2<TSelf, TResult>, TResult> {
}


export type IUnaryNegationOperators_2<TSelf extends IUnaryNegationOperators_2<TSelf, TResult>, TResult> = IUnaryNegationOperators_2$instance<TSelf, TResult>;

export interface IUnaryPlusOperators_2$instance<TSelf extends IUnaryPlusOperators_2<TSelf, TResult>, TResult> {
}


export type IUnaryPlusOperators_2<TSelf extends IUnaryPlusOperators_2<TSelf, TResult>, TResult> = IUnaryPlusOperators_2$instance<TSelf, TResult>;

export interface IUnsignedNumber_1$instance<TSelf extends IUnsignedNumber_1<TSelf>> extends INumberBase_1<TSelf>, IAdditionOperators_3<TSelf, TSelf, TSelf>, IAdditiveIdentity_2<TSelf, TSelf>, IDecrementOperators_1<TSelf>, IDivisionOperators_3<TSelf, TSelf, TSelf>, IEquatable_1<TSelf>, IEqualityOperators_3<TSelf, TSelf, System_Internal.Boolean>, IIncrementOperators_1<TSelf>, IMultiplicativeIdentity_2<TSelf, TSelf>, IMultiplyOperators_3<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable_1<TSelf>, IParsable_1<TSelf>, ISubtractionOperators_3<TSelf, TSelf, TSelf>, IUnaryPlusOperators_2<TSelf, TSelf>, IUnaryNegationOperators_2<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable_1<TSelf> {
    ToString(format: string | undefined, formatProvider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<System_Internal.Char>, charsWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<System_Internal.Byte>, bytesWritten: int, format: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): boolean;
    Equals(other: TSelf): boolean;
}


export type IUnsignedNumber_1<TSelf extends IUnsignedNumber_1<TSelf>> = IUnsignedNumber_1$instance<TSelf>;

export interface BigInteger$instance extends IAdditionOperators_3<BigInteger, BigInteger, BigInteger>, IBitwiseOperators_3<BigInteger, BigInteger, BigInteger>, IComparisonOperators_3<BigInteger, BigInteger, System_Internal.Boolean>, IEqualityOperators_3<BigInteger, BigInteger, System_Internal.Boolean>, IDecrementOperators_1<BigInteger>, IDivisionOperators_3<BigInteger, BigInteger, BigInteger>, IIncrementOperators_1<BigInteger>, IModulusOperators_3<BigInteger, BigInteger, BigInteger>, IMultiplyOperators_3<BigInteger, BigInteger, BigInteger>, ISubtractionOperators_3<BigInteger, BigInteger, BigInteger>, IUnaryNegationOperators_2<BigInteger, BigInteger>, IUnaryPlusOperators_2<BigInteger, BigInteger>, IShiftOperators_3<BigInteger, System_Internal.Int32, BigInteger> {
    readonly IsEven: boolean;
    readonly IsOne: boolean;
    readonly IsPowerOfTwo: boolean;
    readonly IsZero: boolean;
    readonly Sign: int;
    CompareTo(other: long): int;
    CompareTo(other: ulong): int;
    CompareTo(other: BigInteger): int;
    CompareTo(obj: unknown | undefined): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(other: long): boolean;
    Equals(other: ulong): boolean;
    Equals(other: BigInteger): boolean;
    GetBitLength(): long;
    GetByteCount(isUnsigned?: boolean): int;
    GetHashCode(): int;
    ToByteArray(): byte[];
    ToByteArray(isUnsigned?: boolean, isBigEndian?: boolean): byte[];
    ToString(): string;
    ToString(provider: IFormatProvider | undefined): string;
    ToString(format: string | undefined): string;
    ToString(format: string | undefined, provider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<System_Internal.Char>, charsWritten: int, format?: ReadOnlySpan_1<System_Internal.Char>, provider?: IFormatProvider | undefined): boolean;
    TryWriteBytes(destination: Span_1<System_Internal.Byte>, bytesWritten: int, isUnsigned?: boolean, isBigEndian?: boolean): boolean;
}


export const BigInteger: {
    new(value: int): BigInteger;
    new(value: uint): BigInteger;
    new(value: long): BigInteger;
    new(value: ulong): BigInteger;
    new(value: float): BigInteger;
    new(value: double): BigInteger;
    new(value: decimal): BigInteger;
    new(value: byte[]): BigInteger;
    new(value: ReadOnlySpan_1<System_Internal.Byte>, isUnsigned: boolean, isBigEndian: boolean): BigInteger;
    readonly Zero: BigInteger;
    readonly One: BigInteger;
    readonly MinusOne: BigInteger;
    Abs(value: BigInteger): BigInteger;
    Add(left: BigInteger, right: BigInteger): BigInteger;
    Clamp(value: BigInteger, min: BigInteger, max: BigInteger): BigInteger;
    Compare(left: BigInteger, right: BigInteger): int;
    CopySign(value: BigInteger, sign: BigInteger): BigInteger;
    CreateChecked<TOther extends INumberBase_1<TOther>>(value: TOther): BigInteger;
    CreateSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): BigInteger;
    CreateTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): BigInteger;
    Divide(dividend: BigInteger, divisor: BigInteger): BigInteger;
    DivRem(dividend: BigInteger, divisor: BigInteger, remainder: BigInteger): BigInteger;
    DivRem(left: BigInteger, right: BigInteger): ValueTuple_2<BigInteger, BigInteger>;
    GreatestCommonDivisor(left: BigInteger, right: BigInteger): BigInteger;
    IsEvenInteger(value: BigInteger): boolean;
    IsNegative(value: BigInteger): boolean;
    IsOddInteger(value: BigInteger): boolean;
    IsPositive(value: BigInteger): boolean;
    IsPow2(value: BigInteger): boolean;
    LeadingZeroCount(value: BigInteger): BigInteger;
    Log(value: BigInteger, baseValue: double): double;
    Log(value: BigInteger): double;
    Log10(value: BigInteger): double;
    Log2(value: BigInteger): BigInteger;
    Max(left: BigInteger, right: BigInteger): BigInteger;
    MaxMagnitude(x: BigInteger, y: BigInteger): BigInteger;
    Min(left: BigInteger, right: BigInteger): BigInteger;
    MinMagnitude(x: BigInteger, y: BigInteger): BigInteger;
    ModPow(value: BigInteger, exponent: BigInteger, modulus: BigInteger): BigInteger;
    Multiply(left: BigInteger, right: BigInteger): BigInteger;
    Negate(value: BigInteger): BigInteger;
    Parse(value: ReadOnlySpan_1<System_Internal.Char>, style?: NumberStyles, provider?: IFormatProvider | undefined): BigInteger;
    Parse(s: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): BigInteger;
    Parse(value: string, style: NumberStyles, provider: IFormatProvider | undefined): BigInteger;
    Parse(value: string, style: NumberStyles): BigInteger;
    Parse(value: string, provider: IFormatProvider | undefined): BigInteger;
    Parse(value: string): BigInteger;
    PopCount(value: BigInteger): BigInteger;
    Pow(value: BigInteger, exponent: int): BigInteger;
    Remainder(dividend: BigInteger, divisor: BigInteger): BigInteger;
    RotateLeft(value: BigInteger, rotateAmount: int): BigInteger;
    RotateRight(value: BigInteger, rotateAmount: int): BigInteger;
    Subtract(left: BigInteger, right: BigInteger): BigInteger;
    TrailingZeroCount(value: BigInteger): BigInteger;
    TryParse(value: ReadOnlySpan_1<System_Internal.Char>, style: NumberStyles, provider: IFormatProvider | undefined, result: BigInteger): boolean;
    TryParse(s: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined, result: BigInteger): boolean;
    TryParse(value: ReadOnlySpan_1<System_Internal.Char>, result: BigInteger): boolean;
    TryParse(value: string | undefined, style: NumberStyles, provider: IFormatProvider | undefined, result: BigInteger): boolean;
    TryParse(s: string | undefined, provider: IFormatProvider | undefined, result: BigInteger): boolean;
    TryParse(value: string | undefined, result: BigInteger): boolean;
};


export interface __BigInteger$views {
    As_IComparable(): System_Internal.IComparable$instance;
    As_IComparable_1(): System_Internal.IComparable_1$instance<BigInteger>;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<BigInteger>;
    As_IFormattable(): System_Internal.IFormattable$instance;
    As_IParsable_1(): System_Internal.IParsable_1$instance<BigInteger>;
    As_ISpanFormattable(): System_Internal.ISpanFormattable$instance;
    As_ISpanParsable_1(): System_Internal.ISpanParsable_1$instance<BigInteger>;
    As_IUtf8SpanFormattable(): System_Internal.IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): System_Internal.IUtf8SpanParsable_1$instance<BigInteger>;
    As_IAdditiveIdentity_2(): IAdditiveIdentity_2$instance<BigInteger, BigInteger>;
    As_IBinaryInteger_1(): IBinaryInteger_1$instance<BigInteger>;
    As_INumber_1(): INumber_1$instance<BigInteger>;
    As_INumberBase_1(): INumberBase_1$instance<BigInteger>;

    // Structural method bridges for numeric interface constraints
    Equals(other: BigInteger): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: import("../../System/internal/index").IFormatProvider): string;
    TryFormat(destination: import("../../System/internal/index").Span_1<import("../../System/internal/index").Char>, charsWritten: int, format: import("../../System/internal/index").ReadOnlySpan_1<import("../../System/internal/index").Char>, provider: import("../../System/internal/index").IFormatProvider): boolean;
    TryFormat(utf8Destination: import("../../System/internal/index").Span_1<import("../../System/internal/index").Byte>, bytesWritten: int, format: import("../../System/internal/index").ReadOnlySpan_1<import("../../System/internal/index").Char>, provider: import("../../System/internal/index").IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: import("../../System/internal/index").Span_1<import("../../System/internal/index").Byte>, bytesWritten: int): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: import("../../System/internal/index").Span_1<import("../../System/internal/index").Byte>): int;
}

export type BigInteger = BigInteger$instance & __BigInteger$views;


export interface Complex$instance extends IAdditionOperators_3<Complex, Complex, Complex>, IDecrementOperators_1<Complex>, IDivisionOperators_3<Complex, Complex, Complex>, IEqualityOperators_3<Complex, Complex, System_Internal.Boolean>, IIncrementOperators_1<Complex>, IMultiplyOperators_3<Complex, Complex, Complex>, ISubtractionOperators_3<Complex, Complex, Complex>, IUnaryNegationOperators_2<Complex, Complex>, IUnaryPlusOperators_2<Complex, Complex> {
    readonly Imaginary: double;
    readonly Magnitude: double;
    readonly Phase: double;
    readonly Real: double;
    Equals(obj: unknown | undefined): boolean;
    Equals(value: Complex): boolean;
    GetHashCode(): int;
    ToString(): string;
    ToString(format: string | undefined): string;
    ToString(provider: IFormatProvider | undefined): string;
    ToString(format: string | undefined, provider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<System_Internal.Char>, charsWritten: int, format?: ReadOnlySpan_1<System_Internal.Char>, provider?: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<System_Internal.Byte>, bytesWritten: int, format?: ReadOnlySpan_1<System_Internal.Char>, provider?: IFormatProvider | undefined): boolean;
}


export const Complex: {
    new(real: double, imaginary: double): Complex;
    readonly Zero: Complex;
    readonly One: Complex;
    readonly ImaginaryOne: Complex;
    readonly NaN: Complex;
    readonly Infinity: Complex;
    Abs(value: Complex): double;
    Acos(value: Complex): Complex;
    Add(left: double, right: Complex): Complex;
    Add(left: Complex, right: double): Complex;
    Add(left: Complex, right: Complex): Complex;
    Asin(value: Complex): Complex;
    Atan(value: Complex): Complex;
    Conjugate(value: Complex): Complex;
    Cos(value: Complex): Complex;
    Cosh(value: Complex): Complex;
    CreateChecked<TOther extends INumberBase_1<TOther>>(value: TOther): Complex;
    CreateSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): Complex;
    CreateTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): Complex;
    Divide(dividend: double, divisor: Complex): Complex;
    Divide(dividend: Complex, divisor: double): Complex;
    Divide(dividend: Complex, divisor: Complex): Complex;
    Exp(value: Complex): Complex;
    FromPolarCoordinates(magnitude: double, phase: double): Complex;
    IsComplexNumber(value: Complex): boolean;
    IsEvenInteger(value: Complex): boolean;
    IsFinite(value: Complex): boolean;
    IsImaginaryNumber(value: Complex): boolean;
    IsInfinity(value: Complex): boolean;
    IsInteger(value: Complex): boolean;
    IsNaN(value: Complex): boolean;
    IsNegative(value: Complex): boolean;
    IsNegativeInfinity(value: Complex): boolean;
    IsNormal(value: Complex): boolean;
    IsOddInteger(value: Complex): boolean;
    IsPositive(value: Complex): boolean;
    IsPositiveInfinity(value: Complex): boolean;
    IsRealNumber(value: Complex): boolean;
    IsSubnormal(value: Complex): boolean;
    Log(value: Complex, baseValue: double): Complex;
    Log(value: Complex): Complex;
    Log10(value: Complex): Complex;
    MaxMagnitude(x: Complex, y: Complex): Complex;
    MinMagnitude(x: Complex, y: Complex): Complex;
    Multiply(left: double, right: Complex): Complex;
    Multiply(left: Complex, right: double): Complex;
    Multiply(left: Complex, right: Complex): Complex;
    Negate(value: Complex): Complex;
    Parse(s: ReadOnlySpan_1<System_Internal.Char>, style: NumberStyles, provider: IFormatProvider | undefined): Complex;
    Parse(s: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined): Complex;
    Parse(s: string, style: NumberStyles, provider: IFormatProvider | undefined): Complex;
    Parse(s: string, provider: IFormatProvider | undefined): Complex;
    Pow(value: Complex, power: double): Complex;
    Pow(value: Complex, power: Complex): Complex;
    Reciprocal(value: Complex): Complex;
    Sin(value: Complex): Complex;
    Sinh(value: Complex): Complex;
    Sqrt(value: Complex): Complex;
    Subtract(left: double, right: Complex): Complex;
    Subtract(left: Complex, right: double): Complex;
    Subtract(left: Complex, right: Complex): Complex;
    Tan(value: Complex): Complex;
    Tanh(value: Complex): Complex;
    TryParse(s: ReadOnlySpan_1<System_Internal.Char>, style: NumberStyles, provider: IFormatProvider | undefined, result: Complex): boolean;
    TryParse(s: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider | undefined, result: Complex): boolean;
    TryParse(s: string | undefined, style: NumberStyles, provider: IFormatProvider | undefined, result: Complex): boolean;
    TryParse(s: string | undefined, provider: IFormatProvider | undefined, result: Complex): boolean;
};


export interface __Complex$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Complex>;
    As_IFormattable(): System_Internal.IFormattable$instance;
    As_IParsable_1(): System_Internal.IParsable_1$instance<Complex>;
    As_ISpanParsable_1(): System_Internal.ISpanParsable_1$instance<Complex>;
    As_IUtf8SpanFormattable(): System_Internal.IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): System_Internal.IUtf8SpanParsable_1$instance<Complex>;
    As_IAdditiveIdentity_2(): IAdditiveIdentity_2$instance<Complex, Complex>;
    As_INumberBase_1(): INumberBase_1$instance<Complex>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Complex): boolean;
    ToString(format: string, formatProvider: import("../../System/internal/index").IFormatProvider): string;
    TryFormat(destination: import("../../System/internal/index").Span_1<import("../../System/internal/index").Char>, charsWritten: int, format: import("../../System/internal/index").ReadOnlySpan_1<import("../../System/internal/index").Char>, provider: import("../../System/internal/index").IFormatProvider): boolean;
    TryFormat(utf8Destination: import("../../System/internal/index").Span_1<import("../../System/internal/index").Byte>, bytesWritten: int, format: import("../../System/internal/index").ReadOnlySpan_1<import("../../System/internal/index").Char>, provider: import("../../System/internal/index").IFormatProvider): boolean;
}

export type Complex = Complex$instance & __Complex$views;


export interface Matrix3x2$instance {
    M11: float;
    M12: float;
    M21: float;
    M22: float;
    M31: float;
    M32: float;
    readonly IsIdentity: boolean;
    Translation: Vector2;
    X: Vector2;
    Y: Vector2;
    Z: Vector2;
    Equals(obj: unknown | undefined): boolean;
    Equals(other: Matrix3x2): boolean;
    get_Item(row: int): Vector2;
    get_Item(row: int, column: int): float;
    GetDeterminant(): float;
    GetElement(row: int, column: int): float;
    GetHashCode(): int;
    GetRow(index: int): Vector2;
    set_Item(row: int, value: Vector2): void;
    set_Item(row: int, column: int, value: float): void;
    ToString(): string;
    WithElement(row: int, column: int, value: float): Matrix3x2;
    WithRow(index: int, value: Vector2): Matrix3x2;
}


export const Matrix3x2: {
    new(m11: float, m12: float, m21: float, m22: float, m31: float, m32: float): Matrix3x2;
    readonly Identity: Matrix3x2;
    Add(value1: Matrix3x2, value2: Matrix3x2): Matrix3x2;
    Create(x: Vector2, y: Vector2, z: Vector2): Matrix3x2;
    Create(value: Vector2): Matrix3x2;
    Create(m11: float, m12: float, m21: float, m22: float, m31: float, m32: float): Matrix3x2;
    Create(value: float): Matrix3x2;
    CreateRotation(radians: float, centerPoint: Vector2): Matrix3x2;
    CreateRotation(radians: float): Matrix3x2;
    CreateScale(scales: Vector2, centerPoint: Vector2): Matrix3x2;
    CreateScale(scales: Vector2): Matrix3x2;
    CreateScale(scale: float, centerPoint: Vector2): Matrix3x2;
    CreateScale(xScale: float, yScale: float, centerPoint: Vector2): Matrix3x2;
    CreateScale(xScale: float, yScale: float): Matrix3x2;
    CreateScale(scale: float): Matrix3x2;
    CreateSkew(radiansX: float, radiansY: float, centerPoint: Vector2): Matrix3x2;
    CreateSkew(radiansX: float, radiansY: float): Matrix3x2;
    CreateTranslation(position: Vector2): Matrix3x2;
    CreateTranslation(xPosition: float, yPosition: float): Matrix3x2;
    Invert(matrix: Matrix3x2, result: Matrix3x2): boolean;
    Lerp(matrix1: Matrix3x2, matrix2: Matrix3x2, amount: float): Matrix3x2;
    Multiply(value1: Matrix3x2, value2: Matrix3x2): Matrix3x2;
    Multiply(value1: Matrix3x2, value2: float): Matrix3x2;
    Negate(value: Matrix3x2): Matrix3x2;
    Subtract(value1: Matrix3x2, value2: Matrix3x2): Matrix3x2;
};


export interface __Matrix3x2$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Matrix3x2>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Matrix3x2): boolean;
}

export type Matrix3x2 = Matrix3x2$instance & __Matrix3x2$views;


export interface Matrix4x4$instance {
    M11: float;
    M12: float;
    M13: float;
    M14: float;
    M21: float;
    M22: float;
    M23: float;
    M24: float;
    M31: float;
    M32: float;
    M33: float;
    M34: float;
    M41: float;
    M42: float;
    M43: float;
    M44: float;
    readonly IsIdentity: boolean;
    Translation: Vector3;
    W: Vector4;
    X: Vector4;
    Y: Vector4;
    Z: Vector4;
    Equals(obj: unknown | undefined): boolean;
    Equals(other: Matrix4x4): boolean;
    get_Item(row: int): Vector4;
    get_Item(row: int, column: int): float;
    GetDeterminant(): float;
    GetElement(row: int, column: int): float;
    GetHashCode(): int;
    GetRow(index: int): Vector4;
    set_Item(row: int, value: Vector4): void;
    set_Item(row: int, column: int, value: float): void;
    ToString(): string;
    WithElement(row: int, column: int, value: float): Matrix4x4;
    WithRow(index: int, value: Vector4): Matrix4x4;
}


export const Matrix4x4: {
    new(m11: float, m12: float, m13: float, m14: float, m21: float, m22: float, m23: float, m24: float, m31: float, m32: float, m33: float, m34: float, m41: float, m42: float, m43: float, m44: float): Matrix4x4;
    new(value: Matrix3x2): Matrix4x4;
    readonly Identity: Matrix4x4;
    Add(value1: Matrix4x4, value2: Matrix4x4): Matrix4x4;
    Create(value: Matrix3x2): Matrix4x4;
    Create(x: Vector4, y: Vector4, z: Vector4, w: Vector4): Matrix4x4;
    Create(value: Vector4): Matrix4x4;
    Create(m11: float, m12: float, m13: float, m14: float, m21: float, m22: float, m23: float, m24: float, m31: float, m32: float, m33: float, m34: float, m41: float, m42: float, m43: float, m44: float): Matrix4x4;
    Create(value: float): Matrix4x4;
    CreateBillboard(objectPosition: Vector3, cameraPosition: Vector3, cameraUpVector: Vector3, cameraForwardVector: Vector3): Matrix4x4;
    CreateBillboardLeftHanded(objectPosition: Vector3, cameraPosition: Vector3, cameraUpVector: Vector3, cameraForwardVector: Vector3): Matrix4x4;
    CreateConstrainedBillboard(objectPosition: Vector3, cameraPosition: Vector3, rotateAxis: Vector3, cameraForwardVector: Vector3, objectForwardVector: Vector3): Matrix4x4;
    CreateConstrainedBillboardLeftHanded(objectPosition: Vector3, cameraPosition: Vector3, rotateAxis: Vector3, cameraForwardVector: Vector3, objectForwardVector: Vector3): Matrix4x4;
    CreateFromAxisAngle(axis: Vector3, angle: float): Matrix4x4;
    CreateFromQuaternion(quaternion: Quaternion): Matrix4x4;
    CreateFromYawPitchRoll(yaw: float, pitch: float, roll: float): Matrix4x4;
    CreateLookAt(cameraPosition: Vector3, cameraTarget: Vector3, cameraUpVector: Vector3): Matrix4x4;
    CreateLookAtLeftHanded(cameraPosition: Vector3, cameraTarget: Vector3, cameraUpVector: Vector3): Matrix4x4;
    CreateLookTo(cameraPosition: Vector3, cameraDirection: Vector3, cameraUpVector: Vector3): Matrix4x4;
    CreateLookToLeftHanded(cameraPosition: Vector3, cameraDirection: Vector3, cameraUpVector: Vector3): Matrix4x4;
    CreateOrthographic(width: float, height: float, zNearPlane: float, zFarPlane: float): Matrix4x4;
    CreateOrthographicLeftHanded(width: float, height: float, zNearPlane: float, zFarPlane: float): Matrix4x4;
    CreateOrthographicOffCenter(left: float, right: float, bottom: float, top: float, zNearPlane: float, zFarPlane: float): Matrix4x4;
    CreateOrthographicOffCenterLeftHanded(left: float, right: float, bottom: float, top: float, zNearPlane: float, zFarPlane: float): Matrix4x4;
    CreatePerspective(width: float, height: float, nearPlaneDistance: float, farPlaneDistance: float): Matrix4x4;
    CreatePerspectiveFieldOfView(fieldOfView: float, aspectRatio: float, nearPlaneDistance: float, farPlaneDistance: float): Matrix4x4;
    CreatePerspectiveFieldOfViewLeftHanded(fieldOfView: float, aspectRatio: float, nearPlaneDistance: float, farPlaneDistance: float): Matrix4x4;
    CreatePerspectiveLeftHanded(width: float, height: float, nearPlaneDistance: float, farPlaneDistance: float): Matrix4x4;
    CreatePerspectiveOffCenter(left: float, right: float, bottom: float, top: float, nearPlaneDistance: float, farPlaneDistance: float): Matrix4x4;
    CreatePerspectiveOffCenterLeftHanded(left: float, right: float, bottom: float, top: float, nearPlaneDistance: float, farPlaneDistance: float): Matrix4x4;
    CreateReflection(value: Plane): Matrix4x4;
    CreateRotationX(radians: float, centerPoint: Vector3): Matrix4x4;
    CreateRotationX(radians: float): Matrix4x4;
    CreateRotationY(radians: float, centerPoint: Vector3): Matrix4x4;
    CreateRotationY(radians: float): Matrix4x4;
    CreateRotationZ(radians: float, centerPoint: Vector3): Matrix4x4;
    CreateRotationZ(radians: float): Matrix4x4;
    CreateScale(scales: Vector3, centerPoint: Vector3): Matrix4x4;
    CreateScale(scales: Vector3): Matrix4x4;
    CreateScale(scale: float, centerPoint: Vector3): Matrix4x4;
    CreateScale(xScale: float, yScale: float, zScale: float, centerPoint: Vector3): Matrix4x4;
    CreateScale(xScale: float, yScale: float, zScale: float): Matrix4x4;
    CreateScale(scale: float): Matrix4x4;
    CreateShadow(lightDirection: Vector3, plane: Plane): Matrix4x4;
    CreateTranslation(position: Vector3): Matrix4x4;
    CreateTranslation(xPosition: float, yPosition: float, zPosition: float): Matrix4x4;
    CreateViewport(x: float, y: float, width: float, height: float, minDepth: float, maxDepth: float): Matrix4x4;
    CreateViewportLeftHanded(x: float, y: float, width: float, height: float, minDepth: float, maxDepth: float): Matrix4x4;
    CreateWorld(position: Vector3, forward: Vector3, up: Vector3): Matrix4x4;
    Decompose(matrix: Matrix4x4, scale: Vector3, rotation: Quaternion, translation: Vector3): boolean;
    Invert(matrix: Matrix4x4, result: Matrix4x4): boolean;
    Lerp(matrix1: Matrix4x4, matrix2: Matrix4x4, amount: float): Matrix4x4;
    Multiply(value1: Matrix4x4, value2: Matrix4x4): Matrix4x4;
    Multiply(value1: Matrix4x4, value2: float): Matrix4x4;
    Negate(value: Matrix4x4): Matrix4x4;
    Subtract(value1: Matrix4x4, value2: Matrix4x4): Matrix4x4;
    Transform(value: Matrix4x4, rotation: Quaternion): Matrix4x4;
    Transpose(matrix: Matrix4x4): Matrix4x4;
};


export interface __Matrix4x4$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Matrix4x4>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Matrix4x4): boolean;
}

export type Matrix4x4 = Matrix4x4$instance & __Matrix4x4$views;


export interface Plane$instance {
    Normal: Vector3;
    D: float;
    Equals(obj: unknown | undefined): boolean;
    Equals(other: Plane): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const Plane: {
    new(x: float, y: float, z: float, d: float): Plane;
    new(normal: Vector3, d: float): Plane;
    new(value: Vector4): Plane;
    Create(normal: Vector3, d: float): Plane;
    Create(value: Vector4): Plane;
    Create(x: float, y: float, z: float, d: float): Plane;
    CreateFromVertices(point1: Vector3, point2: Vector3, point3: Vector3): Plane;
    Dot(plane: Plane, value: Vector4): float;
    DotCoordinate(plane: Plane, value: Vector3): float;
    DotNormal(plane: Plane, value: Vector3): float;
    Normalize(value: Plane): Plane;
    Transform(plane: Plane, matrix: Matrix4x4): Plane;
    Transform(plane: Plane, rotation: Quaternion): Plane;
};


export interface __Plane$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Plane>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Plane): boolean;
}

export type Plane = Plane$instance & __Plane$views;


export interface Quaternion$instance {
    X: float;
    Y: float;
    Z: float;
    W: float;
    readonly IsIdentity: boolean;
    Item: float;
    Equals(obj: unknown | undefined): boolean;
    Equals(other: Quaternion): boolean;
    GetHashCode(): int;
    Length(): float;
    LengthSquared(): float;
    ToString(): string;
}


export const Quaternion: {
    new(x: float, y: float, z: float, w: float): Quaternion;
    new(vectorPart: Vector3, scalarPart: float): Quaternion;
    readonly Zero: Quaternion;
    readonly Identity: Quaternion;
    Add(value1: Quaternion, value2: Quaternion): Quaternion;
    Concatenate(value1: Quaternion, value2: Quaternion): Quaternion;
    Conjugate(value: Quaternion): Quaternion;
    Create(vectorPart: Vector3, scalarPart: float): Quaternion;
    Create(x: float, y: float, z: float, w: float): Quaternion;
    CreateFromAxisAngle(axis: Vector3, angle: float): Quaternion;
    CreateFromRotationMatrix(matrix: Matrix4x4): Quaternion;
    CreateFromYawPitchRoll(yaw: float, pitch: float, roll: float): Quaternion;
    Divide(value1: Quaternion, value2: Quaternion): Quaternion;
    Dot(quaternion1: Quaternion, quaternion2: Quaternion): float;
    Inverse(value: Quaternion): Quaternion;
    Lerp(quaternion1: Quaternion, quaternion2: Quaternion, amount: float): Quaternion;
    Multiply(value1: Quaternion, value2: Quaternion): Quaternion;
    Multiply(value1: Quaternion, value2: float): Quaternion;
    Negate(value: Quaternion): Quaternion;
    Normalize(value: Quaternion): Quaternion;
    Slerp(quaternion1: Quaternion, quaternion2: Quaternion, amount: float): Quaternion;
    Subtract(value1: Quaternion, value2: Quaternion): Quaternion;
};


export interface __Quaternion$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Quaternion>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Quaternion): boolean;
}

export type Quaternion = Quaternion$instance & __Quaternion$views;


export interface TotalOrderIeee754Comparer_1$instance<T extends IFloatingPointIeee754_1<T>> {
    Compare(x: T | undefined, y: T | undefined): int;
    Equals(x: T | undefined, y: T | undefined): boolean;
    Equals(other: TotalOrderIeee754Comparer_1<T>): boolean;
    Equals(obj: unknown | undefined): boolean;
    GetHashCode(obj: T): int;
    GetHashCode(): int;
}


export const TotalOrderIeee754Comparer_1: {
    new<T extends IFloatingPointIeee754_1<T>>(): TotalOrderIeee754Comparer_1<T>;
};


export interface __TotalOrderIeee754Comparer_1$views<T extends IFloatingPointIeee754_1<T>> {
    As_IComparer_1(): System_Collections_Generic_Internal.IComparer_1$instance<T>;
    As_IEqualityComparer_1(): System_Collections_Generic_Internal.IEqualityComparer_1$instance<T>;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<TotalOrderIeee754Comparer_1<T>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: TotalOrderIeee754Comparer_1<T>): boolean;
}

export type TotalOrderIeee754Comparer_1<T extends IFloatingPointIeee754_1<T>> = TotalOrderIeee754Comparer_1$instance<T> & __TotalOrderIeee754Comparer_1$views<T>;


export interface Vector_1$instance<T> extends IAdditionOperators_3<Vector_1<T>, Vector_1<T>, Vector_1<T>>, IBitwiseOperators_3<Vector_1<T>, Vector_1<T>, Vector_1<T>>, IDivisionOperators_3<Vector_1<T>, Vector_1<T>, Vector_1<T>>, IEqualityOperators_3<Vector_1<T>, Vector_1<T>, System_Internal.Boolean>, IMultiplyOperators_3<Vector_1<T>, Vector_1<T>, Vector_1<T>>, IShiftOperators_3<Vector_1<T>, System_Internal.Int32, Vector_1<T>>, ISubtractionOperators_3<Vector_1<T>, Vector_1<T>, Vector_1<T>>, IUnaryNegationOperators_2<Vector_1<T>, Vector_1<T>>, IUnaryPlusOperators_2<Vector_1<T>, Vector_1<T>> {
    readonly Item: T;
    CopyTo(destination: T[]): void;
    CopyTo(destination: T[], startIndex: int): void;
    CopyTo(destination: Span_1<System_Internal.Byte>): void;
    CopyTo(destination: Span_1<T>): void;
    Equals(obj: unknown | undefined): boolean;
    Equals(other: Vector_1<T>): boolean;
    GetHashCode(): int;
    ToString(): string;
    ToString(format: string | undefined): string;
    ToString(format: string | undefined, formatProvider: IFormatProvider | undefined): string;
    TryCopyTo(destination: Span_1<System_Internal.Byte>): boolean;
    TryCopyTo(destination: Span_1<T>): boolean;
}


export const Vector_1: {
    new<T>(value: T): Vector_1<T>;
    new<T>(values: T[]): Vector_1<T>;
    new<T>(values: T[], index: int): Vector_1<T>;
    new<T>(values: ReadOnlySpan_1<T>): Vector_1<T>;
    new<T>(values: ReadOnlySpan_1<System_Internal.Byte>): Vector_1<T>;
    new<T>(values: Span_1<T>): Vector_1<T>;
    readonly AllBitsSet: unknown;
    readonly Count: int;
    readonly Indices: unknown;
    readonly IsSupported: boolean;
    readonly One: unknown;
    readonly Zero: unknown;
};


export interface __Vector_1$views<T> {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Vector_1<T>>;
    As_IFormattable(): System_Internal.IFormattable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: Vector_1<T>): boolean;
}

export interface Vector_1$instance<T> extends IAdditionOperators_3$instance<Vector_1<T>, Vector_1<T>, Vector_1<T>>, IBitwiseOperators_3$instance<Vector_1<T>, Vector_1<T>, Vector_1<T>>, IDivisionOperators_3$instance<Vector_1<T>, Vector_1<T>, Vector_1<T>>, IEqualityOperators_3$instance<Vector_1<T>, Vector_1<T>, System_Internal.Boolean>, IMultiplyOperators_3$instance<Vector_1<T>, Vector_1<T>, Vector_1<T>>, IShiftOperators_3$instance<Vector_1<T>, System_Internal.Int32, Vector_1<T>>, ISubtractionOperators_3$instance<Vector_1<T>, Vector_1<T>, Vector_1<T>>, IUnaryNegationOperators_2$instance<Vector_1<T>, Vector_1<T>>, IUnaryPlusOperators_2$instance<Vector_1<T>, Vector_1<T>> {}

export type Vector_1<T> = Vector_1$instance<T> & __Vector_1$views<T>;


export interface Vector2$instance {
    X: float;
    Y: float;
    Item: float;
    CopyTo(array: float[]): void;
    CopyTo(array: float[], index: int): void;
    CopyTo(destination: Span_1<System_Internal.Single>): void;
    Equals(obj: unknown | undefined): boolean;
    Equals(other: Vector2): boolean;
    GetHashCode(): int;
    Length(): float;
    LengthSquared(): float;
    ToString(): string;
    ToString(format: string | undefined): string;
    ToString(format: string | undefined, formatProvider: IFormatProvider | undefined): string;
    TryCopyTo(destination: Span_1<System_Internal.Single>): boolean;
}


export const Vector2: {
    new(value: float): Vector2;
    new(x: float, y: float): Vector2;
    new(values: ReadOnlySpan_1<System_Internal.Single>): Vector2;
    readonly AllBitsSet: Vector2;
    readonly E: Vector2;
    readonly Epsilon: Vector2;
    readonly NaN: Vector2;
    readonly NegativeInfinity: Vector2;
    readonly NegativeZero: Vector2;
    readonly One: Vector2;
    readonly Pi: Vector2;
    readonly PositiveInfinity: Vector2;
    readonly Tau: Vector2;
    readonly UnitX: Vector2;
    readonly UnitY: Vector2;
    readonly Zero: Vector2;
    Abs(value: Vector2): Vector2;
    Add(left: Vector2, right: Vector2): Vector2;
    All(vector: Vector2, value: float): boolean;
    AllWhereAllBitsSet(vector: Vector2): boolean;
    AndNot(left: Vector2, right: Vector2): Vector2;
    Any(vector: Vector2, value: float): boolean;
    AnyWhereAllBitsSet(vector: Vector2): boolean;
    BitwiseAnd(left: Vector2, right: Vector2): Vector2;
    BitwiseOr(left: Vector2, right: Vector2): Vector2;
    Clamp(value1: Vector2, min: Vector2, max: Vector2): Vector2;
    ClampNative(value1: Vector2, min: Vector2, max: Vector2): Vector2;
    ConditionalSelect(condition: Vector2, left: Vector2, right: Vector2): Vector2;
    CopySign(value: Vector2, sign: Vector2): Vector2;
    Cos(vector: Vector2): Vector2;
    Count(vector: Vector2, value: float): int;
    CountWhereAllBitsSet(vector: Vector2): int;
    Create(values: ReadOnlySpan_1<System_Internal.Single>): Vector2;
    Create(x: float, y: float): Vector2;
    Create(value: float): Vector2;
    CreateScalar(x: float): Vector2;
    CreateScalarUnsafe(x: float): Vector2;
    Cross(value1: Vector2, value2: Vector2): float;
    DegreesToRadians(degrees: Vector2): Vector2;
    Distance(value1: Vector2, value2: Vector2): float;
    DistanceSquared(value1: Vector2, value2: Vector2): float;
    Divide(left: Vector2, right: Vector2): Vector2;
    Divide(left: Vector2, divisor: float): Vector2;
    Dot(value1: Vector2, value2: Vector2): float;
    Equals(left: Vector2, right: Vector2): Vector2;
    EqualsAll(left: Vector2, right: Vector2): boolean;
    EqualsAny(left: Vector2, right: Vector2): boolean;
    Exp(vector: Vector2): Vector2;
    FusedMultiplyAdd(left: Vector2, right: Vector2, addend: Vector2): Vector2;
    GreaterThan(left: Vector2, right: Vector2): Vector2;
    GreaterThanAll(left: Vector2, right: Vector2): boolean;
    GreaterThanAny(left: Vector2, right: Vector2): boolean;
    GreaterThanOrEqual(left: Vector2, right: Vector2): Vector2;
    GreaterThanOrEqualAll(left: Vector2, right: Vector2): boolean;
    GreaterThanOrEqualAny(left: Vector2, right: Vector2): boolean;
    Hypot(x: Vector2, y: Vector2): Vector2;
    IndexOf(vector: Vector2, value: float): int;
    IndexOfWhereAllBitsSet(vector: Vector2): int;
    IsEvenInteger(vector: Vector2): Vector2;
    IsFinite(vector: Vector2): Vector2;
    IsInfinity(vector: Vector2): Vector2;
    IsInteger(vector: Vector2): Vector2;
    IsNaN(vector: Vector2): Vector2;
    IsNegative(vector: Vector2): Vector2;
    IsNegativeInfinity(vector: Vector2): Vector2;
    IsNormal(vector: Vector2): Vector2;
    IsOddInteger(vector: Vector2): Vector2;
    IsPositive(vector: Vector2): Vector2;
    IsPositiveInfinity(vector: Vector2): Vector2;
    IsSubnormal(vector: Vector2): Vector2;
    IsZero(vector: Vector2): Vector2;
    LastIndexOf(vector: Vector2, value: float): int;
    LastIndexOfWhereAllBitsSet(vector: Vector2): int;
    Lerp(value1: Vector2, value2: Vector2, amount: Vector2): Vector2;
    Lerp(value1: Vector2, value2: Vector2, amount: float): Vector2;
    LessThan(left: Vector2, right: Vector2): Vector2;
    LessThanAll(left: Vector2, right: Vector2): boolean;
    LessThanAny(left: Vector2, right: Vector2): boolean;
    LessThanOrEqual(left: Vector2, right: Vector2): Vector2;
    LessThanOrEqualAll(left: Vector2, right: Vector2): boolean;
    LessThanOrEqualAny(left: Vector2, right: Vector2): boolean;
    Load(source: ptr<float>): Vector2;
    LoadAligned(source: ptr<float>): Vector2;
    LoadAlignedNonTemporal(source: ptr<float>): Vector2;
    LoadUnsafe(source: float, elementOffset: nuint): Vector2;
    LoadUnsafe(source: float): Vector2;
    Log(vector: Vector2): Vector2;
    Log2(vector: Vector2): Vector2;
    Max(value1: Vector2, value2: Vector2): Vector2;
    MaxMagnitude(value1: Vector2, value2: Vector2): Vector2;
    MaxMagnitudeNumber(value1: Vector2, value2: Vector2): Vector2;
    MaxNative(value1: Vector2, value2: Vector2): Vector2;
    MaxNumber(value1: Vector2, value2: Vector2): Vector2;
    Min(value1: Vector2, value2: Vector2): Vector2;
    MinMagnitude(value1: Vector2, value2: Vector2): Vector2;
    MinMagnitudeNumber(value1: Vector2, value2: Vector2): Vector2;
    MinNative(value1: Vector2, value2: Vector2): Vector2;
    MinNumber(value1: Vector2, value2: Vector2): Vector2;
    Multiply(left: Vector2, right: Vector2): Vector2;
    Multiply(left: Vector2, right: float): Vector2;
    Multiply(left: float, right: Vector2): Vector2;
    MultiplyAddEstimate(left: Vector2, right: Vector2, addend: Vector2): Vector2;
    Negate(value: Vector2): Vector2;
    None(vector: Vector2, value: float): boolean;
    NoneWhereAllBitsSet(vector: Vector2): boolean;
    Normalize(value: Vector2): Vector2;
    OnesComplement(value: Vector2): Vector2;
    RadiansToDegrees(radians: Vector2): Vector2;
    Reflect(vector: Vector2, normal: Vector2): Vector2;
    Round(vector: Vector2, mode: MidpointRounding): Vector2;
    Round(vector: Vector2): Vector2;
    Shuffle(vector: Vector2, xIndex: byte, yIndex: byte): Vector2;
    Sin(vector: Vector2): Vector2;
    SinCos(vector: Vector2): ValueTuple_2<Vector2, Vector2>;
    SquareRoot(value: Vector2): Vector2;
    Subtract(left: Vector2, right: Vector2): Vector2;
    Sum(value: Vector2): float;
    Transform(position: Vector2, matrix: Matrix3x2): Vector2;
    Transform(position: Vector2, matrix: Matrix4x4): Vector2;
    Transform(value: Vector2, rotation: Quaternion): Vector2;
    TransformNormal(normal: Vector2, matrix: Matrix3x2): Vector2;
    TransformNormal(normal: Vector2, matrix: Matrix4x4): Vector2;
    Truncate(vector: Vector2): Vector2;
    Xor(left: Vector2, right: Vector2): Vector2;
};


export interface __Vector2$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Vector2>;
    As_IFormattable(): System_Internal.IFormattable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: Vector2): boolean;
}

export type Vector2 = Vector2$instance & __Vector2$views;


export interface Vector3$instance {
    X: float;
    Y: float;
    Z: float;
    Item: float;
    CopyTo(array: float[]): void;
    CopyTo(array: float[], index: int): void;
    CopyTo(destination: Span_1<System_Internal.Single>): void;
    Equals(obj: unknown | undefined): boolean;
    Equals(other: Vector3): boolean;
    GetHashCode(): int;
    Length(): float;
    LengthSquared(): float;
    ToString(): string;
    ToString(format: string | undefined): string;
    ToString(format: string | undefined, formatProvider: IFormatProvider | undefined): string;
    TryCopyTo(destination: Span_1<System_Internal.Single>): boolean;
}


export const Vector3: {
    new(value: float): Vector3;
    new(value: Vector2, z: float): Vector3;
    new(x: float, y: float, z: float): Vector3;
    new(values: ReadOnlySpan_1<System_Internal.Single>): Vector3;
    readonly AllBitsSet: Vector3;
    readonly E: Vector3;
    readonly Epsilon: Vector3;
    readonly NaN: Vector3;
    readonly NegativeInfinity: Vector3;
    readonly NegativeZero: Vector3;
    readonly One: Vector3;
    readonly Pi: Vector3;
    readonly PositiveInfinity: Vector3;
    readonly Tau: Vector3;
    readonly UnitX: Vector3;
    readonly UnitY: Vector3;
    readonly UnitZ: Vector3;
    readonly Zero: Vector3;
    Abs(value: Vector3): Vector3;
    Add(left: Vector3, right: Vector3): Vector3;
    All(vector: Vector3, value: float): boolean;
    AllWhereAllBitsSet(vector: Vector3): boolean;
    AndNot(left: Vector3, right: Vector3): Vector3;
    Any(vector: Vector3, value: float): boolean;
    AnyWhereAllBitsSet(vector: Vector3): boolean;
    BitwiseAnd(left: Vector3, right: Vector3): Vector3;
    BitwiseOr(left: Vector3, right: Vector3): Vector3;
    Clamp(value1: Vector3, min: Vector3, max: Vector3): Vector3;
    ClampNative(value1: Vector3, min: Vector3, max: Vector3): Vector3;
    ConditionalSelect(condition: Vector3, left: Vector3, right: Vector3): Vector3;
    CopySign(value: Vector3, sign: Vector3): Vector3;
    Cos(vector: Vector3): Vector3;
    Count(vector: Vector3, value: float): int;
    CountWhereAllBitsSet(vector: Vector3): int;
    Create(vector: Vector2, z: float): Vector3;
    Create(values: ReadOnlySpan_1<System_Internal.Single>): Vector3;
    Create(x: float, y: float, z: float): Vector3;
    Create(value: float): Vector3;
    CreateScalar(x: float): Vector3;
    CreateScalarUnsafe(x: float): Vector3;
    Cross(vector1: Vector3, vector2: Vector3): Vector3;
    DegreesToRadians(degrees: Vector3): Vector3;
    Distance(value1: Vector3, value2: Vector3): float;
    DistanceSquared(value1: Vector3, value2: Vector3): float;
    Divide(left: Vector3, right: Vector3): Vector3;
    Divide(left: Vector3, divisor: float): Vector3;
    Dot(vector1: Vector3, vector2: Vector3): float;
    Equals(left: Vector3, right: Vector3): Vector3;
    EqualsAll(left: Vector3, right: Vector3): boolean;
    EqualsAny(left: Vector3, right: Vector3): boolean;
    Exp(vector: Vector3): Vector3;
    FusedMultiplyAdd(left: Vector3, right: Vector3, addend: Vector3): Vector3;
    GreaterThan(left: Vector3, right: Vector3): Vector3;
    GreaterThanAll(left: Vector3, right: Vector3): boolean;
    GreaterThanAny(left: Vector3, right: Vector3): boolean;
    GreaterThanOrEqual(left: Vector3, right: Vector3): Vector3;
    GreaterThanOrEqualAll(left: Vector3, right: Vector3): boolean;
    GreaterThanOrEqualAny(left: Vector3, right: Vector3): boolean;
    Hypot(x: Vector3, y: Vector3): Vector3;
    IndexOf(vector: Vector3, value: float): int;
    IndexOfWhereAllBitsSet(vector: Vector3): int;
    IsEvenInteger(vector: Vector3): Vector3;
    IsFinite(vector: Vector3): Vector3;
    IsInfinity(vector: Vector3): Vector3;
    IsInteger(vector: Vector3): Vector3;
    IsNaN(vector: Vector3): Vector3;
    IsNegative(vector: Vector3): Vector3;
    IsNegativeInfinity(vector: Vector3): Vector3;
    IsNormal(vector: Vector3): Vector3;
    IsOddInteger(vector: Vector3): Vector3;
    IsPositive(vector: Vector3): Vector3;
    IsPositiveInfinity(vector: Vector3): Vector3;
    IsSubnormal(vector: Vector3): Vector3;
    IsZero(vector: Vector3): Vector3;
    LastIndexOf(vector: Vector3, value: float): int;
    LastIndexOfWhereAllBitsSet(vector: Vector3): int;
    Lerp(value1: Vector3, value2: Vector3, amount: Vector3): Vector3;
    Lerp(value1: Vector3, value2: Vector3, amount: float): Vector3;
    LessThan(left: Vector3, right: Vector3): Vector3;
    LessThanAll(left: Vector3, right: Vector3): boolean;
    LessThanAny(left: Vector3, right: Vector3): boolean;
    LessThanOrEqual(left: Vector3, right: Vector3): Vector3;
    LessThanOrEqualAll(left: Vector3, right: Vector3): boolean;
    LessThanOrEqualAny(left: Vector3, right: Vector3): boolean;
    Load(source: ptr<float>): Vector3;
    LoadAligned(source: ptr<float>): Vector3;
    LoadAlignedNonTemporal(source: ptr<float>): Vector3;
    LoadUnsafe(source: float, elementOffset: nuint): Vector3;
    LoadUnsafe(source: float): Vector3;
    Log(vector: Vector3): Vector3;
    Log2(vector: Vector3): Vector3;
    Max(value1: Vector3, value2: Vector3): Vector3;
    MaxMagnitude(value1: Vector3, value2: Vector3): Vector3;
    MaxMagnitudeNumber(value1: Vector3, value2: Vector3): Vector3;
    MaxNative(value1: Vector3, value2: Vector3): Vector3;
    MaxNumber(value1: Vector3, value2: Vector3): Vector3;
    Min(value1: Vector3, value2: Vector3): Vector3;
    MinMagnitude(value1: Vector3, value2: Vector3): Vector3;
    MinMagnitudeNumber(value1: Vector3, value2: Vector3): Vector3;
    MinNative(value1: Vector3, value2: Vector3): Vector3;
    MinNumber(value1: Vector3, value2: Vector3): Vector3;
    Multiply(left: Vector3, right: Vector3): Vector3;
    Multiply(left: Vector3, right: float): Vector3;
    Multiply(left: float, right: Vector3): Vector3;
    MultiplyAddEstimate(left: Vector3, right: Vector3, addend: Vector3): Vector3;
    Negate(value: Vector3): Vector3;
    None(vector: Vector3, value: float): boolean;
    NoneWhereAllBitsSet(vector: Vector3): boolean;
    Normalize(value: Vector3): Vector3;
    OnesComplement(value: Vector3): Vector3;
    RadiansToDegrees(radians: Vector3): Vector3;
    Reflect(vector: Vector3, normal: Vector3): Vector3;
    Round(vector: Vector3, mode: MidpointRounding): Vector3;
    Round(vector: Vector3): Vector3;
    Shuffle(vector: Vector3, xIndex: byte, yIndex: byte, zIndex: byte): Vector3;
    Sin(vector: Vector3): Vector3;
    SinCos(vector: Vector3): ValueTuple_2<Vector3, Vector3>;
    SquareRoot(value: Vector3): Vector3;
    Subtract(left: Vector3, right: Vector3): Vector3;
    Sum(value: Vector3): float;
    Transform(position: Vector3, matrix: Matrix4x4): Vector3;
    Transform(value: Vector3, rotation: Quaternion): Vector3;
    TransformNormal(normal: Vector3, matrix: Matrix4x4): Vector3;
    Truncate(vector: Vector3): Vector3;
    Xor(left: Vector3, right: Vector3): Vector3;
};


export interface __Vector3$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Vector3>;
    As_IFormattable(): System_Internal.IFormattable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: Vector3): boolean;
}

export type Vector3 = Vector3$instance & __Vector3$views;


export interface Vector4$instance {
    X: float;
    Y: float;
    Z: float;
    W: float;
    Item: float;
    CopyTo(array: float[]): void;
    CopyTo(array: float[], index: int): void;
    CopyTo(destination: Span_1<System_Internal.Single>): void;
    Equals(other: Vector4): boolean;
    Equals(obj: unknown | undefined): boolean;
    GetHashCode(): int;
    Length(): float;
    LengthSquared(): float;
    ToString(): string;
    ToString(format: string | undefined): string;
    ToString(format: string | undefined, formatProvider: IFormatProvider | undefined): string;
    TryCopyTo(destination: Span_1<System_Internal.Single>): boolean;
}


export const Vector4: {
    new(value: float): Vector4;
    new(value: Vector2, z: float, w: float): Vector4;
    new(value: Vector3, w: float): Vector4;
    new(x: float, y: float, z: float, w: float): Vector4;
    new(values: ReadOnlySpan_1<System_Internal.Single>): Vector4;
    readonly AllBitsSet: Vector4;
    readonly E: Vector4;
    readonly Epsilon: Vector4;
    readonly NaN: Vector4;
    readonly NegativeInfinity: Vector4;
    readonly NegativeZero: Vector4;
    readonly One: Vector4;
    readonly Pi: Vector4;
    readonly PositiveInfinity: Vector4;
    readonly Tau: Vector4;
    readonly UnitX: Vector4;
    readonly UnitY: Vector4;
    readonly UnitZ: Vector4;
    readonly UnitW: Vector4;
    readonly Zero: Vector4;
    Abs(value: Vector4): Vector4;
    Add(left: Vector4, right: Vector4): Vector4;
    All(vector: Vector4, value: float): boolean;
    AllWhereAllBitsSet(vector: Vector4): boolean;
    AndNot(left: Vector4, right: Vector4): Vector4;
    Any(vector: Vector4, value: float): boolean;
    AnyWhereAllBitsSet(vector: Vector4): boolean;
    BitwiseAnd(left: Vector4, right: Vector4): Vector4;
    BitwiseOr(left: Vector4, right: Vector4): Vector4;
    Clamp(value1: Vector4, min: Vector4, max: Vector4): Vector4;
    ClampNative(value1: Vector4, min: Vector4, max: Vector4): Vector4;
    ConditionalSelect(condition: Vector4, left: Vector4, right: Vector4): Vector4;
    CopySign(value: Vector4, sign: Vector4): Vector4;
    Cos(vector: Vector4): Vector4;
    Count(vector: Vector4, value: float): int;
    CountWhereAllBitsSet(vector: Vector4): int;
    Create(vector: Vector2, z: float, w: float): Vector4;
    Create(vector: Vector3, w: float): Vector4;
    Create(values: ReadOnlySpan_1<System_Internal.Single>): Vector4;
    Create(x: float, y: float, z: float, w: float): Vector4;
    Create(value: float): Vector4;
    CreateScalar(x: float): Vector4;
    CreateScalarUnsafe(x: float): Vector4;
    Cross(vector1: Vector4, vector2: Vector4): Vector4;
    DegreesToRadians(degrees: Vector4): Vector4;
    Distance(value1: Vector4, value2: Vector4): float;
    DistanceSquared(value1: Vector4, value2: Vector4): float;
    Divide(left: Vector4, right: Vector4): Vector4;
    Divide(left: Vector4, divisor: float): Vector4;
    Dot(vector1: Vector4, vector2: Vector4): float;
    Equals(left: Vector4, right: Vector4): Vector4;
    EqualsAll(left: Vector4, right: Vector4): boolean;
    EqualsAny(left: Vector4, right: Vector4): boolean;
    Exp(vector: Vector4): Vector4;
    FusedMultiplyAdd(left: Vector4, right: Vector4, addend: Vector4): Vector4;
    GreaterThan(left: Vector4, right: Vector4): Vector4;
    GreaterThanAll(left: Vector4, right: Vector4): boolean;
    GreaterThanAny(left: Vector4, right: Vector4): boolean;
    GreaterThanOrEqual(left: Vector4, right: Vector4): Vector4;
    GreaterThanOrEqualAll(left: Vector4, right: Vector4): boolean;
    GreaterThanOrEqualAny(left: Vector4, right: Vector4): boolean;
    Hypot(x: Vector4, y: Vector4): Vector4;
    IndexOf(vector: Vector4, value: float): int;
    IndexOfWhereAllBitsSet(vector: Vector4): int;
    IsEvenInteger(vector: Vector4): Vector4;
    IsFinite(vector: Vector4): Vector4;
    IsInfinity(vector: Vector4): Vector4;
    IsInteger(vector: Vector4): Vector4;
    IsNaN(vector: Vector4): Vector4;
    IsNegative(vector: Vector4): Vector4;
    IsNegativeInfinity(vector: Vector4): Vector4;
    IsNormal(vector: Vector4): Vector4;
    IsOddInteger(vector: Vector4): Vector4;
    IsPositive(vector: Vector4): Vector4;
    IsPositiveInfinity(vector: Vector4): Vector4;
    IsSubnormal(vector: Vector4): Vector4;
    IsZero(vector: Vector4): Vector4;
    LastIndexOf(vector: Vector4, value: float): int;
    LastIndexOfWhereAllBitsSet(vector: Vector4): int;
    Lerp(value1: Vector4, value2: Vector4, amount: Vector4): Vector4;
    Lerp(value1: Vector4, value2: Vector4, amount: float): Vector4;
    LessThan(left: Vector4, right: Vector4): Vector4;
    LessThanAll(left: Vector4, right: Vector4): boolean;
    LessThanAny(left: Vector4, right: Vector4): boolean;
    LessThanOrEqual(left: Vector4, right: Vector4): Vector4;
    LessThanOrEqualAll(left: Vector4, right: Vector4): boolean;
    LessThanOrEqualAny(left: Vector4, right: Vector4): boolean;
    Load(source: ptr<float>): Vector4;
    LoadAligned(source: ptr<float>): Vector4;
    LoadAlignedNonTemporal(source: ptr<float>): Vector4;
    LoadUnsafe(source: float, elementOffset: nuint): Vector4;
    LoadUnsafe(source: float): Vector4;
    Log(vector: Vector4): Vector4;
    Log2(vector: Vector4): Vector4;
    Max(value1: Vector4, value2: Vector4): Vector4;
    MaxMagnitude(value1: Vector4, value2: Vector4): Vector4;
    MaxMagnitudeNumber(value1: Vector4, value2: Vector4): Vector4;
    MaxNative(value1: Vector4, value2: Vector4): Vector4;
    MaxNumber(value1: Vector4, value2: Vector4): Vector4;
    Min(value1: Vector4, value2: Vector4): Vector4;
    MinMagnitude(value1: Vector4, value2: Vector4): Vector4;
    MinMagnitudeNumber(value1: Vector4, value2: Vector4): Vector4;
    MinNative(value1: Vector4, value2: Vector4): Vector4;
    MinNumber(value1: Vector4, value2: Vector4): Vector4;
    Multiply(left: Vector4, right: Vector4): Vector4;
    Multiply(left: Vector4, right: float): Vector4;
    Multiply(left: float, right: Vector4): Vector4;
    MultiplyAddEstimate(left: Vector4, right: Vector4, addend: Vector4): Vector4;
    Negate(value: Vector4): Vector4;
    None(vector: Vector4, value: float): boolean;
    NoneWhereAllBitsSet(vector: Vector4): boolean;
    Normalize(vector: Vector4): Vector4;
    OnesComplement(value: Vector4): Vector4;
    RadiansToDegrees(radians: Vector4): Vector4;
    Round(vector: Vector4, mode: MidpointRounding): Vector4;
    Round(vector: Vector4): Vector4;
    Shuffle(vector: Vector4, xIndex: byte, yIndex: byte, zIndex: byte, wIndex: byte): Vector4;
    Sin(vector: Vector4): Vector4;
    SinCos(vector: Vector4): ValueTuple_2<Vector4, Vector4>;
    SquareRoot(value: Vector4): Vector4;
    Subtract(left: Vector4, right: Vector4): Vector4;
    Sum(value: Vector4): float;
    Transform(position: Vector2, matrix: Matrix4x4): Vector4;
    Transform(value: Vector2, rotation: Quaternion): Vector4;
    Transform(position: Vector3, matrix: Matrix4x4): Vector4;
    Transform(value: Vector3, rotation: Quaternion): Vector4;
    Transform(vector: Vector4, matrix: Matrix4x4): Vector4;
    Transform(value: Vector4, rotation: Quaternion): Vector4;
    Truncate(vector: Vector4): Vector4;
    Xor(left: Vector4, right: Vector4): Vector4;
};


export interface __Vector4$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Vector4>;
    As_IFormattable(): System_Internal.IFormattable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: Vector4): boolean;
}

export type Vector4 = Vector4$instance & __Vector4$views;


export abstract class BitOperations$instance {
    static Crc32C(crc: uint, data: byte): uint;
    static Crc32C(crc: uint, data: ushort): uint;
    static Crc32C(crc: uint, data: uint): uint;
    static Crc32C(crc: uint, data: ulong): uint;
    static IsPow2(value: int): boolean;
    static IsPow2(value: long): boolean;
    static IsPow2(value: nint): boolean;
    static IsPow2(value: uint): boolean;
    static IsPow2(value: ulong): boolean;
    static IsPow2(value: nuint): boolean;
    static LeadingZeroCount(value: uint): int;
    static LeadingZeroCount(value: ulong): int;
    static LeadingZeroCount(value: nuint): int;
    static Log2(value: uint): int;
    static Log2(value: ulong): int;
    static Log2(value: nuint): int;
    static PopCount(value: uint): int;
    static PopCount(value: ulong): int;
    static PopCount(value: nuint): int;
    static RotateLeft(value: uint, offset: int): uint;
    static RotateLeft(value: ulong, offset: int): ulong;
    static RotateLeft(value: nuint, offset: int): nuint;
    static RotateRight(value: uint, offset: int): uint;
    static RotateRight(value: ulong, offset: int): ulong;
    static RotateRight(value: nuint, offset: int): nuint;
    static RoundUpToPowerOf2(value: uint): uint;
    static RoundUpToPowerOf2(value: ulong): ulong;
    static RoundUpToPowerOf2(value: nuint): nuint;
    static TrailingZeroCount(value: int): int;
    static TrailingZeroCount(value: long): int;
    static TrailingZeroCount(value: nint): int;
    static TrailingZeroCount(value: uint): int;
    static TrailingZeroCount(value: ulong): int;
    static TrailingZeroCount(value: nuint): int;
}


export type BitOperations = BitOperations$instance;

export abstract class Vector$instance {
    static readonly IsHardwareAccelerated: boolean;
    static Abs<T>(value: Vector_1<T>): Vector_1<T>;
    static Add<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static AddSaturate<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static All<T>(vector: Vector_1<T>, value: T): boolean;
    static AllWhereAllBitsSet<T>(vector: Vector_1<T>): boolean;
    static AndNot<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static Any<T>(vector: Vector_1<T>, value: T): boolean;
    static AnyWhereAllBitsSet<T>(vector: Vector_1<T>): boolean;
    static As<TFrom, TTo>(vector: Vector_1<TFrom>): Vector_1<TTo>;
    static AsPlane(value: Vector4): Plane;
    static AsQuaternion(value: Vector4): Quaternion;
    static AsVector2(value: Vector3): Vector2;
    static AsVector2(value: Vector4): Vector2;
    static AsVector3(value: Vector2): Vector3;
    static AsVector3(value: Vector4): Vector3;
    static AsVector3Unsafe(value: Vector2): Vector3;
    static AsVector4(value: Plane): Vector4;
    static AsVector4(value: Quaternion): Vector4;
    static AsVector4(value: Vector2): Vector4;
    static AsVector4(value: Vector3): Vector4;
    static AsVector4Unsafe(value: Vector2): Vector4;
    static AsVector4Unsafe(value: Vector3): Vector4;
    static AsVectorByte<T>(value: Vector_1<T>): Vector_1<System_Internal.Byte>;
    static AsVectorDouble<T>(value: Vector_1<T>): Vector_1<System_Internal.Double>;
    static AsVectorInt16<T>(value: Vector_1<T>): Vector_1<System_Internal.Int16>;
    static AsVectorInt32<T>(value: Vector_1<T>): Vector_1<System_Internal.Int32>;
    static AsVectorInt64<T>(value: Vector_1<T>): Vector_1<System_Internal.Int64>;
    static AsVectorNInt<T>(value: Vector_1<T>): Vector_1<System_Internal.IntPtr>;
    static AsVectorNUInt<T>(value: Vector_1<T>): Vector_1<System_Internal.UIntPtr>;
    static AsVectorSByte<T>(value: Vector_1<T>): Vector_1<System_Internal.SByte>;
    static AsVectorSingle<T>(value: Vector_1<T>): Vector_1<System_Internal.Single>;
    static AsVectorUInt16<T>(value: Vector_1<T>): Vector_1<System_Internal.UInt16>;
    static AsVectorUInt32<T>(value: Vector_1<T>): Vector_1<System_Internal.UInt32>;
    static AsVectorUInt64<T>(value: Vector_1<T>): Vector_1<System_Internal.UInt64>;
    static BitwiseAnd<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static BitwiseOr<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static Ceiling(value: Vector_1<System_Internal.Double>): Vector_1<System_Internal.Double>;
    static Ceiling(value: Vector_1<System_Internal.Single>): Vector_1<System_Internal.Single>;
    static Clamp<T>(value: Vector_1<T>, min: Vector_1<T>, max: Vector_1<T>): Vector_1<T>;
    static ClampNative<T>(value: Vector_1<T>, min: Vector_1<T>, max: Vector_1<T>): Vector_1<T>;
    static ConditionalSelect(condition: Vector_1<System_Internal.Int32>, left: Vector_1<System_Internal.Single>, right: Vector_1<System_Internal.Single>): Vector_1<System_Internal.Single>;
    static ConditionalSelect(condition: Vector_1<System_Internal.Int64>, left: Vector_1<System_Internal.Double>, right: Vector_1<System_Internal.Double>): Vector_1<System_Internal.Double>;
    static ConditionalSelect<T>(condition: Vector_1<T>, left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static ConvertToDouble(value: Vector_1<System_Internal.Int64>): Vector_1<System_Internal.Double>;
    static ConvertToDouble(value: Vector_1<System_Internal.UInt64>): Vector_1<System_Internal.Double>;
    static ConvertToInt32(value: Vector_1<System_Internal.Single>): Vector_1<System_Internal.Int32>;
    static ConvertToInt32Native(value: Vector_1<System_Internal.Single>): Vector_1<System_Internal.Int32>;
    static ConvertToInt64(value: Vector_1<System_Internal.Double>): Vector_1<System_Internal.Int64>;
    static ConvertToInt64Native(value: Vector_1<System_Internal.Double>): Vector_1<System_Internal.Int64>;
    static ConvertToSingle(value: Vector_1<System_Internal.Int32>): Vector_1<System_Internal.Single>;
    static ConvertToSingle(value: Vector_1<System_Internal.UInt32>): Vector_1<System_Internal.Single>;
    static ConvertToUInt32(value: Vector_1<System_Internal.Single>): Vector_1<System_Internal.UInt32>;
    static ConvertToUInt32Native(value: Vector_1<System_Internal.Single>): Vector_1<System_Internal.UInt32>;
    static ConvertToUInt64(value: Vector_1<System_Internal.Double>): Vector_1<System_Internal.UInt64>;
    static ConvertToUInt64Native(value: Vector_1<System_Internal.Double>): Vector_1<System_Internal.UInt64>;
    static CopySign<T>(value: Vector_1<T>, sign: Vector_1<T>): Vector_1<T>;
    static Cos(vector: Vector_1<System_Internal.Double>): Vector_1<System_Internal.Double>;
    static Cos(vector: Vector_1<System_Internal.Single>): Vector_1<System_Internal.Single>;
    static Count<T>(vector: Vector_1<T>, value: T): int;
    static CountWhereAllBitsSet<T>(vector: Vector_1<T>): int;
    static Create<T>(values: ReadOnlySpan_1<T>): Vector_1<T>;
    static Create<T>(value: T): Vector_1<T>;
    static CreateScalar<T>(value: T): Vector_1<T>;
    static CreateScalarUnsafe<T>(value: T): Vector_1<T>;
    static CreateSequence<T>(start: T, step: T): Vector_1<T>;
    static DegreesToRadians(degrees: Vector_1<System_Internal.Double>): Vector_1<System_Internal.Double>;
    static DegreesToRadians(degrees: Vector_1<System_Internal.Single>): Vector_1<System_Internal.Single>;
    static Divide<T>(left: Vector_1<T>, right: T): Vector_1<T>;
    static Divide<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static Dot<T>(left: Vector_1<T>, right: Vector_1<T>): T;
    static Equals(left: Vector_1<System_Internal.Double>, right: Vector_1<System_Internal.Double>): Vector_1<System_Internal.Int64>;
    static Equals(left: Vector_1<System_Internal.Int32>, right: Vector_1<System_Internal.Int32>): Vector_1<System_Internal.Int32>;
    static Equals(left: Vector_1<System_Internal.Int64>, right: Vector_1<System_Internal.Int64>): Vector_1<System_Internal.Int64>;
    static Equals(left: Vector_1<System_Internal.Single>, right: Vector_1<System_Internal.Single>): Vector_1<System_Internal.Int32>;
    static Equals<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static EqualsAll<T>(left: Vector_1<T>, right: Vector_1<T>): boolean;
    static EqualsAny<T>(left: Vector_1<T>, right: Vector_1<T>): boolean;
    static Exp(vector: Vector_1<System_Internal.Double>): Vector_1<System_Internal.Double>;
    static Exp(vector: Vector_1<System_Internal.Single>): Vector_1<System_Internal.Single>;
    static ExtractMostSignificantBits(vector: Vector2): uint;
    static ExtractMostSignificantBits(vector: Vector3): uint;
    static ExtractMostSignificantBits(vector: Vector4): uint;
    static Floor(value: Vector_1<System_Internal.Double>): Vector_1<System_Internal.Double>;
    static Floor(value: Vector_1<System_Internal.Single>): Vector_1<System_Internal.Single>;
    static FusedMultiplyAdd(left: Vector_1<System_Internal.Double>, right: Vector_1<System_Internal.Double>, addend: Vector_1<System_Internal.Double>): Vector_1<System_Internal.Double>;
    static FusedMultiplyAdd(left: Vector_1<System_Internal.Single>, right: Vector_1<System_Internal.Single>, addend: Vector_1<System_Internal.Single>): Vector_1<System_Internal.Single>;
    static GetElement(vector: Vector2, index: int): float;
    static GetElement(vector: Vector3, index: int): float;
    static GetElement(vector: Vector4, index: int): float;
    static GetElement<T>(vector: Vector_1<T>, index: int): T;
    static GreaterThan(left: Vector_1<System_Internal.Double>, right: Vector_1<System_Internal.Double>): Vector_1<System_Internal.Int64>;
    static GreaterThan(left: Vector_1<System_Internal.Int32>, right: Vector_1<System_Internal.Int32>): Vector_1<System_Internal.Int32>;
    static GreaterThan(left: Vector_1<System_Internal.Int64>, right: Vector_1<System_Internal.Int64>): Vector_1<System_Internal.Int64>;
    static GreaterThan(left: Vector_1<System_Internal.Single>, right: Vector_1<System_Internal.Single>): Vector_1<System_Internal.Int32>;
    static GreaterThan<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static GreaterThanAll<T>(left: Vector_1<T>, right: Vector_1<T>): boolean;
    static GreaterThanAny<T>(left: Vector_1<T>, right: Vector_1<T>): boolean;
    static GreaterThanOrEqual(left: Vector_1<System_Internal.Double>, right: Vector_1<System_Internal.Double>): Vector_1<System_Internal.Int64>;
    static GreaterThanOrEqual(left: Vector_1<System_Internal.Int32>, right: Vector_1<System_Internal.Int32>): Vector_1<System_Internal.Int32>;
    static GreaterThanOrEqual(left: Vector_1<System_Internal.Int64>, right: Vector_1<System_Internal.Int64>): Vector_1<System_Internal.Int64>;
    static GreaterThanOrEqual(left: Vector_1<System_Internal.Single>, right: Vector_1<System_Internal.Single>): Vector_1<System_Internal.Int32>;
    static GreaterThanOrEqual<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static GreaterThanOrEqualAll<T>(left: Vector_1<T>, right: Vector_1<T>): boolean;
    static GreaterThanOrEqualAny<T>(left: Vector_1<T>, right: Vector_1<T>): boolean;
    static Hypot(x: Vector_1<System_Internal.Double>, y: Vector_1<System_Internal.Double>): Vector_1<System_Internal.Double>;
    static Hypot(x: Vector_1<System_Internal.Single>, y: Vector_1<System_Internal.Single>): Vector_1<System_Internal.Single>;
    static IndexOf<T>(vector: Vector_1<T>, value: T): int;
    static IndexOfWhereAllBitsSet<T>(vector: Vector_1<T>): int;
    static IsEvenInteger<T>(vector: Vector_1<T>): Vector_1<T>;
    static IsFinite<T>(vector: Vector_1<T>): Vector_1<T>;
    static IsInfinity<T>(vector: Vector_1<T>): Vector_1<T>;
    static IsInteger<T>(vector: Vector_1<T>): Vector_1<T>;
    static IsNaN<T>(vector: Vector_1<T>): Vector_1<T>;
    static IsNegative<T>(vector: Vector_1<T>): Vector_1<T>;
    static IsNegativeInfinity<T>(vector: Vector_1<T>): Vector_1<T>;
    static IsNormal<T>(vector: Vector_1<T>): Vector_1<T>;
    static IsOddInteger<T>(vector: Vector_1<T>): Vector_1<T>;
    static IsPositive<T>(vector: Vector_1<T>): Vector_1<T>;
    static IsPositiveInfinity<T>(vector: Vector_1<T>): Vector_1<T>;
    static IsSubnormal<T>(vector: Vector_1<T>): Vector_1<T>;
    static IsZero<T>(vector: Vector_1<T>): Vector_1<T>;
    static LastIndexOf<T>(vector: Vector_1<T>, value: T): int;
    static LastIndexOfWhereAllBitsSet<T>(vector: Vector_1<T>): int;
    static Lerp(x: Vector_1<System_Internal.Double>, y: Vector_1<System_Internal.Double>, amount: Vector_1<System_Internal.Double>): Vector_1<System_Internal.Double>;
    static Lerp(x: Vector_1<System_Internal.Single>, y: Vector_1<System_Internal.Single>, amount: Vector_1<System_Internal.Single>): Vector_1<System_Internal.Single>;
    static LessThan(left: Vector_1<System_Internal.Double>, right: Vector_1<System_Internal.Double>): Vector_1<System_Internal.Int64>;
    static LessThan(left: Vector_1<System_Internal.Int32>, right: Vector_1<System_Internal.Int32>): Vector_1<System_Internal.Int32>;
    static LessThan(left: Vector_1<System_Internal.Int64>, right: Vector_1<System_Internal.Int64>): Vector_1<System_Internal.Int64>;
    static LessThan(left: Vector_1<System_Internal.Single>, right: Vector_1<System_Internal.Single>): Vector_1<System_Internal.Int32>;
    static LessThan<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static LessThanAll<T>(left: Vector_1<T>, right: Vector_1<T>): boolean;
    static LessThanAny<T>(left: Vector_1<T>, right: Vector_1<T>): boolean;
    static LessThanOrEqual(left: Vector_1<System_Internal.Double>, right: Vector_1<System_Internal.Double>): Vector_1<System_Internal.Int64>;
    static LessThanOrEqual(left: Vector_1<System_Internal.Int32>, right: Vector_1<System_Internal.Int32>): Vector_1<System_Internal.Int32>;
    static LessThanOrEqual(left: Vector_1<System_Internal.Int64>, right: Vector_1<System_Internal.Int64>): Vector_1<System_Internal.Int64>;
    static LessThanOrEqual(left: Vector_1<System_Internal.Single>, right: Vector_1<System_Internal.Single>): Vector_1<System_Internal.Int32>;
    static LessThanOrEqual<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static LessThanOrEqualAll<T>(left: Vector_1<T>, right: Vector_1<T>): boolean;
    static LessThanOrEqualAny<T>(left: Vector_1<T>, right: Vector_1<T>): boolean;
    static Load<T>(source: ptr<T>): Vector_1<T>;
    static LoadAligned<T>(source: ptr<T>): Vector_1<T>;
    static LoadAlignedNonTemporal<T>(source: ptr<T>): Vector_1<T>;
    static LoadUnsafe<T>(source: T, elementOffset: nuint): Vector_1<T>;
    static LoadUnsafe<T>(source: T): Vector_1<T>;
    static Log(vector: Vector_1<System_Internal.Double>): Vector_1<System_Internal.Double>;
    static Log(vector: Vector_1<System_Internal.Single>): Vector_1<System_Internal.Single>;
    static Log2(vector: Vector_1<System_Internal.Double>): Vector_1<System_Internal.Double>;
    static Log2(vector: Vector_1<System_Internal.Single>): Vector_1<System_Internal.Single>;
    static Max<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static MaxMagnitude<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static MaxMagnitudeNumber<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static MaxNative<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static MaxNumber<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static Min<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static MinMagnitude<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static MinMagnitudeNumber<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static MinNative<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static MinNumber<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static Multiply<T>(left: T, right: Vector_1<T>): Vector_1<T>;
    static Multiply<T>(left: Vector_1<T>, right: T): Vector_1<T>;
    static Multiply<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static MultiplyAddEstimate(left: Vector_1<System_Internal.Double>, right: Vector_1<System_Internal.Double>, addend: Vector_1<System_Internal.Double>): Vector_1<System_Internal.Double>;
    static MultiplyAddEstimate(left: Vector_1<System_Internal.Single>, right: Vector_1<System_Internal.Single>, addend: Vector_1<System_Internal.Single>): Vector_1<System_Internal.Single>;
    static Narrow(low: Vector_1<System_Internal.Double>, high: Vector_1<System_Internal.Double>): Vector_1<System_Internal.Single>;
    static Narrow(low: Vector_1<System_Internal.Int16>, high: Vector_1<System_Internal.Int16>): Vector_1<System_Internal.SByte>;
    static Narrow(low: Vector_1<System_Internal.Int32>, high: Vector_1<System_Internal.Int32>): Vector_1<System_Internal.Int16>;
    static Narrow(low: Vector_1<System_Internal.Int64>, high: Vector_1<System_Internal.Int64>): Vector_1<System_Internal.Int32>;
    static Narrow(low: Vector_1<System_Internal.UInt16>, high: Vector_1<System_Internal.UInt16>): Vector_1<System_Internal.Byte>;
    static Narrow(low: Vector_1<System_Internal.UInt32>, high: Vector_1<System_Internal.UInt32>): Vector_1<System_Internal.UInt16>;
    static Narrow(low: Vector_1<System_Internal.UInt64>, high: Vector_1<System_Internal.UInt64>): Vector_1<System_Internal.UInt32>;
    static NarrowWithSaturation(low: Vector_1<System_Internal.Double>, high: Vector_1<System_Internal.Double>): Vector_1<System_Internal.Single>;
    static NarrowWithSaturation(low: Vector_1<System_Internal.Int16>, high: Vector_1<System_Internal.Int16>): Vector_1<System_Internal.SByte>;
    static NarrowWithSaturation(low: Vector_1<System_Internal.Int32>, high: Vector_1<System_Internal.Int32>): Vector_1<System_Internal.Int16>;
    static NarrowWithSaturation(low: Vector_1<System_Internal.Int64>, high: Vector_1<System_Internal.Int64>): Vector_1<System_Internal.Int32>;
    static NarrowWithSaturation(low: Vector_1<System_Internal.UInt16>, high: Vector_1<System_Internal.UInt16>): Vector_1<System_Internal.Byte>;
    static NarrowWithSaturation(low: Vector_1<System_Internal.UInt32>, high: Vector_1<System_Internal.UInt32>): Vector_1<System_Internal.UInt16>;
    static NarrowWithSaturation(low: Vector_1<System_Internal.UInt64>, high: Vector_1<System_Internal.UInt64>): Vector_1<System_Internal.UInt32>;
    static Negate<T>(value: Vector_1<T>): Vector_1<T>;
    static None<T>(vector: Vector_1<T>, value: T): boolean;
    static NoneWhereAllBitsSet<T>(vector: Vector_1<T>): boolean;
    static OnesComplement<T>(value: Vector_1<T>): Vector_1<T>;
    static RadiansToDegrees(radians: Vector_1<System_Internal.Double>): Vector_1<System_Internal.Double>;
    static RadiansToDegrees(radians: Vector_1<System_Internal.Single>): Vector_1<System_Internal.Single>;
    static Round(vector: Vector_1<System_Internal.Double>, mode: MidpointRounding): Vector_1<System_Internal.Double>;
    static Round(vector: Vector_1<System_Internal.Double>): Vector_1<System_Internal.Double>;
    static Round(vector: Vector_1<System_Internal.Single>, mode: MidpointRounding): Vector_1<System_Internal.Single>;
    static Round(vector: Vector_1<System_Internal.Single>): Vector_1<System_Internal.Single>;
    static ShiftLeft(value: Vector_1<System_Internal.Byte>, shiftCount: int): Vector_1<System_Internal.Byte>;
    static ShiftLeft(value: Vector_1<System_Internal.Int16>, shiftCount: int): Vector_1<System_Internal.Int16>;
    static ShiftLeft(value: Vector_1<System_Internal.Int32>, shiftCount: int): Vector_1<System_Internal.Int32>;
    static ShiftLeft(value: Vector_1<System_Internal.Int64>, shiftCount: int): Vector_1<System_Internal.Int64>;
    static ShiftLeft(value: Vector_1<System_Internal.IntPtr>, shiftCount: int): Vector_1<System_Internal.IntPtr>;
    static ShiftLeft(value: Vector_1<System_Internal.SByte>, shiftCount: int): Vector_1<System_Internal.SByte>;
    static ShiftLeft(value: Vector_1<System_Internal.UInt16>, shiftCount: int): Vector_1<System_Internal.UInt16>;
    static ShiftLeft(value: Vector_1<System_Internal.UInt32>, shiftCount: int): Vector_1<System_Internal.UInt32>;
    static ShiftLeft(value: Vector_1<System_Internal.UInt64>, shiftCount: int): Vector_1<System_Internal.UInt64>;
    static ShiftLeft(value: Vector_1<System_Internal.UIntPtr>, shiftCount: int): Vector_1<System_Internal.UIntPtr>;
    static ShiftRightArithmetic(value: Vector_1<System_Internal.Int16>, shiftCount: int): Vector_1<System_Internal.Int16>;
    static ShiftRightArithmetic(value: Vector_1<System_Internal.Int32>, shiftCount: int): Vector_1<System_Internal.Int32>;
    static ShiftRightArithmetic(value: Vector_1<System_Internal.Int64>, shiftCount: int): Vector_1<System_Internal.Int64>;
    static ShiftRightArithmetic(value: Vector_1<System_Internal.IntPtr>, shiftCount: int): Vector_1<System_Internal.IntPtr>;
    static ShiftRightArithmetic(value: Vector_1<System_Internal.SByte>, shiftCount: int): Vector_1<System_Internal.SByte>;
    static ShiftRightLogical(value: Vector_1<System_Internal.Byte>, shiftCount: int): Vector_1<System_Internal.Byte>;
    static ShiftRightLogical(value: Vector_1<System_Internal.Int16>, shiftCount: int): Vector_1<System_Internal.Int16>;
    static ShiftRightLogical(value: Vector_1<System_Internal.Int32>, shiftCount: int): Vector_1<System_Internal.Int32>;
    static ShiftRightLogical(value: Vector_1<System_Internal.Int64>, shiftCount: int): Vector_1<System_Internal.Int64>;
    static ShiftRightLogical(value: Vector_1<System_Internal.IntPtr>, shiftCount: int): Vector_1<System_Internal.IntPtr>;
    static ShiftRightLogical(value: Vector_1<System_Internal.SByte>, shiftCount: int): Vector_1<System_Internal.SByte>;
    static ShiftRightLogical(value: Vector_1<System_Internal.UInt16>, shiftCount: int): Vector_1<System_Internal.UInt16>;
    static ShiftRightLogical(value: Vector_1<System_Internal.UInt32>, shiftCount: int): Vector_1<System_Internal.UInt32>;
    static ShiftRightLogical(value: Vector_1<System_Internal.UInt64>, shiftCount: int): Vector_1<System_Internal.UInt64>;
    static ShiftRightLogical(value: Vector_1<System_Internal.UIntPtr>, shiftCount: int): Vector_1<System_Internal.UIntPtr>;
    static Sin(vector: Vector_1<System_Internal.Double>): Vector_1<System_Internal.Double>;
    static Sin(vector: Vector_1<System_Internal.Single>): Vector_1<System_Internal.Single>;
    static SinCos(vector: Vector_1<System_Internal.Double>): ValueTuple_2<Vector_1<System_Internal.Double>, Vector_1<System_Internal.Double>>;
    static SinCos(vector: Vector_1<System_Internal.Single>): ValueTuple_2<Vector_1<System_Internal.Single>, Vector_1<System_Internal.Single>>;
    static SquareRoot<T>(value: Vector_1<T>): Vector_1<T>;
    static Store(source: Vector2, destination: ptr<float>): void;
    static Store(source: Vector3, destination: ptr<float>): void;
    static Store(source: Vector4, destination: ptr<float>): void;
    static Store<T>(source: Vector_1<T>, destination: ptr<T>): void;
    static StoreAligned(source: Vector2, destination: ptr<float>): void;
    static StoreAligned(source: Vector3, destination: ptr<float>): void;
    static StoreAligned(source: Vector4, destination: ptr<float>): void;
    static StoreAligned<T>(source: Vector_1<T>, destination: ptr<T>): void;
    static StoreAlignedNonTemporal(source: Vector2, destination: ptr<float>): void;
    static StoreAlignedNonTemporal(source: Vector3, destination: ptr<float>): void;
    static StoreAlignedNonTemporal(source: Vector4, destination: ptr<float>): void;
    static StoreAlignedNonTemporal<T>(source: Vector_1<T>, destination: ptr<T>): void;
    static StoreUnsafe(source: Vector2, destination: float, elementOffset: nuint): void;
    static StoreUnsafe(source: Vector2, destination: float): void;
    static StoreUnsafe(source: Vector3, destination: float, elementOffset: nuint): void;
    static StoreUnsafe(source: Vector3, destination: float): void;
    static StoreUnsafe(source: Vector4, destination: float, elementOffset: nuint): void;
    static StoreUnsafe(source: Vector4, destination: float): void;
    static StoreUnsafe<T>(source: Vector_1<T>, destination: T, elementOffset: nuint): void;
    static StoreUnsafe<T>(source: Vector_1<T>, destination: T): void;
    static Subtract<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static SubtractSaturate<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
    static Sum<T>(value: Vector_1<T>): T;
    static ToScalar(vector: Vector2): float;
    static ToScalar(vector: Vector3): float;
    static ToScalar(vector: Vector4): float;
    static ToScalar<T>(vector: Vector_1<T>): T;
    static Truncate(vector: Vector_1<System_Internal.Double>): Vector_1<System_Internal.Double>;
    static Truncate(vector: Vector_1<System_Internal.Single>): Vector_1<System_Internal.Single>;
    static Widen(source: Vector_1<System_Internal.Byte>, low: Vector_1<System_Internal.UInt16>, high: Vector_1<System_Internal.UInt16>): void;
    static Widen(source: Vector_1<System_Internal.Int16>, low: Vector_1<System_Internal.Int32>, high: Vector_1<System_Internal.Int32>): void;
    static Widen(source: Vector_1<System_Internal.Int32>, low: Vector_1<System_Internal.Int64>, high: Vector_1<System_Internal.Int64>): void;
    static Widen(source: Vector_1<System_Internal.SByte>, low: Vector_1<System_Internal.Int16>, high: Vector_1<System_Internal.Int16>): void;
    static Widen(source: Vector_1<System_Internal.Single>, low: Vector_1<System_Internal.Double>, high: Vector_1<System_Internal.Double>): void;
    static Widen(source: Vector_1<System_Internal.UInt16>, low: Vector_1<System_Internal.UInt32>, high: Vector_1<System_Internal.UInt32>): void;
    static Widen(source: Vector_1<System_Internal.UInt32>, low: Vector_1<System_Internal.UInt64>, high: Vector_1<System_Internal.UInt64>): void;
    static WidenLower(source: Vector_1<System_Internal.Byte>): Vector_1<System_Internal.UInt16>;
    static WidenLower(source: Vector_1<System_Internal.Int16>): Vector_1<System_Internal.Int32>;
    static WidenLower(source: Vector_1<System_Internal.Int32>): Vector_1<System_Internal.Int64>;
    static WidenLower(source: Vector_1<System_Internal.SByte>): Vector_1<System_Internal.Int16>;
    static WidenLower(source: Vector_1<System_Internal.Single>): Vector_1<System_Internal.Double>;
    static WidenLower(source: Vector_1<System_Internal.UInt16>): Vector_1<System_Internal.UInt32>;
    static WidenLower(source: Vector_1<System_Internal.UInt32>): Vector_1<System_Internal.UInt64>;
    static WidenUpper(source: Vector_1<System_Internal.Byte>): Vector_1<System_Internal.UInt16>;
    static WidenUpper(source: Vector_1<System_Internal.Int16>): Vector_1<System_Internal.Int32>;
    static WidenUpper(source: Vector_1<System_Internal.Int32>): Vector_1<System_Internal.Int64>;
    static WidenUpper(source: Vector_1<System_Internal.SByte>): Vector_1<System_Internal.Int16>;
    static WidenUpper(source: Vector_1<System_Internal.Single>): Vector_1<System_Internal.Double>;
    static WidenUpper(source: Vector_1<System_Internal.UInt16>): Vector_1<System_Internal.UInt32>;
    static WidenUpper(source: Vector_1<System_Internal.UInt32>): Vector_1<System_Internal.UInt64>;
    static WithElement(vector: Vector2, index: int, value: float): Vector2;
    static WithElement(vector: Vector3, index: int, value: float): Vector3;
    static WithElement(vector: Vector4, index: int, value: float): Vector4;
    static WithElement<T>(vector: Vector_1<T>, index: int, value: T): Vector_1<T>;
    static Xor<T>(left: Vector_1<T>, right: Vector_1<T>): Vector_1<T>;
}


export type Vector = Vector$instance;


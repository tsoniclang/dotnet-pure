// Generated by tsbindgen - Architecture
// Namespace: System.Xml.Linq
// Assembly: System.Private.Xml.Linq

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { IComparer_1, IEnumerable_1, IEqualityComparer_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IComparer, IEqualityComparer } from "../../System.Collections/internal/index.js";
import type { Stream, TextReader, TextWriter } from "../../System.IO/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { Task, Task_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import type { XmlSchema } from "../../System.Xml.Schema/internal/index.js";
import * as System_Xml_Serialization_Internal from "../../System.Xml.Serialization/internal/index.js";
import type { IXmlSerializable } from "../../System.Xml.Serialization/internal/index.js";
import * as System_Xml_Internal from "../../System.Xml/internal/index.js";
import type { IXmlLineInfo, XmlNodeType, XmlReader, XmlWriter } from "../../System.Xml/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Enum, EventArgs, EventHandler_1, IComparable, IConvertible, IEquatable_1, IFormatProvider, IFormattable, Int32, ISpanFormattable, Object as ClrObject, String as ClrString, Type, TypeCode, Void } from "../../System/internal/index.js";

export enum LoadOptions {
    None = 0,
    PreserveWhitespace = 1,
    SetBaseUri = 2,
    SetLineInfo = 4
}


export enum ReaderOptions {
    None = 0,
    OmitDuplicateNamespaces = 1
}


export enum SaveOptions {
    None = 0,
    DisableFormatting = 1,
    OmitDuplicateNamespaces = 2
}


export enum XObjectChange {
    Add = 0,
    Remove = 1,
    Name = 2,
    Value = 3
}


export interface XAttribute$instance extends XObject$instance {
    readonly IsNamespaceDeclaration: boolean;
    readonly Name: XName;
    readonly NextAttribute: XAttribute;
    readonly NodeType: XmlNodeType;
    readonly PreviousAttribute: XAttribute;
    Value: string;
    HasLineInfo(): boolean;
    Remove(): void;
    SetValue(value: unknown): void;
    ToString(): string;
}


export const XAttribute: {
    new(name: XName, value: unknown): XAttribute$instance;
    new(other: XAttribute): XAttribute$instance;
    readonly EmptySequence: IEnumerable_1<XAttribute>;
};


export interface __XAttribute$views {
    As_IXmlLineInfo(): System_Xml_Internal.IXmlLineInfo$instance;
}

export interface XAttribute$instance extends System_Xml_Internal.IXmlLineInfo$instance {}

export type XAttribute = XAttribute$instance & __XAttribute$views;


export interface XCData$instance extends XText$instance {
    readonly NodeType: XmlNodeType;
    HasLineInfo(): boolean;
    WriteTo(writer: XmlWriter): void;
    WriteToAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
}


export const XCData: {
    new(value: string): XCData$instance;
    new(other: XCData): XCData$instance;
};


export interface __XCData$views {
    As_IXmlLineInfo(): System_Xml_Internal.IXmlLineInfo$instance;
}

export type XCData = XCData$instance & __XCData$views;


export interface XComment$instance extends XNode$instance {
    readonly NodeType: XmlNodeType;
    Value: string;
    HasLineInfo(): boolean;
    WriteTo(writer: XmlWriter): void;
    WriteToAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
}


export const XComment: {
    new(value: string): XComment$instance;
    new(other: XComment): XComment$instance;
};


export interface __XComment$views {
    As_IXmlLineInfo(): System_Xml_Internal.IXmlLineInfo$instance;
}

export type XComment = XComment$instance & __XComment$views;


export interface XContainer$instance extends XNode$instance {
    readonly FirstNode: XNode;
    readonly LastNode: XNode;
    Add(content: unknown): void;
    Add(...content: unknown[]): void;
    AddFirst(content: unknown): void;
    AddFirst(...content: unknown[]): void;
    CreateWriter(): XmlWriter;
    DescendantNodes(): IEnumerable_1<XNode>;
    Descendants(): IEnumerable_1<XElement>;
    Descendants(name: XName): IEnumerable_1<XElement>;
    Element(name: XName): XElement;
    Elements(): IEnumerable_1<XElement>;
    Elements(name: XName): IEnumerable_1<XElement>;
    HasLineInfo(): boolean;
    Nodes(): IEnumerable_1<XNode>;
    RemoveNodes(): void;
    ReplaceNodes(content: unknown): void;
    ReplaceNodes(...content: unknown[]): void;
}


export const XContainer: {
};


export interface __XContainer$views {
    As_IXmlLineInfo(): System_Xml_Internal.IXmlLineInfo$instance;
}

export type XContainer = XContainer$instance & __XContainer$views;


export interface XDeclaration$instance {
    Encoding: string;
    Standalone: string;
    Version: string;
    ToString(): string;
}


export const XDeclaration: {
    new(version: string, encoding: string, standalone: string): XDeclaration$instance;
    new(other: XDeclaration): XDeclaration$instance;
};


export type XDeclaration = XDeclaration$instance;

export interface XDocument$instance extends XContainer$instance {
    Declaration: XDeclaration;
    readonly DocumentType: XDocumentType;
    readonly NodeType: XmlNodeType;
    readonly Root: XElement;
    HasLineInfo(): boolean;
    Save(stream: Stream): void;
    Save(stream: Stream, options: SaveOptions): void;
    Save(textWriter: TextWriter): void;
    Save(textWriter: TextWriter, options: SaveOptions): void;
    Save(writer: XmlWriter): void;
    Save(fileName: string): void;
    Save(fileName: string, options: SaveOptions): void;
    SaveAsync(stream: Stream, options: SaveOptions, cancellationToken: CancellationToken): Task;
    SaveAsync(textWriter: TextWriter, options: SaveOptions, cancellationToken: CancellationToken): Task;
    SaveAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
    WriteTo(writer: XmlWriter): void;
    WriteToAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
}


export const XDocument: {
    new(): XDocument$instance;
    new(content: unknown[]): XDocument$instance;
    new(declaration: XDeclaration, content: unknown[]): XDocument$instance;
    new(other: XDocument): XDocument$instance;
    Load(stream: Stream, options: LoadOptions): XDocument;
    Load(stream: Stream): XDocument;
    Load(textReader: TextReader, options: LoadOptions): XDocument;
    Load(textReader: TextReader): XDocument;
    Load(uri: string, options: LoadOptions): XDocument;
    Load(uri: string): XDocument;
    Load(reader: XmlReader, options: LoadOptions): XDocument;
    Load(reader: XmlReader): XDocument;
    LoadAsync(stream: Stream, options: LoadOptions, cancellationToken: CancellationToken): Task_1<XDocument>;
    LoadAsync(textReader: TextReader, options: LoadOptions, cancellationToken: CancellationToken): Task_1<XDocument>;
    LoadAsync(reader: XmlReader, options: LoadOptions, cancellationToken: CancellationToken): Task_1<XDocument>;
    Parse(text: string, options: LoadOptions): XDocument;
    Parse(text: string): XDocument;
};


export interface __XDocument$views {
    As_IXmlLineInfo(): System_Xml_Internal.IXmlLineInfo$instance;
}

export type XDocument = XDocument$instance & __XDocument$views;


export interface XDocumentType$instance extends XNode$instance {
    InternalSubset: string;
    Name: string;
    readonly NodeType: XmlNodeType;
    PublicId: string;
    SystemId: string;
    HasLineInfo(): boolean;
    WriteTo(writer: XmlWriter): void;
    WriteToAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
}


export const XDocumentType: {
    new(name: string, publicId: string, systemId: string, internalSubset: string): XDocumentType$instance;
    new(other: XDocumentType): XDocumentType$instance;
};


export interface __XDocumentType$views {
    As_IXmlLineInfo(): System_Xml_Internal.IXmlLineInfo$instance;
}

export type XDocumentType = XDocumentType$instance & __XDocumentType$views;


export interface XElement$instance extends XContainer$instance {
    readonly FirstAttribute: XAttribute;
    readonly HasAttributes: boolean;
    readonly HasElements: boolean;
    readonly IsEmpty: boolean;
    readonly LastAttribute: XAttribute;
    Name: XName;
    readonly NodeType: XmlNodeType;
    Value: string;
    AncestorsAndSelf(): IEnumerable_1<XElement>;
    AncestorsAndSelf(name: XName): IEnumerable_1<XElement>;
    Attribute(name: XName): XAttribute;
    Attributes(): IEnumerable_1<XAttribute>;
    Attributes(name: XName): IEnumerable_1<XAttribute>;
    DescendantNodesAndSelf(): IEnumerable_1<XNode>;
    DescendantsAndSelf(): IEnumerable_1<XElement>;
    DescendantsAndSelf(name: XName): IEnumerable_1<XElement>;
    GetDefaultNamespace(): XNamespace;
    GetNamespaceOfPrefix(prefix: string): XNamespace;
    GetPrefixOfNamespace(ns: XNamespace): string;
    HasLineInfo(): boolean;
    RemoveAll(): void;
    RemoveAttributes(): void;
    ReplaceAll(content: unknown): void;
    ReplaceAll(...content: unknown[]): void;
    ReplaceAttributes(content: unknown): void;
    ReplaceAttributes(...content: unknown[]): void;
    Save(fileName: string): void;
    Save(fileName: string, options: SaveOptions): void;
    Save(stream: Stream): void;
    Save(stream: Stream, options: SaveOptions): void;
    Save(textWriter: TextWriter): void;
    Save(textWriter: TextWriter, options: SaveOptions): void;
    Save(writer: XmlWriter): void;
    SaveAsync(stream: Stream, options: SaveOptions, cancellationToken: CancellationToken): Task;
    SaveAsync(textWriter: TextWriter, options: SaveOptions, cancellationToken: CancellationToken): Task;
    SaveAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
    SetAttributeValue(name: XName, value: unknown): void;
    SetElementValue(name: XName, value: unknown): void;
    SetValue(value: unknown): void;
    WriteTo(writer: XmlWriter): void;
    WriteToAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
}


export const XElement: {
    new(name: XName): XElement$instance;
    new(name: XName, content: unknown): XElement$instance;
    new(name: XName, content: unknown[]): XElement$instance;
    new(other: XElement): XElement$instance;
    new(other: XStreamingElement): XElement$instance;
    readonly EmptySequence: IEnumerable_1<XElement>;
    Load(stream: Stream, options: LoadOptions): XElement;
    Load(stream: Stream): XElement;
    Load(textReader: TextReader, options: LoadOptions): XElement;
    Load(textReader: TextReader): XElement;
    Load(uri: string, options: LoadOptions): XElement;
    Load(uri: string): XElement;
    Load(reader: XmlReader, options: LoadOptions): XElement;
    Load(reader: XmlReader): XElement;
    LoadAsync(stream: Stream, options: LoadOptions, cancellationToken: CancellationToken): Task_1<XElement>;
    LoadAsync(textReader: TextReader, options: LoadOptions, cancellationToken: CancellationToken): Task_1<XElement>;
    LoadAsync(reader: XmlReader, options: LoadOptions, cancellationToken: CancellationToken): Task_1<XElement>;
    Parse(text: string, options: LoadOptions): XElement;
    Parse(text: string): XElement;
};


export interface __XElement$views {
    As_IXmlLineInfo(): System_Xml_Internal.IXmlLineInfo$instance;
    As_IXmlSerializable(): System_Xml_Serialization_Internal.IXmlSerializable$instance;
}

export interface XElement$instance extends System_Xml_Serialization_Internal.IXmlSerializable$instance {}

export type XElement = XElement$instance & __XElement$views;


export interface XName$instance {
    readonly LocalName: string;
    readonly Namespace: XNamespace;
    readonly NamespaceName: string;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const XName: {
    new(): XName$instance;
    Get(localName: string, namespaceName: string): XName;
    Get(expandedName: string): XName;
};


export interface __XName$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<XName>;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    equals(other: XName): boolean;
}

export interface XName$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type XName = XName$instance & __XName$views;


export interface XNamespace$instance {
    readonly NamespaceName: string;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    GetName(localName: string): XName;
    ToString(): string;
}


export const XNamespace: {
    new(): XNamespace$instance;
    readonly None: XNamespace;
    readonly Xml: XNamespace;
    readonly Xmlns: XNamespace;
    Get(namespaceName: string): XNamespace;
};


export type XNamespace = XNamespace$instance;

export interface XNode$instance extends XObject$instance {
    readonly NextNode: XNode;
    readonly PreviousNode: XNode;
    AddAfterSelf(content: unknown): void;
    AddAfterSelf(...content: unknown[]): void;
    AddBeforeSelf(content: unknown): void;
    AddBeforeSelf(...content: unknown[]): void;
    Ancestors(): IEnumerable_1<XElement>;
    Ancestors(name: XName): IEnumerable_1<XElement>;
    CreateReader(): XmlReader;
    CreateReader(readerOptions: ReaderOptions): XmlReader;
    ElementsAfterSelf(): IEnumerable_1<XElement>;
    ElementsAfterSelf(name: XName): IEnumerable_1<XElement>;
    ElementsBeforeSelf(): IEnumerable_1<XElement>;
    ElementsBeforeSelf(name: XName): IEnumerable_1<XElement>;
    HasLineInfo(): boolean;
    IsAfter(node: XNode): boolean;
    IsBefore(node: XNode): boolean;
    NodesAfterSelf(): IEnumerable_1<XNode>;
    NodesBeforeSelf(): IEnumerable_1<XNode>;
    Remove(): void;
    ReplaceWith(content: unknown): void;
    ReplaceWith(...content: unknown[]): void;
    ToString(): string;
    ToString(options: SaveOptions): string;
    WriteTo(writer: XmlWriter): void;
    WriteToAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
}


export const XNode: {
    readonly DocumentOrderComparer: XNodeDocumentOrderComparer;
    readonly EqualityComparer: XNodeEqualityComparer;
    CompareDocumentOrder(n1: XNode, n2: XNode): int;
    DeepEquals(n1: XNode, n2: XNode): boolean;
    ReadFrom(reader: XmlReader): XNode;
    ReadFromAsync(reader: XmlReader, cancellationToken: CancellationToken): Task_1<XNode>;
};


export interface __XNode$views {
    As_IXmlLineInfo(): System_Xml_Internal.IXmlLineInfo$instance;
}

export interface XNode$instance extends System_Xml_Internal.IXmlLineInfo$instance {}

export type XNode = XNode$instance & __XNode$views;


export interface XNodeDocumentOrderComparer$instance {
    Compare(x: XNode, y: XNode): int;
}


export const XNodeDocumentOrderComparer: {
    new(): XNodeDocumentOrderComparer$instance;
};


export interface __XNodeDocumentOrderComparer$views {
    As_IComparer_1(): System_Collections_Generic_Internal.IComparer_1$instance<XNode>;
    As_IComparer(): System_Collections_Internal.IComparer$instance;
}

export interface XNodeDocumentOrderComparer$instance extends System_Collections_Generic_Internal.IComparer_1$instance<XNode> {}

export type XNodeDocumentOrderComparer = XNodeDocumentOrderComparer$instance & __XNodeDocumentOrderComparer$views;


export interface XNodeEqualityComparer$instance {
    Equals(x: XNode, y: XNode): boolean;
    GetHashCode(obj: XNode): int;
}


export const XNodeEqualityComparer: {
    new(): XNodeEqualityComparer$instance;
};


export interface __XNodeEqualityComparer$views {
    As_IEqualityComparer_1(): System_Collections_Generic_Internal.IEqualityComparer_1$instance<XNode>;
    As_IEqualityComparer(): System_Collections_Internal.IEqualityComparer$instance;
}

export type XNodeEqualityComparer = XNodeEqualityComparer$instance & __XNodeEqualityComparer$views;


export interface XObject$instance {
    readonly BaseUri: string;
    readonly Document: XDocument;
    readonly NodeType: XmlNodeType;
    readonly Parent: XElement;
    AddAnnotation(annotation: unknown): void;
    Annotation(type_: Type): unknown;
    Annotation<T>(): T;
    Annotations(type_: Type): IEnumerable_1<unknown>;
    Annotations<T>(): IEnumerable_1<T>;
    RemoveAnnotations(type_: Type): void;
    RemoveAnnotations<T>(): void;
}


export const XObject: {
};


export interface __XObject$views {
    As_IXmlLineInfo(): System_Xml_Internal.IXmlLineInfo$instance;
}

export interface XObject$instance extends System_Xml_Internal.IXmlLineInfo$instance {}

export type XObject = XObject$instance & __XObject$views;


export interface XObjectChangeEventArgs$instance extends EventArgs {
    readonly ObjectChange: XObjectChange;
}


export const XObjectChangeEventArgs: {
    new(objectChange: XObjectChange): XObjectChangeEventArgs$instance;
    readonly Add: XObjectChangeEventArgs;
    readonly Remove: XObjectChangeEventArgs;
    readonly Name: XObjectChangeEventArgs;
    readonly Value: XObjectChangeEventArgs;
};


export type XObjectChangeEventArgs = XObjectChangeEventArgs$instance;

export interface XProcessingInstruction$instance extends XNode$instance {
    Data: string;
    readonly NodeType: XmlNodeType;
    Target: string;
    HasLineInfo(): boolean;
    WriteTo(writer: XmlWriter): void;
    WriteToAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
}


export const XProcessingInstruction: {
    new(target: string, data: string): XProcessingInstruction$instance;
    new(other: XProcessingInstruction): XProcessingInstruction$instance;
};


export interface __XProcessingInstruction$views {
    As_IXmlLineInfo(): System_Xml_Internal.IXmlLineInfo$instance;
}

export type XProcessingInstruction = XProcessingInstruction$instance & __XProcessingInstruction$views;


export interface XStreamingElement$instance {
    Name: XName;
    Add(content: unknown): void;
    Add(...content: unknown[]): void;
    Save(stream: Stream): void;
    Save(stream: Stream, options: SaveOptions): void;
    Save(textWriter: TextWriter): void;
    Save(textWriter: TextWriter, options: SaveOptions): void;
    Save(writer: XmlWriter): void;
    Save(fileName: string): void;
    Save(fileName: string, options: SaveOptions): void;
    ToString(): string;
    ToString(options: SaveOptions): string;
    WriteTo(writer: XmlWriter): void;
}


export const XStreamingElement: {
    new(name: XName): XStreamingElement$instance;
    new(name: XName, content: unknown): XStreamingElement$instance;
    new(name: XName, content: unknown[]): XStreamingElement$instance;
};


export type XStreamingElement = XStreamingElement$instance;

export interface XText$instance extends XNode$instance {
    readonly NodeType: XmlNodeType;
    Value: string;
    HasLineInfo(): boolean;
    WriteTo(writer: XmlWriter): void;
    WriteToAsync(writer: XmlWriter, cancellationToken: CancellationToken): Task;
}


export const XText: {
    new(value: string): XText$instance;
    new(other: XText): XText$instance;
};


export interface __XText$views {
    As_IXmlLineInfo(): System_Xml_Internal.IXmlLineInfo$instance;
}

export type XText = XText$instance & __XText$views;


export abstract class Extensions$instance {
    static Ancestors<T extends XNode>(source: IEnumerable_1<T>, name: XName): IEnumerable_1<XElement>;
    static Ancestors<T extends XNode>(source: IEnumerable_1<T>): IEnumerable_1<XElement>;
    static AncestorsAndSelf(source: IEnumerable_1<XElement>, name: XName): IEnumerable_1<XElement>;
    static AncestorsAndSelf(source: IEnumerable_1<XElement>): IEnumerable_1<XElement>;
    static Attributes(source: IEnumerable_1<XElement>, name: XName): IEnumerable_1<XAttribute>;
    static Attributes(source: IEnumerable_1<XElement>): IEnumerable_1<XAttribute>;
    static DescendantNodes<T extends XContainer>(source: IEnumerable_1<T>): IEnumerable_1<XNode>;
    static DescendantNodesAndSelf(source: IEnumerable_1<XElement>): IEnumerable_1<XNode>;
    static Descendants<T extends XContainer>(source: IEnumerable_1<T>, name: XName): IEnumerable_1<XElement>;
    static Descendants<T extends XContainer>(source: IEnumerable_1<T>): IEnumerable_1<XElement>;
    static DescendantsAndSelf(source: IEnumerable_1<XElement>, name: XName): IEnumerable_1<XElement>;
    static DescendantsAndSelf(source: IEnumerable_1<XElement>): IEnumerable_1<XElement>;
    static Elements<T extends XContainer>(source: IEnumerable_1<T>, name: XName): IEnumerable_1<XElement>;
    static Elements<T extends XContainer>(source: IEnumerable_1<T>): IEnumerable_1<XElement>;
    static InDocumentOrder<T extends XNode>(source: IEnumerable_1<T>): IEnumerable_1<T>;
    static Nodes<T extends XContainer>(source: IEnumerable_1<T>): IEnumerable_1<XNode>;
    static Remove<T extends XNode>(source: IEnumerable_1<T>): void;
    static Remove(source: IEnumerable_1<XAttribute>): void;
}


export type Extensions = Extensions$instance;


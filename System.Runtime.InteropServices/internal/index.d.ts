// Generated by tsbindgen - Architecture
// Namespace: System.Runtime.InteropServices
// Assembly: System.Collections.Immutable, System.Memory, System.Private.CoreLib, System.Runtime.InteropServices, System.Text.Json

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import * as Microsoft_Win32_SafeHandles_Internal from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import type { SafeHandleZeroOrMinusOneIsInvalid } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import type { MemoryManager_1, ReadOnlySequence_1, ReadOnlySequenceSegment_1, SequenceReader_1 } from "../../System.Buffers/internal/index.js";
import type { Dictionary_2, Dictionary_2_AlternateLookup_1, IEnumerable_1, IList_1, IReadOnlyDictionary_2, List_1 } from "../../System.Collections.Generic/internal/index.js";
import type { ImmutableArray_1, ImmutableArray_1_Builder } from "../../System.Collections.Immutable/internal/index.js";
import type { BitArray, IDictionary } from "../../System.Collections/internal/index.js";
import type { NumberStyles } from "../../System.Globalization/internal/index.js";
import * as System_Numerics_Internal from "../../System.Numerics/internal/index.js";
import type { IAdditionOperators_3, IAdditiveIdentity_2, IBinaryFloatingPointIeee754_1, IBinaryInteger_1, IBinaryNumber_1, IBitwiseOperators_3, IComparisonOperators_3, IDecrementOperators_1, IDivisionOperators_3, IEqualityOperators_3, IExponentialFunctions_1, IFloatingPoint_1, IFloatingPointConstants_1, IFloatingPointIeee754_1, IHyperbolicFunctions_1, IIncrementOperators_1, ILogarithmicFunctions_1, IMinMaxValue_1, IModulusOperators_3, IMultiplicativeIdentity_2, IMultiplyOperators_3, INumber_1, INumberBase_1, IPowerFunctions_1, IRootFunctions_1, ISignedNumber_1, ISubtractionOperators_3, ITrigonometricFunctions_1, IUnaryNegationOperators_2, IUnaryPlusOperators_2 } from "../../System.Numerics/internal/index.js";
import { EventInfo } from "../../System.Reflection/internal/index.js";
import * as System_Reflection_Internal from "../../System.Reflection/internal/index.js";
import type { Assembly, CustomAttributeData, EventAttributes, ICustomAttributeProvider, MemberInfo, MemberTypes, MethodBase, MethodInfo, Module } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_ConstrainedExecution_Internal from "../../System.Runtime.ConstrainedExecution/internal/index.js";
import type { CriticalFinalizerObject } from "../../System.Runtime.ConstrainedExecution/internal/index.js";
import type { ITypeInfo } from "../../System.Runtime.InteropServices.ComTypes/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { SecureString } from "../../System.Security/internal/index.js";
import type { JsonElement, JsonProperty } from "../../System.Text.Json/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Array as ClrArray, ArraySegment_1, AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Char, Decimal, Delegate, Double, Enum, Exception, Guid, IAsyncResult, ICloneable, IComparable, IComparable_1, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, IParsable_1, ISpanFormattable, ISpanParsable_1, IUtf8SpanFormattable, IUtf8SpanParsable_1, MarshalByRefObject, Memory_1, MidpointRounding, MulticastDelegate, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, RuntimeTypeHandle, Single, Span_1, String as ClrString, SystemException, Type, TypeCode, UInt32, UInt64, UIntPtr, ValueTuple_2, ValueType, Void } from "../../System/internal/index.js";

export enum Architecture {
    X86 = 0,
    X64 = 1,
    Arm = 2,
    Arm64 = 3,
    Wasm = 4,
    S390x = 5,
    LoongArch64 = 6,
    Armv6 = 7,
    Ppc64le = 8,
    RiscV64 = 9
}


export enum AssemblyRegistrationFlags {
    None = 0,
    SetCodeBase = 1
}


export enum CallingConvention {
    Winapi = 1,
    Cdecl = 2,
    StdCall = 3,
    ThisCall = 4,
    FastCall = 5
}


export enum CharSet {
    None = 1,
    Ansi = 2,
    Unicode = 3,
    Auto = 4
}


export enum ClassInterfaceType {
    None = 0,
    AutoDispatch = 1,
    AutoDual = 2
}


export enum ComInterfaceType {
    InterfaceIsDual = 0,
    InterfaceIsIUnknown = 1,
    InterfaceIsIDispatch = 2,
    InterfaceIsIInspectable = 3
}


export enum ComMemberType {
    Method = 0,
    PropGet = 1,
    PropSet = 2
}


export enum CreateComInterfaceFlags {
    None = 0,
    CallerDefinedIUnknown = 1,
    TrackerSupport = 2
}


export enum CreatedWrapperFlags {
    None = 0,
    TrackerObject = 1,
    NonWrapping = 2
}


export enum CreateObjectFlags {
    None = 0,
    TrackerObject = 1,
    UniqueInstance = 2,
    Aggregation = 4,
    Unwrap = 8
}


export enum CustomQueryInterfaceMode {
    Ignore = 0,
    Allow = 1
}


export enum CustomQueryInterfaceResult {
    Handled = 0,
    NotHandled = 1,
    Failed = 2
}


export enum DllImportSearchPath {
    UseDllDirectoryForDependencies = 256,
    ApplicationDirectory = 512,
    UserDirectories = 1024,
    System32 = 2048,
    SafeDirectories = 4096,
    AssemblyDirectory = 2,
    LegacyBehavior = 0
}


export enum ExporterEventKind {
    NOTIF_TYPECONVERTED = 0,
    NOTIF_CONVERTWARNING = 1,
    ERROR_REFTOINVALIDASSEMBLY = 2
}


export enum GCHandleType {
    Weak = 0,
    WeakTrackResurrection = 1,
    Normal = 2,
    Pinned = 3
}


export enum LayoutKind {
    Sequential = 0,
    Explicit = 2,
    Auto = 3
}


export enum PosixSignal {
    SIGHUP = -1,
    SIGINT = -2,
    SIGQUIT = -3,
    SIGTERM = -4,
    SIGCHLD = -5,
    SIGCONT = -6,
    SIGWINCH = -7,
    SIGTTIN = -8,
    SIGTTOU = -9,
    SIGTSTP = -10
}


export enum RegistrationClassContext {
    InProcessServer = 1,
    InProcessHandler = 2,
    LocalServer = 4,
    InProcessServer16 = 8,
    RemoteServer = 16,
    InProcessHandler16 = 32,
    Reserved1 = 64,
    Reserved2 = 128,
    Reserved3 = 256,
    Reserved4 = 512,
    NoCodeDownload = 1024,
    Reserved5 = 2048,
    NoCustomMarshal = 4096,
    EnableCodeDownload = 8192,
    NoFailureLog = 16384,
    DisableActivateAsActivator = 32768,
    EnableActivateAsActivator = 65536,
    FromDefaultContext = 131072
}


export enum RegistrationConnectionType {
    SingleUse = 0,
    MultipleUse = 1,
    MultiSeparate = 2,
    Suspended = 4,
    Surrogate = 8
}


export enum StringMarshalling {
    Custom = 0,
    Utf8 = 1,
    Utf16 = 2
}


export enum TypeLibFuncFlags {
    FRestricted = 1,
    FSource = 2,
    FBindable = 4,
    FRequestEdit = 8,
    FDisplayBind = 16,
    FDefaultBind = 32,
    FHidden = 64,
    FUsesGetLastError = 128,
    FDefaultCollelem = 256,
    FUiDefault = 512,
    FNonBrowsable = 1024,
    FReplaceable = 2048,
    FImmediateBind = 4096
}


export enum TypeLibTypeFlags {
    FAppObject = 1,
    FCanCreate = 2,
    FLicensed = 4,
    FPreDeclId = 8,
    FHidden = 16,
    FControl = 32,
    FDual = 64,
    FNonExtensible = 128,
    FOleAutomation = 256,
    FRestricted = 512,
    FAggregatable = 1024,
    FReplaceable = 2048,
    FDispatchable = 4096,
    FReverseBind = 8192
}


export enum TypeLibVarFlags {
    FReadOnly = 1,
    FSource = 2,
    FBindable = 4,
    FRequestEdit = 8,
    FDisplayBind = 16,
    FDefaultBind = 32,
    FHidden = 64,
    FRestricted = 128,
    FDefaultCollelem = 256,
    FUiDefault = 512,
    FNonBrowsable = 1024,
    FReplaceable = 2048,
    FImmediateBind = 4096
}


export enum UnmanagedType {
    Bool = 2,
    I1 = 3,
    U1 = 4,
    I2 = 5,
    U2 = 6,
    I4 = 7,
    U4 = 8,
    I8 = 9,
    U8 = 10,
    R4 = 11,
    R8 = 12,
    Currency = 15,
    BStr = 19,
    LPStr = 20,
    LPWStr = 21,
    LPTStr = 22,
    ByValTStr = 23,
    IUnknown = 25,
    IDispatch = 26,
    Struct = 27,
    Interface = 28,
    SafeArray = 29,
    ByValArray = 30,
    SysInt = 31,
    SysUInt = 32,
    VBByRefStr = 34,
    AnsiBStr = 35,
    TBStr = 36,
    VariantBool = 37,
    FunctionPtr = 38,
    AsAny = 40,
    LPArray = 42,
    LPStruct = 43,
    CustomMarshaler = 44,
    Error = 45,
    IInspectable = 46,
    HString = 47,
    LPUTF8Str = 48
}


export enum VarEnum {
    VT_EMPTY = 0,
    VT_NULL = 1,
    VT_I2 = 2,
    VT_I4 = 3,
    VT_R4 = 4,
    VT_R8 = 5,
    VT_CY = 6,
    VT_DATE = 7,
    VT_BSTR = 8,
    VT_DISPATCH = 9,
    VT_ERROR = 10,
    VT_BOOL = 11,
    VT_VARIANT = 12,
    VT_UNKNOWN = 13,
    VT_DECIMAL = 14,
    VT_I1 = 16,
    VT_UI1 = 17,
    VT_UI2 = 18,
    VT_UI4 = 19,
    VT_I8 = 20,
    VT_UI8 = 21,
    VT_INT = 22,
    VT_UINT = 23,
    VT_VOID = 24,
    VT_HRESULT = 25,
    VT_PTR = 26,
    VT_SAFEARRAY = 27,
    VT_CARRAY = 28,
    VT_USERDEFINED = 29,
    VT_LPSTR = 30,
    VT_LPWSTR = 31,
    VT_RECORD = 36,
    VT_FILETIME = 64,
    VT_BLOB = 65,
    VT_STREAM = 66,
    VT_STORAGE = 67,
    VT_STREAMED_OBJECT = 68,
    VT_STORED_OBJECT = 69,
    VT_BLOB_OBJECT = 70,
    VT_CF = 71,
    VT_CLSID = 72,
    VT_VECTOR = 4096,
    VT_ARRAY = 8192,
    VT_BYREF = 16384
}


export type DllImportResolver = (libraryName: string, assembly: Assembly, searchPath: Nullable_1<DllImportSearchPath>) => nint;


export interface ICustomAdapter$instance {
    GetUnderlyingObject(): unknown;
}


export type ICustomAdapter = ICustomAdapter$instance;

export interface ICustomFactory$instance {
    CreateInstance(serverType: Type): MarshalByRefObject;
}


export type ICustomFactory = ICustomFactory$instance;

export interface ICustomMarshaler$instance {
    CleanUpManagedData(ManagedObj: unknown): void;
    CleanUpNativeData(pNativeData: nint): void;
    GetNativeDataSize(): int;
    MarshalManagedToNative(ManagedObj: unknown): nint;
    MarshalNativeToManaged(pNativeData: nint): unknown;
}


export type ICustomMarshaler = ICustomMarshaler$instance;

export interface ICustomQueryInterface$instance {
    GetInterface(iid: Guid, ppv: nint): CustomQueryInterfaceResult;
}


export type ICustomQueryInterface = ICustomQueryInterface$instance;

export interface IDynamicInterfaceCastable$instance {
    GetInterfaceImplementation(interfaceType: RuntimeTypeHandle): RuntimeTypeHandle;
    IsInterfaceImplemented(interfaceType: RuntimeTypeHandle, throwIfNotImplemented: boolean): boolean;
}


export type IDynamicInterfaceCastable = IDynamicInterfaceCastable$instance;

export interface ArrayWithOffset$instance {
    Equals(obj: unknown): boolean;
    Equals(obj: ArrayWithOffset): boolean;
    GetArray(): unknown;
    GetHashCode(): int;
    GetOffset(): int;
}


export const ArrayWithOffset: {
    new(array: unknown, offset: int): ArrayWithOffset$instance;
};


export interface __ArrayWithOffset$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<ArrayWithOffset>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ArrayWithOffset): boolean;
}

export type ArrayWithOffset = ArrayWithOffset$instance & __ArrayWithOffset$views;


export interface CLong$instance {
    readonly Value: nint;
    Equals(o: unknown): boolean;
    Equals(other: CLong): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const CLong: {
    new(value: int): CLong$instance;
    new(value: nint): CLong$instance;
};


export interface __CLong$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CLong>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CLong): boolean;
}

export type CLong = CLong$instance & __CLong$views;


export interface ComWrappers_ComInterfaceDispatch$instance {
    Vtable: nint;
}


export const ComWrappers_ComInterfaceDispatch: {
    new(): ComWrappers_ComInterfaceDispatch$instance;
    GetInstance<T>(dispatchPtr: ptr<ComWrappers_ComInterfaceDispatch>): T;
};


export type ComWrappers_ComInterfaceDispatch = ComWrappers_ComInterfaceDispatch$instance;

export interface ComWrappers_ComInterfaceEntry$instance {
    IID: Guid;
    Vtable: nint;
}


export const ComWrappers_ComInterfaceEntry: {
    new(): ComWrappers_ComInterfaceEntry$instance;
};


export type ComWrappers_ComInterfaceEntry = ComWrappers_ComInterfaceEntry$instance;

export interface CULong$instance {
    readonly Value: nuint;
    Equals(o: unknown): boolean;
    Equals(other: CULong): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const CULong: {
    new(value: uint): CULong$instance;
    new(value: nuint): CULong$instance;
};


export interface __CULong$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CULong>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CULong): boolean;
}

export type CULong = CULong$instance & __CULong$views;


export interface GCHandle$instance {
    readonly IsAllocated: boolean;
    Target: unknown;
    AddrOfPinnedObject(): nint;
    Equals(o: unknown): boolean;
    Equals(other: GCHandle): boolean;
    Free(): void;
    GetHashCode(): int;
}


export const GCHandle: {
    new(): GCHandle$instance;
    Alloc(value: unknown, type_: GCHandleType): GCHandle;
    Alloc(value: unknown): GCHandle;
    FromIntPtr(value: nint): GCHandle;
    ToIntPtr(value: GCHandle): nint;
};


export interface __GCHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<GCHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: GCHandle): boolean;
}

export type GCHandle = GCHandle$instance & __GCHandle$views;


export interface GCHandle_1$instance<T> {
    readonly IsAllocated: boolean;
    Target: T;
    Dispose(): void;
    Equals(obj: unknown): boolean;
    Equals(other: GCHandle_1<T>): boolean;
    GetHashCode(): int;
}


export const GCHandle_1: {
    new<T>(target: T): GCHandle_1$instance<T>;
    FromIntPtr<T>(value: nint): GCHandle_1<T>;
    ToIntPtr<T>(value: GCHandle_1<T>): nint;
};


export interface __GCHandle_1$views<T> {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<GCHandle_1<T>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: GCHandle_1<T>): boolean;
}

export interface GCHandle_1$instance<T> extends System_Internal.IDisposable$instance {}

export type GCHandle_1<T> = GCHandle_1$instance<T> & __GCHandle_1$views<T>;


export interface HandleRef$instance {
    readonly Handle: nint;
    readonly Wrapper: unknown;
}


export const HandleRef: {
    new(wrapper: unknown, handle: nint): HandleRef$instance;
    ToIntPtr(value: HandleRef): nint;
};


export type HandleRef = HandleRef$instance;

export interface NFloat$instance extends IBitwiseOperators_3<NFloat, NFloat, NFloat>, IComparisonOperators_3<NFloat, NFloat, System_Internal.Boolean>, IEqualityOperators_3<NFloat, NFloat, System_Internal.Boolean>, IModulusOperators_3<NFloat, NFloat, NFloat>, IAdditionOperators_3<NFloat, NFloat, NFloat>, IDecrementOperators_1<NFloat>, IDivisionOperators_3<NFloat, NFloat, NFloat>, IIncrementOperators_1<NFloat>, IMultiplyOperators_3<NFloat, NFloat, NFloat>, ISubtractionOperators_3<NFloat, NFloat, NFloat>, IUnaryPlusOperators_2<NFloat, NFloat>, IUnaryNegationOperators_2<NFloat, NFloat> {
    readonly Value: double;
    CompareTo(obj: unknown): int;
    CompareTo(other: NFloat): int;
    Equals(obj: unknown): boolean;
    Equals(other: NFloat): boolean;
    GetHashCode(): int;
    ToString(): string;
    ToString(format: string): string;
    ToString(provider: IFormatProvider): string;
    ToString(format: string, provider: IFormatProvider): string;
    TryFormat(destination: Span_1<System_Internal.Char>, charsWritten: int, format?: ReadOnlySpan_1<System_Internal.Char>, provider?: IFormatProvider): boolean;
    TryFormat(utf8Destination: Span_1<System_Internal.Byte>, bytesWritten: int, format?: ReadOnlySpan_1<System_Internal.Char>, provider?: IFormatProvider): boolean;
}


export const NFloat: {
    new(value: float): NFloat$instance;
    new(value: double): NFloat$instance;
    readonly Epsilon: NFloat;
    readonly MaxValue: NFloat;
    readonly MinValue: NFloat;
    readonly NaN: NFloat;
    readonly NegativeInfinity: NFloat;
    readonly PositiveInfinity: NFloat;
    readonly Size: int;
    readonly E: NFloat;
    readonly Pi: NFloat;
    readonly Tau: NFloat;
    readonly NegativeZero: NFloat;
    Abs(value: NFloat): NFloat;
    Acos(x: NFloat): NFloat;
    Acosh(x: NFloat): NFloat;
    AcosPi(x: NFloat): NFloat;
    Asin(x: NFloat): NFloat;
    Asinh(x: NFloat): NFloat;
    AsinPi(x: NFloat): NFloat;
    Atan(x: NFloat): NFloat;
    Atan2(y: NFloat, x: NFloat): NFloat;
    Atan2Pi(y: NFloat, x: NFloat): NFloat;
    Atanh(x: NFloat): NFloat;
    AtanPi(x: NFloat): NFloat;
    BitDecrement(x: NFloat): NFloat;
    BitIncrement(x: NFloat): NFloat;
    Cbrt(x: NFloat): NFloat;
    Ceiling(x: NFloat): NFloat;
    Clamp(value: NFloat, min: NFloat, max: NFloat): NFloat;
    ClampNative(value: NFloat, min: NFloat, max: NFloat): NFloat;
    ConvertToInteger<TInteger extends IBinaryInteger_1<TInteger>>(value: NFloat): TInteger;
    ConvertToIntegerNative<TInteger extends IBinaryInteger_1<TInteger>>(value: NFloat): TInteger;
    CopySign(value: NFloat, sign: NFloat): NFloat;
    Cos(x: NFloat): NFloat;
    Cosh(x: NFloat): NFloat;
    CosPi(x: NFloat): NFloat;
    CreateChecked<TOther extends INumberBase_1<TOther>>(value: TOther): NFloat;
    CreateSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): NFloat;
    CreateTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): NFloat;
    DegreesToRadians(degrees: NFloat): NFloat;
    Exp(x: NFloat): NFloat;
    Exp10(x: NFloat): NFloat;
    Exp10M1(x: NFloat): NFloat;
    Exp2(x: NFloat): NFloat;
    Exp2M1(x: NFloat): NFloat;
    ExpM1(x: NFloat): NFloat;
    Floor(x: NFloat): NFloat;
    FusedMultiplyAdd(left: NFloat, right: NFloat, addend: NFloat): NFloat;
    Hypot(x: NFloat, y: NFloat): NFloat;
    Ieee754Remainder(left: NFloat, right: NFloat): NFloat;
    ILogB(x: NFloat): int;
    IsEvenInteger(value: NFloat): boolean;
    IsFinite(value: NFloat): boolean;
    IsInfinity(value: NFloat): boolean;
    IsInteger(value: NFloat): boolean;
    IsNaN(value: NFloat): boolean;
    IsNegative(value: NFloat): boolean;
    IsNegativeInfinity(value: NFloat): boolean;
    IsNormal(value: NFloat): boolean;
    IsOddInteger(value: NFloat): boolean;
    IsPositive(value: NFloat): boolean;
    IsPositiveInfinity(value: NFloat): boolean;
    IsPow2(value: NFloat): boolean;
    IsRealNumber(value: NFloat): boolean;
    IsSubnormal(value: NFloat): boolean;
    Lerp(value1: NFloat, value2: NFloat, amount: NFloat): NFloat;
    Log(x: NFloat, newBase: NFloat): NFloat;
    Log(x: NFloat): NFloat;
    Log10(x: NFloat): NFloat;
    Log10P1(x: NFloat): NFloat;
    Log2(value: NFloat): NFloat;
    Log2P1(x: NFloat): NFloat;
    LogP1(x: NFloat): NFloat;
    Max(x: NFloat, y: NFloat): NFloat;
    MaxMagnitude(x: NFloat, y: NFloat): NFloat;
    MaxMagnitudeNumber(x: NFloat, y: NFloat): NFloat;
    MaxNative(x: NFloat, y: NFloat): NFloat;
    MaxNumber(x: NFloat, y: NFloat): NFloat;
    Min(x: NFloat, y: NFloat): NFloat;
    MinMagnitude(x: NFloat, y: NFloat): NFloat;
    MinMagnitudeNumber(x: NFloat, y: NFloat): NFloat;
    MinNative(x: NFloat, y: NFloat): NFloat;
    MinNumber(x: NFloat, y: NFloat): NFloat;
    MultiplyAddEstimate(left: NFloat, right: NFloat, addend: NFloat): NFloat;
    Parse(utf8Text: ReadOnlySpan_1<System_Internal.Byte>, style?: NumberStyles, provider?: IFormatProvider): NFloat;
    Parse(utf8Text: ReadOnlySpan_1<System_Internal.Byte>, provider: IFormatProvider): NFloat;
    Parse(s: ReadOnlySpan_1<System_Internal.Char>, style?: NumberStyles, provider?: IFormatProvider): NFloat;
    Parse(s: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider): NFloat;
    Parse(s: string, style: NumberStyles, provider: IFormatProvider): NFloat;
    Parse(s: string, style: NumberStyles): NFloat;
    Parse(s: string, provider: IFormatProvider): NFloat;
    Parse(s: string): NFloat;
    Pow(x: NFloat, y: NFloat): NFloat;
    RadiansToDegrees(radians: NFloat): NFloat;
    ReciprocalEstimate(x: NFloat): NFloat;
    ReciprocalSqrtEstimate(x: NFloat): NFloat;
    RootN(x: NFloat, n: int): NFloat;
    Round(x: NFloat, digits: int, mode: MidpointRounding): NFloat;
    Round(x: NFloat, digits: int): NFloat;
    Round(x: NFloat, mode: MidpointRounding): NFloat;
    Round(x: NFloat): NFloat;
    ScaleB(x: NFloat, n: int): NFloat;
    Sign(value: NFloat): int;
    Sin(x: NFloat): NFloat;
    SinCos(x: NFloat): ValueTuple_2<NFloat, NFloat>;
    SinCosPi(x: NFloat): ValueTuple_2<NFloat, NFloat>;
    Sinh(x: NFloat): NFloat;
    SinPi(x: NFloat): NFloat;
    Sqrt(x: NFloat): NFloat;
    Tan(x: NFloat): NFloat;
    Tanh(x: NFloat): NFloat;
    TanPi(x: NFloat): NFloat;
    Truncate(x: NFloat): NFloat;
    TryParse(utf8Text: ReadOnlySpan_1<System_Internal.Byte>, style: NumberStyles, provider: IFormatProvider, result: NFloat): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<System_Internal.Byte>, provider: IFormatProvider, result: NFloat): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<System_Internal.Byte>, result: NFloat): boolean;
    TryParse(s: ReadOnlySpan_1<System_Internal.Char>, style: NumberStyles, provider: IFormatProvider, result: NFloat): boolean;
    TryParse(s: ReadOnlySpan_1<System_Internal.Char>, provider: IFormatProvider, result: NFloat): boolean;
    TryParse(s: ReadOnlySpan_1<System_Internal.Char>, result: NFloat): boolean;
    TryParse(s: string, style: NumberStyles, provider: IFormatProvider, result: NFloat): boolean;
    TryParse(s: string, provider: IFormatProvider, result: NFloat): boolean;
    TryParse(s: string, result: NFloat): boolean;
};


export interface __NFloat$views {
    As_IComparable(): System_Internal.IComparable$instance;
    As_IComparable_1(): System_Internal.IComparable_1$instance<NFloat>;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<NFloat>;
    As_IFormattable(): System_Internal.IFormattable$instance;
    As_IParsable_1(): System_Internal.IParsable_1$instance<NFloat>;
    As_ISpanParsable_1(): System_Internal.ISpanParsable_1$instance<NFloat>;
    As_IUtf8SpanFormattable(): System_Internal.IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): System_Internal.IUtf8SpanParsable_1$instance<NFloat>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<NFloat, NFloat>;
    As_IFloatingPoint_1(): System_Numerics_Internal.IFloatingPoint_1$instance<NFloat>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<NFloat>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<NFloat>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<NFloat>;
    As_IRootFunctions_1(): System_Numerics_Internal.IRootFunctions_1$instance<NFloat>;
    As_ITrigonometricFunctions_1(): System_Numerics_Internal.ITrigonometricFunctions_1$instance<NFloat>;

    // Structural method bridges for numeric interface constraints
    Equals(other: NFloat): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: import("../../System/internal/index").IFormatProvider): string;
    TryFormat(destination: import("../../System/internal/index").Span_1<import("../../System/internal/index").Char>, charsWritten: int, format: import("../../System/internal/index").ReadOnlySpan_1<import("../../System/internal/index").Char>, provider: import("../../System/internal/index").IFormatProvider): boolean;
    TryFormat(utf8Destination: import("../../System/internal/index").Span_1<import("../../System/internal/index").Byte>, bytesWritten: int, format: import("../../System/internal/index").ReadOnlySpan_1<import("../../System/internal/index").Char>, provider: import("../../System/internal/index").IFormatProvider): boolean;
    GetExponentByteCount(): int;
    GetExponentShortestBitLength(): int;
    TryWriteExponentBigEndian(destination: import("../../System/internal/index").Span_1<import("../../System/internal/index").Byte>, bytesWritten: int): boolean;
    WriteExponentBigEndian(destination: byte[], startIndex: int): int;
    WriteExponentBigEndian(destination: byte[]): int;
    WriteExponentBigEndian(destination: import("../../System/internal/index").Span_1<import("../../System/internal/index").Byte>): int;
}

export interface NFloat$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<NFloat> {}

export type NFloat = NFloat$instance & __NFloat$views;


export interface OSPlatform$instance {
    Equals(other: OSPlatform): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const OSPlatform: {
    new(): OSPlatform$instance;
    readonly FreeBSD: OSPlatform;
    readonly Linux: OSPlatform;
    readonly OSX: OSPlatform;
    readonly Windows: OSPlatform;
    Create(osPlatform: string): OSPlatform;
};


export interface __OSPlatform$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<OSPlatform>;

    // Structural method bridges for numeric interface constraints
    Equals(other: OSPlatform): boolean;
}

export type OSPlatform = OSPlatform$instance & __OSPlatform$views;


export interface PinnedGCHandle_1$instance<T> {
    readonly IsAllocated: boolean;
    Target: T;
    Dispose(): void;
    Equals(obj: unknown): boolean;
    Equals(other: PinnedGCHandle_1<T>): boolean;
    GetAddressOfObjectData(): ptr<void>;
    GetHashCode(): int;
}


export const PinnedGCHandle_1: {
    new<T>(target: T): PinnedGCHandle_1$instance<T>;
    FromIntPtr<T>(value: nint): PinnedGCHandle_1<T>;
    ToIntPtr<T>(value: PinnedGCHandle_1<T>): nint;
};


export interface __PinnedGCHandle_1$views<T> {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<PinnedGCHandle_1<T>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: PinnedGCHandle_1<T>): boolean;
}

export interface PinnedGCHandle_1$instance<T> extends System_Internal.IDisposable$instance {}

export type PinnedGCHandle_1<T> = PinnedGCHandle_1$instance<T> & __PinnedGCHandle_1$views<T>;


export interface WeakGCHandle_1$instance<T> {
    readonly IsAllocated: boolean;
    Dispose(): void;
    Equals(obj: unknown): boolean;
    Equals(other: WeakGCHandle_1<T>): boolean;
    GetHashCode(): int;
    SetTarget(target: T): void;
    TryGetTarget(target: T): boolean;
}


export const WeakGCHandle_1: {
    new<T>(target: T, trackResurrection: boolean): WeakGCHandle_1$instance<T>;
    FromIntPtr<T>(value: nint): WeakGCHandle_1<T>;
    ToIntPtr<T>(value: WeakGCHandle_1<T>): nint;
};


export interface __WeakGCHandle_1$views<T> {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<WeakGCHandle_1<T>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: WeakGCHandle_1<T>): boolean;
}

export interface WeakGCHandle_1$instance<T> extends System_Internal.IDisposable$instance {}

export type WeakGCHandle_1<T> = WeakGCHandle_1$instance<T> & __WeakGCHandle_1$views<T>;


export interface AllowReversePInvokeCallsAttribute$instance extends Attribute {
}


export const AllowReversePInvokeCallsAttribute: {
    new(): AllowReversePInvokeCallsAttribute$instance;
};


export type AllowReversePInvokeCallsAttribute = AllowReversePInvokeCallsAttribute$instance;

export interface AutomationProxyAttribute$instance extends Attribute {
    readonly Value: boolean;
}


export const AutomationProxyAttribute: {
    new(val: boolean): AutomationProxyAttribute$instance;
};


export type AutomationProxyAttribute = AutomationProxyAttribute$instance;

export interface BestFitMappingAttribute$instance extends Attribute {
    ThrowOnUnmappableChar: boolean;
    readonly BestFitMapping: boolean;
}


export const BestFitMappingAttribute: {
    new(BestFitMapping: boolean): BestFitMappingAttribute$instance;
};


export type BestFitMappingAttribute = BestFitMappingAttribute$instance;

export interface BStrWrapper$instance {
    readonly WrappedObject: string;
}


export const BStrWrapper: {
    new(value: string): BStrWrapper$instance;
    new(value: unknown): BStrWrapper$instance;
};


export type BStrWrapper = BStrWrapper$instance;

export interface ClassInterfaceAttribute$instance extends Attribute {
    readonly Value: ClassInterfaceType;
}


export const ClassInterfaceAttribute: {
    new(classInterfaceType: ClassInterfaceType): ClassInterfaceAttribute$instance;
    new(classInterfaceType: short): ClassInterfaceAttribute$instance;
};


export type ClassInterfaceAttribute = ClassInterfaceAttribute$instance;

export interface CoClassAttribute$instance extends Attribute {
    readonly CoClass: Type;
}


export const CoClassAttribute: {
    new(coClass: Type): CoClassAttribute$instance;
};


export type CoClassAttribute = CoClassAttribute$instance;

export interface ComAliasNameAttribute$instance extends Attribute {
    readonly Value: string;
}


export const ComAliasNameAttribute: {
    new(alias: string): ComAliasNameAttribute$instance;
};


export type ComAliasNameAttribute = ComAliasNameAttribute$instance;

export interface ComAwareEventInfo$instance extends EventInfo {
    readonly Attributes: EventAttributes;
    readonly DeclaringType: Type;
    readonly MetadataToken: int;
    readonly Module: Module;
    readonly Name: string;
    readonly ReflectedType: Type;
    AddEventHandler(target: unknown, handler: Function): void;
    GetAddMethod(nonPublic: boolean): MethodInfo;
    GetAddMethod(): MethodInfo;
    GetCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    GetCustomAttributes(inherit: boolean): unknown[];
    GetCustomAttributesData(): IList_1<CustomAttributeData>;
    GetCustomAttributesData(): IList_1<CustomAttributeData>;
    GetOtherMethods(nonPublic: boolean): MethodInfo[];
    GetOtherMethods(): MethodInfo[];
    GetRaiseMethod(nonPublic: boolean): MethodInfo;
    GetRaiseMethod(): MethodInfo;
    GetRemoveMethod(nonPublic: boolean): MethodInfo;
    GetRemoveMethod(): MethodInfo;
    IsDefined(attributeType: Type, inherit: boolean): boolean;
    RemoveEventHandler(target: unknown, handler: Function): void;
}


export const ComAwareEventInfo: {
    new(type_: Type, eventName: string): ComAwareEventInfo$instance;
};


export interface __ComAwareEventInfo$views {
    As_ICustomAttributeProvider(): System_Reflection_Internal.ICustomAttributeProvider$instance;
}

export type ComAwareEventInfo = ComAwareEventInfo$instance & __ComAwareEventInfo$views;


export interface ComCompatibleVersionAttribute$instance extends Attribute {
    readonly BuildNumber: int;
    readonly MajorVersion: int;
    readonly MinorVersion: int;
    readonly RevisionNumber: int;
}


export const ComCompatibleVersionAttribute: {
    new(major: int, minor: int, build: int, revision: int): ComCompatibleVersionAttribute$instance;
};


export type ComCompatibleVersionAttribute = ComCompatibleVersionAttribute$instance;

export interface ComConversionLossAttribute$instance extends Attribute {
}


export const ComConversionLossAttribute: {
    new(): ComConversionLossAttribute$instance;
};


export type ComConversionLossAttribute = ComConversionLossAttribute$instance;

export interface ComDefaultInterfaceAttribute$instance extends Attribute {
    readonly Value: Type;
}


export const ComDefaultInterfaceAttribute: {
    new(defaultInterface: Type): ComDefaultInterfaceAttribute$instance;
};


export type ComDefaultInterfaceAttribute = ComDefaultInterfaceAttribute$instance;

export interface ComEventInterfaceAttribute$instance extends Attribute {
    readonly EventProvider: Type;
    readonly SourceInterface: Type;
}


export const ComEventInterfaceAttribute: {
    new(SourceInterface: Type, EventProvider: Type): ComEventInterfaceAttribute$instance;
};


export type ComEventInterfaceAttribute = ComEventInterfaceAttribute$instance;

export interface COMException$instance extends ExternalException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    ToString(): string;
}


export const COMException: {
    new(): COMException$instance;
    new(message: string): COMException$instance;
    new(message: string, inner: Exception): COMException$instance;
    new(message: string, errorCode: int): COMException$instance;
};


export interface __COMException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type COMException = COMException$instance & __COMException$views;


export interface ComImportAttribute$instance extends Attribute {
}


export const ComImportAttribute: {
    new(): ComImportAttribute$instance;
};


export type ComImportAttribute = ComImportAttribute$instance;

export interface ComRegisterFunctionAttribute$instance extends Attribute {
}


export const ComRegisterFunctionAttribute: {
    new(): ComRegisterFunctionAttribute$instance;
};


export type ComRegisterFunctionAttribute = ComRegisterFunctionAttribute$instance;

export interface ComSourceInterfacesAttribute$instance extends Attribute {
    readonly Value: string;
}


export const ComSourceInterfacesAttribute: {
    new(sourceInterfaces: string): ComSourceInterfacesAttribute$instance;
    new(sourceInterface: Type): ComSourceInterfacesAttribute$instance;
    new(sourceInterface1: Type, sourceInterface2: Type): ComSourceInterfacesAttribute$instance;
    new(sourceInterface1: Type, sourceInterface2: Type, sourceInterface3: Type): ComSourceInterfacesAttribute$instance;
    new(sourceInterface1: Type, sourceInterface2: Type, sourceInterface3: Type, sourceInterface4: Type): ComSourceInterfacesAttribute$instance;
};


export type ComSourceInterfacesAttribute = ComSourceInterfacesAttribute$instance;

export interface ComUnregisterFunctionAttribute$instance extends Attribute {
}


export const ComUnregisterFunctionAttribute: {
    new(): ComUnregisterFunctionAttribute$instance;
};


export type ComUnregisterFunctionAttribute = ComUnregisterFunctionAttribute$instance;

export interface ComVisibleAttribute$instance extends Attribute {
    readonly Value: boolean;
}


export const ComVisibleAttribute: {
    new(visibility: boolean): ComVisibleAttribute$instance;
};


export type ComVisibleAttribute = ComVisibleAttribute$instance;

export interface ComWrappers$instance {
    GetOrCreateComInterfaceForObject(instance: unknown, flags: CreateComInterfaceFlags): nint;
    GetOrCreateObjectForComInstance(externalComObject: nint, flags: CreateObjectFlags): unknown;
    GetOrCreateObjectForComInstance(externalComObject: nint, flags: CreateObjectFlags, userState: unknown): unknown;
    GetOrRegisterObjectForComInstance(externalComObject: nint, flags: CreateObjectFlags, wrapper: unknown): unknown;
    GetOrRegisterObjectForComInstance(externalComObject: nint, flags: CreateObjectFlags, wrapper: unknown, inner: nint): unknown;
}


export const ComWrappers: {
    GetIUnknownImpl(fpQueryInterface: nint, fpAddRef: nint, fpRelease: nint): void;
    RegisterForMarshalling(instance: ComWrappers): void;
    RegisterForTrackerSupport(instance: ComWrappers): void;
    TryGetComInstance(obj: unknown, unknown_: nint): boolean;
    TryGetObject(unknown_: nint, obj: unknown): boolean;
};


export type ComWrappers = ComWrappers$instance;

export interface CriticalHandle$instance extends CriticalFinalizerObject {
    readonly IsClosed: boolean;
    readonly IsInvalid: boolean;
    Close(): void;
    Dispose(): void;
    SetHandleAsInvalid(): void;
}


export const CriticalHandle: {
};


export interface __CriticalHandle$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface CriticalHandle$instance extends System_Internal.IDisposable$instance {}

export type CriticalHandle = CriticalHandle$instance & __CriticalHandle$views;


export interface CurrencyWrapper$instance {
    readonly WrappedObject: decimal;
}


export const CurrencyWrapper: {
    new(obj: decimal): CurrencyWrapper$instance;
    new(obj: unknown): CurrencyWrapper$instance;
};


export type CurrencyWrapper = CurrencyWrapper$instance;

export interface DefaultCharSetAttribute$instance extends Attribute {
    readonly CharSet: CharSet;
}


export const DefaultCharSetAttribute: {
    new(charSet: CharSet): DefaultCharSetAttribute$instance;
};


export type DefaultCharSetAttribute = DefaultCharSetAttribute$instance;

export interface DefaultDllImportSearchPathsAttribute$instance extends Attribute {
    readonly Paths: DllImportSearchPath;
}


export const DefaultDllImportSearchPathsAttribute: {
    new(paths: DllImportSearchPath): DefaultDllImportSearchPathsAttribute$instance;
};


export type DefaultDllImportSearchPathsAttribute = DefaultDllImportSearchPathsAttribute$instance;

export interface DefaultParameterValueAttribute$instance extends Attribute {
    readonly Value: unknown;
}


export const DefaultParameterValueAttribute: {
    new(value: unknown): DefaultParameterValueAttribute$instance;
};


export type DefaultParameterValueAttribute = DefaultParameterValueAttribute$instance;

export interface DispatchWrapper$instance {
    readonly WrappedObject: unknown;
}


export const DispatchWrapper: {
    new(obj: unknown): DispatchWrapper$instance;
};


export type DispatchWrapper = DispatchWrapper$instance;

export interface DispIdAttribute$instance extends Attribute {
    readonly Value: int;
}


export const DispIdAttribute: {
    new(dispId: int): DispIdAttribute$instance;
};


export type DispIdAttribute = DispIdAttribute$instance;

export interface DllImportAttribute$instance extends Attribute {
    EntryPoint: string;
    CharSet: CharSet;
    SetLastError: boolean;
    ExactSpelling: boolean;
    CallingConvention: CallingConvention;
    BestFitMapping: boolean;
    PreserveSig: boolean;
    ThrowOnUnmappableChar: boolean;
    readonly Value: string;
}


export const DllImportAttribute: {
    new(dllName: string): DllImportAttribute$instance;
};


export type DllImportAttribute = DllImportAttribute$instance;

export interface DynamicInterfaceCastableImplementationAttribute$instance extends Attribute {
}


export const DynamicInterfaceCastableImplementationAttribute: {
    new(): DynamicInterfaceCastableImplementationAttribute$instance;
};


export type DynamicInterfaceCastableImplementationAttribute = DynamicInterfaceCastableImplementationAttribute$instance;

export interface ErrorWrapper$instance {
    readonly ErrorCode: int;
}


export const ErrorWrapper: {
    new(errorCode: int): ErrorWrapper$instance;
    new(errorCode: unknown): ErrorWrapper$instance;
    new(e: Exception): ErrorWrapper$instance;
};


export type ErrorWrapper = ErrorWrapper$instance;

export interface ExternalException$instance extends SystemException {
    readonly ErrorCode: int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    ToString(): string;
}


export const ExternalException: {
    new(): ExternalException$instance;
    new(message: string): ExternalException$instance;
    new(message: string, inner: Exception): ExternalException$instance;
    new(message: string, errorCode: int): ExternalException$instance;
};


export interface __ExternalException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ExternalException = ExternalException$instance & __ExternalException$views;


export interface FieldOffsetAttribute$instance extends Attribute {
    readonly Value: int;
}


export const FieldOffsetAttribute: {
    new(offset: int): FieldOffsetAttribute$instance;
};


export type FieldOffsetAttribute = FieldOffsetAttribute$instance;

export interface GuidAttribute$instance extends Attribute {
    readonly Value: string;
}


export const GuidAttribute: {
    new(guid: string): GuidAttribute$instance;
};


export type GuidAttribute = GuidAttribute$instance;

export interface HandleCollector$instance {
    readonly Count: int;
    readonly InitialThreshold: int;
    readonly MaximumThreshold: int;
    readonly Name: string;
    Add(): void;
    Remove(): void;
}


export const HandleCollector: {
    new(name: string, initialThreshold: int): HandleCollector$instance;
    new(name: string, initialThreshold: int, maximumThreshold: int): HandleCollector$instance;
};


export type HandleCollector = HandleCollector$instance;

export interface ImportedFromTypeLibAttribute$instance extends Attribute {
    readonly Value: string;
}


export const ImportedFromTypeLibAttribute: {
    new(tlbFile: string): ImportedFromTypeLibAttribute$instance;
};


export type ImportedFromTypeLibAttribute = ImportedFromTypeLibAttribute$instance;

export interface InAttribute$instance extends Attribute {
}


export const InAttribute: {
    new(): InAttribute$instance;
};


export type InAttribute = InAttribute$instance;

export interface InterfaceTypeAttribute$instance extends Attribute {
    readonly Value: ComInterfaceType;
}


export const InterfaceTypeAttribute: {
    new(interfaceType: ComInterfaceType): InterfaceTypeAttribute$instance;
    new(interfaceType: short): InterfaceTypeAttribute$instance;
};


export type InterfaceTypeAttribute = InterfaceTypeAttribute$instance;

export interface InvalidComObjectException$instance extends SystemException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const InvalidComObjectException: {
    new(): InvalidComObjectException$instance;
    new(message: string): InvalidComObjectException$instance;
    new(message: string, inner: Exception): InvalidComObjectException$instance;
};


export interface __InvalidComObjectException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidComObjectException = InvalidComObjectException$instance & __InvalidComObjectException$views;


export interface InvalidOleVariantTypeException$instance extends SystemException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const InvalidOleVariantTypeException: {
    new(): InvalidOleVariantTypeException$instance;
    new(message: string): InvalidOleVariantTypeException$instance;
    new(message: string, inner: Exception): InvalidOleVariantTypeException$instance;
};


export interface __InvalidOleVariantTypeException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidOleVariantTypeException = InvalidOleVariantTypeException$instance & __InvalidOleVariantTypeException$views;


export interface LCIDConversionAttribute$instance extends Attribute {
    readonly Value: int;
}


export const LCIDConversionAttribute: {
    new(lcid: int): LCIDConversionAttribute$instance;
};


export type LCIDConversionAttribute = LCIDConversionAttribute$instance;

export interface LibraryImportAttribute$instance extends Attribute {
    EntryPoint: string;
    readonly LibraryName: string;
    SetLastError: boolean;
    StringMarshalling: StringMarshalling;
    StringMarshallingCustomType: Type;
}


export const LibraryImportAttribute: {
    new(libraryName: string): LibraryImportAttribute$instance;
};


export type LibraryImportAttribute = LibraryImportAttribute$instance;

export interface ManagedToNativeComInteropStubAttribute$instance extends Attribute {
    readonly ClassType: Type;
    readonly MethodName: string;
}


export const ManagedToNativeComInteropStubAttribute: {
    new(classType: Type, methodName: string): ManagedToNativeComInteropStubAttribute$instance;
};


export type ManagedToNativeComInteropStubAttribute = ManagedToNativeComInteropStubAttribute$instance;

export interface MarshalAsAttribute$instance extends Attribute {
    SafeArraySubType: VarEnum;
    SafeArrayUserDefinedSubType: Type;
    IidParameterIndex: int;
    ArraySubType: UnmanagedType;
    SizeParamIndex: short;
    SizeConst: int;
    MarshalType: string;
    MarshalTypeRef: Type;
    MarshalCookie: string;
    readonly Value: UnmanagedType;
}


export const MarshalAsAttribute: {
    new(unmanagedType: UnmanagedType): MarshalAsAttribute$instance;
    new(unmanagedType: short): MarshalAsAttribute$instance;
};


export type MarshalAsAttribute = MarshalAsAttribute$instance;

export interface MarshalDirectiveException$instance extends SystemException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const MarshalDirectiveException: {
    new(): MarshalDirectiveException$instance;
    new(message: string): MarshalDirectiveException$instance;
    new(message: string, inner: Exception): MarshalDirectiveException$instance;
};


export interface __MarshalDirectiveException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MarshalDirectiveException = MarshalDirectiveException$instance & __MarshalDirectiveException$views;


export interface OptionalAttribute$instance extends Attribute {
}


export const OptionalAttribute: {
    new(): OptionalAttribute$instance;
};


export type OptionalAttribute = OptionalAttribute$instance;

export interface OutAttribute$instance extends Attribute {
}


export const OutAttribute: {
    new(): OutAttribute$instance;
};


export type OutAttribute = OutAttribute$instance;

export interface PosixSignalContext$instance {
    Cancel: boolean;
    readonly Signal: PosixSignal;
}


export const PosixSignalContext: {
    new(signal: PosixSignal): PosixSignalContext$instance;
};


export type PosixSignalContext = PosixSignalContext$instance;

export interface PosixSignalRegistration$instance {
    Dispose(): void;
}


export const PosixSignalRegistration: {
    new(): PosixSignalRegistration$instance;
    Create(signal: PosixSignal, handler: Action_1<PosixSignalContext>): PosixSignalRegistration;
};


export interface __PosixSignalRegistration$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface PosixSignalRegistration$instance extends System_Internal.IDisposable$instance {}

export type PosixSignalRegistration = PosixSignalRegistration$instance & __PosixSignalRegistration$views;


export interface PreserveSigAttribute$instance extends Attribute {
}


export const PreserveSigAttribute: {
    new(): PreserveSigAttribute$instance;
};


export type PreserveSigAttribute = PreserveSigAttribute$instance;

export interface PrimaryInteropAssemblyAttribute$instance extends Attribute {
    readonly MajorVersion: int;
    readonly MinorVersion: int;
}


export const PrimaryInteropAssemblyAttribute: {
    new(major: int, minor: int): PrimaryInteropAssemblyAttribute$instance;
};


export type PrimaryInteropAssemblyAttribute = PrimaryInteropAssemblyAttribute$instance;

export interface ProgIdAttribute$instance extends Attribute {
    readonly Value: string;
}


export const ProgIdAttribute: {
    new(progId: string): ProgIdAttribute$instance;
};


export type ProgIdAttribute = ProgIdAttribute$instance;

export interface SafeArrayRankMismatchException$instance extends SystemException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SafeArrayRankMismatchException: {
    new(): SafeArrayRankMismatchException$instance;
    new(message: string): SafeArrayRankMismatchException$instance;
    new(message: string, inner: Exception): SafeArrayRankMismatchException$instance;
};


export interface __SafeArrayRankMismatchException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SafeArrayRankMismatchException = SafeArrayRankMismatchException$instance & __SafeArrayRankMismatchException$views;


export interface SafeArrayTypeMismatchException$instance extends SystemException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SafeArrayTypeMismatchException: {
    new(): SafeArrayTypeMismatchException$instance;
    new(message: string): SafeArrayTypeMismatchException$instance;
    new(message: string, inner: Exception): SafeArrayTypeMismatchException$instance;
};


export interface __SafeArrayTypeMismatchException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SafeArrayTypeMismatchException = SafeArrayTypeMismatchException$instance & __SafeArrayTypeMismatchException$views;


export interface SafeBuffer$instance extends SafeHandleZeroOrMinusOneIsInvalid {
    readonly ByteLength: ulong;
    AcquirePointer(pointer: ptr<byte>): void;
    Dispose(): void;
    Initialize(numBytes: ulong): void;
    Initialize(numElements: uint, sizeOfEachElement: uint): void;
    Initialize<T extends unknown>(numElements: uint): void;
    Read<T extends unknown>(byteOffset: ulong): T;
    ReadArray<T extends unknown>(byteOffset: ulong, array: T[], index: int, count: int): void;
    ReadSpan<T extends unknown>(byteOffset: ulong, buffer: Span_1<T>): void;
    ReleasePointer(): void;
    Write<T extends unknown>(byteOffset: ulong, value: T): void;
    WriteArray<T extends unknown>(byteOffset: ulong, array: T[], index: int, count: int): void;
    WriteSpan<T extends unknown>(byteOffset: ulong, data: ReadOnlySpan_1<T>): void;
}


export const SafeBuffer: {
};


export interface __SafeBuffer$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type SafeBuffer = SafeBuffer$instance & __SafeBuffer$views;


export interface SafeHandle$instance extends CriticalFinalizerObject {
    readonly IsClosed: boolean;
    readonly IsInvalid: boolean;
    Close(): void;
    DangerousAddRef(success: boolean): void;
    DangerousGetHandle(): nint;
    DangerousRelease(): void;
    Dispose(): void;
    SetHandleAsInvalid(): void;
}


export const SafeHandle: {
};


export interface __SafeHandle$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface SafeHandle$instance extends System_Internal.IDisposable$instance {}

export type SafeHandle = SafeHandle$instance & __SafeHandle$views;


export interface SEHException$instance extends ExternalException$instance {
    CanResume(): boolean;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SEHException: {
    new(): SEHException$instance;
    new(message: string): SEHException$instance;
    new(message: string, inner: Exception): SEHException$instance;
};


export interface __SEHException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SEHException = SEHException$instance & __SEHException$views;


export interface StandardOleMarshalObject$instance extends MarshalByRefObject {
}


export const StandardOleMarshalObject: {
    new(): StandardOleMarshalObject$instance;
};


export type StandardOleMarshalObject = StandardOleMarshalObject$instance;

export interface StructLayoutAttribute$instance extends Attribute {
    Pack: int;
    Size: int;
    CharSet: CharSet;
    readonly Value: LayoutKind;
}


export const StructLayoutAttribute: {
    new(layoutKind: LayoutKind): StructLayoutAttribute$instance;
    new(layoutKind: short): StructLayoutAttribute$instance;
};


export type StructLayoutAttribute = StructLayoutAttribute$instance;

export interface SuppressGCTransitionAttribute$instance extends Attribute {
}


export const SuppressGCTransitionAttribute: {
    new(): SuppressGCTransitionAttribute$instance;
};


export type SuppressGCTransitionAttribute = SuppressGCTransitionAttribute$instance;

export interface TypeIdentifierAttribute$instance extends Attribute {
    readonly Identifier: string;
    readonly Scope: string;
}


export const TypeIdentifierAttribute: {
    new(): TypeIdentifierAttribute$instance;
    new(scope: string, identifier: string): TypeIdentifierAttribute$instance;
};


export type TypeIdentifierAttribute = TypeIdentifierAttribute$instance;

export interface TypeLibFuncAttribute$instance extends Attribute {
    readonly Value: TypeLibFuncFlags;
}


export const TypeLibFuncAttribute: {
    new(flags: TypeLibFuncFlags): TypeLibFuncAttribute$instance;
    new(flags: short): TypeLibFuncAttribute$instance;
};


export type TypeLibFuncAttribute = TypeLibFuncAttribute$instance;

export interface TypeLibImportClassAttribute$instance extends Attribute {
    readonly Value: string;
}


export const TypeLibImportClassAttribute: {
    new(importClass: Type): TypeLibImportClassAttribute$instance;
};


export type TypeLibImportClassAttribute = TypeLibImportClassAttribute$instance;

export interface TypeLibTypeAttribute$instance extends Attribute {
    readonly Value: TypeLibTypeFlags;
}


export const TypeLibTypeAttribute: {
    new(flags: TypeLibTypeFlags): TypeLibTypeAttribute$instance;
    new(flags: short): TypeLibTypeAttribute$instance;
};


export type TypeLibTypeAttribute = TypeLibTypeAttribute$instance;

export interface TypeLibVarAttribute$instance extends Attribute {
    readonly Value: TypeLibVarFlags;
}


export const TypeLibVarAttribute: {
    new(flags: TypeLibVarFlags): TypeLibVarAttribute$instance;
    new(flags: short): TypeLibVarAttribute$instance;
};


export type TypeLibVarAttribute = TypeLibVarAttribute$instance;

export interface TypeLibVersionAttribute$instance extends Attribute {
    readonly MajorVersion: int;
    readonly MinorVersion: int;
}


export const TypeLibVersionAttribute: {
    new(major: int, minor: int): TypeLibVersionAttribute$instance;
};


export type TypeLibVersionAttribute = TypeLibVersionAttribute$instance;

export interface TypeMapAssemblyTargetAttribute_1$instance<TTypeMapGroup> extends Attribute {
}


export const TypeMapAssemblyTargetAttribute_1: {
    new<TTypeMapGroup>(assemblyName: string): TypeMapAssemblyTargetAttribute_1$instance<TTypeMapGroup>;
};


export type TypeMapAssemblyTargetAttribute_1<TTypeMapGroup> = TypeMapAssemblyTargetAttribute_1$instance<TTypeMapGroup>;

export interface TypeMapAssociationAttribute_1$instance<TTypeMapGroup> extends Attribute {
}


export const TypeMapAssociationAttribute_1: {
    new<TTypeMapGroup>(source: Type, proxy: Type): TypeMapAssociationAttribute_1$instance<TTypeMapGroup>;
};


export type TypeMapAssociationAttribute_1<TTypeMapGroup> = TypeMapAssociationAttribute_1$instance<TTypeMapGroup>;

export interface TypeMapAttribute_1$instance<TTypeMapGroup> extends Attribute {
}


export const TypeMapAttribute_1: {
    new<TTypeMapGroup>(value: string, target: Type): TypeMapAttribute_1$instance<TTypeMapGroup>;
    new<TTypeMapGroup>(value: string, target: Type, trimTarget: Type): TypeMapAttribute_1$instance<TTypeMapGroup>;
};


export type TypeMapAttribute_1<TTypeMapGroup> = TypeMapAttribute_1$instance<TTypeMapGroup>;

export interface UnknownWrapper$instance {
    readonly WrappedObject: unknown;
}


export const UnknownWrapper: {
    new(obj: unknown): UnknownWrapper$instance;
};


export type UnknownWrapper = UnknownWrapper$instance;

export interface UnmanagedCallConvAttribute$instance extends Attribute {
    CallConvs: Type[];
}


export const UnmanagedCallConvAttribute: {
    new(): UnmanagedCallConvAttribute$instance;
};


export type UnmanagedCallConvAttribute = UnmanagedCallConvAttribute$instance;

export interface UnmanagedCallersOnlyAttribute$instance extends Attribute {
    CallConvs: Type[];
    EntryPoint: string;
}


export const UnmanagedCallersOnlyAttribute: {
    new(): UnmanagedCallersOnlyAttribute$instance;
};


export type UnmanagedCallersOnlyAttribute = UnmanagedCallersOnlyAttribute$instance;

export interface UnmanagedFunctionPointerAttribute$instance extends Attribute {
    BestFitMapping: boolean;
    SetLastError: boolean;
    ThrowOnUnmappableChar: boolean;
    CharSet: CharSet;
    readonly CallingConvention: CallingConvention;
}


export const UnmanagedFunctionPointerAttribute: {
    new(callingConvention: CallingConvention): UnmanagedFunctionPointerAttribute$instance;
};


export type UnmanagedFunctionPointerAttribute = UnmanagedFunctionPointerAttribute$instance;

export interface VariantWrapper$instance {
    readonly WrappedObject: unknown;
}


export const VariantWrapper: {
    new(obj: unknown): VariantWrapper$instance;
};


export type VariantWrapper = VariantWrapper$instance;

export interface WasmImportLinkageAttribute$instance extends Attribute {
}


export const WasmImportLinkageAttribute: {
    new(): WasmImportLinkageAttribute$instance;
};


export type WasmImportLinkageAttribute = WasmImportLinkageAttribute$instance;

export abstract class CollectionsMarshal$instance {
    static AsBytes(array: BitArray): Span_1<System_Internal.Byte>;
    static AsSpan<T>(list: List_1<T>): Span_1<T>;
    static GetValueRefOrAddDefault<TKey, TValue, TAlternateKey>(dictionary: Dictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>, key: TAlternateKey, exists: boolean): TValue;
    static GetValueRefOrAddDefault<TKey, TValue>(dictionary: Dictionary_2<TKey, TValue>, key: TKey, exists: boolean): TValue;
    static GetValueRefOrNullRef<TKey, TValue, TAlternateKey>(dictionary: Dictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>, key: TAlternateKey): TValue;
    static GetValueRefOrNullRef<TKey, TValue>(dictionary: Dictionary_2<TKey, TValue>, key: TKey): TValue;
    static SetCount<T>(list: List_1<T>, count: int): void;
}


export type CollectionsMarshal = CollectionsMarshal$instance;

export abstract class ComEventsHelper$instance {
    static Combine(rcw: unknown, iid: Guid, dispid: int, d: Function): void;
    static Remove(rcw: unknown, iid: Guid, dispid: int, d: Function): Function;
}


export type ComEventsHelper = ComEventsHelper$instance;

export abstract class GCHandleExtensions$instance {
    static GetAddressOfArrayData<T>(handle: PinnedGCHandle_1<T[]>): ptr<T>;
    static GetAddressOfStringData(handle: PinnedGCHandle_1<System_Internal.String>): ptr<char>;
}


export type GCHandleExtensions = GCHandleExtensions$instance;

export abstract class ImmutableCollectionsMarshal$instance {
    static AsArray<T>(array: ImmutableArray_1<T>): T[];
    static AsImmutableArray<T>(array: T[]): ImmutableArray_1<T>;
    static AsMemory<T>(builder: ImmutableArray_1_Builder<T>): Memory_1<T>;
}


export type ImmutableCollectionsMarshal = ImmutableCollectionsMarshal$instance;

export abstract class JsonMarshal$instance {
    static GetRawUtf8PropertyName(property: JsonProperty): ReadOnlySpan_1<System_Internal.Byte>;
    static GetRawUtf8Value(element: JsonElement): ReadOnlySpan_1<System_Internal.Byte>;
}


export type JsonMarshal = JsonMarshal$instance;

export abstract class Marshal$instance {
    static readonly SystemDefaultCharSize: int;
    static readonly SystemMaxDBCSCharSize: int;
    static AddRef(pUnk: nint): int;
    static AllocCoTaskMem(cb: int): nint;
    static AllocHGlobal(cb: int): nint;
    static AllocHGlobal(cb: nint): nint;
    static AreComObjectsAvailableForCleanup(): boolean;
    static BindToMoniker(monikerName: string): unknown;
    static ChangeWrapperHandleStrength(otp: unknown, fIsWeak: boolean): void;
    static CleanupUnusedObjectsInCurrentContext(): void;
    static Copy(source: byte[], startIndex: int, destination: nint, length: int): void;
    static Copy(source: char[], startIndex: int, destination: nint, length: int): void;
    static Copy(source: double[], startIndex: int, destination: nint, length: int): void;
    static Copy(source: short[], startIndex: int, destination: nint, length: int): void;
    static Copy(source: int[], startIndex: int, destination: nint, length: int): void;
    static Copy(source: long[], startIndex: int, destination: nint, length: int): void;
    static Copy(source: nint, destination: byte[], startIndex: int, length: int): void;
    static Copy(source: nint, destination: char[], startIndex: int, length: int): void;
    static Copy(source: nint, destination: double[], startIndex: int, length: int): void;
    static Copy(source: nint, destination: short[], startIndex: int, length: int): void;
    static Copy(source: nint, destination: int[], startIndex: int, length: int): void;
    static Copy(source: nint, destination: long[], startIndex: int, length: int): void;
    static Copy(source: nint, destination: nint[], startIndex: int, length: int): void;
    static Copy(source: nint, destination: float[], startIndex: int, length: int): void;
    static Copy(source: nint[], startIndex: int, destination: nint, length: int): void;
    static Copy(source: float[], startIndex: int, destination: nint, length: int): void;
    static CreateAggregatedObject(pOuter: nint, o: unknown): nint;
    static CreateAggregatedObject<T>(pOuter: nint, o: T): nint;
    static CreateWrapperOfType(o: unknown, t: Type): unknown;
    static CreateWrapperOfType<T, TWrapper>(o: T): TWrapper;
    static DestroyStructure(ptr: nint, structuretype: Type): void;
    static DestroyStructure<T>(ptr: nint): void;
    static FinalReleaseComObject(o: unknown): int;
    static FreeBSTR(ptr: nint): void;
    static FreeCoTaskMem(ptr: nint): void;
    static FreeHGlobal(hglobal: nint): void;
    static GenerateGuidForType(type_: Type): Guid;
    static GenerateProgIdForType(type_: Type): string;
    static GetComInterfaceForObject(o: unknown, T: Type, mode: CustomQueryInterfaceMode): nint;
    static GetComInterfaceForObject(o: unknown, T: Type): nint;
    static GetComInterfaceForObject<T, TInterface>(o: T): nint;
    static GetComObjectData(obj: unknown, key: unknown): unknown;
    static GetDelegateForFunctionPointer(ptr: nint, t: Type): Function;
    static GetDelegateForFunctionPointer<TDelegate>(ptr: nint): TDelegate;
    static GetEndComSlot(t: Type): int;
    static GetExceptionCode(): int;
    static GetExceptionForHR(errorCode: int, iid: Guid, pUnk: nint): Exception;
    static GetExceptionForHR(errorCode: int, errorInfo: nint): Exception;
    static GetExceptionForHR(errorCode: int): Exception;
    static GetExceptionPointers(): nint;
    static GetFunctionPointerForDelegate(d: Function): nint;
    static GetFunctionPointerForDelegate<TDelegate>(d: TDelegate): nint;
    static GetHINSTANCE(m: Module): nint;
    static GetHRForException(e: Exception): int;
    static GetHRForLastWin32Error(): int;
    static GetIDispatchForObject(o: unknown): nint;
    static GetIUnknownForObject(o: unknown): nint;
    static GetLastPInvokeError(): int;
    static GetLastPInvokeErrorMessage(): string;
    static GetLastSystemError(): int;
    static GetLastWin32Error(): int;
    static GetNativeVariantForObject(obj: unknown, pDstNativeVariant: nint): void;
    static GetNativeVariantForObject<T>(obj: T, pDstNativeVariant: nint): void;
    static GetObjectForIUnknown(pUnk: nint): unknown;
    static GetObjectForNativeVariant(pSrcNativeVariant: nint): unknown;
    static GetObjectForNativeVariant<T>(pSrcNativeVariant: nint): T;
    static GetObjectsForNativeVariants(aSrcNativeVariant: nint, cVars: int): unknown[];
    static GetObjectsForNativeVariants<T>(aSrcNativeVariant: nint, cVars: int): T[];
    static GetPInvokeErrorMessage(error: int): string;
    static GetStartComSlot(t: Type): int;
    static GetTypedObjectForIUnknown(pUnk: nint, t: Type): unknown;
    static GetTypeFromCLSID(clsid: Guid): Type;
    static GetTypeInfoName(typeInfo: ITypeInfo): string;
    static GetUniqueObjectForIUnknown(unknown_: nint): unknown;
    static InitHandle(safeHandle: SafeHandle, handle: nint): void;
    static IsComObject(o: unknown): boolean;
    static IsTypeVisibleFromCom(t: Type): boolean;
    static OffsetOf<T>(fieldName: string): nint;
    static OffsetOf(t: Type, fieldName: string): nint;
    static Prelink(m: MethodInfo): void;
    static PrelinkAll(c: Type): void;
    static PtrToStringAnsi(ptr: nint, len: int): string;
    static PtrToStringAnsi(ptr: nint): string;
    static PtrToStringAuto(ptr: nint, len: int): string;
    static PtrToStringAuto(ptr: nint): string;
    static PtrToStringBSTR(ptr: nint): string;
    static PtrToStringUni(ptr: nint, len: int): string;
    static PtrToStringUni(ptr: nint): string;
    static PtrToStringUTF8(ptr: nint, byteLen: int): string;
    static PtrToStringUTF8(ptr: nint): string;
    static PtrToStructure(ptr: nint, structure: unknown): void;
    static PtrToStructure(ptr: nint, structureType: Type): unknown;
    static PtrToStructure<T>(ptr: nint, structure: T): void;
    static PtrToStructure<T>(ptr: nint): T;
    static QueryInterface(pUnk: nint, iid: Guid, ppv: nint): int;
    static ReadByte(ptr: nint, ofs: int): byte;
    static ReadByte(ptr: nint): byte;
    static ReadByte(ptr: unknown, ofs: int): byte;
    static ReadInt16(ptr: nint, ofs: int): short;
    static ReadInt16(ptr: nint): short;
    static ReadInt16(ptr: unknown, ofs: int): short;
    static ReadInt32(ptr: nint, ofs: int): int;
    static ReadInt32(ptr: nint): int;
    static ReadInt32(ptr: unknown, ofs: int): int;
    static ReadInt64(ptr: nint, ofs: int): long;
    static ReadInt64(ptr: nint): long;
    static ReadInt64(ptr: unknown, ofs: int): long;
    static ReadIntPtr(ptr: nint, ofs: int): nint;
    static ReadIntPtr(ptr: nint): nint;
    static ReadIntPtr(ptr: unknown, ofs: int): nint;
    static ReAllocCoTaskMem(pv: nint, cb: int): nint;
    static ReAllocHGlobal(pv: nint, cb: nint): nint;
    static Release(pUnk: nint): int;
    static ReleaseComObject(o: unknown): int;
    static SecureStringToBSTR(s: SecureString): nint;
    static SecureStringToCoTaskMemAnsi(s: SecureString): nint;
    static SecureStringToCoTaskMemUnicode(s: SecureString): nint;
    static SecureStringToGlobalAllocAnsi(s: SecureString): nint;
    static SecureStringToGlobalAllocUnicode(s: SecureString): nint;
    static SetComObjectData(obj: unknown, key: unknown, data: unknown): boolean;
    static SetLastPInvokeError(error: int): void;
    static SetLastSystemError(error: int): void;
    static SizeOf<T>(): int;
    static SizeOf(structure: unknown): int;
    static SizeOf(t: Type): int;
    static SizeOf<T>(structure: T): int;
    static StringToBSTR(s: string): nint;
    static StringToCoTaskMemAnsi(s: string): nint;
    static StringToCoTaskMemAuto(s: string): nint;
    static StringToCoTaskMemUni(s: string): nint;
    static StringToCoTaskMemUTF8(s: string): nint;
    static StringToHGlobalAnsi(s: string): nint;
    static StringToHGlobalAuto(s: string): nint;
    static StringToHGlobalUni(s: string): nint;
    static StructureToPtr(structure: unknown, ptr: nint, fDeleteOld: boolean): void;
    static StructureToPtr<T>(structure: T, ptr: nint, fDeleteOld: boolean): void;
    static ThrowExceptionForHR(errorCode: int, iid: Guid, pUnk: nint): void;
    static ThrowExceptionForHR(errorCode: int, errorInfo: nint): void;
    static ThrowExceptionForHR(errorCode: int): void;
    static UnsafeAddrOfPinnedArrayElement(arr: ClrArray, index: int): nint;
    static UnsafeAddrOfPinnedArrayElement<T>(arr: T[], index: int): nint;
    static WriteByte(ptr: nint, val: byte): void;
    static WriteByte(ptr: nint, ofs: int, val: byte): void;
    static WriteByte(ptr: unknown, ofs: int, val: byte): void;
    static WriteInt16(ptr: nint, val: char): void;
    static WriteInt16(ptr: nint, val: short): void;
    static WriteInt16(ptr: nint, ofs: int, val: char): void;
    static WriteInt16(ptr: nint, ofs: int, val: short): void;
    static WriteInt16(ptr: unknown, ofs: int, val: char): void;
    static WriteInt16(ptr: unknown, ofs: int, val: short): void;
    static WriteInt32(ptr: nint, ofs: int, val: int): void;
    static WriteInt32(ptr: nint, val: int): void;
    static WriteInt32(ptr: unknown, ofs: int, val: int): void;
    static WriteInt64(ptr: nint, ofs: int, val: long): void;
    static WriteInt64(ptr: nint, val: long): void;
    static WriteInt64(ptr: unknown, ofs: int, val: long): void;
    static WriteIntPtr(ptr: nint, ofs: int, val: nint): void;
    static WriteIntPtr(ptr: nint, val: nint): void;
    static WriteIntPtr(ptr: unknown, ofs: int, val: nint): void;
    static ZeroFreeBSTR(s: nint): void;
    static ZeroFreeCoTaskMemAnsi(s: nint): void;
    static ZeroFreeCoTaskMemUnicode(s: nint): void;
    static ZeroFreeCoTaskMemUTF8(s: nint): void;
    static ZeroFreeGlobalAllocAnsi(s: nint): void;
    static ZeroFreeGlobalAllocUnicode(s: nint): void;
}


export type Marshal = Marshal$instance;

export abstract class MemoryMarshal$instance {
    static AsBytes<T extends unknown>(span: ReadOnlySpan_1<T>): ReadOnlySpan_1<System_Internal.Byte>;
    static AsBytes<T extends unknown>(span: Span_1<T>): Span_1<System_Internal.Byte>;
    static AsMemory<T>(memory: ReadOnlyMemory_1<T>): Memory_1<T>;
    static AsRef<T extends unknown>(span: ReadOnlySpan_1<System_Internal.Byte>): T;
    static AsRef<T extends unknown>(span: Span_1<System_Internal.Byte>): T;
    static Cast<TFrom extends unknown, TTo extends unknown>(span: ReadOnlySpan_1<TFrom>): ReadOnlySpan_1<TTo>;
    static Cast<TFrom extends unknown, TTo extends unknown>(span: Span_1<TFrom>): Span_1<TTo>;
    static CreateFromPinnedArray<T>(array: T[], start: int, length: int): Memory_1<T>;
    static CreateReadOnlySpan<T>(reference: T, length: int): ReadOnlySpan_1<T>;
    static CreateReadOnlySpanFromNullTerminated(value: ptr<byte>): ReadOnlySpan_1<System_Internal.Byte>;
    static CreateReadOnlySpanFromNullTerminated(value: ptr<char>): ReadOnlySpan_1<System_Internal.Char>;
    static CreateSpan<T>(reference: T, length: int): Span_1<T>;
    static GetArrayDataReference(array: ClrArray): byte;
    static GetArrayDataReference<T>(array: T[]): T;
    static GetReference<T>(span: ReadOnlySpan_1<T>): T;
    static GetReference<T>(span: Span_1<T>): T;
    static Read<T extends unknown>(source: ReadOnlySpan_1<System_Internal.Byte>): T;
    static ToEnumerable<T>(memory: ReadOnlyMemory_1<T>): IEnumerable_1<T>;
    static TryGetArray<T>(memory: ReadOnlyMemory_1<T>, segment: ArraySegment_1<T>): boolean;
    static TryGetMemoryManager<T, TManager extends MemoryManager_1<T>>(memory: ReadOnlyMemory_1<T>, manager: TManager, start: int, length: int): boolean;
    static TryGetMemoryManager<T, TManager extends MemoryManager_1<T>>(memory: ReadOnlyMemory_1<T>, manager: TManager): boolean;
    static TryGetString(memory: ReadOnlyMemory_1<System_Internal.Char>, text: string, start: int, length: int): boolean;
    static TryRead<T extends unknown>(source: ReadOnlySpan_1<System_Internal.Byte>, value: T): boolean;
    static TryWrite<T extends unknown>(destination: Span_1<System_Internal.Byte>, value: T): boolean;
    static Write<T extends unknown>(destination: Span_1<System_Internal.Byte>, value: T): void;
}


export type MemoryMarshal = MemoryMarshal$instance;

export abstract class NativeLibrary$instance {
    static Free(handle: nint): void;
    static GetExport(handle: nint, name: string): nint;
    static GetMainProgramHandle(): nint;
    static Load(libraryName: string, assembly: Assembly, searchPath: Nullable_1<DllImportSearchPath>): nint;
    static Load(libraryPath: string): nint;
    static SetDllImportResolver(assembly: Assembly, resolver: DllImportResolver): void;
    static TryGetExport(handle: nint, name: string, address: nint): boolean;
    static TryLoad(libraryPath: string, handle: nint): boolean;
    static TryLoad(libraryName: string, assembly: Assembly, searchPath: Nullable_1<DllImportSearchPath>, handle: nint): boolean;
}


export type NativeLibrary = NativeLibrary$instance;

export abstract class NativeMemory$instance {
    static AlignedAlloc(byteCount: nuint, alignment: nuint): ptr<void>;
    static AlignedFree(ptr: ptr<void>): void;
    static AlignedRealloc(ptr: ptr<void>, byteCount: nuint, alignment: nuint): ptr<void>;
    static Alloc(elementCount: nuint, elementSize: nuint): ptr<void>;
    static Alloc(byteCount: nuint): ptr<void>;
    static AllocZeroed(elementCount: nuint, elementSize: nuint): ptr<void>;
    static AllocZeroed(byteCount: nuint): ptr<void>;
    static Clear(ptr: ptr<void>, byteCount: nuint): void;
    static Copy(source: ptr<void>, destination: ptr<void>, byteCount: nuint): void;
    static Fill(ptr: ptr<void>, byteCount: nuint, value: byte): void;
    static Free(ptr: ptr<void>): void;
    static Realloc(ptr: ptr<void>, byteCount: nuint): ptr<void>;
}


export type NativeMemory = NativeMemory$instance;

export abstract class RuntimeEnvironment$instance {
    static readonly SystemConfigurationFile: string;
    static FromGlobalAccessCache(a: Assembly): boolean;
    static GetRuntimeDirectory(): string;
    static GetRuntimeInterfaceAsIntPtr(clsid: Guid, riid: Guid): nint;
    static GetRuntimeInterfaceAsObject(clsid: Guid, riid: Guid): unknown;
    static GetSystemVersion(): string;
}


export type RuntimeEnvironment = RuntimeEnvironment$instance;

export abstract class RuntimeInformation$instance {
    static readonly RuntimeIdentifier: string;
    static readonly ProcessArchitecture: Architecture;
    static readonly OSDescription: string;
    static readonly OSArchitecture: Architecture;
    static readonly FrameworkDescription: string;
    static IsOSPlatform(osPlatform: OSPlatform): boolean;
}


export type RuntimeInformation = RuntimeInformation$instance;

export abstract class SequenceMarshal$instance {
    static TryGetArray<T>(sequence: ReadOnlySequence_1<T>, segment: ArraySegment_1<T>): boolean;
    static TryGetReadOnlyMemory<T>(sequence: ReadOnlySequence_1<T>, memory: ReadOnlyMemory_1<T>): boolean;
    static TryGetReadOnlySequenceSegment<T>(sequence: ReadOnlySequence_1<T>, startSegment: ReadOnlySequenceSegment_1<T>, startIndex: int, endSegment: ReadOnlySequenceSegment_1<T>, endIndex: int): boolean;
    static TryRead<T extends unknown>(reader: SequenceReader_1<System_Internal.Byte>, value: T): boolean;
}


export type SequenceMarshal = SequenceMarshal$instance;

export abstract class TypeMapping$instance {
    static GetOrCreateExternalTypeMapping<TTypeMapGroup>(): IReadOnlyDictionary_2<System_Internal.String, Type>;
    static GetOrCreateProxyTypeMapping<TTypeMapGroup>(): IReadOnlyDictionary_2<Type, Type>;
}


export type TypeMapping = TypeMapping$instance;


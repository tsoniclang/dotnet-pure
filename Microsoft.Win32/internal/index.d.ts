// Generated by tsbindgen - Architecture
// Namespace: Microsoft.Win32
// Assembly: Microsoft.Win32.Registry

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { SafeRegistryHandle } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import type { AccessControlSections, RegistryRights, RegistrySecurity } from "../../System.Security.AccessControl/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Enum, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, ISpanFormattable, MarshalByRefObject, Object as ClrObject, String as ClrString, Type, TypeCode, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum RegistryHive {
    ClassesRoot = -2147483648,
    CurrentUser = -2147483647,
    LocalMachine = -2147483646,
    Users = -2147483645,
    PerformanceData = -2147483644,
    CurrentConfig = -2147483643
}


export enum RegistryKeyPermissionCheck {
    Default = 0,
    ReadSubTree = 1,
    ReadWriteSubTree = 2
}


export enum RegistryOptions {
    None = 0,
    Volatile = 1
}


export enum RegistryValueKind {
    None = -1,
    Unknown = 0,
    String = 1,
    ExpandString = 2,
    Binary = 3,
    DWord = 4,
    MultiString = 7,
    QWord = 11
}


export enum RegistryValueOptions {
    None = 0,
    DoNotExpandEnvironmentNames = 1
}


export enum RegistryView {
    Default = 0,
    Registry64 = 256,
    Registry32 = 512
}


export interface RegistryKey$instance extends MarshalByRefObject {
    readonly Handle: SafeRegistryHandle;
    readonly Name: string;
    readonly SubKeyCount: int;
    readonly ValueCount: int;
    readonly View: RegistryView;
    Close(): void;
    CreateSubKey(subkey: string): RegistryKey;
    CreateSubKey(subkey: string, permissionCheck: RegistryKeyPermissionCheck): RegistryKey;
    CreateSubKey(subkey: string, permissionCheck: RegistryKeyPermissionCheck, registryOptions: RegistryOptions): RegistryKey;
    CreateSubKey(subkey: string, permissionCheck: RegistryKeyPermissionCheck, registryOptions: RegistryOptions, registrySecurity: RegistrySecurity): RegistryKey;
    CreateSubKey(subkey: string, permissionCheck: RegistryKeyPermissionCheck, registrySecurity: RegistrySecurity): RegistryKey;
    CreateSubKey(subkey: string, writable: boolean): RegistryKey;
    CreateSubKey(subkey: string, writable: boolean, options: RegistryOptions): RegistryKey;
    DeleteSubKey(subkey: string): void;
    DeleteSubKey(subkey: string, throwOnMissingSubKey: boolean): void;
    DeleteSubKeyTree(subkey: string): void;
    DeleteSubKeyTree(subkey: string, throwOnMissingSubKey: boolean): void;
    DeleteValue(name: string): void;
    DeleteValue(name: string, throwOnMissingValue: boolean): void;
    Dispose(): void;
    Flush(): void;
    GetAccessControl(): RegistrySecurity;
    GetAccessControl(includeSections: AccessControlSections): RegistrySecurity;
    GetSubKeyNames(): string[];
    GetValue(name: string): unknown;
    GetValue(name: string, defaultValue: unknown): unknown;
    GetValue(name: string, defaultValue: unknown, options: RegistryValueOptions): unknown;
    GetValueKind(name: string): RegistryValueKind;
    GetValueNames(): string[];
    OpenSubKey(name: string): RegistryKey;
    OpenSubKey(name: string, permissionCheck: RegistryKeyPermissionCheck): RegistryKey;
    OpenSubKey(name: string, permissionCheck: RegistryKeyPermissionCheck, rights: RegistryRights): RegistryKey;
    OpenSubKey(name: string, writable: boolean): RegistryKey;
    OpenSubKey(name: string, rights: RegistryRights): RegistryKey;
    SetAccessControl(registrySecurity: RegistrySecurity): void;
    SetValue(name: string, value: unknown): void;
    SetValue(name: string, value: unknown, valueKind: RegistryValueKind): void;
    ToString(): string;
}


export const RegistryKey: {
    new(): RegistryKey$instance;
    FromHandle(handle: SafeRegistryHandle, view: RegistryView): RegistryKey;
    FromHandle(handle: SafeRegistryHandle): RegistryKey;
    OpenBaseKey(hKey: RegistryHive, view: RegistryView): RegistryKey;
    OpenRemoteBaseKey(hKey: RegistryHive, machineName: string, view: RegistryView): RegistryKey;
    OpenRemoteBaseKey(hKey: RegistryHive, machineName: string): RegistryKey;
};


export interface __RegistryKey$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface RegistryKey$instance extends System_Internal.IDisposable$instance {}

export type RegistryKey = RegistryKey$instance & __RegistryKey$views;


export abstract class Registry$instance {
    static readonly ClassesRoot: RegistryKey;
    static readonly CurrentConfig: RegistryKey;
    static readonly CurrentUser: RegistryKey;
    static readonly LocalMachine: RegistryKey;
    static readonly PerformanceData: RegistryKey;
    static readonly Users: RegistryKey;
    static GetValue(keyName: string, valueName: string, defaultValue: unknown): unknown;
    static SetValue(keyName: string, valueName: string, value: unknown, valueKind: RegistryValueKind): void;
    static SetValue(keyName: string, valueName: string, value: unknown): void;
}


export type Registry = Registry$instance;


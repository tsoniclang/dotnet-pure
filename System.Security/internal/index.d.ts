// Generated by tsbindgen - Architecture
// Namespace: System.Security
// Assembly: System.Private.CoreLib, System.Runtime.InteropServices

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ArrayList, Hashtable, ICollection, IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { AssemblyName, MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { PermissionState } from "../../System.Security.Permissions/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Attribute, Boolean as ClrBoolean, Byte, Char, Enum, Exception, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, Object as ClrObject, String as ClrString, SystemException, Type, TypeCode, Void } from "../../System/internal/index.js";

export enum PartialTrustVisibilityLevel {
    VisibleToAllHosts = 0,
    NotVisibleByDefault = 1
}


export enum SecurityCriticalScope {
    Explicit = 0,
    Everything = 1
}


export enum SecurityRuleSet {
    None = 0,
    Level1 = 1,
    Level2 = 2
}


export interface IPermission$instance extends ISecurityEncodable {
    Copy(): IPermission;
    Demand(): void;
    FromXml(e: SecurityElement): void;
    Intersect(target: IPermission): IPermission;
    IsSubsetOf(target: IPermission): boolean;
    ToXml(): SecurityElement;
}


export interface IPermission$instance extends ISecurityEncodable$instance {}

export type IPermission = IPermission$instance;

export interface ISecurityEncodable$instance {
    FromXml(e: SecurityElement): void;
    ToXml(): SecurityElement;
}


export type ISecurityEncodable = ISecurityEncodable$instance;

export interface IStackWalk$instance {
    Assert(): void;
}


export type IStackWalk = IStackWalk$instance;

export interface AllowPartiallyTrustedCallersAttribute$instance extends Attribute {
    PartialTrustVisibilityLevel: PartialTrustVisibilityLevel;
}


export const AllowPartiallyTrustedCallersAttribute: {
    new(): AllowPartiallyTrustedCallersAttribute$instance;
};


export type AllowPartiallyTrustedCallersAttribute = AllowPartiallyTrustedCallersAttribute$instance;

export interface PermissionSet$instance {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    readonly SyncRoot: unknown;
    AddPermission(perm: IPermission): IPermission;
    Assert(): void;
    ContainsNonCodeAccessPermissions(): boolean;
    Copy(): PermissionSet;
    CopyTo(array: ClrArray, index: int): void;
    Demand(): void;
    Deny(): void;
    Equals(o: unknown): boolean;
    FromXml(et: SecurityElement): void;
    GetEnumerator(): IEnumerator;
    GetHashCode(): int;
    GetPermission(permClass: Type): IPermission;
    Intersect(other: PermissionSet): PermissionSet;
    IsEmpty(): boolean;
    IsSubsetOf(target: PermissionSet): boolean;
    IsUnrestricted(): boolean;
    PermitOnly(): void;
    RemovePermission(permClass: Type): IPermission;
    SetPermission(perm: IPermission): IPermission;
    ToString(): string;
    ToXml(): SecurityElement;
    Union(other: PermissionSet): PermissionSet;
}


export const PermissionSet: {
    new(state: PermissionState): PermissionSet$instance;
    new(permSet: PermissionSet): PermissionSet$instance;
    ConvertPermissionSet(inFormat: string, inData: byte[], outFormat: string): byte[];
    RevertAssert(): void;
};


export interface __PermissionSet$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISecurityEncodable(): ISecurityEncodable$instance;
    As_IStackWalk(): IStackWalk$instance;
}

export interface PermissionSet$instance extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, ISecurityEncodable$instance, IStackWalk$instance {}

export type PermissionSet = PermissionSet$instance & __PermissionSet$views;


export interface SecureString$instance {
    readonly Length: int;
    AppendChar(c: char): void;
    Clear(): void;
    Copy(): SecureString;
    Dispose(): void;
    InsertAt(index: int, c: char): void;
    IsReadOnly(): boolean;
    MakeReadOnly(): void;
    RemoveAt(index: int): void;
    SetAt(index: int, c: char): void;
}


export const SecureString: {
    new(): SecureString$instance;
    new(value: ptr<char>, length: int): SecureString$instance;
};


export interface __SecureString$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface SecureString$instance extends System_Internal.IDisposable$instance {}

export type SecureString = SecureString$instance & __SecureString$views;


export interface SecurityCriticalAttribute$instance extends Attribute {
    readonly Scope: SecurityCriticalScope;
}


export const SecurityCriticalAttribute: {
    new(): SecurityCriticalAttribute$instance;
    new(scope: SecurityCriticalScope): SecurityCriticalAttribute$instance;
};


export type SecurityCriticalAttribute = SecurityCriticalAttribute$instance;

export interface SecurityElement$instance {
    Attributes: Hashtable;
    Children: ArrayList;
    Tag: string;
    Text: string;
    AddAttribute(name: string, value: string): void;
    AddChild(child: SecurityElement): void;
    Attribute(name: string): string;
    Copy(): SecurityElement;
    Equal(other: SecurityElement): boolean;
    SearchForChildByTag(tag: string): SecurityElement;
    SearchForTextOfTag(tag: string): string;
    ToString(): string;
}


export const SecurityElement: {
    new(tag: string): SecurityElement$instance;
    new(tag: string, text: string): SecurityElement$instance;
    Escape(str: string): string;
    FromString(xml: string): SecurityElement;
    IsValidAttributeName(name: string): boolean;
    IsValidAttributeValue(value: string): boolean;
    IsValidTag(tag: string): boolean;
    IsValidText(text: string): boolean;
};


export type SecurityElement = SecurityElement$instance;

export interface SecurityException$instance extends SystemException {
    Demanded: unknown;
    DenySetInstance: unknown;
    FailedAssemblyInfo: AssemblyName;
    GrantedSet: string;
    Method: MethodInfo;
    PermissionState: string;
    PermissionType: Type;
    PermitOnlySetInstance: unknown;
    RefusedSet: string;
    Url: string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    ToString(): string;
}


export const SecurityException: {
    new(): SecurityException$instance;
    new(message: string): SecurityException$instance;
    new(message: string, inner: Exception): SecurityException$instance;
    new(message: string, type_: Type): SecurityException$instance;
    new(message: string, type_: Type, state: string): SecurityException$instance;
};


export interface __SecurityException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SecurityException = SecurityException$instance & __SecurityException$views;


export interface SecurityRulesAttribute$instance extends Attribute {
    readonly RuleSet: SecurityRuleSet;
    SkipVerificationInFullTrust: boolean;
}


export const SecurityRulesAttribute: {
    new(ruleSet: SecurityRuleSet): SecurityRulesAttribute$instance;
};


export type SecurityRulesAttribute = SecurityRulesAttribute$instance;

export interface SecuritySafeCriticalAttribute$instance extends Attribute {
}


export const SecuritySafeCriticalAttribute: {
    new(): SecuritySafeCriticalAttribute$instance;
};


export type SecuritySafeCriticalAttribute = SecuritySafeCriticalAttribute$instance;

export interface SecurityTransparentAttribute$instance extends Attribute {
}


export const SecurityTransparentAttribute: {
    new(): SecurityTransparentAttribute$instance;
};


export type SecurityTransparentAttribute = SecurityTransparentAttribute$instance;

export interface SecurityTreatAsSafeAttribute$instance extends Attribute {
}


export const SecurityTreatAsSafeAttribute: {
    new(): SecurityTreatAsSafeAttribute$instance;
};


export type SecurityTreatAsSafeAttribute = SecurityTreatAsSafeAttribute$instance;

export interface SuppressUnmanagedCodeSecurityAttribute$instance extends Attribute {
}


export const SuppressUnmanagedCodeSecurityAttribute: {
    new(): SuppressUnmanagedCodeSecurityAttribute$instance;
};


export type SuppressUnmanagedCodeSecurityAttribute = SuppressUnmanagedCodeSecurityAttribute$instance;

export interface UnverifiableCodeAttribute$instance extends Attribute {
}


export const UnverifiableCodeAttribute: {
    new(): UnverifiableCodeAttribute$instance;
};


export type UnverifiableCodeAttribute = UnverifiableCodeAttribute$instance;

export interface VerificationException$instance extends SystemException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const VerificationException: {
    new(): VerificationException$instance;
    new(message: string): VerificationException$instance;
    new(message: string, innerException: Exception): VerificationException$instance;
};


export interface __VerificationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type VerificationException = VerificationException$instance & __VerificationException$views;


export abstract class SecureStringMarshal$instance {
    static SecureStringToCoTaskMemAnsi(s: SecureString): nint;
    static SecureStringToCoTaskMemUnicode(s: SecureString): nint;
    static SecureStringToGlobalAllocAnsi(s: SecureString): nint;
    static SecureStringToGlobalAllocUnicode(s: SecureString): nint;
}


export type SecureStringMarshal = SecureStringMarshal$instance;


// Generated by tsbindgen - Architecture
// Namespace: System.Security
// Assembly: System.Private.CoreLib, System.Runtime.InteropServices

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ArrayList, Hashtable, ICollection, IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { AssemblyName, MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { PermissionState } from "../../System.Security.Permissions/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Attribute, Boolean as ClrBoolean, Byte, Char, Enum, Exception, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, Object as ClrObject, String as ClrString, SystemException, Type, TypeCode, Void } from "../../System/internal/index.js";

export enum PartialTrustVisibilityLevel {
    VisibleToAllHosts = 0,
    NotVisibleByDefault = 1
}


export enum SecurityCriticalScope {
    Explicit = 0,
    Everything = 1
}


export enum SecurityRuleSet {
    None = 0,
    Level1 = 1,
    Level2 = 2
}


export interface IPermission$instance extends ISecurityEncodable {
    Copy(): IPermission;
    Demand(): void;
    FromXml(e: SecurityElement): void;
    Intersect(target: IPermission): IPermission | undefined;
    IsSubsetOf(target: IPermission): boolean;
    ToXml(): SecurityElement | undefined;
}


export interface IPermission$instance extends ISecurityEncodable$instance {}

export type IPermission = IPermission$instance;

export interface ISecurityEncodable$instance {
    FromXml(e: SecurityElement): void;
    ToXml(): SecurityElement | undefined;
}


export type ISecurityEncodable = ISecurityEncodable$instance;

export interface IStackWalk$instance {
    Assert(): void;
}


export type IStackWalk = IStackWalk$instance;

export interface AllowPartiallyTrustedCallersAttribute$instance extends Attribute {
    PartialTrustVisibilityLevel: PartialTrustVisibilityLevel;
}


export const AllowPartiallyTrustedCallersAttribute: {
    new(): AllowPartiallyTrustedCallersAttribute;
};


export type AllowPartiallyTrustedCallersAttribute = AllowPartiallyTrustedCallersAttribute$instance;

export interface PermissionSet$instance {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    readonly SyncRoot: unknown;
    AddPermission(perm: IPermission): IPermission | undefined;
    Assert(): void;
    ContainsNonCodeAccessPermissions(): boolean;
    Copy(): PermissionSet;
    CopyTo(array: ClrArray, index: int): void;
    Demand(): void;
    Deny(): void;
    Equals(o: unknown): boolean;
    FromXml(et: SecurityElement): void;
    GetEnumerator(): IEnumerator;
    GetHashCode(): int;
    GetPermission(permClass: Type): IPermission | undefined;
    Intersect(other: PermissionSet): PermissionSet | undefined;
    IsEmpty(): boolean;
    IsSubsetOf(target: PermissionSet): boolean;
    IsUnrestricted(): boolean;
    PermitOnly(): void;
    RemovePermission(permClass: Type): IPermission | undefined;
    SetPermission(perm: IPermission): IPermission | undefined;
    ToString(): string;
    ToXml(): SecurityElement | undefined;
    Union(other: PermissionSet): PermissionSet | undefined;
}


export const PermissionSet: {
    new(state: PermissionState): PermissionSet;
    new(permSet: PermissionSet): PermissionSet;
    ConvertPermissionSet(inFormat: string, inData: byte[], outFormat: string): byte[];
    RevertAssert(): void;
};


export interface __PermissionSet$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISecurityEncodable(): ISecurityEncodable$instance;
    As_IStackWalk(): IStackWalk$instance;
}

export interface PermissionSet$instance extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, ISecurityEncodable$instance, IStackWalk$instance {}

export type PermissionSet = PermissionSet$instance & __PermissionSet$views;


export interface SecureString$instance {
    readonly Length: int;
    AppendChar(c: char): void;
    Clear(): void;
    Copy(): SecureString;
    Dispose(): void;
    InsertAt(index: int, c: char): void;
    IsReadOnly(): boolean;
    MakeReadOnly(): void;
    RemoveAt(index: int): void;
    SetAt(index: int, c: char): void;
}


export const SecureString: {
    new(): SecureString;
    new(value: ptr<char>, length: int): SecureString;
};


export interface __SecureString$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface SecureString$instance extends System_Internal.IDisposable$instance {}

export type SecureString = SecureString$instance & __SecureString$views;


export interface SecurityCriticalAttribute$instance extends Attribute {
    readonly Scope: SecurityCriticalScope;
}


export const SecurityCriticalAttribute: {
    new(): SecurityCriticalAttribute;
    new(scope: SecurityCriticalScope): SecurityCriticalAttribute;
};


export type SecurityCriticalAttribute = SecurityCriticalAttribute$instance;

export interface SecurityElement$instance {
    Attributes: Hashtable;
    get Children(): ArrayList | undefined;
    set Children(value: ArrayList);
    Tag: string;
    Text: string;
    AddAttribute(name: string, value: string): void;
    AddChild(child: SecurityElement): void;
    Attribute(name: string): string | undefined;
    Copy(): SecurityElement;
    Equal(other: SecurityElement): boolean;
    SearchForChildByTag(tag: string): SecurityElement | undefined;
    SearchForTextOfTag(tag: string): string | undefined;
    ToString(): string;
}


export const SecurityElement: {
    new(tag: string): SecurityElement;
    new(tag: string, text: string): SecurityElement;
    Escape(str: string): string | undefined;
    FromString(xml: string): SecurityElement | undefined;
    IsValidAttributeName(name: string): boolean;
    IsValidAttributeValue(value: string): boolean;
    IsValidTag(tag: string): boolean;
    IsValidText(text: string): boolean;
};


export type SecurityElement = SecurityElement$instance;

export interface SecurityException$instance extends SystemException {
    get Demanded(): unknown | undefined;
    set Demanded(value: unknown);
    get DenySetInstance(): unknown | undefined;
    set DenySetInstance(value: unknown);
    get FailedAssemblyInfo(): AssemblyName | undefined;
    set FailedAssemblyInfo(value: AssemblyName);
    get GrantedSet(): string | undefined;
    set GrantedSet(value: string);
    Method: MethodInfo;
    get PermissionState(): string | undefined;
    set PermissionState(value: string);
    get PermissionType(): Type | undefined;
    set PermissionType(value: Type);
    get PermitOnlySetInstance(): unknown | undefined;
    set PermitOnlySetInstance(value: unknown);
    get RefusedSet(): string | undefined;
    set RefusedSet(value: string);
    get Url(): string | undefined;
    set Url(value: string);
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    ToString(): string;
}


export const SecurityException: {
    new(): SecurityException;
    new(message: string): SecurityException;
    new(message: string, inner: Exception): SecurityException;
    new(message: string, type_: Type): SecurityException;
    new(message: string, type_: Type, state: string): SecurityException;
};


export interface __SecurityException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SecurityException = SecurityException$instance & __SecurityException$views;


export interface SecurityRulesAttribute$instance extends Attribute {
    readonly RuleSet: SecurityRuleSet;
    SkipVerificationInFullTrust: boolean;
}


export const SecurityRulesAttribute: {
    new(ruleSet: SecurityRuleSet): SecurityRulesAttribute;
};


export type SecurityRulesAttribute = SecurityRulesAttribute$instance;

export interface SecuritySafeCriticalAttribute$instance extends Attribute {
}


export const SecuritySafeCriticalAttribute: {
    new(): SecuritySafeCriticalAttribute;
};


export type SecuritySafeCriticalAttribute = SecuritySafeCriticalAttribute$instance;

export interface SecurityTransparentAttribute$instance extends Attribute {
}


export const SecurityTransparentAttribute: {
    new(): SecurityTransparentAttribute;
};


export type SecurityTransparentAttribute = SecurityTransparentAttribute$instance;

export interface SecurityTreatAsSafeAttribute$instance extends Attribute {
}


export const SecurityTreatAsSafeAttribute: {
    new(): SecurityTreatAsSafeAttribute;
};


export type SecurityTreatAsSafeAttribute = SecurityTreatAsSafeAttribute$instance;

export interface SuppressUnmanagedCodeSecurityAttribute$instance extends Attribute {
}


export const SuppressUnmanagedCodeSecurityAttribute: {
    new(): SuppressUnmanagedCodeSecurityAttribute;
};


export type SuppressUnmanagedCodeSecurityAttribute = SuppressUnmanagedCodeSecurityAttribute$instance;

export interface UnverifiableCodeAttribute$instance extends Attribute {
}


export const UnverifiableCodeAttribute: {
    new(): UnverifiableCodeAttribute;
};


export type UnverifiableCodeAttribute = UnverifiableCodeAttribute$instance;

export interface VerificationException$instance extends SystemException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const VerificationException: {
    new(): VerificationException;
    new(message: string): VerificationException;
    new(message: string, innerException: Exception): VerificationException;
};


export interface __VerificationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type VerificationException = VerificationException$instance & __VerificationException$views;


export abstract class SecureStringMarshal$instance {
    static SecureStringToCoTaskMemAnsi(s: SecureString): nint;
    static SecureStringToCoTaskMemUnicode(s: SecureString): nint;
    static SecureStringToGlobalAllocAnsi(s: SecureString): nint;
    static SecureStringToGlobalAllocUnicode(s: SecureString): nint;
}


export type SecureStringMarshal = SecureStringMarshal$instance;


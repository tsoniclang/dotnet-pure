// Generated by tsbindgen - Architecture
// Namespace: System.Threading.Tasks
// Assembly: System.Private.CoreLib, System.Threading.Tasks.Parallel

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { OrderablePartitioner_1, Partitioner_1 } from "../../System.Collections.Concurrent/internal/index.js";
import type { IAsyncEnumerable_1, IEnumerable_1 } from "../../System.Collections.Generic/internal/index.js";
import type { IDictionary } from "../../System.Collections/internal/index.js";
import type { IBinaryInteger_1 } from "../../System.Numerics/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import type { ConfiguredAsyncDisposable, ConfiguredCancelableAsyncEnumerable_1, ConfiguredTaskAwaitable, ConfiguredTaskAwaitable_1, ConfiguredValueTaskAwaitable, ConfiguredValueTaskAwaitable_1, TaskAwaiter, TaskAwaiter_1, ValueTaskAwaiter, ValueTaskAwaiter_1, YieldAwaitable } from "../../System.Runtime.CompilerServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { IValueTaskSource, IValueTaskSource_1 } from "../../System.Threading.Tasks.Sources/internal/index.js";
import type { CancellationToken, WaitHandle } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action, Action_1, Action_2, Action_3, AggregateException, AsyncCallback, Boolean as ClrBoolean, Enum, EventArgs, EventHandler_1, Exception, Func_1, Func_2, Func_3, Func_4, Func_5, Func_6, IAsyncDisposable, IAsyncResult, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, ISpanFormattable, Nullable_1, Object as ClrObject, OperationCanceledException, ReadOnlySpan_1, String as ClrString, TimeProvider, TimeSpan, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

export enum ConfigureAwaitOptions {
    None = 0,
    ContinueOnCapturedContext = 1,
    SuppressThrowing = 2,
    ForceYielding = 4
}


export enum TaskContinuationOptions {
    None = 0,
    PreferFairness = 1,
    LongRunning = 2,
    AttachedToParent = 4,
    DenyChildAttach = 8,
    HideScheduler = 16,
    LazyCancellation = 32,
    RunContinuationsAsynchronously = 64,
    NotOnRanToCompletion = 65536,
    NotOnFaulted = 131072,
    NotOnCanceled = 262144,
    OnlyOnRanToCompletion = 393216,
    OnlyOnFaulted = 327680,
    OnlyOnCanceled = 196608,
    ExecuteSynchronously = 524288
}


export enum TaskCreationOptions {
    None = 0,
    PreferFairness = 1,
    LongRunning = 2,
    AttachedToParent = 4,
    DenyChildAttach = 8,
    HideScheduler = 16,
    RunContinuationsAsynchronously = 64
}


export enum TaskStatus {
    Created = 0,
    WaitingForActivation = 1,
    WaitingToRun = 2,
    Running = 3,
    WaitingForChildrenToComplete = 4,
    RanToCompletion = 5,
    Canceled = 6,
    Faulted = 7
}


export interface ParallelLoopResult$instance {
    readonly IsCompleted: boolean;
    readonly LowestBreakIteration: Nullable_1<System_Internal.Int64>;
}


export const ParallelLoopResult: {
    new(): ParallelLoopResult$instance;
};


export type ParallelLoopResult = ParallelLoopResult$instance;

export interface ValueTask$instance {
    readonly IsCanceled: boolean;
    readonly IsCompleted: boolean;
    readonly IsCompletedSuccessfully: boolean;
    readonly IsFaulted: boolean;
    AsTask(): Task;
    ConfigureAwait(continueOnCapturedContext: boolean): ConfiguredValueTaskAwaitable;
    Equals(obj: unknown): boolean;
    Equals(other: ValueTask): boolean;
    GetAwaiter(): ValueTaskAwaiter;
    GetHashCode(): int;
    Preserve(): ValueTask;
}


export const ValueTask: {
    new(task: Task): ValueTask$instance;
    new(source: IValueTaskSource, token: short): ValueTask$instance;
    readonly CompletedTask: ValueTask;
    FromCanceled(cancellationToken: CancellationToken): ValueTask;
    FromCanceled<TResult>(cancellationToken: CancellationToken): ValueTask_1<TResult>;
    FromException(exception: Exception): ValueTask;
    FromException<TResult>(exception: Exception): ValueTask_1<TResult>;
    FromResult<TResult>(result: TResult): ValueTask_1<TResult>;
};


export interface __ValueTask$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<ValueTask>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ValueTask): boolean;
}

export type ValueTask = ValueTask$instance & __ValueTask$views;


export interface ValueTask_1$instance<TResult> {
    readonly IsCanceled: boolean;
    readonly IsCompleted: boolean;
    readonly IsCompletedSuccessfully: boolean;
    readonly IsFaulted: boolean;
    readonly Result: TResult;
    AsTask(): Task_1<TResult>;
    ConfigureAwait(continueOnCapturedContext: boolean): ConfiguredValueTaskAwaitable_1<TResult>;
    Equals(obj: unknown): boolean;
    Equals(other: ValueTask_1<TResult>): boolean;
    GetAwaiter(): ValueTaskAwaiter_1<TResult>;
    GetHashCode(): int;
    Preserve(): ValueTask_1<TResult>;
    ToString(): string;
}


export const ValueTask_1: {
    new<TResult>(result: TResult): ValueTask_1$instance<TResult>;
    new<TResult>(task: Task_1<TResult>): ValueTask_1$instance<TResult>;
    new<TResult>(source: IValueTaskSource_1<TResult>, token: short): ValueTask_1$instance<TResult>;
};


export interface __ValueTask_1$views<TResult> {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<ValueTask_1<TResult>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ValueTask_1<TResult>): boolean;
}

export type ValueTask_1<TResult> = ValueTask_1$instance<TResult> & __ValueTask_1$views<TResult>;


export interface ConcurrentExclusiveSchedulerPair$instance {
    readonly Completion: Task;
    readonly ConcurrentScheduler: TaskScheduler;
    readonly ExclusiveScheduler: TaskScheduler;
    Complete(): void;
}


export const ConcurrentExclusiveSchedulerPair: {
    new(): ConcurrentExclusiveSchedulerPair$instance;
    new(taskScheduler: TaskScheduler): ConcurrentExclusiveSchedulerPair$instance;
    new(taskScheduler: TaskScheduler, maxConcurrencyLevel: int): ConcurrentExclusiveSchedulerPair$instance;
    new(taskScheduler: TaskScheduler, maxConcurrencyLevel: int, maxItemsPerTask: int): ConcurrentExclusiveSchedulerPair$instance;
};


export type ConcurrentExclusiveSchedulerPair = ConcurrentExclusiveSchedulerPair$instance;

export interface ParallelLoopState$instance {
    readonly IsExceptional: boolean;
    readonly IsStopped: boolean;
    readonly LowestBreakIteration: Nullable_1<System_Internal.Int64>;
    readonly ShouldExitCurrentIteration: boolean;
    Break(): void;
    Stop(): void;
}


export const ParallelLoopState: {
    new(): ParallelLoopState$instance;
};


export type ParallelLoopState = ParallelLoopState$instance;

export interface ParallelOptions$instance {
    CancellationToken: CancellationToken;
    MaxDegreeOfParallelism: int;
    TaskScheduler: TaskScheduler;
}


export const ParallelOptions: {
    new(): ParallelOptions$instance;
};


export type ParallelOptions = ParallelOptions$instance;

export interface Task$instance {
    readonly AsyncState: unknown;
    readonly CreationOptions: TaskCreationOptions;
    readonly Exception: AggregateException;
    readonly Id: int;
    readonly IsCanceled: boolean;
    readonly IsCompleted: boolean;
    readonly IsCompletedSuccessfully: boolean;
    readonly IsFaulted: boolean;
    readonly Status: TaskStatus;
    ConfigureAwait(continueOnCapturedContext: boolean): ConfiguredTaskAwaitable;
    ConfigureAwait(options: ConfigureAwaitOptions): ConfiguredTaskAwaitable;
    ContinueWith(continuationAction: Action_1<Task>): Task;
    ContinueWith(continuationAction: Action_1<Task>, cancellationToken: CancellationToken): Task;
    ContinueWith(continuationAction: Action_1<Task>, scheduler: TaskScheduler): Task;
    ContinueWith(continuationAction: Action_1<Task>, continuationOptions: TaskContinuationOptions): Task;
    ContinueWith(continuationAction: Action_1<Task>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    ContinueWith(continuationAction: Action_2<Task, unknown>, state: unknown): Task;
    ContinueWith(continuationAction: Action_2<Task, unknown>, state: unknown, cancellationToken: CancellationToken): Task;
    ContinueWith(continuationAction: Action_2<Task, unknown>, state: unknown, scheduler: TaskScheduler): Task;
    ContinueWith(continuationAction: Action_2<Task, unknown>, state: unknown, continuationOptions: TaskContinuationOptions): Task;
    ContinueWith(continuationAction: Action_2<Task, unknown>, state: unknown, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    ContinueWith<TResult>(continuationFunction: Func_2<Task, TResult>): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_2<Task, TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_2<Task, TResult>, scheduler: TaskScheduler): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_2<Task, TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_2<Task, TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_3<Task, unknown, TResult>, state: unknown): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_3<Task, unknown, TResult>, state: unknown, cancellationToken: CancellationToken): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_3<Task, unknown, TResult>, state: unknown, scheduler: TaskScheduler): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_3<Task, unknown, TResult>, state: unknown, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_3<Task, unknown, TResult>, state: unknown, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    Dispose(): void;
    GetAwaiter(): TaskAwaiter;
    RunSynchronously(): void;
    RunSynchronously(scheduler: TaskScheduler): void;
    Start(): void;
    Start(scheduler: TaskScheduler): void;
    Wait(): void;
    Wait(timeout: TimeSpan): boolean;
    Wait(timeout: TimeSpan, cancellationToken: CancellationToken): boolean;
    Wait(cancellationToken: CancellationToken): void;
    Wait(millisecondsTimeout: int): boolean;
    Wait(millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
    WaitAsync(cancellationToken: CancellationToken): Task;
    WaitAsync(timeout: TimeSpan): Task;
    WaitAsync(timeout: TimeSpan, timeProvider: TimeProvider): Task;
    WaitAsync(timeout: TimeSpan, cancellationToken: CancellationToken): Task;
    WaitAsync(timeout: TimeSpan, timeProvider: TimeProvider, cancellationToken: CancellationToken): Task;
}


export const Task: {
    new(action: Action): Task$instance;
    new(action: Action, cancellationToken: CancellationToken): Task$instance;
    new(action: Action, creationOptions: TaskCreationOptions): Task$instance;
    new(action: Action, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions): Task$instance;
    new(action: Action_1<unknown>, state: unknown): Task$instance;
    new(action: Action_1<unknown>, state: unknown, cancellationToken: CancellationToken): Task$instance;
    new(action: Action_1<unknown>, state: unknown, creationOptions: TaskCreationOptions): Task$instance;
    new(action: Action_1<unknown>, state: unknown, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions): Task$instance;
    readonly CurrentId: Nullable_1<System_Internal.Int32>;
    readonly Factory: TaskFactory;
    readonly CompletedTask: Task;
    Delay(millisecondsDelay: int, cancellationToken: CancellationToken): Task;
    Delay(millisecondsDelay: int): Task;
    Delay(delay: TimeSpan, cancellationToken: CancellationToken): Task;
    Delay(delay: TimeSpan, timeProvider: TimeProvider, cancellationToken: CancellationToken): Task;
    Delay(delay: TimeSpan, timeProvider: TimeProvider): Task;
    Delay(delay: TimeSpan): Task;
    FromCanceled(cancellationToken: CancellationToken): Task;
    FromCanceled<TResult>(cancellationToken: CancellationToken): Task_1<TResult>;
    FromException(exception: Exception): Task;
    FromException<TResult>(exception: Exception): Task_1<TResult>;
    FromResult<TResult>(result: TResult): Task_1<TResult>;
    Run<TResult>(function_: Func_1<TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    Run<TResult>(function_: Func_1<TResult>): Task_1<TResult>;
    Run(action: Action, cancellationToken: CancellationToken): Task;
    Run(action: Action): Task;
    Run(function_: Func_1<Task>, cancellationToken: CancellationToken): Task;
    Run(function_: Func_1<Task>): Task;
    WaitAll(tasks: IEnumerable_1<Task>, cancellationToken?: CancellationToken): void;
    WaitAll(tasks: ReadOnlySpan_1<Task>): void;
    WaitAll(tasks: Task[], millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
    WaitAll(tasks: Task[], millisecondsTimeout: int): boolean;
    WaitAll(tasks: Task[], cancellationToken: CancellationToken): void;
    WaitAll(tasks: Task[], timeout: TimeSpan): boolean;
    WaitAll(...tasks: Task[]): void;
    WaitAny(tasks: Task[], millisecondsTimeout: int, cancellationToken: CancellationToken): int;
    WaitAny(tasks: Task[], millisecondsTimeout: int): int;
    WaitAny(tasks: Task[], cancellationToken: CancellationToken): int;
    WaitAny(tasks: Task[], timeout: TimeSpan): int;
    WaitAny(...tasks: Task[]): int;
    WhenAll<TResult>(tasks: IEnumerable_1<Task_1<TResult>>): Task_1<TResult[]>;
    WhenAll<TResult>(tasks: ReadOnlySpan_1<Task_1<TResult>>): Task_1<TResult[]>;
    WhenAll(tasks: IEnumerable_1<Task>): Task;
    WhenAll(tasks: ReadOnlySpan_1<Task>): Task;
    WhenAll(...tasks: Task[]): Task;
    WhenAll<TResult>(...tasks: Task_1<TResult>[]): Task_1<TResult[]>;
    WhenAny<TResult>(tasks: IEnumerable_1<Task_1<TResult>>): Task_1<Task_1<TResult>>;
    WhenAny<TResult>(tasks: ReadOnlySpan_1<Task_1<TResult>>): Task_1<Task_1<TResult>>;
    WhenAny(tasks: IEnumerable_1<Task>): Task_1<Task>;
    WhenAny(tasks: ReadOnlySpan_1<Task>): Task_1<Task>;
    WhenAny(task1: Task, task2: Task): Task_1<Task>;
    WhenAny(...tasks: Task[]): Task_1<Task>;
    WhenAny<TResult>(task1: Task_1<TResult>, task2: Task_1<TResult>): Task_1<Task_1<TResult>>;
    WhenAny<TResult>(...tasks: Task_1<TResult>[]): Task_1<Task_1<TResult>>;
    WhenEach<TResult>(tasks: IEnumerable_1<Task_1<TResult>>): IAsyncEnumerable_1<Task_1<TResult>>;
    WhenEach<TResult>(tasks: ReadOnlySpan_1<Task_1<TResult>>): IAsyncEnumerable_1<Task_1<TResult>>;
    WhenEach(tasks: IEnumerable_1<Task>): IAsyncEnumerable_1<Task>;
    WhenEach(tasks: ReadOnlySpan_1<Task>): IAsyncEnumerable_1<Task>;
    WhenEach(...tasks: Task[]): IAsyncEnumerable_1<Task>;
    WhenEach<TResult>(...tasks: Task_1<TResult>[]): IAsyncEnumerable_1<Task_1<TResult>>;
    Yield(): YieldAwaitable;
};


export interface __Task$views {
    As_IAsyncResult(): System_Internal.IAsyncResult$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Task$instance extends System_Internal.IAsyncResult$instance, System_Internal.IDisposable$instance {}

export type Task = Task$instance & __Task$views;


export interface Task_1$instance<TResult> extends Task$instance {
    readonly Result: TResult;
    ConfigureAwait(options: ConfigureAwaitOptions): ConfiguredTaskAwaitable_1<TResult>;
    ConfigureAwait(continueOnCapturedContext: boolean): ConfiguredTaskAwaitable;
    ConfigureAwait(options: ConfigureAwaitOptions): ConfiguredTaskAwaitable;
    ContinueWith(continuationAction: Action_1<Task_1<TResult>>): Task;
    ContinueWith(continuationAction: Action_1<Task_1<TResult>>, cancellationToken: CancellationToken): Task;
    ContinueWith(continuationAction: Action_1<Task_1<TResult>>, scheduler: TaskScheduler): Task;
    ContinueWith(continuationAction: Action_1<Task_1<TResult>>, continuationOptions: TaskContinuationOptions): Task;
    ContinueWith(continuationAction: Action_1<Task_1<TResult>>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    ContinueWith(continuationAction: Action_2<Task_1<TResult>, unknown>, state: unknown): Task;
    ContinueWith(continuationAction: Action_2<Task_1<TResult>, unknown>, state: unknown, cancellationToken: CancellationToken): Task;
    ContinueWith(continuationAction: Action_2<Task_1<TResult>, unknown>, state: unknown, scheduler: TaskScheduler): Task;
    ContinueWith(continuationAction: Action_2<Task_1<TResult>, unknown>, state: unknown, continuationOptions: TaskContinuationOptions): Task;
    ContinueWith(continuationAction: Action_2<Task_1<TResult>, unknown>, state: unknown, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    ContinueWith<TNewResult>(continuationFunction: Func_2<Task_1<TResult>, TNewResult>): Task_1<TNewResult>;
    ContinueWith<TNewResult>(continuationFunction: Func_2<Task_1<TResult>, TNewResult>, cancellationToken: CancellationToken): Task_1<TNewResult>;
    ContinueWith<TNewResult>(continuationFunction: Func_2<Task_1<TResult>, TNewResult>, scheduler: TaskScheduler): Task_1<TNewResult>;
    ContinueWith<TNewResult>(continuationFunction: Func_2<Task_1<TResult>, TNewResult>, continuationOptions: TaskContinuationOptions): Task_1<TNewResult>;
    ContinueWith<TNewResult>(continuationFunction: Func_2<Task_1<TResult>, TNewResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TNewResult>;
    ContinueWith<TNewResult>(continuationFunction: Func_3<Task_1<TResult>, unknown, TNewResult>, state: unknown): Task_1<TNewResult>;
    ContinueWith<TNewResult>(continuationFunction: Func_3<Task_1<TResult>, unknown, TNewResult>, state: unknown, cancellationToken: CancellationToken): Task_1<TNewResult>;
    ContinueWith<TNewResult>(continuationFunction: Func_3<Task_1<TResult>, unknown, TNewResult>, state: unknown, scheduler: TaskScheduler): Task_1<TNewResult>;
    ContinueWith<TNewResult>(continuationFunction: Func_3<Task_1<TResult>, unknown, TNewResult>, state: unknown, continuationOptions: TaskContinuationOptions): Task_1<TNewResult>;
    ContinueWith<TNewResult>(continuationFunction: Func_3<Task_1<TResult>, unknown, TNewResult>, state: unknown, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TNewResult>;
    ContinueWith(continuationAction: Action_1<Task>): Task;
    ContinueWith(continuationAction: Action_1<Task>, cancellationToken: CancellationToken): Task;
    ContinueWith(continuationAction: Action_1<Task>, scheduler: TaskScheduler): Task;
    ContinueWith(continuationAction: Action_1<Task>, continuationOptions: TaskContinuationOptions): Task;
    ContinueWith(continuationAction: Action_1<Task>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    ContinueWith(continuationAction: Action_2<Task, unknown>, state: unknown): Task;
    ContinueWith(continuationAction: Action_2<Task, unknown>, state: unknown, cancellationToken: CancellationToken): Task;
    ContinueWith(continuationAction: Action_2<Task, unknown>, state: unknown, scheduler: TaskScheduler): Task;
    ContinueWith(continuationAction: Action_2<Task, unknown>, state: unknown, continuationOptions: TaskContinuationOptions): Task;
    ContinueWith(continuationAction: Action_2<Task, unknown>, state: unknown, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    ContinueWith<TResult>(continuationFunction: Func_2<Task, TResult>): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_2<Task, TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_2<Task, TResult>, scheduler: TaskScheduler): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_2<Task, TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_2<Task, TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_3<Task, unknown, TResult>, state: unknown): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_3<Task, unknown, TResult>, state: unknown, cancellationToken: CancellationToken): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_3<Task, unknown, TResult>, state: unknown, scheduler: TaskScheduler): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_3<Task, unknown, TResult>, state: unknown, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    ContinueWith<TResult>(continuationFunction: Func_3<Task, unknown, TResult>, state: unknown, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    Dispose(): void;
    GetAwaiter(): TaskAwaiter;
    WaitAsync(timeout: TimeSpan): Task_1<TResult>;
    WaitAsync(timeout: TimeSpan, timeProvider: TimeProvider): Task_1<TResult>;
    WaitAsync(cancellationToken: CancellationToken): Task;
    WaitAsync(timeout: TimeSpan): Task;
    WaitAsync(timeout: TimeSpan, timeProvider: TimeProvider): Task;
    WaitAsync(timeout: TimeSpan, cancellationToken: CancellationToken): Task;
    WaitAsync(timeout: TimeSpan, timeProvider: TimeProvider, cancellationToken: CancellationToken): Task;
}


export const Task_1: {
    new<TResult>(function_: Func_1<TResult>): Task_1$instance<TResult>;
    new<TResult>(function_: Func_1<TResult>, cancellationToken: CancellationToken): Task_1$instance<TResult>;
    new<TResult>(function_: Func_1<TResult>, creationOptions: TaskCreationOptions): Task_1$instance<TResult>;
    new<TResult>(function_: Func_1<TResult>, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions): Task_1$instance<TResult>;
    new<TResult>(function_: Func_2<unknown, TResult>, state: unknown): Task_1$instance<TResult>;
    new<TResult>(function_: Func_2<unknown, TResult>, state: unknown, cancellationToken: CancellationToken): Task_1$instance<TResult>;
    new<TResult>(function_: Func_2<unknown, TResult>, state: unknown, creationOptions: TaskCreationOptions): Task_1$instance<TResult>;
    new<TResult>(function_: Func_2<unknown, TResult>, state: unknown, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions): Task_1$instance<TResult>;
};


export interface __Task_1$views<TResult> {
    As_IAsyncResult(): System_Internal.IAsyncResult$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Task_1$instance<TResult> extends System_Internal.IAsyncResult$instance {}

export type Task_1<TResult> = Task_1$instance<TResult> & __Task_1$views<TResult>;


export interface TaskCanceledException$instance extends OperationCanceledException {
    readonly Task: Task;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TaskCanceledException: {
    new(): TaskCanceledException$instance;
    new(message: string): TaskCanceledException$instance;
    new(message: string, innerException: Exception): TaskCanceledException$instance;
    new(message: string, innerException: Exception, token: CancellationToken): TaskCanceledException$instance;
    new(task: Task): TaskCanceledException$instance;
};


export interface __TaskCanceledException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TaskCanceledException = TaskCanceledException$instance & __TaskCanceledException$views;


export interface TaskCompletionSource$instance {
    readonly Task: Task;
    SetCanceled(): void;
    SetCanceled(cancellationToken: CancellationToken): void;
    SetException(exception: Exception): void;
    SetException(exceptions: IEnumerable_1<Exception>): void;
    SetFromTask(completedTask: Task): void;
    SetResult(): void;
    TrySetCanceled(): boolean;
    TrySetCanceled(cancellationToken: CancellationToken): boolean;
    TrySetException(exception: Exception): boolean;
    TrySetException(exceptions: IEnumerable_1<Exception>): boolean;
    TrySetFromTask(completedTask: Task): boolean;
    TrySetResult(): boolean;
}


export const TaskCompletionSource: {
    new(): TaskCompletionSource$instance;
    new(creationOptions: TaskCreationOptions): TaskCompletionSource$instance;
    new(state: unknown): TaskCompletionSource$instance;
    new(state: unknown, creationOptions: TaskCreationOptions): TaskCompletionSource$instance;
};


export type TaskCompletionSource = TaskCompletionSource$instance;

export interface TaskCompletionSource_1$instance<TResult> {
    readonly Task: Task_1<TResult>;
    SetCanceled(): void;
    SetCanceled(cancellationToken: CancellationToken): void;
    SetException(exception: Exception): void;
    SetException(exceptions: IEnumerable_1<Exception>): void;
    SetFromTask(completedTask: Task_1<TResult>): void;
    SetResult(result: TResult): void;
    TrySetCanceled(): boolean;
    TrySetCanceled(cancellationToken: CancellationToken): boolean;
    TrySetException(exception: Exception): boolean;
    TrySetException(exceptions: IEnumerable_1<Exception>): boolean;
    TrySetFromTask(completedTask: Task_1<TResult>): boolean;
    TrySetResult(result: TResult): boolean;
}


export const TaskCompletionSource_1: {
    new<TResult>(): TaskCompletionSource_1$instance<TResult>;
    new<TResult>(creationOptions: TaskCreationOptions): TaskCompletionSource_1$instance<TResult>;
    new<TResult>(state: unknown): TaskCompletionSource_1$instance<TResult>;
    new<TResult>(state: unknown, creationOptions: TaskCreationOptions): TaskCompletionSource_1$instance<TResult>;
};


export type TaskCompletionSource_1<TResult> = TaskCompletionSource_1$instance<TResult>;

export interface TaskFactory$instance {
    readonly CancellationToken: CancellationToken;
    readonly ContinuationOptions: TaskContinuationOptions;
    readonly CreationOptions: TaskCreationOptions;
    readonly Scheduler: TaskScheduler;
    ContinueWhenAll(tasks: Task[], continuationAction: Action_1<Task[]>): Task;
    ContinueWhenAll(tasks: Task[], continuationAction: Action_1<Task[]>, cancellationToken: CancellationToken): Task;
    ContinueWhenAll(tasks: Task[], continuationAction: Action_1<Task[]>, continuationOptions: TaskContinuationOptions): Task;
    ContinueWhenAll(tasks: Task[], continuationAction: Action_1<Task[]>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    ContinueWhenAll<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationAction: Action_1<Task_1<TAntecedentResult>[]>): Task;
    ContinueWhenAll<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationAction: Action_1<Task_1<TAntecedentResult>[]>, cancellationToken: CancellationToken): Task;
    ContinueWhenAll<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationAction: Action_1<Task_1<TAntecedentResult>[]>, continuationOptions: TaskContinuationOptions): Task;
    ContinueWhenAll<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationAction: Action_1<Task_1<TAntecedentResult>[]>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    ContinueWhenAll<TResult>(tasks: Task[], continuationFunction: Func_2<Task[], TResult>): Task_1<TResult>;
    ContinueWhenAll<TResult>(tasks: Task[], continuationFunction: Func_2<Task[], TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    ContinueWhenAll<TResult>(tasks: Task[], continuationFunction: Func_2<Task[], TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    ContinueWhenAll<TResult>(tasks: Task[], continuationFunction: Func_2<Task[], TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    ContinueWhenAll<TAntecedentResult, TResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>[], TResult>): Task_1<TResult>;
    ContinueWhenAll<TAntecedentResult, TResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>[], TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    ContinueWhenAll<TAntecedentResult, TResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>[], TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    ContinueWhenAll<TAntecedentResult, TResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>[], TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    ContinueWhenAny(tasks: Task[], continuationAction: Action_1<Task>): Task;
    ContinueWhenAny(tasks: Task[], continuationAction: Action_1<Task>, cancellationToken: CancellationToken): Task;
    ContinueWhenAny(tasks: Task[], continuationAction: Action_1<Task>, continuationOptions: TaskContinuationOptions): Task;
    ContinueWhenAny(tasks: Task[], continuationAction: Action_1<Task>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    ContinueWhenAny<TResult>(tasks: Task[], continuationFunction: Func_2<Task, TResult>): Task_1<TResult>;
    ContinueWhenAny<TResult>(tasks: Task[], continuationFunction: Func_2<Task, TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    ContinueWhenAny<TResult>(tasks: Task[], continuationFunction: Func_2<Task, TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    ContinueWhenAny<TResult>(tasks: Task[], continuationFunction: Func_2<Task, TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    ContinueWhenAny<TAntecedentResult, TResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>, TResult>): Task_1<TResult>;
    ContinueWhenAny<TAntecedentResult, TResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>, TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    ContinueWhenAny<TAntecedentResult, TResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>, TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    ContinueWhenAny<TAntecedentResult, TResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>, TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    ContinueWhenAny<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationAction: Action_1<Task_1<TAntecedentResult>>): Task;
    ContinueWhenAny<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationAction: Action_1<Task_1<TAntecedentResult>>, cancellationToken: CancellationToken): Task;
    ContinueWhenAny<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationAction: Action_1<Task_1<TAntecedentResult>>, continuationOptions: TaskContinuationOptions): Task;
    ContinueWhenAny<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationAction: Action_1<Task_1<TAntecedentResult>>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task;
    FromAsync(asyncResult: IAsyncResult, endMethod: Action_1<IAsyncResult>): Task;
    FromAsync(asyncResult: IAsyncResult, endMethod: Action_1<IAsyncResult>, creationOptions: TaskCreationOptions): Task;
    FromAsync(asyncResult: IAsyncResult, endMethod: Action_1<IAsyncResult>, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task;
    FromAsync(beginMethod: Func_3<AsyncCallback, unknown, IAsyncResult>, endMethod: Action_1<IAsyncResult>, state: unknown): Task;
    FromAsync(beginMethod: Func_3<AsyncCallback, unknown, IAsyncResult>, endMethod: Action_1<IAsyncResult>, state: unknown, creationOptions: TaskCreationOptions): Task;
    FromAsync<TArg1>(beginMethod: Func_4<TArg1, AsyncCallback, unknown, IAsyncResult>, endMethod: Action_1<IAsyncResult>, arg1: TArg1, state: unknown): Task;
    FromAsync<TArg1>(beginMethod: Func_4<TArg1, AsyncCallback, unknown, IAsyncResult>, endMethod: Action_1<IAsyncResult>, arg1: TArg1, state: unknown, creationOptions: TaskCreationOptions): Task;
    FromAsync<TArg1, TArg2>(beginMethod: Func_5<TArg1, TArg2, AsyncCallback, unknown, IAsyncResult>, endMethod: Action_1<IAsyncResult>, arg1: TArg1, arg2: TArg2, state: unknown): Task;
    FromAsync<TArg1, TArg2>(beginMethod: Func_5<TArg1, TArg2, AsyncCallback, unknown, IAsyncResult>, endMethod: Action_1<IAsyncResult>, arg1: TArg1, arg2: TArg2, state: unknown, creationOptions: TaskCreationOptions): Task;
    FromAsync<TArg1, TArg2, TArg3>(beginMethod: Func_6<TArg1, TArg2, TArg3, AsyncCallback, unknown, IAsyncResult>, endMethod: Action_1<IAsyncResult>, arg1: TArg1, arg2: TArg2, arg3: TArg3, state: unknown): Task;
    FromAsync<TArg1, TArg2, TArg3>(beginMethod: Func_6<TArg1, TArg2, TArg3, AsyncCallback, unknown, IAsyncResult>, endMethod: Action_1<IAsyncResult>, arg1: TArg1, arg2: TArg2, arg3: TArg3, state: unknown, creationOptions: TaskCreationOptions): Task;
    FromAsync<TResult>(asyncResult: IAsyncResult, endMethod: Func_2<IAsyncResult, TResult>): Task_1<TResult>;
    FromAsync<TResult>(asyncResult: IAsyncResult, endMethod: Func_2<IAsyncResult, TResult>, creationOptions: TaskCreationOptions): Task_1<TResult>;
    FromAsync<TResult>(asyncResult: IAsyncResult, endMethod: Func_2<IAsyncResult, TResult>, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    FromAsync<TResult>(beginMethod: Func_3<AsyncCallback, unknown, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, state: unknown): Task_1<TResult>;
    FromAsync<TResult>(beginMethod: Func_3<AsyncCallback, unknown, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, state: unknown, creationOptions: TaskCreationOptions): Task_1<TResult>;
    FromAsync<TArg1, TResult>(beginMethod: Func_4<TArg1, AsyncCallback, unknown, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, state: unknown): Task_1<TResult>;
    FromAsync<TArg1, TResult>(beginMethod: Func_4<TArg1, AsyncCallback, unknown, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, state: unknown, creationOptions: TaskCreationOptions): Task_1<TResult>;
    FromAsync<TArg1, TArg2, TResult>(beginMethod: Func_5<TArg1, TArg2, AsyncCallback, unknown, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, state: unknown): Task_1<TResult>;
    FromAsync<TArg1, TArg2, TResult>(beginMethod: Func_5<TArg1, TArg2, AsyncCallback, unknown, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, state: unknown, creationOptions: TaskCreationOptions): Task_1<TResult>;
    FromAsync<TArg1, TArg2, TArg3, TResult>(beginMethod: Func_6<TArg1, TArg2, TArg3, AsyncCallback, unknown, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, arg3: TArg3, state: unknown): Task_1<TResult>;
    FromAsync<TArg1, TArg2, TArg3, TResult>(beginMethod: Func_6<TArg1, TArg2, TArg3, AsyncCallback, unknown, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, arg3: TArg3, state: unknown, creationOptions: TaskCreationOptions): Task_1<TResult>;
    StartNew(action: Action): Task;
    StartNew(action: Action, cancellationToken: CancellationToken): Task;
    StartNew(action: Action, creationOptions: TaskCreationOptions): Task;
    StartNew(action: Action, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task;
    StartNew(action: Action_1<unknown>, state: unknown): Task;
    StartNew(action: Action_1<unknown>, state: unknown, cancellationToken: CancellationToken): Task;
    StartNew(action: Action_1<unknown>, state: unknown, creationOptions: TaskCreationOptions): Task;
    StartNew(action: Action_1<unknown>, state: unknown, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task;
    StartNew<TResult>(function_: Func_1<TResult>): Task_1<TResult>;
    StartNew<TResult>(function_: Func_1<TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    StartNew<TResult>(function_: Func_1<TResult>, creationOptions: TaskCreationOptions): Task_1<TResult>;
    StartNew<TResult>(function_: Func_1<TResult>, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    StartNew<TResult>(function_: Func_2<unknown, TResult>, state: unknown): Task_1<TResult>;
    StartNew<TResult>(function_: Func_2<unknown, TResult>, state: unknown, cancellationToken: CancellationToken): Task_1<TResult>;
    StartNew<TResult>(function_: Func_2<unknown, TResult>, state: unknown, creationOptions: TaskCreationOptions): Task_1<TResult>;
    StartNew<TResult>(function_: Func_2<unknown, TResult>, state: unknown, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task_1<TResult>;
}


export const TaskFactory: {
    new(): TaskFactory$instance;
    new(cancellationToken: CancellationToken): TaskFactory$instance;
    new(scheduler: TaskScheduler): TaskFactory$instance;
    new(creationOptions: TaskCreationOptions, continuationOptions: TaskContinuationOptions): TaskFactory$instance;
    new(cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): TaskFactory$instance;
};


export type TaskFactory = TaskFactory$instance;

export interface TaskFactory_1$instance<TResult> {
    readonly CancellationToken: CancellationToken;
    readonly ContinuationOptions: TaskContinuationOptions;
    readonly CreationOptions: TaskCreationOptions;
    readonly Scheduler: TaskScheduler;
    ContinueWhenAll(tasks: Task[], continuationFunction: Func_2<Task[], TResult>): Task_1<TResult>;
    ContinueWhenAll(tasks: Task[], continuationFunction: Func_2<Task[], TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    ContinueWhenAll(tasks: Task[], continuationFunction: Func_2<Task[], TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    ContinueWhenAll(tasks: Task[], continuationFunction: Func_2<Task[], TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    ContinueWhenAll<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>[], TResult>): Task_1<TResult>;
    ContinueWhenAll<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>[], TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    ContinueWhenAll<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>[], TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    ContinueWhenAll<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>[], TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    ContinueWhenAny(tasks: Task[], continuationFunction: Func_2<Task, TResult>): Task_1<TResult>;
    ContinueWhenAny(tasks: Task[], continuationFunction: Func_2<Task, TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    ContinueWhenAny(tasks: Task[], continuationFunction: Func_2<Task, TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    ContinueWhenAny(tasks: Task[], continuationFunction: Func_2<Task, TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    ContinueWhenAny<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>, TResult>): Task_1<TResult>;
    ContinueWhenAny<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>, TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    ContinueWhenAny<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>, TResult>, continuationOptions: TaskContinuationOptions): Task_1<TResult>;
    ContinueWhenAny<TAntecedentResult>(tasks: Task_1<TAntecedentResult>[], continuationFunction: Func_2<Task_1<TAntecedentResult>, TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    FromAsync(asyncResult: IAsyncResult, endMethod: Func_2<IAsyncResult, TResult>): Task_1<TResult>;
    FromAsync(asyncResult: IAsyncResult, endMethod: Func_2<IAsyncResult, TResult>, creationOptions: TaskCreationOptions): Task_1<TResult>;
    FromAsync(asyncResult: IAsyncResult, endMethod: Func_2<IAsyncResult, TResult>, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    FromAsync(beginMethod: Func_3<AsyncCallback, unknown, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, state: unknown): Task_1<TResult>;
    FromAsync(beginMethod: Func_3<AsyncCallback, unknown, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, state: unknown, creationOptions: TaskCreationOptions): Task_1<TResult>;
    FromAsync<TArg1>(beginMethod: Func_4<TArg1, AsyncCallback, unknown, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, state: unknown): Task_1<TResult>;
    FromAsync<TArg1>(beginMethod: Func_4<TArg1, AsyncCallback, unknown, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, state: unknown, creationOptions: TaskCreationOptions): Task_1<TResult>;
    FromAsync<TArg1, TArg2>(beginMethod: Func_5<TArg1, TArg2, AsyncCallback, unknown, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, state: unknown): Task_1<TResult>;
    FromAsync<TArg1, TArg2>(beginMethod: Func_5<TArg1, TArg2, AsyncCallback, unknown, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, state: unknown, creationOptions: TaskCreationOptions): Task_1<TResult>;
    FromAsync<TArg1, TArg2, TArg3>(beginMethod: Func_6<TArg1, TArg2, TArg3, AsyncCallback, unknown, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, arg3: TArg3, state: unknown): Task_1<TResult>;
    FromAsync<TArg1, TArg2, TArg3>(beginMethod: Func_6<TArg1, TArg2, TArg3, AsyncCallback, unknown, IAsyncResult>, endMethod: Func_2<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, arg3: TArg3, state: unknown, creationOptions: TaskCreationOptions): Task_1<TResult>;
    StartNew(function_: Func_1<TResult>): Task_1<TResult>;
    StartNew(function_: Func_1<TResult>, cancellationToken: CancellationToken): Task_1<TResult>;
    StartNew(function_: Func_1<TResult>, creationOptions: TaskCreationOptions): Task_1<TResult>;
    StartNew(function_: Func_1<TResult>, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task_1<TResult>;
    StartNew(function_: Func_2<unknown, TResult>, state: unknown): Task_1<TResult>;
    StartNew(function_: Func_2<unknown, TResult>, state: unknown, cancellationToken: CancellationToken): Task_1<TResult>;
    StartNew(function_: Func_2<unknown, TResult>, state: unknown, creationOptions: TaskCreationOptions): Task_1<TResult>;
    StartNew(function_: Func_2<unknown, TResult>, state: unknown, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task_1<TResult>;
}


export const TaskFactory_1: {
    new<TResult>(): TaskFactory_1$instance<TResult>;
    new<TResult>(cancellationToken: CancellationToken): TaskFactory_1$instance<TResult>;
    new<TResult>(scheduler: TaskScheduler): TaskFactory_1$instance<TResult>;
    new<TResult>(creationOptions: TaskCreationOptions, continuationOptions: TaskContinuationOptions): TaskFactory_1$instance<TResult>;
    new<TResult>(cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): TaskFactory_1$instance<TResult>;
};


export type TaskFactory_1<TResult> = TaskFactory_1$instance<TResult>;

export interface TaskScheduler$instance {
    readonly Id: int;
    readonly MaximumConcurrencyLevel: int;
}


export const TaskScheduler: {
    readonly Default: TaskScheduler;
    readonly Current: TaskScheduler;
    FromCurrentSynchronizationContext(): TaskScheduler;
};


export type TaskScheduler = TaskScheduler$instance;

export interface TaskSchedulerException$instance extends Exception {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TaskSchedulerException: {
    new(): TaskSchedulerException$instance;
    new(message: string): TaskSchedulerException$instance;
    new(innerException: Exception): TaskSchedulerException$instance;
    new(message: string, innerException: Exception): TaskSchedulerException$instance;
};


export interface __TaskSchedulerException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TaskSchedulerException = TaskSchedulerException$instance & __TaskSchedulerException$views;


export interface UnobservedTaskExceptionEventArgs$instance extends EventArgs {
    readonly Exception: AggregateException;
    readonly Observed: boolean;
    SetObserved(): void;
}


export const UnobservedTaskExceptionEventArgs: {
    new(exception: AggregateException): UnobservedTaskExceptionEventArgs$instance;
};


export type UnobservedTaskExceptionEventArgs = UnobservedTaskExceptionEventArgs$instance;

export abstract class Parallel$instance {
    static For<TLocal>(fromInclusive: int, toExclusive: int, localInit: Func_1<TLocal>, body: Func_4<System_Internal.Int32, ParallelLoopState, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static For(fromInclusive: int, toExclusive: int, body: Action_1<System_Internal.Int32>): ParallelLoopResult;
    static For(fromInclusive: int, toExclusive: int, body: Action_2<System_Internal.Int32, ParallelLoopState>): ParallelLoopResult;
    static For<TLocal>(fromInclusive: int, toExclusive: int, parallelOptions: ParallelOptions, localInit: Func_1<TLocal>, body: Func_4<System_Internal.Int32, ParallelLoopState, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static For(fromInclusive: int, toExclusive: int, parallelOptions: ParallelOptions, body: Action_1<System_Internal.Int32>): ParallelLoopResult;
    static For(fromInclusive: int, toExclusive: int, parallelOptions: ParallelOptions, body: Action_2<System_Internal.Int32, ParallelLoopState>): ParallelLoopResult;
    static For<TLocal>(fromInclusive: long, toExclusive: long, localInit: Func_1<TLocal>, body: Func_4<System_Internal.Int64, ParallelLoopState, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static For(fromInclusive: long, toExclusive: long, body: Action_1<System_Internal.Int64>): ParallelLoopResult;
    static For(fromInclusive: long, toExclusive: long, body: Action_2<System_Internal.Int64, ParallelLoopState>): ParallelLoopResult;
    static For<TLocal>(fromInclusive: long, toExclusive: long, parallelOptions: ParallelOptions, localInit: Func_1<TLocal>, body: Func_4<System_Internal.Int64, ParallelLoopState, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static For(fromInclusive: long, toExclusive: long, parallelOptions: ParallelOptions, body: Action_1<System_Internal.Int64>): ParallelLoopResult;
    static For(fromInclusive: long, toExclusive: long, parallelOptions: ParallelOptions, body: Action_2<System_Internal.Int64, ParallelLoopState>): ParallelLoopResult;
    static ForAsync<T extends IBinaryInteger_1<T>>(fromInclusive: T, toExclusive: T, body: Func_3<T, CancellationToken, ValueTask>): Task;
    static ForAsync<T extends IBinaryInteger_1<T>>(fromInclusive: T, toExclusive: T, cancellationToken: CancellationToken, body: Func_3<T, CancellationToken, ValueTask>): Task;
    static ForAsync<T extends IBinaryInteger_1<T>>(fromInclusive: T, toExclusive: T, parallelOptions: ParallelOptions, body: Func_3<T, CancellationToken, ValueTask>): Task;
    static ForEach<TSource>(source: IEnumerable_1<TSource>, body: Action_1<TSource>): ParallelLoopResult;
    static ForEach<TSource>(source: IEnumerable_1<TSource>, body: Action_2<TSource, ParallelLoopState>): ParallelLoopResult;
    static ForEach<TSource>(source: IEnumerable_1<TSource>, body: Action_3<TSource, ParallelLoopState, System_Internal.Int64>): ParallelLoopResult;
    static ForEach<TSource, TLocal>(source: IEnumerable_1<TSource>, localInit: Func_1<TLocal>, body: Func_4<TSource, ParallelLoopState, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static ForEach<TSource, TLocal>(source: IEnumerable_1<TSource>, localInit: Func_1<TLocal>, body: Func_5<TSource, ParallelLoopState, System_Internal.Int64, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static ForEach<TSource>(source: IEnumerable_1<TSource>, parallelOptions: ParallelOptions, body: Action_1<TSource>): ParallelLoopResult;
    static ForEach<TSource>(source: IEnumerable_1<TSource>, parallelOptions: ParallelOptions, body: Action_2<TSource, ParallelLoopState>): ParallelLoopResult;
    static ForEach<TSource>(source: IEnumerable_1<TSource>, parallelOptions: ParallelOptions, body: Action_3<TSource, ParallelLoopState, System_Internal.Int64>): ParallelLoopResult;
    static ForEach<TSource, TLocal>(source: IEnumerable_1<TSource>, parallelOptions: ParallelOptions, localInit: Func_1<TLocal>, body: Func_4<TSource, ParallelLoopState, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static ForEach<TSource, TLocal>(source: IEnumerable_1<TSource>, parallelOptions: ParallelOptions, localInit: Func_1<TLocal>, body: Func_5<TSource, ParallelLoopState, System_Internal.Int64, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static ForEach<TSource>(source: OrderablePartitioner_1<TSource>, body: Action_3<TSource, ParallelLoopState, System_Internal.Int64>): ParallelLoopResult;
    static ForEach<TSource, TLocal>(source: OrderablePartitioner_1<TSource>, localInit: Func_1<TLocal>, body: Func_5<TSource, ParallelLoopState, System_Internal.Int64, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static ForEach<TSource>(source: OrderablePartitioner_1<TSource>, parallelOptions: ParallelOptions, body: Action_3<TSource, ParallelLoopState, System_Internal.Int64>): ParallelLoopResult;
    static ForEach<TSource, TLocal>(source: OrderablePartitioner_1<TSource>, parallelOptions: ParallelOptions, localInit: Func_1<TLocal>, body: Func_5<TSource, ParallelLoopState, System_Internal.Int64, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static ForEach<TSource>(source: Partitioner_1<TSource>, body: Action_1<TSource>): ParallelLoopResult;
    static ForEach<TSource>(source: Partitioner_1<TSource>, body: Action_2<TSource, ParallelLoopState>): ParallelLoopResult;
    static ForEach<TSource, TLocal>(source: Partitioner_1<TSource>, localInit: Func_1<TLocal>, body: Func_4<TSource, ParallelLoopState, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static ForEach<TSource>(source: Partitioner_1<TSource>, parallelOptions: ParallelOptions, body: Action_1<TSource>): ParallelLoopResult;
    static ForEach<TSource>(source: Partitioner_1<TSource>, parallelOptions: ParallelOptions, body: Action_2<TSource, ParallelLoopState>): ParallelLoopResult;
    static ForEach<TSource, TLocal>(source: Partitioner_1<TSource>, parallelOptions: ParallelOptions, localInit: Func_1<TLocal>, body: Func_4<TSource, ParallelLoopState, TLocal, TLocal>, localFinally: Action_1<TLocal>): ParallelLoopResult;
    static ForEachAsync<TSource>(source: IAsyncEnumerable_1<TSource>, body: Func_3<TSource, CancellationToken, ValueTask>): Task;
    static ForEachAsync<TSource>(source: IAsyncEnumerable_1<TSource>, cancellationToken: CancellationToken, body: Func_3<TSource, CancellationToken, ValueTask>): Task;
    static ForEachAsync<TSource>(source: IAsyncEnumerable_1<TSource>, parallelOptions: ParallelOptions, body: Func_3<TSource, CancellationToken, ValueTask>): Task;
    static ForEachAsync<TSource>(source: IEnumerable_1<TSource>, body: Func_3<TSource, CancellationToken, ValueTask>): Task;
    static ForEachAsync<TSource>(source: IEnumerable_1<TSource>, cancellationToken: CancellationToken, body: Func_3<TSource, CancellationToken, ValueTask>): Task;
    static ForEachAsync<TSource>(source: IEnumerable_1<TSource>, parallelOptions: ParallelOptions, body: Func_3<TSource, CancellationToken, ValueTask>): Task;
    static Invoke(...actions: Action[]): void;
    static Invoke(parallelOptions: ParallelOptions, ...actions: Action[]): void;
}


export type Parallel = Parallel$instance;

export abstract class TaskAsyncEnumerableExtensions$instance {
    static ConfigureAwait<T>(source: IAsyncEnumerable_1<T>, continueOnCapturedContext: boolean): ConfiguredCancelableAsyncEnumerable_1<T>;
    static ConfigureAwait(source: IAsyncDisposable, continueOnCapturedContext: boolean): ConfiguredAsyncDisposable;
    static ToBlockingEnumerable<T>(source: IAsyncEnumerable_1<T>, cancellationToken?: CancellationToken): IEnumerable_1<T>;
    static WithCancellation<T>(source: IAsyncEnumerable_1<T>, cancellationToken: CancellationToken): ConfiguredCancelableAsyncEnumerable_1<T>;
}


export type TaskAsyncEnumerableExtensions = TaskAsyncEnumerableExtensions$instance;

export abstract class TaskExtensions$instance {
    static Unwrap(task: Task_1<Task>): Task;
    static Unwrap<TResult>(task: Task_1<Task_1<TResult>>): Task_1<TResult>;
}


export type TaskExtensions = TaskExtensions$instance;

export abstract class TaskToAsyncResult$instance {
    static Begin(task: Task, callback: AsyncCallback, state: unknown): IAsyncResult;
    static End(asyncResult: IAsyncResult): void;
    static End<TResult>(asyncResult: IAsyncResult): TResult;
    static Unwrap(asyncResult: IAsyncResult): Task;
    static Unwrap<TResult>(asyncResult: IAsyncResult): Task_1<TResult>;
}


export type TaskToAsyncResult = TaskToAsyncResult$instance;


// Generated by tsbindgen - Architecture
// Namespace: System.IO
// Assembly: System.IO.FileSystem.AccessControl, System.IO.FileSystem.DriveInfo, System.IO.FileSystem.Watcher, System.Private.CoreLib

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { SafeFileHandle } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import type { IAsyncEnumerable_1, IEnumerable_1, IReadOnlyList_1 } from "../../System.Collections.Generic/internal/index.js";
import type { Collection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import type { IDictionary } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { Component, IComponent, IContainer, ISite, ISupportInitialize, ISynchronizeInvoke } from "../../System.ComponentModel/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import type { SafeBuffer } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { AccessControlSections, DirectorySecurity, FileSecurity, FileSystemRights } from "../../System.Security.AccessControl/internal/index.js";
import type { Encoding, StringBuilder } from "../../System.Text/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { ArraySegment_1, AsyncCallback, Boolean as ClrBoolean, Byte, Char, DateTime, Decimal, Delegate, Double, Enum, EventArgs, Exception, Half, IAsyncDisposable, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, MarshalByRefObject, Memory_1, MulticastDelegate, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, SByte, Single, Span_1, String as ClrString, SystemException, TimeSpan, Type, TypeCode, UInt16, UInt32, UInt64, ValueType, Void } from "../../System/internal/index.js";

export enum DriveType {
    Unknown = 0,
    NoRootDirectory = 1,
    Removable = 2,
    Fixed = 3,
    Network = 4,
    CDRom = 5,
    Ram = 6
}


export enum FileAccess {
    Read = 1,
    Write = 2,
    ReadWrite = 3
}


export enum FileAttributes {
    None = 0,
    ReadOnly = 1,
    Hidden = 2,
    System = 4,
    Directory = 16,
    Archive = 32,
    Device = 64,
    Normal = 128,
    Temporary = 256,
    SparseFile = 512,
    ReparsePoint = 1024,
    Compressed = 2048,
    Offline = 4096,
    NotContentIndexed = 8192,
    Encrypted = 16384,
    IntegrityStream = 32768,
    NoScrubData = 131072
}


export enum FileMode {
    CreateNew = 1,
    Create = 2,
    Open = 3,
    OpenOrCreate = 4,
    Truncate = 5,
    Append = 6
}


export enum FileOptions {
    None = 0,
    WriteThrough = -2147483648,
    Asynchronous = 1073741824,
    RandomAccess = 268435456,
    DeleteOnClose = 67108864,
    SequentialScan = 134217728,
    Encrypted = 16384
}


export enum FileShare {
    None = 0,
    Read = 1,
    Write = 2,
    ReadWrite = 3,
    Delete = 4,
    Inheritable = 16
}


export enum HandleInheritability {
    None = 0,
    Inheritable = 1
}


export enum MatchCasing {
    PlatformDefault = 0,
    CaseSensitive = 1,
    CaseInsensitive = 2
}


export enum MatchType {
    Simple = 0,
    Win32 = 1
}


export enum NotifyFilters {
    FileName = 1,
    DirectoryName = 2,
    Attributes = 4,
    Size = 8,
    LastWrite = 16,
    LastAccess = 32,
    CreationTime = 64,
    Security = 256
}


export enum SearchOption {
    TopDirectoryOnly = 0,
    AllDirectories = 1
}


export enum SeekOrigin {
    Begin = 0,
    Current = 1,
    End = 2
}


export enum UnixFileMode {
    None = 0,
    OtherExecute = 1,
    OtherWrite = 2,
    OtherRead = 4,
    GroupExecute = 8,
    GroupWrite = 16,
    GroupRead = 32,
    UserExecute = 64,
    UserWrite = 128,
    UserRead = 256,
    StickyBit = 512,
    SetGroup = 1024,
    SetUser = 2048
}


export enum WatcherChangeTypes {
    Created = 1,
    Deleted = 2,
    Changed = 4,
    Renamed = 8,
    All = 15
}


export type ErrorEventHandler = (sender: unknown, e: ErrorEventArgs) => void;


export type FileSystemEventHandler = (sender: unknown, e: FileSystemEventArgs) => void;


export type RenamedEventHandler = (sender: unknown, e: RenamedEventArgs) => void;


export interface WaitForChangedResult$instance {
    ChangeType: WatcherChangeTypes;
    Name: string;
    get OldName(): string | undefined;
    set OldName(value: string);
    TimedOut: boolean;
}


export const WaitForChangedResult: {
    new(): WaitForChangedResult;
};


export type WaitForChangedResult = WaitForChangedResult$instance;

export interface BinaryReader$instance {
    readonly BaseStream: Stream;
    Close(): void;
    Dispose(): void;
    PeekChar(): int;
    Read(): int;
    Read(buffer: char[], index: int, count: int): int;
    Read(buffer: Span_1<System_Internal.Char>): int;
    Read(buffer: byte[], index: int, count: int): int;
    Read(buffer: Span_1<System_Internal.Byte>): int;
    Read7BitEncodedInt(): int;
    Read7BitEncodedInt64(): long;
    ReadBoolean(): boolean;
    ReadByte(): byte;
    ReadBytes(count: int): byte[];
    ReadChar(): char;
    ReadChars(count: int): char[];
    ReadDecimal(): decimal;
    ReadDouble(): double;
    ReadExactly(buffer: Span_1<System_Internal.Byte>): void;
    ReadHalf(): half;
    ReadInt16(): short;
    ReadInt32(): int;
    ReadInt64(): long;
    ReadSByte(): sbyte;
    ReadSingle(): float;
    ReadString(): string;
    ReadUInt16(): ushort;
    ReadUInt32(): uint;
    ReadUInt64(): ulong;
}


export const BinaryReader: {
    new(input: Stream): BinaryReader;
    new(input: Stream, encoding: Encoding): BinaryReader;
    new(input: Stream, encoding: Encoding, leaveOpen: boolean): BinaryReader;
};


export interface __BinaryReader$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface BinaryReader$instance extends System_Internal.IDisposable$instance {}

export type BinaryReader = BinaryReader$instance & __BinaryReader$views;


export interface BinaryWriter$instance {
    readonly BaseStream: Stream;
    Close(): void;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    Flush(): void;
    Seek(offset: int, origin: SeekOrigin): long;
    Write(value: boolean): void;
    Write(value: byte): void;
    Write(value: sbyte): void;
    Write(buffer: byte[]): void;
    Write(buffer: byte[], index: int, count: int): void;
    Write(ch: char): void;
    Write(chars: char[]): void;
    Write(chars: char[], index: int, count: int): void;
    Write(value: double): void;
    Write(value: decimal): void;
    Write(value: short): void;
    Write(value: ushort): void;
    Write(value: int): void;
    Write(value: uint): void;
    Write(value: long): void;
    Write(value: ulong): void;
    Write(value: float): void;
    Write(value: half): void;
    Write(value: string): void;
    Write(buffer: ReadOnlySpan_1<System_Internal.Byte>): void;
    Write(chars: ReadOnlySpan_1<System_Internal.Char>): void;
    Write7BitEncodedInt(value: int): void;
    Write7BitEncodedInt64(value: long): void;
}


export const BinaryWriter: {
    new(output: Stream): BinaryWriter;
    new(output: Stream, encoding: Encoding): BinaryWriter;
    new(output: Stream, encoding: Encoding, leaveOpen: boolean): BinaryWriter;
    readonly Null: BinaryWriter;
};


export interface __BinaryWriter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface BinaryWriter$instance extends System_Internal.IAsyncDisposable$instance, System_Internal.IDisposable$instance {}

export type BinaryWriter = BinaryWriter$instance & __BinaryWriter$views;


export interface BufferedStream$instance extends Stream$instance {
    readonly BufferSize: int;
    readonly CanRead: boolean;
    readonly CanSeek: boolean;
    readonly CanWrite: boolean;
    readonly Length: long;
    Position: long;
    readonly UnderlyingStream: Stream;
    BeginRead(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginWrite(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    CopyTo(destination: Stream, bufferSize: int): void;
    CopyTo(destination: Stream): void;
    CopyToAsync(destination: Stream, bufferSize: int, cancellationToken: CancellationToken): Task;
    CopyToAsync(destination: Stream): Task;
    CopyToAsync(destination: Stream, bufferSize: int): Task;
    CopyToAsync(destination: Stream, cancellationToken: CancellationToken): Task;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    EndRead(asyncResult: IAsyncResult): int;
    EndWrite(asyncResult: IAsyncResult): void;
    Flush(): void;
    FlushAsync(cancellationToken: CancellationToken): Task;
    FlushAsync(): Task;
    Read(buffer: byte[], offset: int, count: int): int;
    Read(destination: Span_1<System_Internal.Byte>): int;
    Read(buffer: Span_1<System_Internal.Byte>): int;
    ReadAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<System_Internal.Int32>;
    ReadAsync(buffer: Memory_1<System_Internal.Byte>, cancellationToken?: CancellationToken): ValueTask_1<System_Internal.Int32>;
    ReadAsync(buffer: byte[], offset: int, count: int): Task_1<System_Internal.Int32>;
    ReadAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<System_Internal.Int32>;
    ReadAsync(buffer: Memory_1<System_Internal.Byte>, cancellationToken?: CancellationToken): ValueTask_1<System_Internal.Int32>;
    ReadByte(): int;
    Seek(offset: long, origin: SeekOrigin): long;
    SetLength(value: long): void;
    Write(buffer: byte[], offset: int, count: int): void;
    Write(buffer: ReadOnlySpan_1<System_Internal.Byte>): void;
    Write(buffer: ReadOnlySpan_1<System_Internal.Byte>): void;
    WriteAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<System_Internal.Byte>, cancellationToken?: CancellationToken): ValueTask;
    WriteAsync(buffer: byte[], offset: int, count: int): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<System_Internal.Byte>, cancellationToken?: CancellationToken): ValueTask;
    WriteByte(value: byte): void;
}


export const BufferedStream: {
    new(stream: Stream): BufferedStream;
    new(stream: Stream, bufferSize: int): BufferedStream;
};


export interface __BufferedStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type BufferedStream = BufferedStream$instance & __BufferedStream$views;


export interface DirectoryInfo$instance extends FileSystemInfo$instance {
    readonly Exists: boolean;
    readonly Name: string;
    readonly Parent: DirectoryInfo;
    readonly Root: DirectoryInfo;
    Create(): void;
    CreateSubdirectory(path: string): DirectoryInfo;
    Delete(): void;
    EnumerateDirectories(): IEnumerable_1<DirectoryInfo>;
    EnumerateDirectories(searchPattern: string): IEnumerable_1<DirectoryInfo>;
    EnumerateDirectories(searchPattern: string, searchOption: SearchOption): IEnumerable_1<DirectoryInfo>;
    EnumerateDirectories(searchPattern: string, enumerationOptions: EnumerationOptions): IEnumerable_1<DirectoryInfo>;
    EnumerateFiles(): IEnumerable_1<FileInfo>;
    EnumerateFiles(searchPattern: string): IEnumerable_1<FileInfo>;
    EnumerateFiles(searchPattern: string, searchOption: SearchOption): IEnumerable_1<FileInfo>;
    EnumerateFiles(searchPattern: string, enumerationOptions: EnumerationOptions): IEnumerable_1<FileInfo>;
    EnumerateFileSystemInfos(): IEnumerable_1<FileSystemInfo>;
    EnumerateFileSystemInfos(searchPattern: string): IEnumerable_1<FileSystemInfo>;
    EnumerateFileSystemInfos(searchPattern: string, searchOption: SearchOption): IEnumerable_1<FileSystemInfo>;
    EnumerateFileSystemInfos(searchPattern: string, enumerationOptions: EnumerationOptions): IEnumerable_1<FileSystemInfo>;
    GetDirectories(): DirectoryInfo[];
    GetDirectories(searchPattern: string): DirectoryInfo[];
    GetDirectories(searchPattern: string, searchOption: SearchOption): DirectoryInfo[];
    GetDirectories(searchPattern: string, enumerationOptions: EnumerationOptions): DirectoryInfo[];
    GetFiles(): FileInfo[];
    GetFiles(searchPattern: string): FileInfo[];
    GetFiles(searchPattern: string, searchOption: SearchOption): FileInfo[];
    GetFiles(searchPattern: string, enumerationOptions: EnumerationOptions): FileInfo[];
    GetFileSystemInfos(): FileSystemInfo[];
    GetFileSystemInfos(searchPattern: string): FileSystemInfo[];
    GetFileSystemInfos(searchPattern: string, searchOption: SearchOption): FileSystemInfo[];
    GetFileSystemInfos(searchPattern: string, enumerationOptions: EnumerationOptions): FileSystemInfo[];
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    MoveTo(destDirName: string): void;
}


export const DirectoryInfo: {
    new(path: string): DirectoryInfo;
};


export interface __DirectoryInfo$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DirectoryInfo = DirectoryInfo$instance & __DirectoryInfo$views;


export interface DirectoryNotFoundException$instance extends IOException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const DirectoryNotFoundException: {
    new(): DirectoryNotFoundException;
    new(message: string): DirectoryNotFoundException;
    new(message: string, innerException: Exception): DirectoryNotFoundException;
};


export interface __DirectoryNotFoundException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DirectoryNotFoundException = DirectoryNotFoundException$instance & __DirectoryNotFoundException$views;


export interface DriveInfo$instance {
    readonly AvailableFreeSpace: long;
    readonly DriveFormat: string;
    readonly DriveType: DriveType;
    readonly IsReady: boolean;
    readonly Name: string;
    readonly RootDirectory: DirectoryInfo;
    readonly TotalFreeSpace: long;
    readonly TotalSize: long;
    VolumeLabel: string;
    ToString(): string;
}


export const DriveInfo: {
    new(driveName: string): DriveInfo;
    GetDrives(): DriveInfo[];
};


export interface __DriveInfo$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface DriveInfo$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type DriveInfo = DriveInfo$instance & __DriveInfo$views;


export interface DriveNotFoundException$instance extends IOException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const DriveNotFoundException: {
    new(): DriveNotFoundException;
    new(message: string): DriveNotFoundException;
    new(message: string, innerException: Exception): DriveNotFoundException;
};


export interface __DriveNotFoundException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DriveNotFoundException = DriveNotFoundException$instance & __DriveNotFoundException$views;


export interface EndOfStreamException$instance extends IOException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const EndOfStreamException: {
    new(): EndOfStreamException;
    new(message: string): EndOfStreamException;
    new(message: string, innerException: Exception): EndOfStreamException;
};


export interface __EndOfStreamException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type EndOfStreamException = EndOfStreamException$instance & __EndOfStreamException$views;


export interface EnumerationOptions$instance {
    AttributesToSkip: FileAttributes;
    BufferSize: int;
    IgnoreInaccessible: boolean;
    MatchCasing: MatchCasing;
    MatchType: MatchType;
    MaxRecursionDepth: int;
    RecurseSubdirectories: boolean;
    ReturnSpecialDirectories: boolean;
}


export const EnumerationOptions: {
    new(): EnumerationOptions;
};


export type EnumerationOptions = EnumerationOptions$instance;

export interface ErrorEventArgs$instance extends EventArgs {
    GetException(): Exception;
}


export const ErrorEventArgs: {
    new(exception: Exception): ErrorEventArgs;
};


export type ErrorEventArgs = ErrorEventArgs$instance;

export interface FileInfo$instance extends FileSystemInfo$instance {
    readonly Directory: DirectoryInfo | undefined;
    readonly DirectoryName: string | undefined;
    readonly Exists: boolean;
    IsReadOnly: boolean;
    readonly Length: long;
    readonly Name: string;
    AppendText(): StreamWriter;
    CopyTo(destFileName: string): FileInfo;
    CopyTo(destFileName: string, overwrite: boolean): FileInfo;
    Create(): FileStream;
    CreateText(): StreamWriter;
    Decrypt(): void;
    Delete(): void;
    Encrypt(): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    MoveTo(destFileName: string): void;
    MoveTo(destFileName: string, overwrite: boolean): void;
    Open(options: FileStreamOptions): FileStream;
    Open(mode: FileMode): FileStream;
    Open(mode: FileMode, access: FileAccess): FileStream;
    Open(mode: FileMode, access: FileAccess, share: FileShare): FileStream;
    OpenRead(): FileStream;
    OpenText(): StreamReader;
    OpenWrite(): FileStream;
    Replace(destinationFileName: string, destinationBackupFileName: string): FileInfo;
    Replace(destinationFileName: string, destinationBackupFileName: string, ignoreMetadataErrors: boolean): FileInfo;
}


export const FileInfo: {
    new(fileName: string): FileInfo;
};


export interface __FileInfo$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type FileInfo = FileInfo$instance & __FileInfo$views;


export interface FileLoadException$instance extends IOException$instance {
    readonly FileName: string;
    readonly FusionLog: string | undefined;
    readonly Message: string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    ToString(): string;
}


export const FileLoadException: {
    new(): FileLoadException;
    new(message: string): FileLoadException;
    new(message: string, inner: Exception): FileLoadException;
    new(message: string, fileName: string): FileLoadException;
    new(message: string, fileName: string, inner: Exception): FileLoadException;
};


export interface __FileLoadException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type FileLoadException = FileLoadException$instance & __FileLoadException$views;


export interface FileNotFoundException$instance extends IOException$instance {
    readonly FileName: string;
    readonly FusionLog: string | undefined;
    readonly Message: string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    ToString(): string;
}


export const FileNotFoundException: {
    new(): FileNotFoundException;
    new(message: string): FileNotFoundException;
    new(message: string, innerException: Exception): FileNotFoundException;
    new(message: string, fileName: string): FileNotFoundException;
    new(message: string, fileName: string, innerException: Exception): FileNotFoundException;
};


export interface __FileNotFoundException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type FileNotFoundException = FileNotFoundException$instance & __FileNotFoundException$views;


export interface FileStream$instance extends Stream$instance {
    readonly CanRead: boolean;
    readonly CanSeek: boolean;
    readonly CanWrite: boolean;
    readonly Handle: nint;
    readonly IsAsync: boolean;
    readonly Length: long;
    readonly Name: string;
    Position: long;
    readonly SafeFileHandle: SafeFileHandle;
    BeginRead(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginWrite(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    CopyTo(destination: Stream, bufferSize: int): void;
    CopyTo(destination: Stream): void;
    CopyToAsync(destination: Stream, bufferSize: int, cancellationToken: CancellationToken): Task;
    CopyToAsync(destination: Stream): Task;
    CopyToAsync(destination: Stream, bufferSize: int): Task;
    CopyToAsync(destination: Stream, cancellationToken: CancellationToken): Task;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    EndRead(asyncResult: IAsyncResult): int;
    EndWrite(asyncResult: IAsyncResult): void;
    Flush(): void;
    FlushAsync(cancellationToken: CancellationToken): Task;
    FlushAsync(): Task;
    Lock(position: long, length: long): void;
    Read(buffer: byte[], offset: int, count: int): int;
    Read(buffer: Span_1<System_Internal.Byte>): int;
    Read(buffer: Span_1<System_Internal.Byte>): int;
    ReadAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<System_Internal.Int32>;
    ReadAsync(buffer: Memory_1<System_Internal.Byte>, cancellationToken?: CancellationToken): ValueTask_1<System_Internal.Int32>;
    ReadAsync(buffer: byte[], offset: int, count: int): Task_1<System_Internal.Int32>;
    ReadAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<System_Internal.Int32>;
    ReadAsync(buffer: Memory_1<System_Internal.Byte>, cancellationToken?: CancellationToken): ValueTask_1<System_Internal.Int32>;
    ReadByte(): int;
    Seek(offset: long, origin: SeekOrigin): long;
    SetLength(value: long): void;
    Unlock(position: long, length: long): void;
    Write(buffer: byte[], offset: int, count: int): void;
    Write(buffer: ReadOnlySpan_1<System_Internal.Byte>): void;
    Write(buffer: ReadOnlySpan_1<System_Internal.Byte>): void;
    WriteAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<System_Internal.Byte>, cancellationToken?: CancellationToken): ValueTask;
    WriteAsync(buffer: byte[], offset: int, count: int): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<System_Internal.Byte>, cancellationToken?: CancellationToken): ValueTask;
    WriteByte(value: byte): void;
}


export const FileStream: {
    new(handle: nint, access: FileAccess): FileStream;
    new(handle: nint, access: FileAccess, ownsHandle: boolean): FileStream;
    new(handle: nint, access: FileAccess, ownsHandle: boolean, bufferSize: int): FileStream;
    new(handle: nint, access: FileAccess, ownsHandle: boolean, bufferSize: int, isAsync: boolean): FileStream;
    new(handle: SafeFileHandle, access: FileAccess): FileStream;
    new(handle: SafeFileHandle, access: FileAccess, bufferSize: int): FileStream;
    new(handle: SafeFileHandle, access: FileAccess, bufferSize: int, isAsync: boolean): FileStream;
    new(path: string, mode: FileMode): FileStream;
    new(path: string, mode: FileMode, access: FileAccess): FileStream;
    new(path: string, mode: FileMode, access: FileAccess, share: FileShare): FileStream;
    new(path: string, mode: FileMode, access: FileAccess, share: FileShare, bufferSize: int): FileStream;
    new(path: string, mode: FileMode, access: FileAccess, share: FileShare, bufferSize: int, useAsync: boolean): FileStream;
    new(path: string, mode: FileMode, access: FileAccess, share: FileShare, bufferSize: int, options: FileOptions): FileStream;
    new(path: string, options: FileStreamOptions): FileStream;
};


export interface __FileStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type FileStream = FileStream$instance & __FileStream$views;


export interface FileStreamOptions$instance {
    Access: FileAccess;
    BufferSize: int;
    Mode: FileMode;
    Options: FileOptions;
    PreallocationSize: long;
    Share: FileShare;
    UnixCreateMode: Nullable_1<UnixFileMode>;
}


export const FileStreamOptions: {
    new(): FileStreamOptions;
};


export type FileStreamOptions = FileStreamOptions$instance;

export interface FileSystemEventArgs$instance extends EventArgs {
    readonly ChangeType: WatcherChangeTypes;
    readonly FullPath: string;
    readonly Name: string;
}


export const FileSystemEventArgs: {
    new(changeType: WatcherChangeTypes, directory: string, name: string): FileSystemEventArgs;
};


export type FileSystemEventArgs = FileSystemEventArgs$instance;

export interface FileSystemInfo$instance extends MarshalByRefObject {
    Attributes: FileAttributes;
    CreationTime: DateTime;
    CreationTimeUtc: DateTime;
    readonly Exists: boolean;
    readonly Extension: string;
    readonly FullName: string;
    LastAccessTime: DateTime;
    LastAccessTimeUtc: DateTime;
    LastWriteTime: DateTime;
    LastWriteTimeUtc: DateTime;
    readonly LinkTarget: string | undefined;
    readonly Name: string;
    UnixFileMode: UnixFileMode;
    CreateAsSymbolicLink(pathToTarget: string): void;
    Delete(): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Refresh(): void;
    ResolveLinkTarget(returnFinalTarget: boolean): FileSystemInfo | undefined;
    ToString(): string;
}


export const FileSystemInfo: {
};


export interface __FileSystemInfo$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface FileSystemInfo$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type FileSystemInfo = FileSystemInfo$instance & __FileSystemInfo$views;


export interface FileSystemWatcher$instance extends Component {
    EnableRaisingEvents: boolean;
    Filter: string;
    readonly Filters: Collection_1<System_Internal.String>;
    IncludeSubdirectories: boolean;
    InternalBufferSize: int;
    NotifyFilter: NotifyFilters;
    Path: string;
    get Site(): ISite | undefined;
    set Site(value: ISite);
    get SynchronizingObject(): ISynchronizeInvoke | undefined;
    set SynchronizingObject(value: ISynchronizeInvoke);
    BeginInit(): void;
    Dispose(): void;
    EndInit(): void;
    WaitForChanged(changeType: WatcherChangeTypes): WaitForChangedResult;
    WaitForChanged(changeType: WatcherChangeTypes, timeout: int): WaitForChangedResult;
    WaitForChanged(changeType: WatcherChangeTypes, timeout: TimeSpan): WaitForChangedResult;
}


export const FileSystemWatcher: {
    new(): FileSystemWatcher;
    new(path: string): FileSystemWatcher;
    new(path: string, filter: string): FileSystemWatcher;
};


export interface __FileSystemWatcher$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_ISupportInitialize(): System_ComponentModel_Internal.ISupportInitialize$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface FileSystemWatcher$instance extends System_ComponentModel_Internal.IComponent$instance, System_ComponentModel_Internal.ISupportInitialize$instance {}

export type FileSystemWatcher = FileSystemWatcher$instance & __FileSystemWatcher$views;


export interface InternalBufferOverflowException$instance extends SystemException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const InternalBufferOverflowException: {
    new(): InternalBufferOverflowException;
    new(message: string): InternalBufferOverflowException;
    new(message: string, inner: Exception): InternalBufferOverflowException;
};


export interface __InternalBufferOverflowException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InternalBufferOverflowException = InternalBufferOverflowException$instance & __InternalBufferOverflowException$views;


export interface InvalidDataException$instance extends SystemException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const InvalidDataException: {
    new(): InvalidDataException;
    new(message: string): InvalidDataException;
    new(message: string, innerException: Exception): InvalidDataException;
};


export interface __InvalidDataException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidDataException = InvalidDataException$instance & __InvalidDataException$views;


export interface IOException$instance extends SystemException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const IOException: {
    new(): IOException;
    new(message: string): IOException;
    new(message: string, hresult: int): IOException;
    new(message: string, innerException: Exception): IOException;
};


export interface __IOException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type IOException = IOException$instance & __IOException$views;


export interface MemoryStream$instance extends Stream$instance {
    readonly CanRead: boolean;
    readonly CanSeek: boolean;
    readonly CanWrite: boolean;
    Capacity: int;
    readonly Length: long;
    Position: long;
    CopyTo(destination: Stream, bufferSize: int): void;
    CopyTo(destination: Stream): void;
    CopyToAsync(destination: Stream, bufferSize: int, cancellationToken: CancellationToken): Task;
    CopyToAsync(destination: Stream): Task;
    CopyToAsync(destination: Stream, bufferSize: int): Task;
    CopyToAsync(destination: Stream, cancellationToken: CancellationToken): Task;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    Flush(): void;
    FlushAsync(cancellationToken: CancellationToken): Task;
    FlushAsync(): Task;
    GetBuffer(): byte[];
    Read(buffer: byte[], offset: int, count: int): int;
    Read(buffer: Span_1<System_Internal.Byte>): int;
    Read(buffer: Span_1<System_Internal.Byte>): int;
    ReadAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<System_Internal.Int32>;
    ReadAsync(buffer: Memory_1<System_Internal.Byte>, cancellationToken?: CancellationToken): ValueTask_1<System_Internal.Int32>;
    ReadAsync(buffer: byte[], offset: int, count: int): Task_1<System_Internal.Int32>;
    ReadAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<System_Internal.Int32>;
    ReadAsync(buffer: Memory_1<System_Internal.Byte>, cancellationToken?: CancellationToken): ValueTask_1<System_Internal.Int32>;
    ReadByte(): int;
    Seek(offset: long, loc: SeekOrigin): long;
    SetLength(value: long): void;
    ToArray(): byte[];
    TryGetBuffer(buffer: ArraySegment_1<System_Internal.Byte>): boolean;
    Write(buffer: byte[], offset: int, count: int): void;
    Write(buffer: ReadOnlySpan_1<System_Internal.Byte>): void;
    Write(buffer: ReadOnlySpan_1<System_Internal.Byte>): void;
    WriteAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<System_Internal.Byte>, cancellationToken?: CancellationToken): ValueTask;
    WriteAsync(buffer: byte[], offset: int, count: int): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<System_Internal.Byte>, cancellationToken?: CancellationToken): ValueTask;
    WriteByte(value: byte): void;
    WriteTo(stream: Stream): void;
}


export const MemoryStream: {
    new(): MemoryStream;
    new(capacity: int): MemoryStream;
    new(buffer: byte[]): MemoryStream;
    new(buffer: byte[], writable: boolean): MemoryStream;
    new(buffer: byte[], index: int, count: int): MemoryStream;
    new(buffer: byte[], index: int, count: int, writable: boolean): MemoryStream;
    new(buffer: byte[], index: int, count: int, writable: boolean, publiclyVisible: boolean): MemoryStream;
};


export interface __MemoryStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type MemoryStream = MemoryStream$instance & __MemoryStream$views;


export interface PathTooLongException$instance extends IOException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const PathTooLongException: {
    new(): PathTooLongException;
    new(message: string): PathTooLongException;
    new(message: string, innerException: Exception): PathTooLongException;
};


export interface __PathTooLongException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type PathTooLongException = PathTooLongException$instance & __PathTooLongException$views;


export interface RenamedEventArgs$instance extends FileSystemEventArgs {
    readonly OldFullPath: string;
    readonly OldName: string | undefined;
}


export const RenamedEventArgs: {
    new(changeType: WatcherChangeTypes, directory: string, name: string, oldName: string): RenamedEventArgs;
};


export type RenamedEventArgs = RenamedEventArgs$instance;

export interface Stream$instance extends MarshalByRefObject {
    readonly CanRead: boolean;
    readonly CanSeek: boolean;
    readonly CanTimeout: boolean;
    readonly CanWrite: boolean;
    readonly Length: long;
    Position: long;
    ReadTimeout: int;
    WriteTimeout: int;
    BeginRead(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginWrite(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    Close(): void;
    CopyTo(destination: Stream): void;
    CopyTo(destination: Stream, bufferSize: int): void;
    CopyToAsync(destination: Stream): Task;
    CopyToAsync(destination: Stream, bufferSize: int): Task;
    CopyToAsync(destination: Stream, cancellationToken: CancellationToken): Task;
    CopyToAsync(destination: Stream, bufferSize: int, cancellationToken: CancellationToken): Task;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    EndRead(asyncResult: IAsyncResult): int;
    EndWrite(asyncResult: IAsyncResult): void;
    Flush(): void;
    FlushAsync(): Task;
    FlushAsync(cancellationToken: CancellationToken): Task;
    Read(buffer: byte[], offset: int, count: int): int;
    Read(buffer: Span_1<System_Internal.Byte>): int;
    ReadAsync(buffer: byte[], offset: int, count: int): Task_1<System_Internal.Int32>;
    ReadAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<System_Internal.Int32>;
    ReadAsync(buffer: Memory_1<System_Internal.Byte>, cancellationToken?: CancellationToken): ValueTask_1<System_Internal.Int32>;
    ReadAtLeast(buffer: Span_1<System_Internal.Byte>, minimumBytes: int, throwOnEndOfStream?: boolean): int;
    ReadAtLeastAsync(buffer: Memory_1<System_Internal.Byte>, minimumBytes: int, throwOnEndOfStream?: boolean, cancellationToken?: CancellationToken): ValueTask_1<System_Internal.Int32>;
    ReadByte(): int;
    ReadExactly(buffer: Span_1<System_Internal.Byte>): void;
    ReadExactly(buffer: byte[], offset: int, count: int): void;
    ReadExactlyAsync(buffer: Memory_1<System_Internal.Byte>, cancellationToken?: CancellationToken): ValueTask;
    ReadExactlyAsync(buffer: byte[], offset: int, count: int, cancellationToken?: CancellationToken): ValueTask;
    Seek(offset: long, origin: SeekOrigin): long;
    SetLength(value: long): void;
    Write(buffer: byte[], offset: int, count: int): void;
    Write(buffer: ReadOnlySpan_1<System_Internal.Byte>): void;
    WriteAsync(buffer: byte[], offset: int, count: int): Task;
    WriteAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<System_Internal.Byte>, cancellationToken?: CancellationToken): ValueTask;
    WriteByte(value: byte): void;
}


export const Stream: {
    readonly Null: Stream;
    Synchronized(stream: Stream): Stream;
};


export interface __Stream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Stream$instance extends System_Internal.IAsyncDisposable$instance, System_Internal.IDisposable$instance {}

export type Stream = Stream$instance & __Stream$views;


export interface StreamReader$instance extends TextReader$instance {
    readonly BaseStream: Stream;
    readonly CurrentEncoding: Encoding;
    readonly EndOfStream: boolean;
    Close(): void;
    DiscardBufferedData(): void;
    Dispose(): void;
    Peek(): int;
    Read(): int;
    Read(buffer: char[], index: int, count: int): int;
    Read(buffer: Span_1<System_Internal.Char>): int;
    Read(buffer: Span_1<System_Internal.Char>): int;
    ReadAsync(buffer: char[], index: int, count: int): Task_1<System_Internal.Int32>;
    ReadAsync(buffer: Memory_1<System_Internal.Char>, cancellationToken?: CancellationToken): ValueTask_1<System_Internal.Int32>;
    ReadAsync(buffer: char[], index: int, count: int): Task_1<System_Internal.Int32>;
    ReadAsync(buffer: Memory_1<System_Internal.Char>, cancellationToken?: CancellationToken): ValueTask_1<System_Internal.Int32>;
    ReadBlock(buffer: char[], index: int, count: int): int;
    ReadBlock(buffer: Span_1<System_Internal.Char>): int;
    ReadBlock(buffer: Span_1<System_Internal.Char>): int;
    ReadBlockAsync(buffer: char[], index: int, count: int): Task_1<System_Internal.Int32>;
    ReadBlockAsync(buffer: Memory_1<System_Internal.Char>, cancellationToken?: CancellationToken): ValueTask_1<System_Internal.Int32>;
    ReadBlockAsync(buffer: char[], index: int, count: int): Task_1<System_Internal.Int32>;
    ReadBlockAsync(buffer: Memory_1<System_Internal.Char>, cancellationToken?: CancellationToken): ValueTask_1<System_Internal.Int32>;
    ReadLine(): string | undefined;
    ReadLineAsync(): Task_1<string | undefined>;
    ReadLineAsync(cancellationToken: CancellationToken): ValueTask_1<System_Internal.String>;
    ReadLineAsync(): Task_1<string | undefined>;
    ReadLineAsync(cancellationToken: CancellationToken): ValueTask_1<System_Internal.String>;
    ReadToEnd(): string;
    ReadToEndAsync(): Task_1<System_Internal.String>;
    ReadToEndAsync(cancellationToken: CancellationToken): Task_1<System_Internal.String>;
    ReadToEndAsync(): Task_1<System_Internal.String>;
    ReadToEndAsync(cancellationToken: CancellationToken): Task_1<System_Internal.String>;
}


export const StreamReader: {
    new(stream: Stream): StreamReader;
    new(stream: Stream, detectEncodingFromByteOrderMarks: boolean): StreamReader;
    new(stream: Stream, encoding: Encoding): StreamReader;
    new(stream: Stream, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean): StreamReader;
    new(stream: Stream, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean, bufferSize: int): StreamReader;
    new(stream: Stream, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean, bufferSize: int, leaveOpen: boolean): StreamReader;
    new(path: string): StreamReader;
    new(path: string, detectEncodingFromByteOrderMarks: boolean): StreamReader;
    new(path: string, encoding: Encoding): StreamReader;
    new(path: string, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean): StreamReader;
    new(path: string, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean, bufferSize: int): StreamReader;
    new(path: string, options: FileStreamOptions): StreamReader;
    new(path: string, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean, options: FileStreamOptions): StreamReader;
};


export interface __StreamReader$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type StreamReader = StreamReader$instance & __StreamReader$views;


export interface StreamWriter$instance extends TextWriter$instance {
    AutoFlush: boolean;
    readonly BaseStream: Stream;
    readonly Encoding: Encoding;
    Close(): void;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    Flush(): void;
    FlushAsync(): Task;
    FlushAsync(cancellationToken: CancellationToken): Task;
    Write(value: char): void;
    Write(buffer: char[]): void;
    Write(buffer: char[], index: int, count: int): void;
    Write(buffer: ReadOnlySpan_1<System_Internal.Char>): void;
    Write(value: string): void;
    Write(format: string, arg0: unknown): void;
    Write(format: string, arg0: unknown, arg1: unknown): void;
    Write(format: string, arg0: unknown, arg1: unknown, arg2: unknown): void;
    Write(format: string, ...arg: unknown[]): void;
    Write(format: string, arg: ReadOnlySpan_1<unknown>): void;
    Write(buffer: ReadOnlySpan_1<System_Internal.Char>): void;
    Write(value: boolean): void;
    Write(value: int): void;
    Write(value: uint): void;
    Write(value: long): void;
    Write(value: ulong): void;
    Write(value: float): void;
    Write(value: double): void;
    Write(value: decimal): void;
    Write(value: unknown): void;
    Write(value: StringBuilder): void;
    Write(format: string, arg: ReadOnlySpan_1<unknown>): void;
    WriteAsync(value: char): Task;
    WriteAsync(value: string): Task;
    WriteAsync(buffer: char[], index: int, count: int): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<System_Internal.Char>, cancellationToken?: CancellationToken): Task;
    WriteAsync(value: StringBuilder, cancellationToken?: CancellationToken): Task;
    WriteAsync(buffer: char[]): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<System_Internal.Char>, cancellationToken?: CancellationToken): Task;
    WriteLine(value: string): void;
    WriteLine(buffer: ReadOnlySpan_1<System_Internal.Char>): void;
    WriteLine(format: string, arg0: unknown): void;
    WriteLine(format: string, arg0: unknown, arg1: unknown): void;
    WriteLine(format: string, arg0: unknown, arg1: unknown, arg2: unknown): void;
    WriteLine(format: string, ...arg: unknown[]): void;
    WriteLine(format: string, arg: ReadOnlySpan_1<unknown>): void;
    WriteLine(): void;
    WriteLine(value: char): void;
    WriteLine(buffer: char[]): void;
    WriteLine(buffer: char[], index: int, count: int): void;
    WriteLine(buffer: ReadOnlySpan_1<System_Internal.Char>): void;
    WriteLine(value: boolean): void;
    WriteLine(value: int): void;
    WriteLine(value: uint): void;
    WriteLine(value: long): void;
    WriteLine(value: ulong): void;
    WriteLine(value: float): void;
    WriteLine(value: double): void;
    WriteLine(value: decimal): void;
    WriteLine(value: StringBuilder): void;
    WriteLine(value: unknown): void;
    WriteLine(format: string, arg: ReadOnlySpan_1<unknown>): void;
    WriteLineAsync(): Task;
    WriteLineAsync(value: char): Task;
    WriteLineAsync(value: string): Task;
    WriteLineAsync(buffer: char[], index: int, count: int): Task;
    WriteLineAsync(buffer: ReadOnlyMemory_1<System_Internal.Char>, cancellationToken?: CancellationToken): Task;
    WriteLineAsync(value: StringBuilder, cancellationToken?: CancellationToken): Task;
    WriteLineAsync(buffer: char[]): Task;
    WriteLineAsync(buffer: ReadOnlyMemory_1<System_Internal.Char>, cancellationToken?: CancellationToken): Task;
}


export const StreamWriter: {
    new(stream: Stream): StreamWriter;
    new(stream: Stream, encoding: Encoding): StreamWriter;
    new(stream: Stream, encoding: Encoding, bufferSize: int): StreamWriter;
    new(stream: Stream, encoding: Encoding, bufferSize: int, leaveOpen: boolean): StreamWriter;
    new(path: string): StreamWriter;
    new(path: string, append: boolean): StreamWriter;
    new(path: string, append: boolean, encoding: Encoding): StreamWriter;
    new(path: string, append: boolean, encoding: Encoding, bufferSize: int): StreamWriter;
    new(path: string, options: FileStreamOptions): StreamWriter;
    new(path: string, encoding: Encoding, options: FileStreamOptions): StreamWriter;
};


export interface __StreamWriter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type StreamWriter = StreamWriter$instance & __StreamWriter$views;


export interface StringReader$instance extends TextReader$instance {
    Close(): void;
    Dispose(): void;
    Peek(): int;
    Read(): int;
    Read(buffer: char[], index: int, count: int): int;
    Read(buffer: Span_1<System_Internal.Char>): int;
    Read(buffer: Span_1<System_Internal.Char>): int;
    ReadAsync(buffer: char[], index: int, count: int): Task_1<System_Internal.Int32>;
    ReadAsync(buffer: Memory_1<System_Internal.Char>, cancellationToken?: CancellationToken): ValueTask_1<System_Internal.Int32>;
    ReadAsync(buffer: char[], index: int, count: int): Task_1<System_Internal.Int32>;
    ReadAsync(buffer: Memory_1<System_Internal.Char>, cancellationToken?: CancellationToken): ValueTask_1<System_Internal.Int32>;
    ReadBlock(buffer: Span_1<System_Internal.Char>): int;
    ReadBlock(buffer: char[], index: int, count: int): int;
    ReadBlock(buffer: Span_1<System_Internal.Char>): int;
    ReadBlockAsync(buffer: char[], index: int, count: int): Task_1<System_Internal.Int32>;
    ReadBlockAsync(buffer: Memory_1<System_Internal.Char>, cancellationToken?: CancellationToken): ValueTask_1<System_Internal.Int32>;
    ReadBlockAsync(buffer: char[], index: int, count: int): Task_1<System_Internal.Int32>;
    ReadBlockAsync(buffer: Memory_1<System_Internal.Char>, cancellationToken?: CancellationToken): ValueTask_1<System_Internal.Int32>;
    ReadLine(): string | undefined;
    ReadLineAsync(): Task_1<string | undefined>;
    ReadLineAsync(cancellationToken: CancellationToken): ValueTask_1<System_Internal.String>;
    ReadLineAsync(): Task_1<string | undefined>;
    ReadLineAsync(cancellationToken: CancellationToken): ValueTask_1<System_Internal.String>;
    ReadToEnd(): string;
    ReadToEndAsync(): Task_1<System_Internal.String>;
    ReadToEndAsync(cancellationToken: CancellationToken): Task_1<System_Internal.String>;
    ReadToEndAsync(): Task_1<System_Internal.String>;
    ReadToEndAsync(cancellationToken: CancellationToken): Task_1<System_Internal.String>;
}


export const StringReader: {
    new(s: string): StringReader;
};


export interface __StringReader$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type StringReader = StringReader$instance & __StringReader$views;


export interface StringWriter$instance extends TextWriter$instance {
    readonly Encoding: Encoding;
    Close(): void;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    FlushAsync(): Task;
    FlushAsync(cancellationToken: CancellationToken): Task;
    GetStringBuilder(): StringBuilder;
    ToString(): string;
    Write(value: char): void;
    Write(buffer: char[], index: int, count: int): void;
    Write(buffer: ReadOnlySpan_1<System_Internal.Char>): void;
    Write(value: string): void;
    Write(value: StringBuilder): void;
    Write(buffer: char[]): void;
    Write(buffer: ReadOnlySpan_1<System_Internal.Char>): void;
    Write(value: boolean): void;
    Write(value: int): void;
    Write(value: uint): void;
    Write(value: long): void;
    Write(value: ulong): void;
    Write(value: float): void;
    Write(value: double): void;
    Write(value: decimal): void;
    Write(value: unknown): void;
    Write(format: string, arg0: unknown): void;
    Write(format: string, arg0: unknown, arg1: unknown): void;
    Write(format: string, arg0: unknown, arg1: unknown, arg2: unknown): void;
    Write(format: string, ...arg: unknown[]): void;
    Write(format: string, arg: ReadOnlySpan_1<unknown>): void;
    WriteAsync(value: char): Task;
    WriteAsync(value: string): Task;
    WriteAsync(buffer: char[], index: int, count: int): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<System_Internal.Char>, cancellationToken?: CancellationToken): Task;
    WriteAsync(value: StringBuilder, cancellationToken?: CancellationToken): Task;
    WriteAsync(buffer: char[]): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<System_Internal.Char>, cancellationToken?: CancellationToken): Task;
    WriteLine(buffer: ReadOnlySpan_1<System_Internal.Char>): void;
    WriteLine(value: StringBuilder): void;
    WriteLine(): void;
    WriteLine(value: char): void;
    WriteLine(buffer: char[]): void;
    WriteLine(buffer: char[], index: int, count: int): void;
    WriteLine(buffer: ReadOnlySpan_1<System_Internal.Char>): void;
    WriteLine(value: boolean): void;
    WriteLine(value: int): void;
    WriteLine(value: uint): void;
    WriteLine(value: long): void;
    WriteLine(value: ulong): void;
    WriteLine(value: float): void;
    WriteLine(value: double): void;
    WriteLine(value: decimal): void;
    WriteLine(value: string): void;
    WriteLine(value: unknown): void;
    WriteLine(format: string, arg0: unknown): void;
    WriteLine(format: string, arg0: unknown, arg1: unknown): void;
    WriteLine(format: string, arg0: unknown, arg1: unknown, arg2: unknown): void;
    WriteLine(format: string, ...arg: unknown[]): void;
    WriteLine(format: string, arg: ReadOnlySpan_1<unknown>): void;
    WriteLineAsync(value: char): Task;
    WriteLineAsync(value: string): Task;
    WriteLineAsync(value: StringBuilder, cancellationToken?: CancellationToken): Task;
    WriteLineAsync(buffer: char[], index: int, count: int): Task;
    WriteLineAsync(buffer: ReadOnlyMemory_1<System_Internal.Char>, cancellationToken?: CancellationToken): Task;
    WriteLineAsync(buffer: char[]): Task;
    WriteLineAsync(buffer: ReadOnlyMemory_1<System_Internal.Char>, cancellationToken?: CancellationToken): Task;
    WriteLineAsync(): Task;
}


export const StringWriter: {
    new(): StringWriter;
    new(formatProvider: IFormatProvider): StringWriter;
    new(sb: StringBuilder): StringWriter;
    new(sb: StringBuilder, formatProvider: IFormatProvider): StringWriter;
};


export interface __StringWriter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type StringWriter = StringWriter$instance & __StringWriter$views;


export interface TextReader$instance extends MarshalByRefObject {
    Close(): void;
    Dispose(): void;
    Peek(): int;
    Read(): int;
    Read(buffer: char[], index: int, count: int): int;
    Read(buffer: Span_1<System_Internal.Char>): int;
    ReadAsync(buffer: char[], index: int, count: int): Task_1<System_Internal.Int32>;
    ReadAsync(buffer: Memory_1<System_Internal.Char>, cancellationToken?: CancellationToken): ValueTask_1<System_Internal.Int32>;
    ReadBlock(buffer: char[], index: int, count: int): int;
    ReadBlock(buffer: Span_1<System_Internal.Char>): int;
    ReadBlockAsync(buffer: char[], index: int, count: int): Task_1<System_Internal.Int32>;
    ReadBlockAsync(buffer: Memory_1<System_Internal.Char>, cancellationToken?: CancellationToken): ValueTask_1<System_Internal.Int32>;
    ReadLine(): string | undefined;
    ReadLineAsync(): Task_1<string | undefined>;
    ReadLineAsync(cancellationToken: CancellationToken): ValueTask_1<System_Internal.String>;
    ReadToEnd(): string;
    ReadToEndAsync(): Task_1<System_Internal.String>;
    ReadToEndAsync(cancellationToken: CancellationToken): Task_1<System_Internal.String>;
}


export const TextReader: {
    readonly Null: TextReader;
    Synchronized(reader: TextReader): TextReader;
};


export interface __TextReader$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface TextReader$instance extends System_Internal.IDisposable$instance {}

export type TextReader = TextReader$instance & __TextReader$views;


export interface TextWriter$instance extends MarshalByRefObject {
    readonly Encoding: Encoding;
    readonly FormatProvider: IFormatProvider;
    NewLine: string;
    Close(): void;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    Flush(): void;
    FlushAsync(): Task;
    FlushAsync(cancellationToken: CancellationToken): Task;
    Write(value: char): void;
    Write(buffer: char[]): void;
    Write(buffer: char[], index: int, count: int): void;
    Write(buffer: ReadOnlySpan_1<System_Internal.Char>): void;
    Write(value: boolean): void;
    Write(value: int): void;
    Write(value: uint): void;
    Write(value: long): void;
    Write(value: ulong): void;
    Write(value: float): void;
    Write(value: double): void;
    Write(value: decimal): void;
    Write(value: string): void;
    Write(value: unknown): void;
    Write(value: StringBuilder): void;
    Write(format: string, arg0: unknown): void;
    Write(format: string, arg0: unknown, arg1: unknown): void;
    Write(format: string, arg0: unknown, arg1: unknown, arg2: unknown): void;
    Write(format: string, ...arg: unknown[]): void;
    Write(format: string, arg: ReadOnlySpan_1<unknown>): void;
    WriteAsync(value: char): Task;
    WriteAsync(value: string): Task;
    WriteAsync(value: StringBuilder, cancellationToken?: CancellationToken): Task;
    WriteAsync(buffer: char[]): Task;
    WriteAsync(buffer: char[], index: int, count: int): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<System_Internal.Char>, cancellationToken?: CancellationToken): Task;
    WriteLine(): void;
    WriteLine(value: char): void;
    WriteLine(buffer: char[]): void;
    WriteLine(buffer: char[], index: int, count: int): void;
    WriteLine(buffer: ReadOnlySpan_1<System_Internal.Char>): void;
    WriteLine(value: boolean): void;
    WriteLine(value: int): void;
    WriteLine(value: uint): void;
    WriteLine(value: long): void;
    WriteLine(value: ulong): void;
    WriteLine(value: float): void;
    WriteLine(value: double): void;
    WriteLine(value: decimal): void;
    WriteLine(value: string): void;
    WriteLine(value: StringBuilder): void;
    WriteLine(value: unknown): void;
    WriteLine(format: string, arg0: unknown): void;
    WriteLine(format: string, arg0: unknown, arg1: unknown): void;
    WriteLine(format: string, arg0: unknown, arg1: unknown, arg2: unknown): void;
    WriteLine(format: string, ...arg: unknown[]): void;
    WriteLine(format: string, arg: ReadOnlySpan_1<unknown>): void;
    WriteLineAsync(value: char): Task;
    WriteLineAsync(value: string): Task;
    WriteLineAsync(value: StringBuilder, cancellationToken?: CancellationToken): Task;
    WriteLineAsync(buffer: char[]): Task;
    WriteLineAsync(buffer: char[], index: int, count: int): Task;
    WriteLineAsync(buffer: ReadOnlyMemory_1<System_Internal.Char>, cancellationToken?: CancellationToken): Task;
    WriteLineAsync(): Task;
}


export const TextWriter: {
    readonly Null: TextWriter;
    CreateBroadcasting(...writers: TextWriter[]): TextWriter;
    Synchronized(writer: TextWriter): TextWriter;
};


export interface __TextWriter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface TextWriter$instance extends System_Internal.IAsyncDisposable$instance, System_Internal.IDisposable$instance {}

export type TextWriter = TextWriter$instance & __TextWriter$views;


export interface UnmanagedMemoryAccessor$instance {
    readonly CanRead: boolean;
    readonly CanWrite: boolean;
    readonly Capacity: long;
    Dispose(): void;
    Read<T extends unknown>(position: long, structure: T): void;
    ReadArray<T extends unknown>(position: long, array: T[], offset: int, count: int): int;
    ReadBoolean(position: long): boolean;
    ReadByte(position: long): byte;
    ReadChar(position: long): char;
    ReadDecimal(position: long): decimal;
    ReadDouble(position: long): double;
    ReadInt16(position: long): short;
    ReadInt32(position: long): int;
    ReadInt64(position: long): long;
    ReadSByte(position: long): sbyte;
    ReadSingle(position: long): float;
    ReadUInt16(position: long): ushort;
    ReadUInt32(position: long): uint;
    ReadUInt64(position: long): ulong;
    Write(position: long, value: boolean): void;
    Write(position: long, value: byte): void;
    Write(position: long, value: char): void;
    Write(position: long, value: short): void;
    Write(position: long, value: int): void;
    Write(position: long, value: long): void;
    Write(position: long, value: decimal): void;
    Write(position: long, value: float): void;
    Write(position: long, value: double): void;
    Write(position: long, value: sbyte): void;
    Write(position: long, value: ushort): void;
    Write(position: long, value: uint): void;
    Write(position: long, value: ulong): void;
    Write<T extends unknown>(position: long, structure: T): void;
    WriteArray<T extends unknown>(position: long, array: T[], offset: int, count: int): void;
}


export const UnmanagedMemoryAccessor: {
    new(buffer: SafeBuffer, offset: long, capacity: long): UnmanagedMemoryAccessor;
    new(buffer: SafeBuffer, offset: long, capacity: long, access: FileAccess): UnmanagedMemoryAccessor;
};


export interface __UnmanagedMemoryAccessor$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface UnmanagedMemoryAccessor$instance extends System_Internal.IDisposable$instance {}

export type UnmanagedMemoryAccessor = UnmanagedMemoryAccessor$instance & __UnmanagedMemoryAccessor$views;


export interface UnmanagedMemoryStream$instance extends Stream$instance {
    readonly CanRead: boolean;
    readonly CanSeek: boolean;
    readonly CanWrite: boolean;
    readonly Capacity: long;
    readonly Length: long;
    Position: long;
    PositionPointer: ptr<byte>;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    Flush(): void;
    FlushAsync(cancellationToken: CancellationToken): Task;
    FlushAsync(): Task;
    Read(buffer: byte[], offset: int, count: int): int;
    Read(buffer: Span_1<System_Internal.Byte>): int;
    Read(buffer: Span_1<System_Internal.Byte>): int;
    ReadAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<System_Internal.Int32>;
    ReadAsync(buffer: Memory_1<System_Internal.Byte>, cancellationToken?: CancellationToken): ValueTask_1<System_Internal.Int32>;
    ReadAsync(buffer: byte[], offset: int, count: int): Task_1<System_Internal.Int32>;
    ReadAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<System_Internal.Int32>;
    ReadAsync(buffer: Memory_1<System_Internal.Byte>, cancellationToken?: CancellationToken): ValueTask_1<System_Internal.Int32>;
    ReadByte(): int;
    Seek(offset: long, loc: SeekOrigin): long;
    SetLength(value: long): void;
    Write(buffer: byte[], offset: int, count: int): void;
    Write(buffer: ReadOnlySpan_1<System_Internal.Byte>): void;
    Write(buffer: ReadOnlySpan_1<System_Internal.Byte>): void;
    WriteAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<System_Internal.Byte>, cancellationToken?: CancellationToken): ValueTask;
    WriteAsync(buffer: byte[], offset: int, count: int): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<System_Internal.Byte>, cancellationToken?: CancellationToken): ValueTask;
    WriteByte(value: byte): void;
}


export const UnmanagedMemoryStream: {
    new(buffer: SafeBuffer, offset: long, length: long): UnmanagedMemoryStream;
    new(buffer: SafeBuffer, offset: long, length: long, access: FileAccess): UnmanagedMemoryStream;
    new(pointer: ptr<byte>, length: long): UnmanagedMemoryStream;
    new(pointer: ptr<byte>, length: long, capacity: long, access: FileAccess): UnmanagedMemoryStream;
};


export interface __UnmanagedMemoryStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type UnmanagedMemoryStream = UnmanagedMemoryStream$instance & __UnmanagedMemoryStream$views;


export abstract class Directory$instance {
    static CreateDirectory(path: string, unixCreateMode: UnixFileMode): DirectoryInfo;
    static CreateDirectory(path: string): DirectoryInfo;
    static CreateSymbolicLink(path: string, pathToTarget: string): FileSystemInfo;
    static CreateTempSubdirectory(prefix?: string): DirectoryInfo;
    static Delete(path: string, recursive: boolean): void;
    static Delete(path: string): void;
    static EnumerateDirectories(path: string, searchPattern: string, enumerationOptions: EnumerationOptions): IEnumerable_1<System_Internal.String>;
    static EnumerateDirectories(path: string, searchPattern: string, searchOption: SearchOption): IEnumerable_1<System_Internal.String>;
    static EnumerateDirectories(path: string, searchPattern: string): IEnumerable_1<System_Internal.String>;
    static EnumerateDirectories(path: string): IEnumerable_1<System_Internal.String>;
    static EnumerateFiles(path: string, searchPattern: string, enumerationOptions: EnumerationOptions): IEnumerable_1<System_Internal.String>;
    static EnumerateFiles(path: string, searchPattern: string, searchOption: SearchOption): IEnumerable_1<System_Internal.String>;
    static EnumerateFiles(path: string, searchPattern: string): IEnumerable_1<System_Internal.String>;
    static EnumerateFiles(path: string): IEnumerable_1<System_Internal.String>;
    static EnumerateFileSystemEntries(path: string, searchPattern: string, enumerationOptions: EnumerationOptions): IEnumerable_1<System_Internal.String>;
    static EnumerateFileSystemEntries(path: string, searchPattern: string, searchOption: SearchOption): IEnumerable_1<System_Internal.String>;
    static EnumerateFileSystemEntries(path: string, searchPattern: string): IEnumerable_1<System_Internal.String>;
    static EnumerateFileSystemEntries(path: string): IEnumerable_1<System_Internal.String>;
    static Exists(path: string): boolean;
    static GetCreationTime(path: string): DateTime;
    static GetCreationTimeUtc(path: string): DateTime;
    static GetCurrentDirectory(): string;
    static GetDirectories(path: string, searchPattern: string, enumerationOptions: EnumerationOptions): string[];
    static GetDirectories(path: string, searchPattern: string, searchOption: SearchOption): string[];
    static GetDirectories(path: string, searchPattern: string): string[];
    static GetDirectories(path: string): string[];
    static GetDirectoryRoot(path: string): string;
    static GetFiles(path: string, searchPattern: string, enumerationOptions: EnumerationOptions): string[];
    static GetFiles(path: string, searchPattern: string, searchOption: SearchOption): string[];
    static GetFiles(path: string, searchPattern: string): string[];
    static GetFiles(path: string): string[];
    static GetFileSystemEntries(path: string, searchPattern: string, enumerationOptions: EnumerationOptions): string[];
    static GetFileSystemEntries(path: string, searchPattern: string, searchOption: SearchOption): string[];
    static GetFileSystemEntries(path: string, searchPattern: string): string[];
    static GetFileSystemEntries(path: string): string[];
    static GetLastAccessTime(path: string): DateTime;
    static GetLastAccessTimeUtc(path: string): DateTime;
    static GetLastWriteTime(path: string): DateTime;
    static GetLastWriteTimeUtc(path: string): DateTime;
    static GetLogicalDrives(): string[];
    static GetParent(path: string): DirectoryInfo | undefined;
    static Move(sourceDirName: string, destDirName: string): void;
    static ResolveLinkTarget(linkPath: string, returnFinalTarget: boolean): FileSystemInfo | undefined;
    static SetCreationTime(path: string, creationTime: DateTime): void;
    static SetCreationTimeUtc(path: string, creationTimeUtc: DateTime): void;
    static SetCurrentDirectory(path: string): void;
    static SetLastAccessTime(path: string, lastAccessTime: DateTime): void;
    static SetLastAccessTimeUtc(path: string, lastAccessTimeUtc: DateTime): void;
    static SetLastWriteTime(path: string, lastWriteTime: DateTime): void;
    static SetLastWriteTimeUtc(path: string, lastWriteTimeUtc: DateTime): void;
}


export type Directory = Directory$instance;

export abstract class File$instance {
    static AppendAllBytes(path: string, bytes: byte[]): void;
    static AppendAllBytes(path: string, bytes: ReadOnlySpan_1<System_Internal.Byte>): void;
    static AppendAllBytesAsync(path: string, bytes: byte[], cancellationToken?: CancellationToken): Task;
    static AppendAllBytesAsync(path: string, bytes: ReadOnlyMemory_1<System_Internal.Byte>, cancellationToken?: CancellationToken): Task;
    static AppendAllLines(path: string, contents: IEnumerable_1<System_Internal.String>, encoding: Encoding): void;
    static AppendAllLines(path: string, contents: IEnumerable_1<System_Internal.String>): void;
    static AppendAllLinesAsync(path: string, contents: IEnumerable_1<System_Internal.String>, encoding: Encoding, cancellationToken?: CancellationToken): Task;
    static AppendAllLinesAsync(path: string, contents: IEnumerable_1<System_Internal.String>, cancellationToken?: CancellationToken): Task;
    static AppendAllText(path: string, contents: ReadOnlySpan_1<System_Internal.Char>, encoding: Encoding): void;
    static AppendAllText(path: string, contents: ReadOnlySpan_1<System_Internal.Char>): void;
    static AppendAllText(path: string, contents: string, encoding: Encoding): void;
    static AppendAllText(path: string, contents: string): void;
    static AppendAllTextAsync(path: string, contents: ReadOnlyMemory_1<System_Internal.Char>, encoding: Encoding, cancellationToken?: CancellationToken): Task;
    static AppendAllTextAsync(path: string, contents: ReadOnlyMemory_1<System_Internal.Char>, cancellationToken?: CancellationToken): Task;
    static AppendAllTextAsync(path: string, contents: string, encoding: Encoding, cancellationToken?: CancellationToken): Task;
    static AppendAllTextAsync(path: string, contents: string, cancellationToken?: CancellationToken): Task;
    static AppendText(path: string): StreamWriter;
    static Copy(sourceFileName: string, destFileName: string, overwrite: boolean): void;
    static Copy(sourceFileName: string, destFileName: string): void;
    static Create(path: string, bufferSize: int, options: FileOptions): FileStream;
    static Create(path: string, bufferSize: int): FileStream;
    static Create(path: string): FileStream;
    static CreateSymbolicLink(path: string, pathToTarget: string): FileSystemInfo;
    static CreateText(path: string): StreamWriter;
    static Decrypt(path: string): void;
    static Delete(path: string): void;
    static Encrypt(path: string): void;
    static Exists(path: string): boolean;
    static GetAttributes(fileHandle: SafeFileHandle): FileAttributes;
    static GetAttributes(path: string): FileAttributes;
    static GetCreationTime(fileHandle: SafeFileHandle): DateTime;
    static GetCreationTime(path: string): DateTime;
    static GetCreationTimeUtc(fileHandle: SafeFileHandle): DateTime;
    static GetCreationTimeUtc(path: string): DateTime;
    static GetLastAccessTime(fileHandle: SafeFileHandle): DateTime;
    static GetLastAccessTime(path: string): DateTime;
    static GetLastAccessTimeUtc(fileHandle: SafeFileHandle): DateTime;
    static GetLastAccessTimeUtc(path: string): DateTime;
    static GetLastWriteTime(fileHandle: SafeFileHandle): DateTime;
    static GetLastWriteTime(path: string): DateTime;
    static GetLastWriteTimeUtc(fileHandle: SafeFileHandle): DateTime;
    static GetLastWriteTimeUtc(path: string): DateTime;
    static GetUnixFileMode(fileHandle: SafeFileHandle): UnixFileMode;
    static GetUnixFileMode(path: string): UnixFileMode;
    static Move(sourceFileName: string, destFileName: string, overwrite: boolean): void;
    static Move(sourceFileName: string, destFileName: string): void;
    static Open(path: string, mode: FileMode, access: FileAccess, share: FileShare): FileStream;
    static Open(path: string, mode: FileMode, access: FileAccess): FileStream;
    static Open(path: string, mode: FileMode): FileStream;
    static Open(path: string, options: FileStreamOptions): FileStream;
    static OpenHandle(path: string, mode?: FileMode, access?: FileAccess, share?: FileShare, options?: FileOptions, preallocationSize?: long): SafeFileHandle;
    static OpenRead(path: string): FileStream;
    static OpenText(path: string): StreamReader;
    static OpenWrite(path: string): FileStream;
    static ReadAllBytes(path: string): byte[];
    static ReadAllBytesAsync(path: string, cancellationToken?: CancellationToken): Task_1<byte[]>;
    static ReadAllLines(path: string, encoding: Encoding): string[];
    static ReadAllLines(path: string): string[];
    static ReadAllLinesAsync(path: string, encoding: Encoding, cancellationToken?: CancellationToken): Task_1<string[]>;
    static ReadAllLinesAsync(path: string, cancellationToken?: CancellationToken): Task_1<string[]>;
    static ReadAllText(path: string, encoding: Encoding): string;
    static ReadAllText(path: string): string;
    static ReadAllTextAsync(path: string, encoding: Encoding, cancellationToken?: CancellationToken): Task_1<System_Internal.String>;
    static ReadAllTextAsync(path: string, cancellationToken?: CancellationToken): Task_1<System_Internal.String>;
    static ReadLines(path: string, encoding: Encoding): IEnumerable_1<System_Internal.String>;
    static ReadLines(path: string): IEnumerable_1<System_Internal.String>;
    static ReadLinesAsync(path: string, encoding: Encoding, cancellationToken?: CancellationToken): IAsyncEnumerable_1<System_Internal.String>;
    static ReadLinesAsync(path: string, cancellationToken?: CancellationToken): IAsyncEnumerable_1<System_Internal.String>;
    static Replace(sourceFileName: string, destinationFileName: string, destinationBackupFileName: string, ignoreMetadataErrors: boolean): void;
    static Replace(sourceFileName: string, destinationFileName: string, destinationBackupFileName: string): void;
    static ResolveLinkTarget(linkPath: string, returnFinalTarget: boolean): FileSystemInfo | undefined;
    static SetAttributes(fileHandle: SafeFileHandle, fileAttributes: FileAttributes): void;
    static SetAttributes(path: string, fileAttributes: FileAttributes): void;
    static SetCreationTime(fileHandle: SafeFileHandle, creationTime: DateTime): void;
    static SetCreationTime(path: string, creationTime: DateTime): void;
    static SetCreationTimeUtc(fileHandle: SafeFileHandle, creationTimeUtc: DateTime): void;
    static SetCreationTimeUtc(path: string, creationTimeUtc: DateTime): void;
    static SetLastAccessTime(fileHandle: SafeFileHandle, lastAccessTime: DateTime): void;
    static SetLastAccessTime(path: string, lastAccessTime: DateTime): void;
    static SetLastAccessTimeUtc(fileHandle: SafeFileHandle, lastAccessTimeUtc: DateTime): void;
    static SetLastAccessTimeUtc(path: string, lastAccessTimeUtc: DateTime): void;
    static SetLastWriteTime(fileHandle: SafeFileHandle, lastWriteTime: DateTime): void;
    static SetLastWriteTime(path: string, lastWriteTime: DateTime): void;
    static SetLastWriteTimeUtc(fileHandle: SafeFileHandle, lastWriteTimeUtc: DateTime): void;
    static SetLastWriteTimeUtc(path: string, lastWriteTimeUtc: DateTime): void;
    static SetUnixFileMode(fileHandle: SafeFileHandle, mode: UnixFileMode): void;
    static SetUnixFileMode(path: string, mode: UnixFileMode): void;
    static WriteAllBytes(path: string, bytes: byte[]): void;
    static WriteAllBytes(path: string, bytes: ReadOnlySpan_1<System_Internal.Byte>): void;
    static WriteAllBytesAsync(path: string, bytes: byte[], cancellationToken?: CancellationToken): Task;
    static WriteAllBytesAsync(path: string, bytes: ReadOnlyMemory_1<System_Internal.Byte>, cancellationToken?: CancellationToken): Task;
    static WriteAllLines(path: string, contents: IEnumerable_1<System_Internal.String>, encoding: Encoding): void;
    static WriteAllLines(path: string, contents: IEnumerable_1<System_Internal.String>): void;
    static WriteAllLines(path: string, contents: string[], encoding: Encoding): void;
    static WriteAllLines(path: string, contents: string[]): void;
    static WriteAllLinesAsync(path: string, contents: IEnumerable_1<System_Internal.String>, encoding: Encoding, cancellationToken?: CancellationToken): Task;
    static WriteAllLinesAsync(path: string, contents: IEnumerable_1<System_Internal.String>, cancellationToken?: CancellationToken): Task;
    static WriteAllText(path: string, contents: ReadOnlySpan_1<System_Internal.Char>, encoding: Encoding): void;
    static WriteAllText(path: string, contents: ReadOnlySpan_1<System_Internal.Char>): void;
    static WriteAllText(path: string, contents: string, encoding: Encoding): void;
    static WriteAllText(path: string, contents: string): void;
    static WriteAllTextAsync(path: string, contents: ReadOnlyMemory_1<System_Internal.Char>, encoding: Encoding, cancellationToken?: CancellationToken): Task;
    static WriteAllTextAsync(path: string, contents: ReadOnlyMemory_1<System_Internal.Char>, cancellationToken?: CancellationToken): Task;
    static WriteAllTextAsync(path: string, contents: string, encoding: Encoding, cancellationToken?: CancellationToken): Task;
    static WriteAllTextAsync(path: string, contents: string, cancellationToken?: CancellationToken): Task;
}


export type File = File$instance;

export abstract class FileSystemAclExtensions$instance {
    static Create(directoryInfo: DirectoryInfo, directorySecurity: DirectorySecurity): void;
    static Create(fileInfo: FileInfo, mode: FileMode, rights: FileSystemRights, share: FileShare, bufferSize: int, options: FileOptions, fileSecurity: FileSecurity): FileStream;
    static CreateDirectory(directorySecurity: DirectorySecurity, path: string): DirectoryInfo;
    static GetAccessControl(directoryInfo: DirectoryInfo, includeSections: AccessControlSections): DirectorySecurity;
    static GetAccessControl(directoryInfo: DirectoryInfo): DirectorySecurity;
    static GetAccessControl(fileInfo: FileInfo, includeSections: AccessControlSections): FileSecurity;
    static GetAccessControl(fileInfo: FileInfo): FileSecurity;
    static GetAccessControl(fileStream: FileStream): FileSecurity;
    static SetAccessControl(directoryInfo: DirectoryInfo, directorySecurity: DirectorySecurity): void;
    static SetAccessControl(fileInfo: FileInfo, fileSecurity: FileSecurity): void;
    static SetAccessControl(fileStream: FileStream, fileSecurity: FileSecurity): void;
}


export type FileSystemAclExtensions = FileSystemAclExtensions$instance;

export abstract class Path$instance {
    static readonly DirectorySeparatorChar: char;
    static readonly AltDirectorySeparatorChar: char;
    static readonly VolumeSeparatorChar: char;
    static readonly PathSeparator: char;
    static readonly InvalidPathChars: char[];
    static ChangeExtension(path: string, extension: string): string | undefined;
    static Combine(paths: ReadOnlySpan_1<System_Internal.String>): string;
    static Combine(path1: string, path2: string, path3: string, path4: string): string;
    static Combine(path1: string, path2: string, path3: string): string;
    static Combine(path1: string, path2: string): string;
    static Combine(...paths: string[]): string;
    static EndsInDirectorySeparator(path: ReadOnlySpan_1<System_Internal.Char>): boolean;
    static EndsInDirectorySeparator(path: string): boolean;
    static Exists(path: string): boolean;
    static GetDirectoryName(path: ReadOnlySpan_1<System_Internal.Char>): ReadOnlySpan_1<System_Internal.Char>;
    static GetDirectoryName(path: string): string | undefined;
    static GetExtension(path: ReadOnlySpan_1<System_Internal.Char>): ReadOnlySpan_1<System_Internal.Char>;
    static GetExtension(path: string): string | undefined;
    static GetFileName(path: ReadOnlySpan_1<System_Internal.Char>): ReadOnlySpan_1<System_Internal.Char>;
    static GetFileName(path: string): string | undefined;
    static GetFileNameWithoutExtension(path: ReadOnlySpan_1<System_Internal.Char>): ReadOnlySpan_1<System_Internal.Char>;
    static GetFileNameWithoutExtension(path: string): string | undefined;
    static GetFullPath(path: string, basePath: string): string;
    static GetFullPath(path: string): string;
    static GetInvalidFileNameChars(): char[];
    static GetInvalidPathChars(): char[];
    static GetPathRoot(path: ReadOnlySpan_1<System_Internal.Char>): ReadOnlySpan_1<System_Internal.Char>;
    static GetPathRoot(path: string): string | undefined;
    static GetRandomFileName(): string;
    static GetRelativePath(relativeTo: string, path: string): string;
    static GetTempFileName(): string;
    static GetTempPath(): string;
    static HasExtension(path: ReadOnlySpan_1<System_Internal.Char>): boolean;
    static HasExtension(path: string): boolean;
    static IsPathFullyQualified(path: ReadOnlySpan_1<System_Internal.Char>): boolean;
    static IsPathFullyQualified(path: string): boolean;
    static IsPathRooted(path: ReadOnlySpan_1<System_Internal.Char>): boolean;
    static IsPathRooted(path: string): boolean;
    static Join(path1: ReadOnlySpan_1<System_Internal.Char>, path2: ReadOnlySpan_1<System_Internal.Char>, path3: ReadOnlySpan_1<System_Internal.Char>, path4: ReadOnlySpan_1<System_Internal.Char>): string;
    static Join(path1: ReadOnlySpan_1<System_Internal.Char>, path2: ReadOnlySpan_1<System_Internal.Char>, path3: ReadOnlySpan_1<System_Internal.Char>): string;
    static Join(path1: ReadOnlySpan_1<System_Internal.Char>, path2: ReadOnlySpan_1<System_Internal.Char>): string;
    static Join(paths: ReadOnlySpan_1<System_Internal.String>): string;
    static Join(path1: string, path2: string, path3: string, path4: string): string;
    static Join(path1: string, path2: string, path3: string): string;
    static Join(path1: string, path2: string): string;
    static Join(...paths: string[]): string;
    static TrimEndingDirectorySeparator(path: ReadOnlySpan_1<System_Internal.Char>): ReadOnlySpan_1<System_Internal.Char>;
    static TrimEndingDirectorySeparator(path: string): string;
    static TryJoin(path1: ReadOnlySpan_1<System_Internal.Char>, path2: ReadOnlySpan_1<System_Internal.Char>, path3: ReadOnlySpan_1<System_Internal.Char>, destination: Span_1<System_Internal.Char>, charsWritten: int): boolean;
    static TryJoin(path1: ReadOnlySpan_1<System_Internal.Char>, path2: ReadOnlySpan_1<System_Internal.Char>, destination: Span_1<System_Internal.Char>, charsWritten: int): boolean;
}


export type Path = Path$instance;

export abstract class RandomAccess$instance {
    static FlushToDisk(handle: SafeFileHandle): void;
    static GetLength(handle: SafeFileHandle): long;
    static Read(handle: SafeFileHandle, buffers: IReadOnlyList_1<Memory_1<System_Internal.Byte>>, fileOffset: long): long;
    static Read(handle: SafeFileHandle, buffer: Span_1<System_Internal.Byte>, fileOffset: long): int;
    static ReadAsync(handle: SafeFileHandle, buffers: IReadOnlyList_1<Memory_1<System_Internal.Byte>>, fileOffset: long, cancellationToken?: CancellationToken): ValueTask_1<System_Internal.Int64>;
    static ReadAsync(handle: SafeFileHandle, buffer: Memory_1<System_Internal.Byte>, fileOffset: long, cancellationToken?: CancellationToken): ValueTask_1<System_Internal.Int32>;
    static SetLength(handle: SafeFileHandle, length: long): void;
    static Write(handle: SafeFileHandle, buffers: IReadOnlyList_1<ReadOnlyMemory_1<System_Internal.Byte>>, fileOffset: long): void;
    static Write(handle: SafeFileHandle, buffer: ReadOnlySpan_1<System_Internal.Byte>, fileOffset: long): void;
    static WriteAsync(handle: SafeFileHandle, buffers: IReadOnlyList_1<ReadOnlyMemory_1<System_Internal.Byte>>, fileOffset: long, cancellationToken?: CancellationToken): ValueTask;
    static WriteAsync(handle: SafeFileHandle, buffer: ReadOnlyMemory_1<System_Internal.Byte>, fileOffset: long, cancellationToken?: CancellationToken): ValueTask;
}


export type RandomAccess = RandomAccess$instance;


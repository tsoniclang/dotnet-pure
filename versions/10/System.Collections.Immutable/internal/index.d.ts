// Generated by tsbindgen - Architecture
// Namespace: System.Collections.Immutable
// Assembly: System.Collections.Immutable

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IComparer_1, IDictionary_2, IEnumerable_1, IEnumerator_1, IEqualityComparer_1, IList_1, IReadOnlyCollection_1, IReadOnlyDictionary_2, IReadOnlyList_1, IReadOnlySet_1, ISet_1, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IComparer, IDictionary, IDictionaryEnumerator, IEnumerable, IEnumerator, IEqualityComparer, IList, IStructuralComparable, IStructuralEquatable } from "../../System.Collections/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Array as ClrArray, Boolean as ClrBoolean, Comparison_1, Func_2, Func_3, IDisposable, IEquatable_1, Int32, Object as ClrObject, Predicate_1, Range, ReadOnlyMemory_1, ReadOnlySpan_1, Span_1, String as ClrString, Type, ValueType, Void } from "../../System/internal/index.js";

export interface IImmutableDictionary_2$instance<TKey, TValue> extends IReadOnlyDictionary_2<TKey, TValue>, IEnumerable_1<KeyValuePair_2<TKey, TValue>>, IEnumerable, IReadOnlyCollection_1<KeyValuePair_2<TKey, TValue>> {
    readonly Item: TValue;
    readonly Keys: IEnumerable_1<TKey>;
    readonly Values: IEnumerable_1<TValue>;
    readonly Count: int;
    Add(key: TKey, value: TValue): IImmutableDictionary_2<TKey, TValue>;
    AddRange(pairs: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): IImmutableDictionary_2<TKey, TValue>;
    Clear(): IImmutableDictionary_2<TKey, TValue>;
    Contains(pair: KeyValuePair_2<TKey, TValue>): boolean;
    ContainsKey(key: TKey): boolean;
    GetEnumerator(): IEnumerator_1<KeyValuePair_2<TKey, TValue>>;
    GetEnumerator(): IEnumerator;
    Remove(key: TKey): IImmutableDictionary_2<TKey, TValue>;
    TryGetKey(equalKey: TKey, actualKey: TKey): boolean;
    TryGetValue(key: TKey, value: TValue): boolean;
    GetEnumerator2(): IEnumerator;
}


export type IImmutableDictionary_2<TKey, TValue> = IImmutableDictionary_2$instance<TKey, TValue>;

export interface IImmutableList_1$instance<T> extends IReadOnlyList_1<T>, IEnumerable_1<T>, IEnumerable, IReadOnlyCollection_1<T> {
    readonly Item: T;
    readonly Count: int;
    Add(value: T): IImmutableList_1<T>;
    AddRange(items: IEnumerable_1<T>): IImmutableList_1<T>;
    Clear(): IImmutableList_1<T>;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
    IndexOf(item: T, index: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    Insert(index: int, element: T): IImmutableList_1<T>;
    InsertRange(index: int, items: IEnumerable_1<T>): IImmutableList_1<T>;
    Remove(value: T, equalityComparer: IEqualityComparer_1<T>): IImmutableList_1<T>;
    RemoveAll(match: Predicate_1<T>): IImmutableList_1<T>;
    RemoveAt(index: int): IImmutableList_1<T>;
    RemoveRange(items: IEnumerable_1<T>, equalityComparer: IEqualityComparer_1<T>): IImmutableList_1<T>;
    RemoveRange(index: int, count: int): IImmutableList_1<T>;
    Replace(oldValue: T, newValue: T, equalityComparer: IEqualityComparer_1<T>): IImmutableList_1<T>;
    GetEnumerator2(): IEnumerator;
}


export type IImmutableList_1<T> = IImmutableList_1$instance<T>;

export interface IImmutableQueue_1$instance<T> extends IEnumerable_1<T>, IEnumerable {
    readonly IsEmpty: boolean;
    Clear(): IImmutableQueue_1<T>;
    Enqueue(value: T): IImmutableQueue_1<T>;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
    Peek(): T;
    GetEnumerator2(): IEnumerator;
}


export type IImmutableQueue_1<T> = IImmutableQueue_1$instance<T>;

export interface IImmutableSet_1$instance<T> extends IReadOnlyCollection_1<T>, IEnumerable_1<T>, IEnumerable {
    readonly Count: int;
    Add(value: T): IImmutableSet_1<T>;
    Clear(): IImmutableSet_1<T>;
    Contains(value: T): boolean;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
    Intersect(other: IEnumerable_1<T>): IImmutableSet_1<T>;
    SetEquals(other: IEnumerable_1<T>): boolean;
    TryGetValue(equalValue: T, actualValue: T): boolean;
    GetEnumerator2(): IEnumerator;
}


export type IImmutableSet_1<T> = IImmutableSet_1$instance<T>;

export interface IImmutableStack_1$instance<T> extends IEnumerable_1<T>, IEnumerable {
    readonly IsEmpty: boolean;
    Clear(): IImmutableStack_1<T>;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
    Peek(): T;
    Push(value: T): IImmutableStack_1<T>;
    GetEnumerator2(): IEnumerator;
}


export type IImmutableStack_1<T> = IImmutableStack_1$instance<T>;

export interface ImmutableArray_1$instance<T> {
    readonly IsDefault: boolean;
    readonly IsDefaultOrEmpty: boolean;
    readonly IsEmpty: boolean;
    readonly Item: T;
    readonly Length: int;
    Add(item: T): ImmutableArray_1<T>;
    AddRange(items: IEnumerable_1<T>): ImmutableArray_1<T>;
    AddRange(items: T[], length: int): ImmutableArray_1<T>;
    AddRange<TDerived extends T>(items: TDerived[]): ImmutableArray_1<T>;
    AddRange(items: ImmutableArray_1<T>, length: int): ImmutableArray_1<T>;
    AddRange<TDerived extends T>(items: ImmutableArray_1<TDerived>): ImmutableArray_1<T>;
    AddRange(items: ReadOnlySpan_1<T>): ImmutableArray_1<T>;
    AddRange(...items: T[]): ImmutableArray_1<T>;
    As<TOther>(): ImmutableArray_1<TOther>;
    AsMemory(): ReadOnlyMemory_1<T>;
    AsSpan(): ReadOnlySpan_1<T>;
    AsSpan(start: int, length: int): ReadOnlySpan_1<T>;
    AsSpan(range: Range): ReadOnlySpan_1<T>;
    CastArray<TOther>(): ImmutableArray_1<TOther>;
    Clear(): ImmutableArray_1<T>;
    Contains(item: T): boolean;
    Contains(item: T, equalityComparer: IEqualityComparer_1<T>): boolean;
    CopyTo(destination: Span_1<T>): void;
    CopyTo(destination: T[]): void;
    CopyTo(destination: T[], destinationIndex: int): void;
    CopyTo(sourceIndex: int, destination: T[], destinationIndex: int, length: int): void;
    Equals(obj: unknown): boolean;
    Equals(other: ImmutableArray_1<T>): boolean;
    GetEnumerator(): ImmutableArray_1_Enumerator<T>;
    GetHashCode(): int;
    IndexOf(item: T): int;
    IndexOf(item: T, startIndex: int, equalityComparer: IEqualityComparer_1<T>): int;
    IndexOf(item: T, startIndex: int): int;
    IndexOf(item: T, startIndex: int, count: int): int;
    IndexOf(item: T, startIndex: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    Insert(index: int, item: T): ImmutableArray_1<T>;
    InsertRange(index: int, items: IEnumerable_1<T>): ImmutableArray_1<T>;
    InsertRange(index: int, items: ImmutableArray_1<T>): ImmutableArray_1<T>;
    InsertRange(index: int, items: T[]): ImmutableArray_1<T>;
    InsertRange(index: int, items: ReadOnlySpan_1<T>): ImmutableArray_1<T>;
    ItemRef(index: int): T;
    LastIndexOf(item: T): int;
    LastIndexOf(item: T, startIndex: int): int;
    LastIndexOf(item: T, startIndex: int, count: int): int;
    LastIndexOf(item: T, startIndex: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    OfType<TResult>(): IEnumerable_1<TResult>;
    Remove(item: T): ImmutableArray_1<T>;
    Remove(item: T, equalityComparer: IEqualityComparer_1<T>): ImmutableArray_1<T>;
    RemoveAll(match: Predicate_1<T>): ImmutableArray_1<T>;
    RemoveAt(index: int): ImmutableArray_1<T>;
    RemoveRange(index: int, length: int): ImmutableArray_1<T>;
    RemoveRange(items: IEnumerable_1<T>): ImmutableArray_1<T>;
    RemoveRange(items: IEnumerable_1<T>, equalityComparer: IEqualityComparer_1<T>): ImmutableArray_1<T>;
    RemoveRange(items: ImmutableArray_1<T>): ImmutableArray_1<T>;
    RemoveRange(items: ImmutableArray_1<T>, equalityComparer: IEqualityComparer_1<T>): ImmutableArray_1<T>;
    RemoveRange(items: ReadOnlySpan_1<T>, equalityComparer?: IEqualityComparer_1<T>): ImmutableArray_1<T>;
    RemoveRange(items: T[], equalityComparer?: IEqualityComparer_1<T>): ImmutableArray_1<T>;
    Replace(oldValue: T, newValue: T): ImmutableArray_1<T>;
    Replace(oldValue: T, newValue: T, equalityComparer: IEqualityComparer_1<T>): ImmutableArray_1<T>;
    SetItem(index: int, item: T): ImmutableArray_1<T>;
    Slice(start: int, length: int): ImmutableArray_1<T>;
    Sort(): ImmutableArray_1<T>;
    Sort(comparison: Comparison_1<T>): ImmutableArray_1<T>;
    Sort(comparer: IComparer_1<T>): ImmutableArray_1<T>;
    Sort(index: int, count: int, comparer: IComparer_1<T>): ImmutableArray_1<T>;
    ToBuilder(): ImmutableArray_1_Builder<T>;
}


export const ImmutableArray_1: {
    new<T>(): ImmutableArray_1<T>;
    readonly Empty: unknown;
    CastUp<T, TDerived extends T>(items: ImmutableArray_1<TDerived>): ImmutableArray_1<T>;
};


export interface __ImmutableArray_1$views<T> {
    As_IImmutableList_1(): IImmutableList_1$instance<T>;
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<ImmutableArray_1<T>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ImmutableArray_1<T>): boolean;
}

export interface ImmutableArray_1$instance<T> extends System_Collections_Internal.IStructuralComparable$instance {}

export type ImmutableArray_1<T> = ImmutableArray_1$instance<T> & __ImmutableArray_1$views<T>;


export interface ImmutableArray_1_Enumerator$instance<T> {
    readonly Current: T;
    MoveNext(): boolean;
}


export const ImmutableArray_1_Enumerator: {
    new<T>(): ImmutableArray_1_Enumerator<T>;
};


export type ImmutableArray_1_Enumerator<T> = ImmutableArray_1_Enumerator$instance<T>;

export interface ImmutableDictionary_2_Enumerator$instance<TKey, TValue> extends IDisposable {
    readonly Current: KeyValuePair_2<TKey, TValue>;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export const ImmutableDictionary_2_Enumerator: {
    new<TKey, TValue>(): ImmutableDictionary_2_Enumerator<TKey, TValue>;
};


export interface __ImmutableDictionary_2_Enumerator$views<TKey, TValue> {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type ImmutableDictionary_2_Enumerator<TKey, TValue> = ImmutableDictionary_2_Enumerator$instance<TKey, TValue> & __ImmutableDictionary_2_Enumerator$views<TKey, TValue>;


export interface ImmutableHashSet_1_Enumerator$instance<T> extends IDisposable {
    readonly Current: T;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export const ImmutableHashSet_1_Enumerator: {
    new<T>(): ImmutableHashSet_1_Enumerator<T>;
};


export interface __ImmutableHashSet_1_Enumerator$views<T> {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<T>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type ImmutableHashSet_1_Enumerator<T> = ImmutableHashSet_1_Enumerator$instance<T> & __ImmutableHashSet_1_Enumerator$views<T>;


export interface ImmutableList_1_Enumerator$instance<T> extends IDisposable {
    readonly Current: T;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export const ImmutableList_1_Enumerator: {
    new<T>(): ImmutableList_1_Enumerator<T>;
};


export interface __ImmutableList_1_Enumerator$views<T> {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<T>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type ImmutableList_1_Enumerator<T> = ImmutableList_1_Enumerator$instance<T> & __ImmutableList_1_Enumerator$views<T>;


export interface ImmutableQueue_1_Enumerator$instance<T> {
    readonly Current: T;
    MoveNext(): boolean;
}


export const ImmutableQueue_1_Enumerator: {
    new<T>(): ImmutableQueue_1_Enumerator<T>;
};


export type ImmutableQueue_1_Enumerator<T> = ImmutableQueue_1_Enumerator$instance<T>;

export interface ImmutableSortedDictionary_2_Enumerator$instance<TKey, TValue> extends IDisposable {
    readonly Current: KeyValuePair_2<TKey, TValue>;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export const ImmutableSortedDictionary_2_Enumerator: {
    new<TKey, TValue>(): ImmutableSortedDictionary_2_Enumerator<TKey, TValue>;
};


export interface __ImmutableSortedDictionary_2_Enumerator$views<TKey, TValue> {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type ImmutableSortedDictionary_2_Enumerator<TKey, TValue> = ImmutableSortedDictionary_2_Enumerator$instance<TKey, TValue> & __ImmutableSortedDictionary_2_Enumerator$views<TKey, TValue>;


export interface ImmutableSortedSet_1_Enumerator$instance<T> extends IDisposable {
    readonly Current: T;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export const ImmutableSortedSet_1_Enumerator: {
    new<T>(): ImmutableSortedSet_1_Enumerator<T>;
};


export interface __ImmutableSortedSet_1_Enumerator$views<T> {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<T>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type ImmutableSortedSet_1_Enumerator<T> = ImmutableSortedSet_1_Enumerator$instance<T> & __ImmutableSortedSet_1_Enumerator$views<T>;


export interface ImmutableStack_1_Enumerator$instance<T> {
    readonly Current: T;
    MoveNext(): boolean;
}


export const ImmutableStack_1_Enumerator: {
    new<T>(): ImmutableStack_1_Enumerator<T>;
};


export type ImmutableStack_1_Enumerator<T> = ImmutableStack_1_Enumerator$instance<T>;

export interface ImmutableArray_1_Builder$instance<T> {
    Capacity: int;
    Count: int;
    Item: T;
    Add(item: T): void;
    AddRange(items: IEnumerable_1<T>): void;
    AddRange(...items: T[]): void;
    AddRange<TDerived extends T>(items: TDerived[]): void;
    AddRange(items: T[], length: int): void;
    AddRange(items: ImmutableArray_1<T>): void;
    AddRange(items: ImmutableArray_1<T>, length: int): void;
    AddRange(items: ReadOnlySpan_1<T>): void;
    AddRange(items: ImmutableArray_1_Builder<T>): void;
    Clear(): void;
    Contains(item: T): boolean;
    CopyTo(array: T[], index: int): void;
    CopyTo(destination: T[]): void;
    CopyTo(sourceIndex: int, destination: T[], destinationIndex: int, length: int): void;
    CopyTo(destination: Span_1<T>): void;
    DrainToImmutable(): ImmutableArray_1<T>;
    GetEnumerator(): IEnumerator_1<T>;
    IndexOf(item: T): int;
    IndexOf(item: T, startIndex: int): int;
    IndexOf(item: T, startIndex: int, count: int): int;
    IndexOf(item: T, startIndex: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    IndexOf(item: T, startIndex: int, equalityComparer: IEqualityComparer_1<T>): int;
    Insert(index: int, item: T): void;
    InsertRange(index: int, items: IEnumerable_1<T>): void;
    InsertRange(index: int, items: ImmutableArray_1<T>): void;
    ItemRef(index: int): T;
    LastIndexOf(item: T): int;
    LastIndexOf(item: T, startIndex: int): int;
    LastIndexOf(item: T, startIndex: int, count: int): int;
    LastIndexOf(item: T, startIndex: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    MoveToImmutable(): ImmutableArray_1<T>;
    Remove(element: T): boolean;
    Remove(element: T, equalityComparer: IEqualityComparer_1<T>): boolean;
    RemoveAll(match: Predicate_1<T>): void;
    RemoveAt(index: int): void;
    RemoveRange(index: int, length: int): void;
    RemoveRange(items: IEnumerable_1<T>): void;
    RemoveRange(items: IEnumerable_1<T>, equalityComparer: IEqualityComparer_1<T>): void;
    Replace(oldValue: T, newValue: T): void;
    Replace(oldValue: T, newValue: T, equalityComparer: IEqualityComparer_1<T>): void;
    Reverse(): void;
    Sort(): void;
    Sort(comparison: Comparison_1<T>): void;
    Sort(comparer: IComparer_1<T>): void;
    Sort(index: int, count: int, comparer: IComparer_1<T>): void;
    ToArray(): T[];
    ToImmutable(): ImmutableArray_1<T>;
}


export const ImmutableArray_1_Builder: {
    new<T>(): ImmutableArray_1_Builder<T>;
};


export interface __ImmutableArray_1_Builder$views<T> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableArray_1_Builder<T> = ImmutableArray_1_Builder$instance<T> & __ImmutableArray_1_Builder$views<T>;


export interface ImmutableDictionary_2$instance<TKey, TValue> {
    readonly Count: int;
    readonly IsEmpty: boolean;
    readonly Item: TValue;
    readonly KeyComparer: IEqualityComparer_1<TKey>;
    readonly Keys: IEnumerable_1<TKey>;
    readonly ValueComparer: IEqualityComparer_1<TValue>;
    readonly Values: IEnumerable_1<TValue>;
    Add(key: TKey, value: TValue): ImmutableDictionary_2<TKey, TValue>;
    AddRange(pairs: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableDictionary_2<TKey, TValue>;
    Clear(): ImmutableDictionary_2<TKey, TValue>;
    Contains(pair: KeyValuePair_2<TKey, TValue>): boolean;
    ContainsKey(key: TKey): boolean;
    ContainsValue(value: TValue): boolean;
    GetEnumerator(): ImmutableDictionary_2_Enumerator<TKey, TValue>;
    Remove(key: TKey): ImmutableDictionary_2<TKey, TValue>;
    RemoveRange(keys: IEnumerable_1<TKey>): ImmutableDictionary_2<TKey, TValue>;
    SetItem(key: TKey, value: TValue): ImmutableDictionary_2<TKey, TValue>;
    SetItems(items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableDictionary_2<TKey, TValue>;
    ToBuilder(): ImmutableDictionary_2_Builder<TKey, TValue>;
    TryGetKey(equalKey: TKey, actualKey: TKey): boolean;
    TryGetValue(key: TKey, value: TValue): boolean;
    WithComparers(keyComparer: IEqualityComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableDictionary_2<TKey, TValue>;
    WithComparers(keyComparer: IEqualityComparer_1<TKey>): ImmutableDictionary_2<TKey, TValue>;
}


export const ImmutableDictionary_2: {
    new<TKey, TValue>(): ImmutableDictionary_2<TKey, TValue>;
    readonly Empty: unknown;
};


export interface __ImmutableDictionary_2$views<TKey, TValue> {
    As_IImmutableDictionary_2(): IImmutableDictionary_2$instance<TKey, TValue>;
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionary_2(): System_Collections_Generic_Internal.IDictionary_2$instance<TKey, TValue>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyDictionary_2(): System_Collections_Generic_Internal.IReadOnlyDictionary_2$instance<TKey, TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableDictionary_2<TKey, TValue> = ImmutableDictionary_2$instance<TKey, TValue> & __ImmutableDictionary_2$views<TKey, TValue>;


export interface ImmutableDictionary_2_Builder$instance<TKey, TValue> {
    readonly Count: int;
    Item: TValue;
    KeyComparer: IEqualityComparer_1<TKey>;
    readonly Keys: IEnumerable_1<TKey>;
    ValueComparer: IEqualityComparer_1<TValue>;
    readonly Values: IEnumerable_1<TValue>;
    Add(key: TKey, value: TValue): void;
    Add(item: KeyValuePair_2<TKey, TValue>): void;
    AddRange(items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): void;
    Clear(): void;
    Contains(item: KeyValuePair_2<TKey, TValue>): boolean;
    ContainsKey(key: TKey): boolean;
    ContainsValue(value: TValue): boolean;
    GetEnumerator(): ImmutableDictionary_2_Enumerator<TKey, TValue>;
    GetValueOrDefault(key: TKey): TValue | undefined;
    GetValueOrDefault(key: TKey, defaultValue: TValue): TValue;
    Remove(key: TKey): boolean;
    Remove(item: KeyValuePair_2<TKey, TValue>): boolean;
    RemoveRange(keys: IEnumerable_1<TKey>): void;
    ToImmutable(): ImmutableDictionary_2<TKey, TValue>;
    TryGetKey(equalKey: TKey, actualKey: TKey): boolean;
    TryGetValue(key: TKey, value: TValue): boolean;
}


export const ImmutableDictionary_2_Builder: {
    new<TKey, TValue>(): ImmutableDictionary_2_Builder<TKey, TValue>;
};


export interface __ImmutableDictionary_2_Builder$views<TKey, TValue> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionary_2(): System_Collections_Generic_Internal.IDictionary_2$instance<TKey, TValue>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyDictionary_2(): System_Collections_Generic_Internal.IReadOnlyDictionary_2$instance<TKey, TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableDictionary_2_Builder<TKey, TValue> = ImmutableDictionary_2_Builder$instance<TKey, TValue> & __ImmutableDictionary_2_Builder$views<TKey, TValue>;


export interface ImmutableHashSet_1$instance<T> {
    readonly Count: int;
    readonly IsEmpty: boolean;
    readonly KeyComparer: IEqualityComparer_1<T>;
    Add(item: T): ImmutableHashSet_1<T>;
    Clear(): ImmutableHashSet_1<T>;
    Contains(item: T): boolean;
    Except(other: IEnumerable_1<T>): ImmutableHashSet_1<T>;
    GetEnumerator(): ImmutableHashSet_1_Enumerator<T>;
    Intersect(other: IEnumerable_1<T>): ImmutableHashSet_1<T>;
    IsProperSubsetOf(other: IEnumerable_1<T>): boolean;
    IsProperSupersetOf(other: IEnumerable_1<T>): boolean;
    IsSubsetOf(other: IEnumerable_1<T>): boolean;
    IsSupersetOf(other: IEnumerable_1<T>): boolean;
    Overlaps(other: IEnumerable_1<T>): boolean;
    Remove(item: T): ImmutableHashSet_1<T>;
    SetEquals(other: IEnumerable_1<T>): boolean;
    SymmetricExcept(other: IEnumerable_1<T>): ImmutableHashSet_1<T>;
    ToBuilder(): ImmutableHashSet_1_Builder<T>;
    TryGetValue(equalValue: T, actualValue: T): boolean;
    Union(other: IEnumerable_1<T>): ImmutableHashSet_1<T>;
    WithComparer(equalityComparer: IEqualityComparer_1<T>): ImmutableHashSet_1<T>;
}


export const ImmutableHashSet_1: {
    new<T>(): ImmutableHashSet_1<T>;
    readonly Empty: unknown;
};


export interface __ImmutableHashSet_1$views<T> {
    As_IImmutableSet_1(): IImmutableSet_1$instance<T>;
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_IReadOnlySet_1(): System_Collections_Generic_Internal.IReadOnlySet_1$instance<T>;
    As_ISet_1(): System_Collections_Generic_Internal.ISet_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableHashSet_1<T> = ImmutableHashSet_1$instance<T> & __ImmutableHashSet_1$views<T>;


export interface ImmutableHashSet_1_Builder$instance<T> {
    readonly Count: int;
    KeyComparer: IEqualityComparer_1<T>;
    Add(item: T): boolean;
    Clear(): void;
    Contains(item: T): boolean;
    ExceptWith(other: IEnumerable_1<T>): void;
    GetEnumerator(): ImmutableHashSet_1_Enumerator<T>;
    IntersectWith(other: IEnumerable_1<T>): void;
    IsProperSubsetOf(other: IEnumerable_1<T>): boolean;
    IsProperSupersetOf(other: IEnumerable_1<T>): boolean;
    IsSubsetOf(other: IEnumerable_1<T>): boolean;
    IsSupersetOf(other: IEnumerable_1<T>): boolean;
    Overlaps(other: IEnumerable_1<T>): boolean;
    Remove(item: T): boolean;
    SetEquals(other: IEnumerable_1<T>): boolean;
    SymmetricExceptWith(other: IEnumerable_1<T>): void;
    ToImmutable(): ImmutableHashSet_1<T>;
    TryGetValue(equalValue: T, actualValue: T): boolean;
    UnionWith(other: IEnumerable_1<T>): void;
}


export const ImmutableHashSet_1_Builder: {
    new<T>(): ImmutableHashSet_1_Builder<T>;
};


export interface __ImmutableHashSet_1_Builder$views<T> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_ISet_1(): System_Collections_Generic_Internal.ISet_1$instance<T>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableHashSet_1_Builder<T> = ImmutableHashSet_1_Builder$instance<T> & __ImmutableHashSet_1_Builder$views<T>;


export interface ImmutableList_1$instance<T> {
    readonly Count: int;
    readonly IsEmpty: boolean;
    readonly Item: T;
    Add(value: T): ImmutableList_1<T>;
    AddRange(items: IEnumerable_1<T>): ImmutableList_1<T>;
    BinarySearch(item: T): int;
    BinarySearch(item: T, comparer: IComparer_1<T>): int;
    BinarySearch(index: int, count: int, item: T, comparer: IComparer_1<T>): int;
    Clear(): ImmutableList_1<T>;
    Contains(value: T): boolean;
    ConvertAll<TOutput>(converter: Func_2<T, TOutput>): ImmutableList_1<TOutput>;
    CopyTo(array: T[]): void;
    CopyTo(array: T[], arrayIndex: int): void;
    CopyTo(index: int, array: T[], arrayIndex: int, count: int): void;
    Exists(match: Predicate_1<T>): boolean;
    Find(match: Predicate_1<T>): T | undefined;
    FindAll(match: Predicate_1<T>): ImmutableList_1<T>;
    FindIndex(match: Predicate_1<T>): int;
    FindIndex(startIndex: int, match: Predicate_1<T>): int;
    FindIndex(startIndex: int, count: int, match: Predicate_1<T>): int;
    FindLast(match: Predicate_1<T>): T | undefined;
    FindLastIndex(match: Predicate_1<T>): int;
    FindLastIndex(startIndex: int, match: Predicate_1<T>): int;
    FindLastIndex(startIndex: int, count: int, match: Predicate_1<T>): int;
    ForEach(action: Action_1<T>): void;
    GetEnumerator(): ImmutableList_1_Enumerator<T>;
    GetRange(index: int, count: int): ImmutableList_1<T>;
    IndexOf(item: T, index: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    IndexOf(value: T): int;
    Insert(index: int, item: T): ImmutableList_1<T>;
    InsertRange(index: int, items: IEnumerable_1<T>): ImmutableList_1<T>;
    ItemRef(index: int): T;
    LastIndexOf(item: T, index: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    Remove(value: T): ImmutableList_1<T>;
    Remove(value: T, equalityComparer: IEqualityComparer_1<T>): ImmutableList_1<T>;
    RemoveAll(match: Predicate_1<T>): ImmutableList_1<T>;
    RemoveAt(index: int): ImmutableList_1<T>;
    RemoveRange(index: int, count: int): ImmutableList_1<T>;
    RemoveRange(items: IEnumerable_1<T>): ImmutableList_1<T>;
    RemoveRange(items: IEnumerable_1<T>, equalityComparer: IEqualityComparer_1<T>): ImmutableList_1<T>;
    Replace(oldValue: T, newValue: T): ImmutableList_1<T>;
    Replace(oldValue: T, newValue: T, equalityComparer: IEqualityComparer_1<T>): ImmutableList_1<T>;
    Reverse(): ImmutableList_1<T>;
    Reverse(index: int, count: int): ImmutableList_1<T>;
    SetItem(index: int, value: T): ImmutableList_1<T>;
    Sort(): ImmutableList_1<T>;
    Sort(comparison: Comparison_1<T>): ImmutableList_1<T>;
    Sort(comparer: IComparer_1<T>): ImmutableList_1<T>;
    Sort(index: int, count: int, comparer: IComparer_1<T>): ImmutableList_1<T>;
    ToBuilder(): ImmutableList_1_Builder<T>;
    TrueForAll(match: Predicate_1<T>): boolean;
}


export const ImmutableList_1: {
    new<T>(): ImmutableList_1<T>;
    readonly Empty: unknown;
};


export interface __ImmutableList_1$views<T> {
    As_IImmutableList_1(): IImmutableList_1$instance<T>;
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type ImmutableList_1<T> = ImmutableList_1$instance<T> & __ImmutableList_1$views<T>;


export interface ImmutableList_1_Builder$instance<T> {
    readonly Count: int;
    Item: T;
    Add(item: T): void;
    AddRange(items: IEnumerable_1<T>): void;
    BinarySearch(item: T): int;
    BinarySearch(item: T, comparer: IComparer_1<T>): int;
    BinarySearch(index: int, count: int, item: T, comparer: IComparer_1<T>): int;
    Clear(): void;
    Contains(item: T): boolean;
    ConvertAll<TOutput>(converter: Func_2<T, TOutput>): ImmutableList_1<TOutput>;
    CopyTo(array: T[]): void;
    CopyTo(array: T[], arrayIndex: int): void;
    CopyTo(index: int, array: T[], arrayIndex: int, count: int): void;
    Exists(match: Predicate_1<T>): boolean;
    Find(match: Predicate_1<T>): T | undefined;
    FindAll(match: Predicate_1<T>): ImmutableList_1<T>;
    FindIndex(match: Predicate_1<T>): int;
    FindIndex(startIndex: int, match: Predicate_1<T>): int;
    FindIndex(startIndex: int, count: int, match: Predicate_1<T>): int;
    FindLast(match: Predicate_1<T>): T | undefined;
    FindLastIndex(match: Predicate_1<T>): int;
    FindLastIndex(startIndex: int, match: Predicate_1<T>): int;
    FindLastIndex(startIndex: int, count: int, match: Predicate_1<T>): int;
    ForEach(action: Action_1<T>): void;
    GetEnumerator(): ImmutableList_1_Enumerator<T>;
    GetRange(index: int, count: int): ImmutableList_1<T>;
    IndexOf(item: T): int;
    IndexOf(item: T, index: int): int;
    IndexOf(item: T, index: int, count: int): int;
    IndexOf(item: T, index: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    Insert(index: int, item: T): void;
    InsertRange(index: int, items: IEnumerable_1<T>): void;
    ItemRef(index: int): T;
    LastIndexOf(item: T): int;
    LastIndexOf(item: T, startIndex: int): int;
    LastIndexOf(item: T, startIndex: int, count: int): int;
    LastIndexOf(item: T, startIndex: int, count: int, equalityComparer: IEqualityComparer_1<T>): int;
    Remove(item: T): boolean;
    Remove(item: T, equalityComparer: IEqualityComparer_1<T>): boolean;
    RemoveAll(match: Predicate_1<T>): int;
    RemoveAt(index: int): void;
    RemoveRange(index: int, count: int): void;
    RemoveRange(items: IEnumerable_1<T>, equalityComparer: IEqualityComparer_1<T>): void;
    RemoveRange(items: IEnumerable_1<T>): void;
    Replace(oldValue: T, newValue: T): void;
    Replace(oldValue: T, newValue: T, equalityComparer: IEqualityComparer_1<T>): void;
    Reverse(): void;
    Reverse(index: int, count: int): void;
    Sort(): void;
    Sort(comparison: Comparison_1<T>): void;
    Sort(comparer: IComparer_1<T>): void;
    Sort(index: int, count: int, comparer: IComparer_1<T>): void;
    ToImmutable(): ImmutableList_1<T>;
    TrueForAll(match: Predicate_1<T>): boolean;
}


export const ImmutableList_1_Builder: {
    new<T>(): ImmutableList_1_Builder<T>;
};


export interface __ImmutableList_1_Builder$views<T> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type ImmutableList_1_Builder<T> = ImmutableList_1_Builder$instance<T> & __ImmutableList_1_Builder$views<T>;


export interface ImmutableQueue_1$instance<T> {
    readonly IsEmpty: boolean;
    Clear(): ImmutableQueue_1<T>;
    Dequeue(): ImmutableQueue_1<T>;
    Dequeue(value: T): ImmutableQueue_1<T>;
    Enqueue(value: T): ImmutableQueue_1<T>;
    GetEnumerator(): ImmutableQueue_1_Enumerator<T>;
    Peek(): T;
    PeekRef(): T;
}


export const ImmutableQueue_1: {
    new<T>(): ImmutableQueue_1<T>;
    readonly Empty: unknown;
};


export interface __ImmutableQueue_1$views<T> {
    As_IImmutableQueue_1(): IImmutableQueue_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableQueue_1<T> = ImmutableQueue_1$instance<T> & __ImmutableQueue_1$views<T>;


export interface ImmutableSortedDictionary_2$instance<TKey, TValue> {
    readonly Count: int;
    readonly IsEmpty: boolean;
    readonly Item: TValue;
    readonly KeyComparer: IComparer_1<TKey>;
    readonly Keys: IEnumerable_1<TKey>;
    readonly ValueComparer: IEqualityComparer_1<TValue>;
    readonly Values: IEnumerable_1<TValue>;
    Add(key: TKey, value: TValue): ImmutableSortedDictionary_2<TKey, TValue>;
    AddRange(items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableSortedDictionary_2<TKey, TValue>;
    Clear(): ImmutableSortedDictionary_2<TKey, TValue>;
    Contains(pair: KeyValuePair_2<TKey, TValue>): boolean;
    ContainsKey(key: TKey): boolean;
    ContainsValue(value: TValue): boolean;
    GetEnumerator(): ImmutableSortedDictionary_2_Enumerator<TKey, TValue>;
    Remove(value: TKey): ImmutableSortedDictionary_2<TKey, TValue>;
    RemoveRange(keys: IEnumerable_1<TKey>): ImmutableSortedDictionary_2<TKey, TValue>;
    SetItem(key: TKey, value: TValue): ImmutableSortedDictionary_2<TKey, TValue>;
    SetItems(items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableSortedDictionary_2<TKey, TValue>;
    ToBuilder(): ImmutableSortedDictionary_2_Builder<TKey, TValue>;
    TryGetKey(equalKey: TKey, actualKey: TKey): boolean;
    TryGetValue(key: TKey, value: TValue): boolean;
    ValueRef(key: TKey): TValue;
    WithComparers(keyComparer: IComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableSortedDictionary_2<TKey, TValue>;
    WithComparers(keyComparer: IComparer_1<TKey>): ImmutableSortedDictionary_2<TKey, TValue>;
}


export const ImmutableSortedDictionary_2: {
    new<TKey, TValue>(): ImmutableSortedDictionary_2<TKey, TValue>;
    readonly Empty: unknown;
};


export interface __ImmutableSortedDictionary_2$views<TKey, TValue> {
    As_IImmutableDictionary_2(): IImmutableDictionary_2$instance<TKey, TValue>;
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionary_2(): System_Collections_Generic_Internal.IDictionary_2$instance<TKey, TValue>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyDictionary_2(): System_Collections_Generic_Internal.IReadOnlyDictionary_2$instance<TKey, TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableSortedDictionary_2<TKey, TValue> = ImmutableSortedDictionary_2$instance<TKey, TValue> & __ImmutableSortedDictionary_2$views<TKey, TValue>;


export interface ImmutableSortedDictionary_2_Builder$instance<TKey, TValue> {
    readonly Count: int;
    Item: TValue;
    KeyComparer: IComparer_1<TKey>;
    readonly Keys: IEnumerable_1<TKey>;
    ValueComparer: IEqualityComparer_1<TValue>;
    readonly Values: IEnumerable_1<TValue>;
    Add(key: TKey, value: TValue): void;
    Add(item: KeyValuePair_2<TKey, TValue>): void;
    AddRange(items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): void;
    Clear(): void;
    Contains(item: KeyValuePair_2<TKey, TValue>): boolean;
    ContainsKey(key: TKey): boolean;
    ContainsValue(value: TValue): boolean;
    GetEnumerator(): ImmutableSortedDictionary_2_Enumerator<TKey, TValue>;
    GetValueOrDefault(key: TKey): TValue | undefined;
    GetValueOrDefault(key: TKey, defaultValue: TValue): TValue;
    Remove(key: TKey): boolean;
    Remove(item: KeyValuePair_2<TKey, TValue>): boolean;
    RemoveRange(keys: IEnumerable_1<TKey>): void;
    ToImmutable(): ImmutableSortedDictionary_2<TKey, TValue>;
    TryGetKey(equalKey: TKey, actualKey: TKey): boolean;
    TryGetValue(key: TKey, value: TValue): boolean;
    ValueRef(key: TKey): TValue;
}


export const ImmutableSortedDictionary_2_Builder: {
    new<TKey, TValue>(): ImmutableSortedDictionary_2_Builder<TKey, TValue>;
};


export interface __ImmutableSortedDictionary_2_Builder$views<TKey, TValue> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionary_2(): System_Collections_Generic_Internal.IDictionary_2$instance<TKey, TValue>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyDictionary_2(): System_Collections_Generic_Internal.IReadOnlyDictionary_2$instance<TKey, TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableSortedDictionary_2_Builder<TKey, TValue> = ImmutableSortedDictionary_2_Builder$instance<TKey, TValue> & __ImmutableSortedDictionary_2_Builder$views<TKey, TValue>;


export interface ImmutableSortedSet_1$instance<T> {
    readonly Count: int;
    readonly IsEmpty: boolean;
    readonly Item: T;
    readonly KeyComparer: IComparer_1<T>;
    readonly Max: T | undefined;
    readonly Min: T | undefined;
    Add(value: T): ImmutableSortedSet_1<T>;
    Clear(): ImmutableSortedSet_1<T>;
    Contains(value: T): boolean;
    Except(other: IEnumerable_1<T>): ImmutableSortedSet_1<T>;
    GetEnumerator(): ImmutableSortedSet_1_Enumerator<T>;
    IndexOf(item: T): int;
    Intersect(other: IEnumerable_1<T>): ImmutableSortedSet_1<T>;
    IsProperSubsetOf(other: IEnumerable_1<T>): boolean;
    IsProperSupersetOf(other: IEnumerable_1<T>): boolean;
    IsSubsetOf(other: IEnumerable_1<T>): boolean;
    IsSupersetOf(other: IEnumerable_1<T>): boolean;
    ItemRef(index: int): T;
    Overlaps(other: IEnumerable_1<T>): boolean;
    Remove(value: T): ImmutableSortedSet_1<T>;
    Reverse(): IEnumerable_1<T>;
    SetEquals(other: IEnumerable_1<T>): boolean;
    SymmetricExcept(other: IEnumerable_1<T>): ImmutableSortedSet_1<T>;
    ToBuilder(): ImmutableSortedSet_1_Builder<T>;
    TryGetValue(equalValue: T, actualValue: T): boolean;
    Union(other: IEnumerable_1<T>): ImmutableSortedSet_1<T>;
    WithComparer(comparer: IComparer_1<T>): ImmutableSortedSet_1<T>;
}


export const ImmutableSortedSet_1: {
    new<T>(): ImmutableSortedSet_1<T>;
    readonly Empty: unknown;
};


export interface __ImmutableSortedSet_1$views<T> {
    As_IImmutableSet_1(): IImmutableSet_1$instance<T>;
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_IReadOnlySet_1(): System_Collections_Generic_Internal.IReadOnlySet_1$instance<T>;
    As_ISet_1(): System_Collections_Generic_Internal.ISet_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type ImmutableSortedSet_1<T> = ImmutableSortedSet_1$instance<T> & __ImmutableSortedSet_1$views<T>;


export interface ImmutableSortedSet_1_Builder$instance<T> {
    readonly Count: int;
    readonly Item: T;
    KeyComparer: IComparer_1<T>;
    readonly Max: T | undefined;
    readonly Min: T | undefined;
    Add(item: T): boolean;
    Clear(): void;
    Contains(item: T): boolean;
    ExceptWith(other: IEnumerable_1<T>): void;
    GetEnumerator(): ImmutableSortedSet_1_Enumerator<T>;
    IndexOf(item: T): int;
    IntersectWith(other: IEnumerable_1<T>): void;
    IsProperSubsetOf(other: IEnumerable_1<T>): boolean;
    IsProperSupersetOf(other: IEnumerable_1<T>): boolean;
    IsSubsetOf(other: IEnumerable_1<T>): boolean;
    IsSupersetOf(other: IEnumerable_1<T>): boolean;
    ItemRef(index: int): T;
    Overlaps(other: IEnumerable_1<T>): boolean;
    Remove(item: T): boolean;
    Reverse(): IEnumerable_1<T>;
    SetEquals(other: IEnumerable_1<T>): boolean;
    SymmetricExceptWith(other: IEnumerable_1<T>): void;
    ToImmutable(): ImmutableSortedSet_1<T>;
    TryGetValue(equalValue: T, actualValue: T): boolean;
    UnionWith(other: IEnumerable_1<T>): void;
}


export const ImmutableSortedSet_1_Builder: {
    new<T>(): ImmutableSortedSet_1_Builder<T>;
};


export interface __ImmutableSortedSet_1_Builder$views<T> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_ISet_1(): System_Collections_Generic_Internal.ISet_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableSortedSet_1_Builder<T> = ImmutableSortedSet_1_Builder$instance<T> & __ImmutableSortedSet_1_Builder$views<T>;


export interface ImmutableStack_1$instance<T> {
    readonly IsEmpty: boolean;
    Clear(): ImmutableStack_1<T>;
    GetEnumerator(): ImmutableStack_1_Enumerator<T>;
    Peek(): T;
    PeekRef(): T;
    Pop(): ImmutableStack_1<T>;
    Pop(value: T): ImmutableStack_1<T>;
    Push(value: T): ImmutableStack_1<T>;
}


export const ImmutableStack_1: {
    new<T>(): ImmutableStack_1<T>;
    readonly Empty: unknown;
};


export interface __ImmutableStack_1$views<T> {
    As_IImmutableStack_1(): IImmutableStack_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ImmutableStack_1<T> = ImmutableStack_1$instance<T> & __ImmutableStack_1$views<T>;


export abstract class ImmutableArray$instance {
    static BinarySearch<T>(array: ImmutableArray_1<T>, index: int, length: int, value: T, comparer: IComparer_1<T>): int;
    static BinarySearch<T>(array: ImmutableArray_1<T>, index: int, length: int, value: T): int;
    static BinarySearch<T>(array: ImmutableArray_1<T>, value: T, comparer: IComparer_1<T>): int;
    static BinarySearch<T>(array: ImmutableArray_1<T>, value: T): int;
    static Create<T>(): ImmutableArray_1<T>;
    static Create<T>(items: ImmutableArray_1<T>, start: int, length: int): ImmutableArray_1<T>;
    static Create<T>(items: ReadOnlySpan_1<T>): ImmutableArray_1<T>;
    static Create<T>(items: Span_1<T>): ImmutableArray_1<T>;
    static Create<T>(item1: T, item2: T, item3: T, item4: T): ImmutableArray_1<T>;
    static Create<T>(item1: T, item2: T, item3: T): ImmutableArray_1<T>;
    static Create<T>(item1: T, item2: T): ImmutableArray_1<T>;
    static Create<T>(item: T): ImmutableArray_1<T>;
    static Create<T>(items: T[], start: int, length: int): ImmutableArray_1<T>;
    static Create<T>(...items: T[]): ImmutableArray_1<T>;
    static CreateBuilder<T>(): ImmutableArray_1_Builder<T>;
    static CreateBuilder<T>(initialCapacity: int): ImmutableArray_1_Builder<T>;
    static CreateRange<T>(items: IEnumerable_1<T>): ImmutableArray_1<T>;
    static CreateRange<TSource, TResult>(items: ImmutableArray_1<TSource>, selector: Func_2<TSource, TResult>): ImmutableArray_1<TResult>;
    static CreateRange<TSource, TArg, TResult>(items: ImmutableArray_1<TSource>, selector: Func_3<TSource, TArg, TResult>, arg: TArg): ImmutableArray_1<TResult>;
    static CreateRange<TSource, TResult>(items: ImmutableArray_1<TSource>, start: int, length: int, selector: Func_2<TSource, TResult>): ImmutableArray_1<TResult>;
    static CreateRange<TSource, TArg, TResult>(items: ImmutableArray_1<TSource>, start: int, length: int, selector: Func_3<TSource, TArg, TResult>, arg: TArg): ImmutableArray_1<TResult>;
    static ToImmutableArray<TSource>(builder: ImmutableArray_1_Builder<TSource>): ImmutableArray_1<TSource>;
    static ToImmutableArray<TSource>(items: IEnumerable_1<TSource>): ImmutableArray_1<TSource>;
    static ToImmutableArray<T>(items: ReadOnlySpan_1<T>): ImmutableArray_1<T>;
    static ToImmutableArray<T>(items: Span_1<T>): ImmutableArray_1<T>;
}


export type ImmutableArray = ImmutableArray$instance;

export abstract class ImmutableDictionary$instance {
    static Contains<TKey, TValue>(map: IImmutableDictionary_2<TKey, TValue>, key: TKey, value: TValue): boolean;
    static Create<TKey, TValue>(): ImmutableDictionary_2<TKey, TValue>;
    static Create<TKey, TValue>(keyComparer: IEqualityComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableDictionary_2<TKey, TValue>;
    static Create<TKey, TValue>(keyComparer: IEqualityComparer_1<TKey>): ImmutableDictionary_2<TKey, TValue>;
    static CreateBuilder<TKey, TValue>(): ImmutableDictionary_2_Builder<TKey, TValue>;
    static CreateBuilder<TKey, TValue>(keyComparer: IEqualityComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableDictionary_2_Builder<TKey, TValue>;
    static CreateBuilder<TKey, TValue>(keyComparer: IEqualityComparer_1<TKey>): ImmutableDictionary_2_Builder<TKey, TValue>;
    static CreateRange<TKey, TValue>(items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableDictionary_2<TKey, TValue>;
    static CreateRange<TKey, TValue>(keyComparer: IEqualityComparer_1<TKey>, items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableDictionary_2<TKey, TValue>;
    static CreateRange<TKey, TValue>(keyComparer: IEqualityComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>, items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableDictionary_2<TKey, TValue>;
    static CreateRangeWithOverwrite<TKey, TValue>(keyComparer: IEqualityComparer_1<TKey>, items: ReadOnlySpan_1<KeyValuePair_2<TKey, TValue>>): ImmutableDictionary_2<TKey, TValue>;
    static CreateRangeWithOverwrite<TKey, TValue>(items: ReadOnlySpan_1<KeyValuePair_2<TKey, TValue>>): ImmutableDictionary_2<TKey, TValue>;
    static GetValueOrDefault<TKey, TValue>(dictionary: IImmutableDictionary_2<TKey, TValue>, key: TKey, defaultValue: TValue): TValue;
    static GetValueOrDefault<TKey, TValue>(dictionary: IImmutableDictionary_2<TKey, TValue>, key: TKey): TValue | undefined;
    static ToImmutableDictionary<TKey, TValue>(builder: ImmutableDictionary_2_Builder<TKey, TValue>): ImmutableDictionary_2<TKey, TValue>;
    static ToImmutableDictionary<TSource, TKey, TValue>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TValue>, keyComparer: IEqualityComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableDictionary_2<TKey, TValue>;
    static ToImmutableDictionary<TSource, TKey, TValue>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TValue>, keyComparer: IEqualityComparer_1<TKey>): ImmutableDictionary_2<TKey, TValue>;
    static ToImmutableDictionary<TSource, TKey, TValue>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TValue>): ImmutableDictionary_2<TKey, TValue>;
    static ToImmutableDictionary<TSource, TKey>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, keyComparer: IEqualityComparer_1<TKey>): ImmutableDictionary_2<TKey, TSource>;
    static ToImmutableDictionary<TSource, TKey>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>): ImmutableDictionary_2<TKey, TSource>;
    static ToImmutableDictionary<TKey, TValue>(source: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, keyComparer: IEqualityComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableDictionary_2<TKey, TValue>;
    static ToImmutableDictionary<TKey, TValue>(source: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, keyComparer: IEqualityComparer_1<TKey>): ImmutableDictionary_2<TKey, TValue>;
    static ToImmutableDictionary<TKey, TValue>(source: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableDictionary_2<TKey, TValue>;
}


export type ImmutableDictionary = ImmutableDictionary$instance;

export abstract class ImmutableHashSet$instance {
    static Create<T>(): ImmutableHashSet_1<T>;
    static Create<T>(equalityComparer: IEqualityComparer_1<T>, items: ReadOnlySpan_1<T>): ImmutableHashSet_1<T>;
    static Create<T>(equalityComparer: IEqualityComparer_1<T>, item: T): ImmutableHashSet_1<T>;
    static Create<T>(equalityComparer: IEqualityComparer_1<T>, ...items: T[]): ImmutableHashSet_1<T>;
    static Create<T>(equalityComparer: IEqualityComparer_1<T>): ImmutableHashSet_1<T>;
    static Create<T>(items: ReadOnlySpan_1<T>): ImmutableHashSet_1<T>;
    static Create<T>(item: T): ImmutableHashSet_1<T>;
    static Create<T>(...items: T[]): ImmutableHashSet_1<T>;
    static CreateBuilder<T>(): ImmutableHashSet_1_Builder<T>;
    static CreateBuilder<T>(equalityComparer: IEqualityComparer_1<T>): ImmutableHashSet_1_Builder<T>;
    static CreateRange<T>(items: IEnumerable_1<T>): ImmutableHashSet_1<T>;
    static CreateRange<T>(equalityComparer: IEqualityComparer_1<T>, items: IEnumerable_1<T>): ImmutableHashSet_1<T>;
    static ToImmutableHashSet<TSource>(builder: ImmutableHashSet_1_Builder<TSource>): ImmutableHashSet_1<TSource>;
    static ToImmutableHashSet<TSource>(source: IEnumerable_1<TSource>, equalityComparer: IEqualityComparer_1<TSource>): ImmutableHashSet_1<TSource>;
    static ToImmutableHashSet<TSource>(source: IEnumerable_1<TSource>): ImmutableHashSet_1<TSource>;
}


export type ImmutableHashSet = ImmutableHashSet$instance;

export abstract class ImmutableInterlocked$instance {
    static AddOrUpdate<TKey, TValue>(location: ImmutableDictionary_2<TKey, TValue>, key: TKey, addValueFactory: Func_2<TKey, TValue>, updateValueFactory: Func_3<TKey, TValue, TValue>): TValue;
    static AddOrUpdate<TKey, TValue>(location: ImmutableDictionary_2<TKey, TValue>, key: TKey, addValue: TValue, updateValueFactory: Func_3<TKey, TValue, TValue>): TValue;
    static Enqueue<T>(location: ImmutableQueue_1<T>, value: T): void;
    static GetOrAdd<TKey, TValue>(location: ImmutableDictionary_2<TKey, TValue>, key: TKey, valueFactory: Func_2<TKey, TValue>): TValue;
    static GetOrAdd<TKey, TValue, TArg>(location: ImmutableDictionary_2<TKey, TValue>, key: TKey, valueFactory: Func_3<TKey, TArg, TValue>, factoryArgument: TArg): TValue;
    static GetOrAdd<TKey, TValue>(location: ImmutableDictionary_2<TKey, TValue>, key: TKey, value: TValue): TValue;
    static InterlockedCompareExchange<T>(location: ImmutableArray_1<T>, value: ImmutableArray_1<T>, comparand: ImmutableArray_1<T>): ImmutableArray_1<T>;
    static InterlockedExchange<T>(location: ImmutableArray_1<T>, value: ImmutableArray_1<T>): ImmutableArray_1<T>;
    static InterlockedInitialize<T>(location: ImmutableArray_1<T>, value: ImmutableArray_1<T>): boolean;
    static Push<T>(location: ImmutableStack_1<T>, value: T): void;
    static TryAdd<TKey, TValue>(location: ImmutableDictionary_2<TKey, TValue>, key: TKey, value: TValue): boolean;
    static TryDequeue<T>(location: ImmutableQueue_1<T>, value: T): boolean;
    static TryPop<T>(location: ImmutableStack_1<T>, value: T): boolean;
    static TryRemove<TKey, TValue>(location: ImmutableDictionary_2<TKey, TValue>, key: TKey, value: TValue): boolean;
    static TryUpdate<TKey, TValue>(location: ImmutableDictionary_2<TKey, TValue>, key: TKey, newValue: TValue, comparisonValue: TValue): boolean;
    static Update<T>(location: ImmutableArray_1<T>, transformer: Func_2<ImmutableArray_1<T>, ImmutableArray_1<T>>): boolean;
    static Update<T, TArg>(location: ImmutableArray_1<T>, transformer: Func_3<ImmutableArray_1<T>, TArg, ImmutableArray_1<T>>, transformerArgument: TArg): boolean;
    static Update<T>(location: T, transformer: Func_2<T, T>): boolean;
    static Update<T, TArg>(location: T, transformer: Func_3<T, TArg, T>, transformerArgument: TArg): boolean;
}


export type ImmutableInterlocked = ImmutableInterlocked$instance;

export abstract class ImmutableList$instance {
    static Create<T>(): ImmutableList_1<T>;
    static Create<T>(items: ReadOnlySpan_1<T>): ImmutableList_1<T>;
    static Create<T>(item: T): ImmutableList_1<T>;
    static Create<T>(...items: T[]): ImmutableList_1<T>;
    static CreateBuilder<T>(): ImmutableList_1_Builder<T>;
    static CreateRange<T>(items: IEnumerable_1<T>): ImmutableList_1<T>;
    static IndexOf<T>(list: IImmutableList_1<T>, item: T, equalityComparer: IEqualityComparer_1<T>): int;
    static IndexOf<T>(list: IImmutableList_1<T>, item: T, startIndex: int, count: int): int;
    static IndexOf<T>(list: IImmutableList_1<T>, item: T, startIndex: int): int;
    static IndexOf<T>(list: IImmutableList_1<T>, item: T): int;
    static LastIndexOf<T>(list: IImmutableList_1<T>, item: T, equalityComparer: IEqualityComparer_1<T>): int;
    static LastIndexOf<T>(list: IImmutableList_1<T>, item: T, startIndex: int, count: int): int;
    static LastIndexOf<T>(list: IImmutableList_1<T>, item: T, startIndex: int): int;
    static LastIndexOf<T>(list: IImmutableList_1<T>, item: T): int;
    static Remove<T>(list: IImmutableList_1<T>, value: T): IImmutableList_1<T>;
    static RemoveRange<T>(list: IImmutableList_1<T>, items: IEnumerable_1<T>): IImmutableList_1<T>;
    static Replace<T>(list: IImmutableList_1<T>, oldValue: T, newValue: T): IImmutableList_1<T>;
    static ToImmutableList<TSource>(builder: ImmutableList_1_Builder<TSource>): ImmutableList_1<TSource>;
    static ToImmutableList<TSource>(source: IEnumerable_1<TSource>): ImmutableList_1<TSource>;
}


export type ImmutableList = ImmutableList$instance;

export abstract class ImmutableQueue$instance {
    static Create<T>(): ImmutableQueue_1<T>;
    static Create<T>(items: ReadOnlySpan_1<T>): ImmutableQueue_1<T>;
    static Create<T>(item: T): ImmutableQueue_1<T>;
    static Create<T>(...items: T[]): ImmutableQueue_1<T>;
    static CreateRange<T>(items: IEnumerable_1<T>): ImmutableQueue_1<T>;
    static Dequeue<T>(queue: IImmutableQueue_1<T>, value: T): IImmutableQueue_1<T>;
}


export type ImmutableQueue = ImmutableQueue$instance;

export abstract class ImmutableSortedDictionary$instance {
    static Create<TKey, TValue>(): ImmutableSortedDictionary_2<TKey, TValue>;
    static Create<TKey, TValue>(keyComparer: IComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableSortedDictionary_2<TKey, TValue>;
    static Create<TKey, TValue>(keyComparer: IComparer_1<TKey>): ImmutableSortedDictionary_2<TKey, TValue>;
    static CreateBuilder<TKey, TValue>(): ImmutableSortedDictionary_2_Builder<TKey, TValue>;
    static CreateBuilder<TKey, TValue>(keyComparer: IComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableSortedDictionary_2_Builder<TKey, TValue>;
    static CreateBuilder<TKey, TValue>(keyComparer: IComparer_1<TKey>): ImmutableSortedDictionary_2_Builder<TKey, TValue>;
    static CreateRange<TKey, TValue>(keyComparer: IComparer_1<TKey>, items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableSortedDictionary_2<TKey, TValue>;
    static CreateRange<TKey, TValue>(keyComparer: IComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>, items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableSortedDictionary_2<TKey, TValue>;
    static CreateRange<TKey, TValue>(items: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableSortedDictionary_2<TKey, TValue>;
    static ToImmutableSortedDictionary<TKey, TValue>(builder: ImmutableSortedDictionary_2_Builder<TKey, TValue>): ImmutableSortedDictionary_2<TKey, TValue>;
    static ToImmutableSortedDictionary<TSource, TKey, TValue>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TValue>, keyComparer: IComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableSortedDictionary_2<TKey, TValue>;
    static ToImmutableSortedDictionary<TSource, TKey, TValue>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TValue>, keyComparer: IComparer_1<TKey>): ImmutableSortedDictionary_2<TKey, TValue>;
    static ToImmutableSortedDictionary<TSource, TKey, TValue>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TValue>): ImmutableSortedDictionary_2<TKey, TValue>;
    static ToImmutableSortedDictionary<TKey, TValue>(source: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, keyComparer: IComparer_1<TKey>, valueComparer: IEqualityComparer_1<TValue>): ImmutableSortedDictionary_2<TKey, TValue>;
    static ToImmutableSortedDictionary<TKey, TValue>(source: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, keyComparer: IComparer_1<TKey>): ImmutableSortedDictionary_2<TKey, TValue>;
    static ToImmutableSortedDictionary<TKey, TValue>(source: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ImmutableSortedDictionary_2<TKey, TValue>;
}


export type ImmutableSortedDictionary = ImmutableSortedDictionary$instance;

export abstract class ImmutableSortedSet$instance {
    static Create<T>(): ImmutableSortedSet_1<T>;
    static Create<T>(comparer: IComparer_1<T>, items: ReadOnlySpan_1<T>): ImmutableSortedSet_1<T>;
    static Create<T>(comparer: IComparer_1<T>, item: T): ImmutableSortedSet_1<T>;
    static Create<T>(comparer: IComparer_1<T>, ...items: T[]): ImmutableSortedSet_1<T>;
    static Create<T>(comparer: IComparer_1<T>): ImmutableSortedSet_1<T>;
    static Create<T>(items: ReadOnlySpan_1<T>): ImmutableSortedSet_1<T>;
    static Create<T>(item: T): ImmutableSortedSet_1<T>;
    static Create<T>(...items: T[]): ImmutableSortedSet_1<T>;
    static CreateBuilder<T>(): ImmutableSortedSet_1_Builder<T>;
    static CreateBuilder<T>(comparer: IComparer_1<T>): ImmutableSortedSet_1_Builder<T>;
    static CreateRange<T>(comparer: IComparer_1<T>, items: IEnumerable_1<T>): ImmutableSortedSet_1<T>;
    static CreateRange<T>(items: IEnumerable_1<T>): ImmutableSortedSet_1<T>;
    static ToImmutableSortedSet<TSource>(builder: ImmutableSortedSet_1_Builder<TSource>): ImmutableSortedSet_1<TSource>;
    static ToImmutableSortedSet<TSource>(source: IEnumerable_1<TSource>, comparer: IComparer_1<TSource>): ImmutableSortedSet_1<TSource>;
    static ToImmutableSortedSet<TSource>(source: IEnumerable_1<TSource>): ImmutableSortedSet_1<TSource>;
}


export type ImmutableSortedSet = ImmutableSortedSet$instance;

export abstract class ImmutableStack$instance {
    static Create<T>(): ImmutableStack_1<T>;
    static Create<T>(items: ReadOnlySpan_1<T>): ImmutableStack_1<T>;
    static Create<T>(item: T): ImmutableStack_1<T>;
    static Create<T>(...items: T[]): ImmutableStack_1<T>;
    static CreateRange<T>(items: IEnumerable_1<T>): ImmutableStack_1<T>;
    static Pop<T>(stack: IImmutableStack_1<T>, value: T): IImmutableStack_1<T>;
}


export type ImmutableStack = ImmutableStack$instance;


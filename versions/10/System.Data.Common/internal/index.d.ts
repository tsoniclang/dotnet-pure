// Generated by tsbindgen - Architecture
// Namespace: System.Data.Common
// Assembly: System.Data.Common

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IList_1 } from "../../System.Collections.Generic/internal/index.js";
import type { ReadOnlyCollection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IDictionaryEnumerator, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { AttributeCollection, Component, EventDescriptor, EventDescriptorCollection, IComponent, IContainer, ICustomTypeDescriptor, ISite, PropertyDescriptor, PropertyDescriptorCollection, TypeConverter } from "../../System.ComponentModel/internal/index.js";
import * as System_Data_Internal from "../../System.Data/internal/index.js";
import type { CommandBehavior, CommandType, ConflictOption, ConnectionState, DataColumn, DataRow, DataRowVersion, DataSet, DataTable, DbType, FillErrorEventHandler, IColumnMapping, IColumnMappingCollection, IDataAdapter, IDataParameter, IDataParameterCollection, IDataReader, IDataRecord, IDbCommand, IDbConnection, IDbDataAdapter, IDbDataParameter, IDbTransaction, IsolationLevel, ITableMapping, ITableMappingCollection, LoadOption, MissingMappingAction, MissingSchemaAction, ParameterDirection, SchemaType, StateChangeEventHandler, StatementType, UpdateRowSource, UpdateStatus } from "../../System.Data/internal/index.js";
import type { Stream, TextReader } from "../../System.IO/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_InteropServices_Internal from "../../System.Runtime.InteropServices/internal/index.js";
import type { ExternalException } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { StringBuilder } from "../../System.Text/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import type { Transaction } from "../../System.Transactions/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Attribute, Boolean as ClrBoolean, Byte, Char, DateTime, Decimal, Double, Enum, EventArgs, Exception, Guid, IAsyncDisposable, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int16, Int32, Int64, ISpanFormattable, MarshalByRefObject, Nullable_1, Object as ClrObject, Single, String as ClrString, Type, TypeCode, Void } from "../../System/internal/index.js";

export enum CatalogLocation {
    Start = 1,
    End = 2
}


export enum GroupByBehavior {
    Unknown = 0,
    NotSupported = 1,
    Unrelated = 2,
    MustContainAll = 3,
    ExactMatch = 4
}


export enum IdentifierCase {
    Unknown = 0,
    Insensitive = 1,
    Sensitive = 2
}


export enum SupportedJoinOperators {
    None = 0,
    Inner = 1,
    LeftOuter = 2,
    RightOuter = 4,
    FullOuter = 8
}


export interface IDbColumnSchemaGenerator$instance {
    GetColumnSchema(): ReadOnlyCollection_1<DbColumn>;
}


export type IDbColumnSchemaGenerator = IDbColumnSchemaGenerator$instance;

export interface DataAdapter$instance extends Component {
    AcceptChangesDuringFill: boolean;
    AcceptChangesDuringUpdate: boolean;
    ContinueUpdateOnError: boolean;
    FillLoadOption: LoadOption;
    MissingMappingAction: MissingMappingAction;
    MissingSchemaAction: MissingSchemaAction;
    ReturnProviderSpecificTypes: boolean;
    readonly TableMappings: DataTableMappingCollection;
    Dispose(): void;
    Fill(dataSet: DataSet): int;
    FillSchema(dataSet: DataSet, schemaType: SchemaType): DataTable[];
    GetFillParameters(): IDataParameter[];
    ResetFillLoadOption(): void;
    ShouldSerializeAcceptChangesDuringFill(): boolean;
    ShouldSerializeFillLoadOption(): boolean;
    Update(dataSet: DataSet): int;
}


export const DataAdapter: {
    new(): DataAdapter;
};


export interface __DataAdapter$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDataAdapter(): System_Data_Internal.IDataAdapter$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DataAdapter$instance extends System_ComponentModel_Internal.IComponent$instance {}

export type DataAdapter = DataAdapter$instance & __DataAdapter$views;


export interface DataColumnMapping$instance extends MarshalByRefObject {
    DataSetColumn: string;
    SourceColumn: string;
    GetDataColumnBySchemaAction(dataTable: DataTable, dataType: Type, schemaAction: MissingSchemaAction): DataColumn | undefined;
    ToString(): string;
}


export const DataColumnMapping: {
    new(): DataColumnMapping;
    new(sourceColumn: string, dataSetColumn: string): DataColumnMapping;
    GetDataColumnBySchemaAction(sourceColumn: string, dataSetColumn: string, dataTable: DataTable, dataType: Type, schemaAction: MissingSchemaAction): DataColumn | undefined;
};


export interface __DataColumnMapping$views {
    As_IColumnMapping(): System_Data_Internal.IColumnMapping$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface DataColumnMapping$instance extends System_Data_Internal.IColumnMapping$instance, System_Internal.ICloneable$instance {}

export type DataColumnMapping = DataColumnMapping$instance & __DataColumnMapping$views;


export interface DataColumnMappingCollection$instance extends MarshalByRefObject {
    readonly Count: int;
    Add(value: unknown): int;
    Add(sourceColumn: string, dataSetColumn: string): DataColumnMapping;
    AddRange(values: DataColumnMapping[]): void;
    AddRange(values: ClrArray): void;
    Clear(): void;
    Contains(value: string): boolean;
    Contains(value: unknown): boolean;
    CopyTo(array: ClrArray, index: int): void;
    CopyTo(array: DataColumnMapping[], index: int): void;
    get_Item(index: int): DataColumnMapping;
    get_Item(sourceColumn: string): DataColumnMapping;
    GetByDataSetColumn(value: string): DataColumnMapping;
    GetEnumerator(): IEnumerator;
    IndexOf(value: unknown): int;
    IndexOf(sourceColumn: string): int;
    IndexOfDataSetColumn(dataSetColumn: string): int;
    Insert(index: int, value: unknown): void;
    Insert(index: int, value: DataColumnMapping): void;
    Remove(value: unknown): void;
    Remove(value: DataColumnMapping): void;
    RemoveAt(index: int): void;
    RemoveAt(sourceColumn: string): void;
    set_Item(index: int, value: DataColumnMapping): void;
    set_Item(sourceColumn: string, value: DataColumnMapping): void;
}


export const DataColumnMappingCollection: {
    new(): DataColumnMappingCollection;
    GetColumnMappingBySchemaAction(columnMappings: DataColumnMappingCollection, sourceColumn: string, mappingAction: MissingMappingAction): DataColumnMapping | undefined;
    GetDataColumn(columnMappings: DataColumnMappingCollection, sourceColumn: string, dataType: Type, dataTable: DataTable, mappingAction: MissingMappingAction, schemaAction: MissingSchemaAction): DataColumn | undefined;
};


export interface __DataColumnMappingCollection$views {
    As_IColumnMappingCollection(): System_Data_Internal.IColumnMappingCollection$instance;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type DataColumnMappingCollection = DataColumnMappingCollection$instance & __DataColumnMappingCollection$views;


export interface DataTableMapping$instance extends MarshalByRefObject {
    readonly ColumnMappings: DataColumnMappingCollection;
    DataSetTable: string;
    SourceTable: string;
    GetColumnMappingBySchemaAction(sourceColumn: string, mappingAction: MissingMappingAction): DataColumnMapping | undefined;
    GetDataColumn(sourceColumn: string, dataType: Type, dataTable: DataTable, mappingAction: MissingMappingAction, schemaAction: MissingSchemaAction): DataColumn | undefined;
    GetDataTableBySchemaAction(dataSet: DataSet, schemaAction: MissingSchemaAction): DataTable | undefined;
    ToString(): string;
}


export const DataTableMapping: {
    new(): DataTableMapping;
    new(sourceTable: string, dataSetTable: string): DataTableMapping;
    new(sourceTable: string, dataSetTable: string, columnMappings: DataColumnMapping[]): DataTableMapping;
};


export interface __DataTableMapping$views {
    As_ITableMapping(): System_Data_Internal.ITableMapping$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface DataTableMapping$instance extends System_Internal.ICloneable$instance {}

export type DataTableMapping = DataTableMapping$instance & __DataTableMapping$views;


export interface DataTableMappingCollection$instance extends MarshalByRefObject {
    readonly Count: int;
    Add(value: unknown): int;
    Add(sourceTable: string, dataSetTable: string): DataTableMapping;
    AddRange(values: DataTableMapping[]): void;
    AddRange(values: ClrArray): void;
    Clear(): void;
    Contains(value: string): boolean;
    Contains(value: unknown): boolean;
    CopyTo(array: ClrArray, index: int): void;
    CopyTo(array: DataTableMapping[], index: int): void;
    get_Item(index: int): DataTableMapping;
    get_Item(sourceTable: string): DataTableMapping;
    GetByDataSetTable(dataSetTable: string): DataTableMapping;
    GetEnumerator(): IEnumerator;
    IndexOf(value: unknown): int;
    IndexOf(sourceTable: string): int;
    IndexOfDataSetTable(dataSetTable: string): int;
    Insert(index: int, value: unknown): void;
    Insert(index: int, value: DataTableMapping): void;
    Remove(value: unknown): void;
    Remove(value: DataTableMapping): void;
    RemoveAt(index: int): void;
    RemoveAt(sourceTable: string): void;
    set_Item(index: int, value: DataTableMapping): void;
    set_Item(sourceTable: string, value: DataTableMapping): void;
}


export const DataTableMappingCollection: {
    new(): DataTableMappingCollection;
    GetTableMappingBySchemaAction(tableMappings: DataTableMappingCollection, sourceTable: string, dataSetTable: string, mappingAction: MissingMappingAction): DataTableMapping | undefined;
};


export interface __DataTableMappingCollection$views {
    As_ITableMappingCollection(): System_Data_Internal.ITableMappingCollection$instance;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type DataTableMappingCollection = DataTableMappingCollection$instance & __DataTableMappingCollection$views;


export interface DbBatch$instance {
    readonly BatchCommands: DbBatchCommandCollection;
    Connection: DbConnection;
    Timeout: int;
    get Transaction(): DbTransaction | undefined;
    set Transaction(value: DbTransaction);
    Cancel(): void;
    CreateBatchCommand(): DbBatchCommand;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    ExecuteNonQuery(): int;
    ExecuteNonQueryAsync(cancellationToken?: CancellationToken): Task_1<System_Internal.Int32>;
    ExecuteReader(behavior?: CommandBehavior): DbDataReader;
    ExecuteReaderAsync(cancellationToken?: CancellationToken): Task_1<DbDataReader>;
    ExecuteReaderAsync(behavior: CommandBehavior, cancellationToken?: CancellationToken): Task_1<DbDataReader>;
    ExecuteScalar(): unknown | undefined;
    ExecuteScalarAsync(cancellationToken?: CancellationToken): Task_1<unknown | undefined>;
    Prepare(): void;
    PrepareAsync(cancellationToken?: CancellationToken): Task;
}


export const DbBatch: {
};


export interface __DbBatch$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DbBatch$instance extends System_Internal.IAsyncDisposable$instance, System_Internal.IDisposable$instance {}

export type DbBatch = DbBatch$instance & __DbBatch$views;


export interface DbBatchCommand$instance {
    readonly CanCreateParameter: boolean;
    CommandText: string;
    CommandType: CommandType;
    readonly Parameters: DbParameterCollection;
    readonly RecordsAffected: int;
    CreateParameter(): DbParameter;
}


export const DbBatchCommand: {
};


export type DbBatchCommand = DbBatchCommand$instance;

export interface DbBatchCommandCollection$instance {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    Item: DbBatchCommand;
    Add(item: DbBatchCommand): void;
    Clear(): void;
    Contains(item: DbBatchCommand): boolean;
    CopyTo(array: DbBatchCommand[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator_1<DbBatchCommand>;
    IndexOf(item: DbBatchCommand): int;
    Insert(index: int, item: DbBatchCommand): void;
    Remove(item: DbBatchCommand): boolean;
    RemoveAt(index: int): void;
}


export const DbBatchCommandCollection: {
};


export interface __DbBatchCommandCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<DbBatchCommand>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<DbBatchCommand>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<DbBatchCommand>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type DbBatchCommandCollection = DbBatchCommandCollection$instance & __DbBatchCommandCollection$views;


export interface DbColumn$instance {
    readonly AllowDBNull: Nullable_1<System_Internal.Boolean>;
    readonly BaseCatalogName: string | undefined;
    readonly BaseColumnName: string | undefined;
    readonly BaseSchemaName: string | undefined;
    readonly BaseServerName: string | undefined;
    readonly BaseTableName: string | undefined;
    readonly ColumnName: string;
    readonly ColumnOrdinal: Nullable_1<System_Internal.Int32>;
    readonly ColumnSize: Nullable_1<System_Internal.Int32>;
    readonly DataType: Type;
    readonly DataTypeName: string | undefined;
    readonly IsAliased: Nullable_1<System_Internal.Boolean>;
    readonly IsAutoIncrement: Nullable_1<System_Internal.Boolean>;
    readonly IsExpression: Nullable_1<System_Internal.Boolean>;
    readonly IsHidden: Nullable_1<System_Internal.Boolean>;
    readonly IsIdentity: Nullable_1<System_Internal.Boolean>;
    readonly IsKey: Nullable_1<System_Internal.Boolean>;
    readonly IsLong: Nullable_1<System_Internal.Boolean>;
    readonly IsReadOnly: Nullable_1<System_Internal.Boolean>;
    readonly IsUnique: Nullable_1<System_Internal.Boolean>;
    readonly Item: unknown;
    readonly NumericPrecision: Nullable_1<System_Internal.Int32>;
    readonly NumericScale: Nullable_1<System_Internal.Int32>;
    readonly UdtAssemblyQualifiedName: string | undefined;
}


export const DbColumn: {
};


export type DbColumn = DbColumn$instance;

export interface DbCommand$instance extends Component {
    CommandText: string;
    CommandTimeout: int;
    CommandType: CommandType;
    Connection: DbConnection;
    DesignTimeVisible: boolean;
    readonly Parameters: DbParameterCollection;
    get Transaction(): DbTransaction | undefined;
    set Transaction(value: DbTransaction);
    UpdatedRowSource: UpdateRowSource;
    Cancel(): void;
    CreateParameter(): DbParameter;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    ExecuteNonQuery(): int;
    ExecuteNonQueryAsync(): Task_1<System_Internal.Int32>;
    ExecuteNonQueryAsync(cancellationToken: CancellationToken): Task_1<System_Internal.Int32>;
    ExecuteReader(): DbDataReader;
    ExecuteReader(behavior: CommandBehavior): DbDataReader;
    ExecuteReaderAsync(): Task_1<DbDataReader>;
    ExecuteReaderAsync(cancellationToken: CancellationToken): Task_1<DbDataReader>;
    ExecuteReaderAsync(behavior: CommandBehavior): Task_1<DbDataReader>;
    ExecuteReaderAsync(behavior: CommandBehavior, cancellationToken: CancellationToken): Task_1<DbDataReader>;
    ExecuteScalar(): unknown | undefined;
    ExecuteScalarAsync(): Task_1<unknown | undefined>;
    ExecuteScalarAsync(cancellationToken: CancellationToken): Task_1<unknown | undefined>;
    Prepare(): void;
    PrepareAsync(cancellationToken?: CancellationToken): Task;
}


export const DbCommand: {
};


export interface __DbCommand$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDbCommand(): System_Data_Internal.IDbCommand$instance;
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DbCommand$instance extends System_ComponentModel_Internal.IComponent$instance, System_Internal.IAsyncDisposable$instance {}

export type DbCommand = DbCommand$instance & __DbCommand$views;


export interface DbCommandBuilder$instance extends Component {
    CatalogLocation: CatalogLocation;
    CatalogSeparator: string;
    ConflictOption: ConflictOption;
    get DataAdapter(): DbDataAdapter | undefined;
    set DataAdapter(value: DbDataAdapter);
    QuotePrefix: string;
    QuoteSuffix: string;
    SchemaSeparator: string;
    SetAllValues: boolean;
    Dispose(): void;
    GetDeleteCommand(): DbCommand;
    GetDeleteCommand(useColumnsForParameterNames: boolean): DbCommand;
    GetInsertCommand(): DbCommand;
    GetInsertCommand(useColumnsForParameterNames: boolean): DbCommand;
    GetUpdateCommand(): DbCommand;
    GetUpdateCommand(useColumnsForParameterNames: boolean): DbCommand;
    QuoteIdentifier(unquotedIdentifier: string): string;
    RefreshSchema(): void;
    UnquoteIdentifier(quotedIdentifier: string): string;
}


export const DbCommandBuilder: {
};


export interface __DbCommandBuilder$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DbCommandBuilder$instance extends System_ComponentModel_Internal.IComponent$instance {}

export type DbCommandBuilder = DbCommandBuilder$instance & __DbCommandBuilder$views;


export interface DbConnection$instance extends Component {
    readonly CanCreateBatch: boolean;
    ConnectionString: string;
    readonly ConnectionTimeout: int;
    readonly Database: string;
    readonly DataSource: string;
    readonly ServerVersion: string;
    readonly State: ConnectionState;
    BeginTransaction(): DbTransaction;
    BeginTransaction(isolationLevel: IsolationLevel): DbTransaction;
    BeginTransactionAsync(cancellationToken?: CancellationToken): ValueTask_1<DbTransaction>;
    BeginTransactionAsync(isolationLevel: IsolationLevel, cancellationToken?: CancellationToken): ValueTask_1<DbTransaction>;
    ChangeDatabase(databaseName: string): void;
    ChangeDatabaseAsync(databaseName: string, cancellationToken?: CancellationToken): Task;
    Close(): void;
    CloseAsync(): Task;
    CreateBatch(): DbBatch;
    CreateCommand(): DbCommand;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    EnlistTransaction(transaction: Transaction): void;
    GetSchema(): DataTable;
    GetSchema(collectionName: string): DataTable;
    GetSchema(collectionName: string, restrictionValues: string[]): DataTable;
    GetSchemaAsync(cancellationToken?: CancellationToken): Task_1<DataTable>;
    GetSchemaAsync(collectionName: string, cancellationToken?: CancellationToken): Task_1<DataTable>;
    GetSchemaAsync(collectionName: string, restrictionValues: string[], cancellationToken?: CancellationToken): Task_1<DataTable>;
    Open(): void;
    OpenAsync(): Task;
    OpenAsync(cancellationToken: CancellationToken): Task;
}


export const DbConnection: {
};


export interface __DbConnection$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDbConnection(): System_Data_Internal.IDbConnection$instance;
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DbConnection$instance extends System_ComponentModel_Internal.IComponent$instance, System_Internal.IAsyncDisposable$instance {}

export type DbConnection = DbConnection$instance & __DbConnection$views;


export interface DbConnectionStringBuilder$instance {
    BrowsableConnectionString: boolean;
    ConnectionString: string;
    readonly Count: int;
    readonly IsFixedSize: boolean;
    readonly IsReadOnly: boolean;
    Item: unknown;
    readonly Keys: ICollection;
    readonly Values: ICollection;
    Add(keyword: string, value: unknown): void;
    Clear(): void;
    ContainsKey(keyword: string): boolean;
    EquivalentTo(connectionStringBuilder: DbConnectionStringBuilder): boolean;
    Remove(keyword: string): boolean;
    ShouldSerialize(keyword: string): boolean;
    ToString(): string;
    TryGetValue(keyword: string, value: unknown): boolean;
}


export const DbConnectionStringBuilder: {
    new(): DbConnectionStringBuilder;
    new(useOdbcRules: boolean): DbConnectionStringBuilder;
    AppendKeyValuePair(builder: StringBuilder, keyword: string, value: string, useOdbcRules: boolean): void;
    AppendKeyValuePair(builder: StringBuilder, keyword: string, value: string): void;
};


export interface __DbConnectionStringBuilder$views {
    As_ICustomTypeDescriptor(): System_ComponentModel_Internal.ICustomTypeDescriptor$instance;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export interface DbConnectionStringBuilder$instance extends System_ComponentModel_Internal.ICustomTypeDescriptor$instance {}

export type DbConnectionStringBuilder = DbConnectionStringBuilder$instance & __DbConnectionStringBuilder$views;


export interface DbDataAdapter$instance extends DataAdapter$instance {
    get DeleteCommand(): DbCommand | undefined;
    set DeleteCommand(value: DbCommand);
    get InsertCommand(): DbCommand | undefined;
    set InsertCommand(value: DbCommand);
    get SelectCommand(): DbCommand | undefined;
    set SelectCommand(value: DbCommand);
    UpdateBatchSize: int;
    get UpdateCommand(): DbCommand | undefined;
    set UpdateCommand(value: DbCommand);
    Dispose(): void;
    Fill(dataSet: DataSet): int;
    Fill(dataTable: DataTable): int;
    FillSchema(dataTable: DataTable, schemaType: SchemaType): DataTable | undefined;
    FillSchema(dataSet: DataSet, schemaType: SchemaType): DataTable[];
    GetFillParameters(): IDataParameter[];
    Update(dataSet: DataSet): int;
    Update(dataTable: DataTable): int;
}


export const DbDataAdapter: {
    readonly DefaultSourceTableName: string;
};


export interface __DbDataAdapter$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDataAdapter(): System_Data_Internal.IDataAdapter$instance;
    As_IDbDataAdapter(): System_Data_Internal.IDbDataAdapter$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DbDataAdapter$instance extends System_Internal.ICloneable$instance {}

export type DbDataAdapter = DbDataAdapter$instance & __DbDataAdapter$views;


export interface DbDataReader$instance extends MarshalByRefObject {
    readonly Depth: int;
    readonly FieldCount: int;
    readonly HasRows: boolean;
    readonly IsClosed: boolean;
    readonly RecordsAffected: int;
    readonly VisibleFieldCount: int;
    Close(): void;
    CloseAsync(): Task;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    get_Item(ordinal: int): unknown;
    get_Item(name: string): unknown;
    GetBoolean(ordinal: int): boolean;
    GetByte(ordinal: int): byte;
    GetBytes(ordinal: int, dataOffset: long, buffer: byte[], bufferOffset: int, length: int): long;
    GetChar(ordinal: int): char;
    GetChars(ordinal: int, dataOffset: long, buffer: char[], bufferOffset: int, length: int): long;
    GetColumnSchemaAsync(cancellationToken?: CancellationToken): Task_1<ReadOnlyCollection_1<DbColumn>>;
    GetData(ordinal: int): DbDataReader;
    GetDataTypeName(ordinal: int): string;
    GetDateTime(ordinal: int): DateTime;
    GetDecimal(ordinal: int): decimal;
    GetDouble(ordinal: int): double;
    GetEnumerator(): IEnumerator;
    GetFieldType(ordinal: int): Type;
    GetFieldValue<T>(ordinal: int): T;
    GetFieldValueAsync<T>(ordinal: int): Task_1<T>;
    GetFieldValueAsync<T>(ordinal: int, cancellationToken: CancellationToken): Task_1<T>;
    GetFloat(ordinal: int): float;
    GetGuid(ordinal: int): Guid;
    GetInt16(ordinal: int): short;
    GetInt32(ordinal: int): int;
    GetInt64(ordinal: int): long;
    GetName(ordinal: int): string;
    GetOrdinal(name: string): int;
    GetProviderSpecificFieldType(ordinal: int): Type;
    GetProviderSpecificValue(ordinal: int): unknown;
    GetProviderSpecificValues(values: unknown[]): int;
    GetSchemaTable(): DataTable | undefined;
    GetSchemaTableAsync(cancellationToken?: CancellationToken): Task_1<DataTable | undefined>;
    GetStream(ordinal: int): Stream;
    GetString(ordinal: int): string;
    GetTextReader(ordinal: int): TextReader;
    GetValue(ordinal: int): unknown;
    GetValues(values: unknown[]): int;
    IsDBNull(ordinal: int): boolean;
    IsDBNullAsync(ordinal: int): Task_1<System_Internal.Boolean>;
    IsDBNullAsync(ordinal: int, cancellationToken: CancellationToken): Task_1<System_Internal.Boolean>;
    NextResult(): boolean;
    NextResultAsync(): Task_1<System_Internal.Boolean>;
    NextResultAsync(cancellationToken: CancellationToken): Task_1<System_Internal.Boolean>;
    Read(): boolean;
    ReadAsync(): Task_1<System_Internal.Boolean>;
    ReadAsync(cancellationToken: CancellationToken): Task_1<System_Internal.Boolean>;
}


export const DbDataReader: {
};


export interface __DbDataReader$views {
    As_IDataReader(): System_Data_Internal.IDataReader$instance;
    As_IDataRecord(): System_Data_Internal.IDataRecord$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DbDataReader$instance extends System_Collections_Internal.IEnumerable$instance, System_Internal.IAsyncDisposable$instance {}

export type DbDataReader = DbDataReader$instance & __DbDataReader$views;


export interface DbDataRecord$instance {
    readonly FieldCount: int;
    get_Item(i: int): unknown;
    get_Item(name: string): unknown;
    GetBoolean(i: int): boolean;
    GetByte(i: int): byte;
    GetBytes(i: int, dataIndex: long, buffer: byte[], bufferIndex: int, length: int): long;
    GetChar(i: int): char;
    GetChars(i: int, dataIndex: long, buffer: char[], bufferIndex: int, length: int): long;
    GetData(i: int): IDataReader;
    GetDataTypeName(i: int): string;
    GetDateTime(i: int): DateTime;
    GetDecimal(i: int): decimal;
    GetDouble(i: int): double;
    GetFieldType(i: int): Type;
    GetFloat(i: int): float;
    GetGuid(i: int): Guid;
    GetInt16(i: int): short;
    GetInt32(i: int): int;
    GetInt64(i: int): long;
    GetName(i: int): string;
    GetOrdinal(name: string): int;
    GetString(i: int): string;
    GetValue(i: int): unknown;
    GetValues(values: unknown[]): int;
    IsDBNull(i: int): boolean;
}


export const DbDataRecord: {
};


export interface __DbDataRecord$views {
    As_ICustomTypeDescriptor(): System_ComponentModel_Internal.ICustomTypeDescriptor$instance;
    As_IDataRecord(): System_Data_Internal.IDataRecord$instance;
}

export interface DbDataRecord$instance extends System_ComponentModel_Internal.ICustomTypeDescriptor$instance, System_Data_Internal.IDataRecord$instance {}

export type DbDataRecord = DbDataRecord$instance & __DbDataRecord$views;


export interface DbDataSource$instance {
    readonly ConnectionString: string;
    CreateBatch(): DbBatch;
    CreateCommand(commandText?: string): DbCommand;
    CreateConnection(): DbConnection;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    OpenConnection(): DbConnection;
    OpenConnectionAsync(cancellationToken?: CancellationToken): ValueTask_1<DbConnection>;
}


export const DbDataSource: {
};


export interface __DbDataSource$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DbDataSource$instance extends System_Internal.IAsyncDisposable$instance, System_Internal.IDisposable$instance {}

export type DbDataSource = DbDataSource$instance & __DbDataSource$views;


export interface DbDataSourceEnumerator$instance {
    GetDataSources(): DataTable;
}


export const DbDataSourceEnumerator: {
};


export type DbDataSourceEnumerator = DbDataSourceEnumerator$instance;

export interface DbEnumerator$instance {
    readonly Current: unknown;
    MoveNext(): boolean;
    Reset(): void;
}


export const DbEnumerator: {
    new(reader: IDataReader): DbEnumerator;
    new(reader: IDataReader, closeReader: boolean): DbEnumerator;
    new(reader: DbDataReader): DbEnumerator;
    new(reader: DbDataReader, closeReader: boolean): DbEnumerator;
};


export interface __DbEnumerator$views {
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export interface DbEnumerator$instance extends System_Collections_Internal.IEnumerator$instance {}

export type DbEnumerator = DbEnumerator$instance & __DbEnumerator$views;


export interface DbException$instance extends ExternalException {
    readonly BatchCommand: DbBatchCommand | undefined;
    readonly IsTransient: boolean;
    readonly SqlState: string | undefined;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const DbException: {
};


export interface __DbException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DbException = DbException$instance & __DbException$views;


export interface DbParameter$instance extends MarshalByRefObject {
    DbType: DbType;
    Direction: ParameterDirection;
    IsNullable: boolean;
    ParameterName: string;
    Precision: byte;
    Scale: byte;
    Size: int;
    SourceColumn: string;
    SourceColumnNullMapping: boolean;
    SourceVersion: DataRowVersion;
    Value: unknown;
    ResetDbType(): void;
}


export const DbParameter: {
};


export interface __DbParameter$views {
    As_IDataParameter(): System_Data_Internal.IDataParameter$instance;
    As_IDbDataParameter(): System_Data_Internal.IDbDataParameter$instance;
}

export type DbParameter = DbParameter$instance & __DbParameter$views;


export interface DbParameterCollection$instance extends MarshalByRefObject {
    readonly Count: int;
    readonly IsFixedSize: boolean;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    readonly SyncRoot: unknown;
    Add(value: unknown): int;
    AddRange(values: ClrArray): void;
    Clear(): void;
    Contains(value: unknown): boolean;
    Contains(value: string): boolean;
    CopyTo(array: ClrArray, index: int): void;
    get_Item(index: int): DbParameter;
    get_Item(parameterName: string): DbParameter;
    GetEnumerator(): IEnumerator;
    IndexOf(value: unknown): int;
    IndexOf(parameterName: string): int;
    Insert(index: int, value: unknown): void;
    Remove(value: unknown): void;
    RemoveAt(index: int): void;
    RemoveAt(parameterName: string): void;
    set_Item(index: int, value: DbParameter): void;
    set_Item(parameterName: string, value: DbParameter): void;
}


export const DbParameterCollection: {
};


export interface __DbParameterCollection$views {
    As_IDataParameterCollection(): System_Data_Internal.IDataParameterCollection$instance;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type DbParameterCollection = DbParameterCollection$instance & __DbParameterCollection$views;


export interface DbProviderFactory$instance {
    readonly CanCreateBatch: boolean;
    readonly CanCreateCommandBuilder: boolean;
    readonly CanCreateDataAdapter: boolean;
    readonly CanCreateDataSourceEnumerator: boolean;
    CreateBatch(): DbBatch;
    CreateBatchCommand(): DbBatchCommand;
    CreateCommand(): DbCommand;
    CreateCommandBuilder(): DbCommandBuilder | undefined;
    CreateConnection(): DbConnection;
    CreateConnectionStringBuilder(): DbConnectionStringBuilder | undefined;
    CreateDataAdapter(): DbDataAdapter | undefined;
    CreateDataSource(connectionString: string): DbDataSource;
    CreateDataSourceEnumerator(): DbDataSourceEnumerator | undefined;
    CreateParameter(): DbParameter;
}


export const DbProviderFactory: {
};


export type DbProviderFactory = DbProviderFactory$instance;

export interface DbProviderSpecificTypePropertyAttribute$instance extends Attribute {
    readonly IsProviderSpecificTypeProperty: boolean;
}


export const DbProviderSpecificTypePropertyAttribute: {
    new(isProviderSpecificTypeProperty: boolean): DbProviderSpecificTypePropertyAttribute;
};


export type DbProviderSpecificTypePropertyAttribute = DbProviderSpecificTypePropertyAttribute$instance;

export interface DbTransaction$instance extends MarshalByRefObject {
    readonly Connection: DbConnection;
    readonly IsolationLevel: IsolationLevel;
    readonly SupportsSavepoints: boolean;
    Commit(): void;
    CommitAsync(cancellationToken?: CancellationToken): Task;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    Release(savepointName: string): void;
    ReleaseAsync(savepointName: string, cancellationToken?: CancellationToken): Task;
    Rollback(): void;
    Rollback(savepointName: string): void;
    RollbackAsync(cancellationToken?: CancellationToken): Task;
    RollbackAsync(savepointName: string, cancellationToken?: CancellationToken): Task;
    Save(savepointName: string): void;
    SaveAsync(savepointName: string, cancellationToken?: CancellationToken): Task;
}


export const DbTransaction: {
};


export interface __DbTransaction$views {
    As_IDbTransaction(): System_Data_Internal.IDbTransaction$instance;
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DbTransaction$instance extends System_Internal.IAsyncDisposable$instance {}

export type DbTransaction = DbTransaction$instance & __DbTransaction$views;


export interface RowUpdatedEventArgs$instance extends EventArgs {
    readonly Command: IDbCommand | undefined;
    Errors: Exception;
    readonly RecordsAffected: int;
    readonly Row: DataRow;
    readonly RowCount: int;
    readonly StatementType: StatementType;
    Status: UpdateStatus;
    readonly TableMapping: DataTableMapping;
    CopyToRows(array: DataRow[]): void;
    CopyToRows(array: DataRow[], arrayIndex: int): void;
}


export const RowUpdatedEventArgs: {
    new(dataRow: DataRow, command: IDbCommand, statementType: StatementType, tableMapping: DataTableMapping): RowUpdatedEventArgs;
};


export type RowUpdatedEventArgs = RowUpdatedEventArgs$instance;

export interface RowUpdatingEventArgs$instance extends EventArgs {
    get Command(): IDbCommand | undefined;
    set Command(value: IDbCommand);
    Errors: Exception;
    readonly Row: DataRow;
    readonly StatementType: StatementType;
    Status: UpdateStatus;
    readonly TableMapping: DataTableMapping;
}


export const RowUpdatingEventArgs: {
    new(dataRow: DataRow, command: IDbCommand, statementType: StatementType, tableMapping: DataTableMapping): RowUpdatingEventArgs;
};


export type RowUpdatingEventArgs = RowUpdatingEventArgs$instance;

export abstract class DbDataReaderExtensions$instance {
    static CanGetColumnSchema(reader: DbDataReader): boolean;
    static GetColumnSchema(reader: DbDataReader): ReadOnlyCollection_1<DbColumn>;
}


export type DbDataReaderExtensions = DbDataReaderExtensions$instance;

export abstract class DbMetaDataCollectionNames$instance {
    static readonly MetaDataCollections: string;
    static readonly DataSourceInformation: string;
    static readonly DataTypes: string;
    static readonly Restrictions: string;
    static readonly ReservedWords: string;
}


export type DbMetaDataCollectionNames = DbMetaDataCollectionNames$instance;

export abstract class DbMetaDataColumnNames$instance {
    static readonly CollectionName: string;
    static readonly ColumnSize: string;
    static readonly CompositeIdentifierSeparatorPattern: string;
    static readonly CreateFormat: string;
    static readonly CreateParameters: string;
    static readonly DataSourceProductName: string;
    static readonly DataSourceProductVersion: string;
    static readonly DataType: string;
    static readonly DataSourceProductVersionNormalized: string;
    static readonly GroupByBehavior: string;
    static readonly IdentifierCase: string;
    static readonly IdentifierPattern: string;
    static readonly IsAutoIncrementable: string;
    static readonly IsBestMatch: string;
    static readonly IsCaseSensitive: string;
    static readonly IsConcurrencyType: string;
    static readonly IsFixedLength: string;
    static readonly IsFixedPrecisionScale: string;
    static readonly IsLiteralSupported: string;
    static readonly IsLong: string;
    static readonly IsNullable: string;
    static readonly IsSearchable: string;
    static readonly IsSearchableWithLike: string;
    static readonly IsUnsigned: string;
    static readonly LiteralPrefix: string;
    static readonly LiteralSuffix: string;
    static readonly MaximumScale: string;
    static readonly MinimumScale: string;
    static readonly NumberOfIdentifierParts: string;
    static readonly NumberOfRestrictions: string;
    static readonly OrderByColumnsInSelect: string;
    static readonly ParameterMarkerFormat: string;
    static readonly ParameterMarkerPattern: string;
    static readonly ParameterNameMaxLength: string;
    static readonly ParameterNamePattern: string;
    static readonly ProviderDbType: string;
    static readonly QuotedIdentifierCase: string;
    static readonly QuotedIdentifierPattern: string;
    static readonly ReservedWord: string;
    static readonly StatementSeparatorPattern: string;
    static readonly StringLiteralPattern: string;
    static readonly SupportedJoinOperators: string;
    static readonly TypeName: string;
}


export type DbMetaDataColumnNames = DbMetaDataColumnNames$instance;

export abstract class DbProviderFactories$instance {
    static GetFactory(connection: DbConnection): DbProviderFactory | undefined;
    static GetFactory(providerRow: DataRow): DbProviderFactory;
    static GetFactory(providerInvariantName: string): DbProviderFactory;
    static GetFactoryClasses(): DataTable;
    static GetProviderInvariantNames(): IEnumerable_1<System_Internal.String>;
    static RegisterFactory(providerInvariantName: string, factory: DbProviderFactory): void;
    static RegisterFactory(providerInvariantName: string, factoryTypeAssemblyQualifiedName: string): void;
    static RegisterFactory(providerInvariantName: string, providerFactoryClass: Type): void;
    static TryGetFactory(providerInvariantName: string, factory: DbProviderFactory): boolean;
    static UnregisterFactory(providerInvariantName: string): boolean;
}


export type DbProviderFactories = DbProviderFactories$instance;

export abstract class SchemaTableColumn$instance {
    static readonly ColumnName: string;
    static readonly ColumnOrdinal: string;
    static readonly ColumnSize: string;
    static readonly NumericPrecision: string;
    static readonly NumericScale: string;
    static readonly DataType: string;
    static readonly ProviderType: string;
    static readonly NonVersionedProviderType: string;
    static readonly IsLong: string;
    static readonly AllowDBNull: string;
    static readonly IsAliased: string;
    static readonly IsExpression: string;
    static readonly IsKey: string;
    static readonly IsUnique: string;
    static readonly BaseSchemaName: string;
    static readonly BaseTableName: string;
    static readonly BaseColumnName: string;
}


export type SchemaTableColumn = SchemaTableColumn$instance;

export abstract class SchemaTableOptionalColumn$instance {
    static readonly ProviderSpecificDataType: string;
    static readonly IsAutoIncrement: string;
    static readonly IsHidden: string;
    static readonly IsReadOnly: string;
    static readonly IsRowVersion: string;
    static readonly BaseServerName: string;
    static readonly BaseCatalogName: string;
    static readonly AutoIncrementSeed: string;
    static readonly AutoIncrementStep: string;
    static readonly DefaultValue: string;
    static readonly Expression: string;
    static readonly BaseTableNamespace: string;
    static readonly BaseColumnNamespace: string;
    static readonly ColumnMapping: string;
}


export type SchemaTableOptionalColumn = SchemaTableOptionalColumn$instance;


// Generated by tsbindgen - Architecture
// Namespace: System.Security.Cryptography.X509Certificates
// Assembly: System.Security.Cryptography

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { SafeX509ChainHandle } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { IEnumerable_1, IEnumerator_1 } from "../../System.Collections.Generic/internal/index.js";
import type { Collection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { CollectionBase, ICollection, IDictionary, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import type { UniversalTagNumber } from "../../System.Formats.Asn1/internal/index.js";
import type { IPAddress } from "../../System.Net/internal/index.js";
import type { BigInteger } from "../../System.Numerics/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Security_Cryptography_Internal from "../../System.Security.Cryptography/internal/index.js";
import type { AsnEncodedData, AsymmetricAlgorithm, CompositeMLDsa, CryptographicException, DSA, ECDiffieHellman, ECDsa, HashAlgorithmName, MLDsa, MLKem, Oid, OidCollection, PbeParameters, RSA, RSASignaturePadding, SlhDsa } from "../../System.Security.Cryptography/internal/index.js";
import type { SecureString } from "../../System.Security/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Boolean as ClrBoolean, Byte, Char, DateTime, DateTimeOffset, Enum, Exception, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, Nullable_1, Object as ClrObject, ReadOnlyMemory_1, ReadOnlySpan_1, Span_1, String as ClrString, TimeSpan, Type, TypeCode, Uri, ValueType, Void } from "../../System/internal/index.js";

export enum CertificateRequestLoadOptions {
    Default = 0,
    SkipSignatureValidation = 1,
    UnsafeLoadCertificateExtensions = 2
}


export enum OpenFlags {
    ReadOnly = 0,
    ReadWrite = 1,
    MaxAllowed = 2,
    OpenExistingOnly = 4,
    IncludeArchived = 8
}


export enum Pkcs12ExportPbeParameters {
    Default = 0,
    Pkcs12TripleDesSha1 = 1,
    Pbes2Aes256Sha256 = 2
}


export enum StoreLocation {
    CurrentUser = 1,
    LocalMachine = 2
}


export enum StoreName {
    AddressBook = 1,
    AuthRoot = 2,
    CertificateAuthority = 3,
    Disallowed = 4,
    My = 5,
    Root = 6,
    TrustedPeople = 7,
    TrustedPublisher = 8
}


export enum X500DistinguishedNameFlags {
    None = 0,
    Reversed = 1,
    UseSemicolons = 16,
    DoNotUsePlusSign = 32,
    DoNotUseQuotes = 64,
    UseCommas = 128,
    UseNewLines = 256,
    UseUTF8Encoding = 4096,
    UseT61Encoding = 8192,
    ForceUTF8Encoding = 16384
}


export enum X509ChainStatusFlags {
    NoError = 0,
    NotTimeValid = 1,
    NotTimeNested = 2,
    Revoked = 4,
    NotSignatureValid = 8,
    NotValidForUsage = 16,
    UntrustedRoot = 32,
    RevocationStatusUnknown = 64,
    Cyclic = 128,
    InvalidExtension = 256,
    InvalidPolicyConstraints = 512,
    InvalidBasicConstraints = 1024,
    InvalidNameConstraints = 2048,
    HasNotSupportedNameConstraint = 4096,
    HasNotDefinedNameConstraint = 8192,
    HasNotPermittedNameConstraint = 16384,
    HasExcludedNameConstraint = 32768,
    PartialChain = 65536,
    CtlNotTimeValid = 131072,
    CtlNotSignatureValid = 262144,
    CtlNotValidForUsage = 524288,
    OfflineRevocation = 16777216,
    NoIssuanceChainPolicy = 33554432,
    ExplicitDistrust = 67108864,
    HasNotSupportedCriticalExtension = 134217728,
    HasWeakSignature = 1048576
}


export enum X509ChainTrustMode {
    System = 0,
    CustomRootTrust = 1
}


export enum X509ContentType {
    Unknown = 0,
    Cert = 1,
    SerializedCert = 2,
    Pfx = 3,
    Pkcs12 = 3,
    SerializedStore = 4,
    Pkcs7 = 5,
    Authenticode = 6
}


export enum X509FindType {
    FindByThumbprint = 0,
    FindBySubjectName = 1,
    FindBySubjectDistinguishedName = 2,
    FindByIssuerName = 3,
    FindByIssuerDistinguishedName = 4,
    FindBySerialNumber = 5,
    FindByTimeValid = 6,
    FindByTimeNotYetValid = 7,
    FindByTimeExpired = 8,
    FindByTemplateName = 9,
    FindByApplicationPolicy = 10,
    FindByCertificatePolicy = 11,
    FindByExtension = 12,
    FindByKeyUsage = 13,
    FindBySubjectKeyIdentifier = 14
}


export enum X509IncludeOption {
    None = 0,
    ExcludeRoot = 1,
    EndCertOnly = 2,
    WholeChain = 3
}


export enum X509KeyStorageFlags {
    DefaultKeySet = 0,
    UserKeySet = 1,
    MachineKeySet = 2,
    Exportable = 4,
    UserProtected = 8,
    PersistKeySet = 16,
    EphemeralKeySet = 32
}


export enum X509KeyUsageFlags {
    None = 0,
    EncipherOnly = 1,
    CrlSign = 2,
    KeyCertSign = 4,
    KeyAgreement = 8,
    DataEncipherment = 16,
    KeyEncipherment = 32,
    NonRepudiation = 64,
    DigitalSignature = 128,
    DecipherOnly = 32768
}


export enum X509NameType {
    SimpleName = 0,
    EmailName = 1,
    UpnName = 2,
    DnsName = 3,
    DnsFromAlternativeName = 4,
    UrlName = 5
}


export enum X509RevocationFlag {
    EndCertificateOnly = 0,
    EntireChain = 1,
    ExcludeRoot = 2
}


export enum X509RevocationMode {
    NoCheck = 0,
    Online = 1,
    Offline = 2
}


export enum X509RevocationReason {
    Unspecified = 0,
    KeyCompromise = 1,
    CACompromise = 2,
    AffiliationChanged = 3,
    Superseded = 4,
    CessationOfOperation = 5,
    CertificateHold = 6,
    RemoveFromCrl = 8,
    PrivilegeWithdrawn = 9,
    AACompromise = 10,
    WeakAlgorithmOrKey = 11
}


export enum X509SubjectKeyIdentifierHashAlgorithm {
    Sha1 = 0,
    ShortSha1 = 1,
    CapiSha1 = 2,
    Sha256 = 3,
    Sha384 = 4,
    Sha512 = 5,
    ShortSha256 = 6,
    ShortSha384 = 7,
    ShortSha512 = 8
}


export enum X509VerificationFlags {
    NoFlag = 0,
    IgnoreNotTimeValid = 1,
    IgnoreCtlNotTimeValid = 2,
    IgnoreNotTimeNested = 4,
    IgnoreInvalidBasicConstraints = 8,
    AllowUnknownCertificateAuthority = 16,
    IgnoreWrongUsage = 32,
    IgnoreInvalidName = 64,
    IgnoreInvalidPolicy = 128,
    IgnoreEndRevocationUnknown = 256,
    IgnoreCtlSignerRevocationUnknown = 512,
    IgnoreCertificateAuthorityRevocationUnknown = 1024,
    IgnoreRootRevocationUnknown = 2048,
    AllFlags = 4095
}


export interface X509ChainStatus$instance {
    Status: X509ChainStatusFlags;
    StatusInformation: string;
}


export const X509ChainStatus: {
    new(): X509ChainStatus;
};


export type X509ChainStatus = X509ChainStatus$instance;

export interface CertificateRequest$instance {
    readonly CertificateExtensions: Collection_1<X509Extension>;
    readonly HashAlgorithm: HashAlgorithmName;
    readonly OtherRequestAttributes: Collection_1<AsnEncodedData>;
    readonly PublicKey: PublicKey;
    readonly SubjectName: X500DistinguishedName;
    Create(issuerCertificate: X509Certificate2, notBefore: DateTimeOffset, notAfter: DateTimeOffset, serialNumber: byte[]): X509Certificate2;
    Create(issuerCertificate: X509Certificate2, notBefore: DateTimeOffset, notAfter: DateTimeOffset, serialNumber: ReadOnlySpan_1<System_Internal.Byte>): X509Certificate2;
    Create(issuerName: X500DistinguishedName, generator: X509SignatureGenerator, notBefore: DateTimeOffset, notAfter: DateTimeOffset, serialNumber: byte[]): X509Certificate2;
    Create(issuerName: X500DistinguishedName, generator: X509SignatureGenerator, notBefore: DateTimeOffset, notAfter: DateTimeOffset, serialNumber: ReadOnlySpan_1<System_Internal.Byte>): X509Certificate2;
    CreateSelfSigned(notBefore: DateTimeOffset, notAfter: DateTimeOffset): X509Certificate2;
    CreateSigningRequest(): byte[];
    CreateSigningRequest(signatureGenerator: X509SignatureGenerator): byte[];
    CreateSigningRequestPem(): string;
    CreateSigningRequestPem(signatureGenerator: X509SignatureGenerator): string;
}


export const CertificateRequest: {
    new(subjectName: string, key: ECDsa, hashAlgorithm: HashAlgorithmName): CertificateRequest;
    new(subjectName: X500DistinguishedName, key: ECDsa, hashAlgorithm: HashAlgorithmName): CertificateRequest;
    new(subjectName: string, key: RSA, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): CertificateRequest;
    new(subjectName: X500DistinguishedName, key: RSA, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): CertificateRequest;
    new(subjectName: string, key: MLDsa): CertificateRequest;
    new(subjectName: X500DistinguishedName, key: MLDsa): CertificateRequest;
    new(subjectName: string, key: SlhDsa): CertificateRequest;
    new(subjectName: X500DistinguishedName, key: SlhDsa): CertificateRequest;
    new(subjectName: string, key: CompositeMLDsa): CertificateRequest;
    new(subjectName: X500DistinguishedName, key: CompositeMLDsa): CertificateRequest;
    new(subjectName: X500DistinguishedName, publicKey: PublicKey, hashAlgorithm: HashAlgorithmName): CertificateRequest;
    new(subjectName: X500DistinguishedName, publicKey: PublicKey, hashAlgorithm: HashAlgorithmName, rsaSignaturePadding: RSASignaturePadding): CertificateRequest;
    LoadSigningRequest(pkcs10: byte[], signerHashAlgorithm: HashAlgorithmName, options?: CertificateRequestLoadOptions, signerSignaturePadding?: RSASignaturePadding): CertificateRequest;
    LoadSigningRequest(pkcs10: ReadOnlySpan_1<System_Internal.Byte>, signerHashAlgorithm: HashAlgorithmName, bytesConsumed: int, options?: CertificateRequestLoadOptions, signerSignaturePadding?: RSASignaturePadding): CertificateRequest;
    LoadSigningRequestPem(pkcs10Pem: ReadOnlySpan_1<System_Internal.Char>, signerHashAlgorithm: HashAlgorithmName, options?: CertificateRequestLoadOptions, signerSignaturePadding?: RSASignaturePadding): CertificateRequest;
    LoadSigningRequestPem(pkcs10Pem: string, signerHashAlgorithm: HashAlgorithmName, options?: CertificateRequestLoadOptions, signerSignaturePadding?: RSASignaturePadding): CertificateRequest;
};


export type CertificateRequest = CertificateRequest$instance;

export interface CertificateRevocationListBuilder$instance {
    AddEntry(certificate: X509Certificate2, revocationTime?: Nullable_1<DateTimeOffset>, reason?: Nullable_1<X509RevocationReason>): void;
    AddEntry(serialNumber: byte[], revocationTime?: Nullable_1<DateTimeOffset>, reason?: Nullable_1<X509RevocationReason>): void;
    AddEntry(serialNumber: ReadOnlySpan_1<System_Internal.Byte>, revocationTime?: Nullable_1<DateTimeOffset>, reason?: Nullable_1<X509RevocationReason>): void;
    Build(issuerCertificate: X509Certificate2, crlNumber: BigInteger, nextUpdate: DateTimeOffset, hashAlgorithm: HashAlgorithmName, rsaSignaturePadding?: RSASignaturePadding, thisUpdate?: Nullable_1<DateTimeOffset>): byte[];
    Build(issuerName: X500DistinguishedName, generator: X509SignatureGenerator, crlNumber: BigInteger, nextUpdate: DateTimeOffset, hashAlgorithm: HashAlgorithmName, authorityKeyIdentifier: X509AuthorityKeyIdentifierExtension, thisUpdate?: Nullable_1<DateTimeOffset>): byte[];
    RemoveEntry(serialNumber: byte[]): boolean;
    RemoveEntry(serialNumber: ReadOnlySpan_1<System_Internal.Byte>): boolean;
}


export const CertificateRevocationListBuilder: {
    new(): CertificateRevocationListBuilder;
    BuildCrlDistributionPointExtension(uris: IEnumerable_1<System_Internal.String>, critical?: boolean): X509Extension;
    Load(currentCrl: byte[], currentCrlNumber: BigInteger): CertificateRevocationListBuilder;
    Load(currentCrl: ReadOnlySpan_1<System_Internal.Byte>, currentCrlNumber: BigInteger, bytesConsumed: int): CertificateRevocationListBuilder;
    LoadPem(currentCrl: ReadOnlySpan_1<System_Internal.Char>, currentCrlNumber: BigInteger): CertificateRevocationListBuilder;
    LoadPem(currentCrl: string, currentCrlNumber: BigInteger): CertificateRevocationListBuilder;
};


export type CertificateRevocationListBuilder = CertificateRevocationListBuilder$instance;

export interface Pkcs12LoaderLimits$instance {
    AllowDuplicateAttributes: boolean;
    IgnoreEncryptedAuthSafes: boolean;
    IgnorePrivateKeys: boolean;
    IndividualKdfIterationLimit: Nullable_1<System_Internal.Int32>;
    readonly IsReadOnly: boolean;
    MacIterationLimit: Nullable_1<System_Internal.Int32>;
    MaxCertificates: Nullable_1<System_Internal.Int32>;
    MaxKeys: Nullable_1<System_Internal.Int32>;
    PreserveCertificateAlias: boolean;
    PreserveKeyName: boolean;
    PreserveStorageProvider: boolean;
    PreserveUnknownAttributes: boolean;
    TotalKdfIterationLimit: Nullable_1<System_Internal.Int32>;
    MakeReadOnly(): void;
}


export const Pkcs12LoaderLimits: {
    new(): Pkcs12LoaderLimits;
    new(copyFrom: Pkcs12LoaderLimits): Pkcs12LoaderLimits;
    readonly Defaults: Pkcs12LoaderLimits;
    readonly DangerousNoLimits: Pkcs12LoaderLimits;
};


export type Pkcs12LoaderLimits = Pkcs12LoaderLimits$instance;

export interface Pkcs12LoadLimitExceededException$instance extends CryptographicException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const Pkcs12LoadLimitExceededException: {
    new(propertyName: string): Pkcs12LoadLimitExceededException;
};


export interface __Pkcs12LoadLimitExceededException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Pkcs12LoadLimitExceededException = Pkcs12LoadLimitExceededException$instance & __Pkcs12LoadLimitExceededException$views;


export interface PublicKey$instance {
    readonly EncodedKeyValue: AsnEncodedData;
    readonly EncodedParameters: AsnEncodedData | undefined;
    readonly Key: AsymmetricAlgorithm;
    readonly Oid: Oid;
    ExportSubjectPublicKeyInfo(): byte[];
    GetCompositeMLDsaPublicKey(): CompositeMLDsa | undefined;
    GetDSAPublicKey(): DSA | undefined;
    GetECDiffieHellmanPublicKey(): ECDiffieHellman | undefined;
    GetECDsaPublicKey(): ECDsa | undefined;
    GetMLDsaPublicKey(): MLDsa | undefined;
    GetMLKemPublicKey(): MLKem | undefined;
    GetRSAPublicKey(): RSA | undefined;
    GetSlhDsaPublicKey(): SlhDsa | undefined;
    TryExportSubjectPublicKeyInfo(destination: Span_1<System_Internal.Byte>, bytesWritten: int): boolean;
}


export const PublicKey: {
    new(oid: Oid, parameters: AsnEncodedData, keyValue: AsnEncodedData): PublicKey;
    new(key: AsymmetricAlgorithm): PublicKey;
    new(key: MLKem): PublicKey;
    new(key: MLDsa): PublicKey;
    new(key: SlhDsa): PublicKey;
    new(key: CompositeMLDsa): PublicKey;
    CreateFromSubjectPublicKeyInfo(source: ReadOnlySpan_1<System_Internal.Byte>, bytesRead: int): PublicKey;
};


export type PublicKey = PublicKey$instance;

export interface SubjectAlternativeNameBuilder$instance {
    AddDnsName(dnsName: string): void;
    AddEmailAddress(emailAddress: string): void;
    AddIpAddress(ipAddress: IPAddress): void;
    AddUri(uri: Uri): void;
    AddUserPrincipalName(upn: string): void;
    Build(critical?: boolean): X509Extension;
}


export const SubjectAlternativeNameBuilder: {
    new(): SubjectAlternativeNameBuilder;
};


export type SubjectAlternativeNameBuilder = SubjectAlternativeNameBuilder$instance;

export interface X500DistinguishedName$instance extends AsnEncodedData {
    readonly Name: string;
    Decode(flag: X500DistinguishedNameFlags): string;
    EnumerateRelativeDistinguishedNames(reversed?: boolean): IEnumerable_1<X500RelativeDistinguishedName>;
    Format(multiLine: boolean): string;
}


export const X500DistinguishedName: {
    new(encodedDistinguishedName: byte[]): X500DistinguishedName;
    new(encodedDistinguishedName: ReadOnlySpan_1<System_Internal.Byte>): X500DistinguishedName;
    new(encodedDistinguishedName: AsnEncodedData): X500DistinguishedName;
    new(distinguishedName: X500DistinguishedName): X500DistinguishedName;
    new(distinguishedName: string): X500DistinguishedName;
    new(distinguishedName: string, flag: X500DistinguishedNameFlags): X500DistinguishedName;
};


export type X500DistinguishedName = X500DistinguishedName$instance;

export interface X500DistinguishedNameBuilder$instance {
    Add(oidValue: string, value: string, stringEncodingType?: Nullable_1<UniversalTagNumber>): void;
    Add(oid: Oid, value: string, stringEncodingType?: Nullable_1<UniversalTagNumber>): void;
    AddCommonName(commonName: string): void;
    AddCountryOrRegion(twoLetterCode: string): void;
    AddDomainComponent(domainComponent: string): void;
    AddEmailAddress(emailAddress: string): void;
    AddLocalityName(localityName: string): void;
    AddOrganizationalUnitName(organizationalUnitName: string): void;
    AddOrganizationName(organizationName: string): void;
    AddStateOrProvinceName(stateOrProvinceName: string): void;
    Build(): X500DistinguishedName;
}


export const X500DistinguishedNameBuilder: {
    new(): X500DistinguishedNameBuilder;
};


export type X500DistinguishedNameBuilder = X500DistinguishedNameBuilder$instance;

export interface X500RelativeDistinguishedName$instance {
    readonly HasMultipleElements: boolean;
    readonly RawData: ReadOnlyMemory_1<System_Internal.Byte>;
    GetSingleElementType(): Oid;
    GetSingleElementValue(): string | undefined;
}


export const X500RelativeDistinguishedName: {
    new(): X500RelativeDistinguishedName;
};


export type X500RelativeDistinguishedName = X500RelativeDistinguishedName$instance;

export interface X509AuthorityInformationAccessExtension$instance extends X509Extension {
    CopyFrom(asnEncodedData: AsnEncodedData): void;
    EnumerateCAIssuersUris(): IEnumerable_1<System_Internal.String>;
    EnumerateOcspUris(): IEnumerable_1<System_Internal.String>;
    EnumerateUris(accessMethodOid: string): IEnumerable_1<System_Internal.String>;
    EnumerateUris(accessMethodOid: Oid): IEnumerable_1<System_Internal.String>;
}


export const X509AuthorityInformationAccessExtension: {
    new(): X509AuthorityInformationAccessExtension;
    new(rawData: byte[], critical: boolean): X509AuthorityInformationAccessExtension;
    new(rawData: ReadOnlySpan_1<System_Internal.Byte>, critical: boolean): X509AuthorityInformationAccessExtension;
    new(ocspUris: IEnumerable_1<System_Internal.String>, caIssuersUris: IEnumerable_1<System_Internal.String>, critical: boolean): X509AuthorityInformationAccessExtension;
};


export type X509AuthorityInformationAccessExtension = X509AuthorityInformationAccessExtension$instance;

export interface X509AuthorityKeyIdentifierExtension$instance extends X509Extension {
    readonly KeyIdentifier: Nullable_1<ReadOnlyMemory_1<System_Internal.Byte>>;
    readonly NamedIssuer: X500DistinguishedName | undefined;
    readonly RawIssuer: Nullable_1<ReadOnlyMemory_1<System_Internal.Byte>>;
    readonly SerialNumber: Nullable_1<ReadOnlyMemory_1<System_Internal.Byte>>;
    CopyFrom(asnEncodedData: AsnEncodedData): void;
}


export const X509AuthorityKeyIdentifierExtension: {
    new(): X509AuthorityKeyIdentifierExtension;
    new(rawData: byte[], critical: boolean): X509AuthorityKeyIdentifierExtension;
    new(rawData: ReadOnlySpan_1<System_Internal.Byte>, critical: boolean): X509AuthorityKeyIdentifierExtension;
    Create(keyIdentifier: byte[], issuerName: X500DistinguishedName, serialNumber: byte[]): X509AuthorityKeyIdentifierExtension;
    Create(keyIdentifier: ReadOnlySpan_1<System_Internal.Byte>, issuerName: X500DistinguishedName, serialNumber: ReadOnlySpan_1<System_Internal.Byte>): X509AuthorityKeyIdentifierExtension;
    CreateFromCertificate(certificate: X509Certificate2, includeKeyIdentifier: boolean, includeIssuerAndSerial: boolean): X509AuthorityKeyIdentifierExtension;
    CreateFromIssuerNameAndSerialNumber(issuerName: X500DistinguishedName, serialNumber: byte[]): X509AuthorityKeyIdentifierExtension;
    CreateFromIssuerNameAndSerialNumber(issuerName: X500DistinguishedName, serialNumber: ReadOnlySpan_1<System_Internal.Byte>): X509AuthorityKeyIdentifierExtension;
    CreateFromSubjectKeyIdentifier(subjectKeyIdentifier: byte[]): X509AuthorityKeyIdentifierExtension;
    CreateFromSubjectKeyIdentifier(subjectKeyIdentifier: ReadOnlySpan_1<System_Internal.Byte>): X509AuthorityKeyIdentifierExtension;
    CreateFromSubjectKeyIdentifier(subjectKeyIdentifier: X509SubjectKeyIdentifierExtension): X509AuthorityKeyIdentifierExtension;
};


export type X509AuthorityKeyIdentifierExtension = X509AuthorityKeyIdentifierExtension$instance;

export interface X509BasicConstraintsExtension$instance extends X509Extension {
    readonly CertificateAuthority: boolean;
    readonly HasPathLengthConstraint: boolean;
    readonly PathLengthConstraint: int;
    CopyFrom(asnEncodedData: AsnEncodedData): void;
}


export const X509BasicConstraintsExtension: {
    new(): X509BasicConstraintsExtension;
    new(certificateAuthority: boolean, hasPathLengthConstraint: boolean, pathLengthConstraint: int, critical: boolean): X509BasicConstraintsExtension;
    new(encodedBasicConstraints: AsnEncodedData, critical: boolean): X509BasicConstraintsExtension;
    CreateForCertificateAuthority(pathLengthConstraint?: Nullable_1<System_Internal.Int32>): X509BasicConstraintsExtension;
    CreateForEndEntity(critical?: boolean): X509BasicConstraintsExtension;
};


export type X509BasicConstraintsExtension = X509BasicConstraintsExtension$instance;

export interface X509Certificate$instance {
    readonly Handle: nint;
    readonly Issuer: string;
    readonly SerialNumberBytes: ReadOnlyMemory_1<System_Internal.Byte>;
    readonly Subject: string;
    Dispose(): void;
    Equals(obj: unknown): boolean;
    Equals(other: X509Certificate): boolean;
    Export(contentType: X509ContentType): byte[];
    Export(contentType: X509ContentType, password: string): byte[];
    Export(contentType: X509ContentType, password: SecureString): byte[];
    ExportPkcs12(exportParameters: Pkcs12ExportPbeParameters, password: string): byte[];
    ExportPkcs12(exportParameters: PbeParameters, password: string): byte[];
    GetCertHash(): byte[];
    GetCertHash(hashAlgorithm: HashAlgorithmName): byte[];
    GetCertHashString(): string;
    GetCertHashString(hashAlgorithm: HashAlgorithmName): string;
    GetEffectiveDateString(): string;
    GetExpirationDateString(): string;
    GetFormat(): string;
    GetHashCode(): int;
    GetIssuerName(): string;
    GetKeyAlgorithm(): string;
    GetKeyAlgorithmParameters(): byte[] | undefined;
    GetKeyAlgorithmParametersString(): string | undefined;
    GetName(): string;
    GetPublicKey(): byte[];
    GetPublicKeyString(): string;
    GetRawCertData(): byte[];
    GetRawCertDataString(): string;
    GetSerialNumber(): byte[];
    GetSerialNumberString(): string;
    Import(rawData: byte[]): void;
    Import(rawData: byte[], password: string, keyStorageFlags: X509KeyStorageFlags): void;
    Import(rawData: byte[], password: SecureString, keyStorageFlags: X509KeyStorageFlags): void;
    Import(fileName: string): void;
    Import(fileName: string, password: string, keyStorageFlags: X509KeyStorageFlags): void;
    Import(fileName: string, password: SecureString, keyStorageFlags: X509KeyStorageFlags): void;
    Reset(): void;
    ToString(): string;
    ToString(fVerbose: boolean): string;
    TryGetCertHash(hashAlgorithm: HashAlgorithmName, destination: Span_1<System_Internal.Byte>, bytesWritten: int): boolean;
}


export const X509Certificate: {
    new(): X509Certificate;
    new(data: byte[]): X509Certificate;
    new(rawData: byte[], password: string): X509Certificate;
    new(rawData: byte[], password: SecureString): X509Certificate;
    new(rawData: byte[], password: string, keyStorageFlags: X509KeyStorageFlags): X509Certificate;
    new(rawData: byte[], password: SecureString, keyStorageFlags: X509KeyStorageFlags): X509Certificate;
    new(handle: nint): X509Certificate;
    new(fileName: string): X509Certificate;
    new(fileName: string, password: string): X509Certificate;
    new(fileName: string, password: SecureString): X509Certificate;
    new(fileName: string, password: string, keyStorageFlags: X509KeyStorageFlags): X509Certificate;
    new(fileName: string, password: SecureString, keyStorageFlags: X509KeyStorageFlags): X509Certificate;
    new(cert: X509Certificate): X509Certificate;
    new(info: SerializationInfo, context: StreamingContext): X509Certificate;
    CreateFromCertFile(filename: string): X509Certificate;
    CreateFromSignedFile(filename: string): X509Certificate;
};


export interface __X509Certificate$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface X509Certificate$instance extends System_Internal.IDisposable$instance, System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type X509Certificate = X509Certificate$instance & __X509Certificate$views;


export interface X509Certificate2$instance extends X509Certificate$instance {
    Archived: boolean;
    readonly Extensions: X509ExtensionCollection;
    FriendlyName: string;
    readonly HasPrivateKey: boolean;
    readonly IssuerName: X500DistinguishedName;
    readonly NotAfter: DateTime;
    readonly NotBefore: DateTime;
    get PrivateKey(): AsymmetricAlgorithm | undefined;
    set PrivateKey(value: AsymmetricAlgorithm);
    readonly PublicKey: PublicKey;
    readonly RawData: byte[];
    readonly RawDataMemory: ReadOnlyMemory_1<System_Internal.Byte>;
    readonly SerialNumber: string;
    readonly SignatureAlgorithm: Oid;
    readonly SubjectName: X500DistinguishedName;
    readonly Thumbprint: string;
    readonly Version: int;
    CopyWithPrivateKey(privateKey: ECDiffieHellman): X509Certificate2;
    CopyWithPrivateKey(privateKey: MLKem): X509Certificate2;
    CopyWithPrivateKey(privateKey: MLDsa): X509Certificate2;
    CopyWithPrivateKey(privateKey: SlhDsa): X509Certificate2;
    CopyWithPrivateKey(privateKey: CompositeMLDsa): X509Certificate2;
    Dispose(): void;
    ExportCertificatePem(): string;
    GetCompositeMLDsaPrivateKey(): CompositeMLDsa | undefined;
    GetCompositeMLDsaPublicKey(): CompositeMLDsa | undefined;
    GetECDiffieHellmanPrivateKey(): ECDiffieHellman | undefined;
    GetECDiffieHellmanPublicKey(): ECDiffieHellman | undefined;
    GetMLDsaPrivateKey(): MLDsa | undefined;
    GetMLDsaPublicKey(): MLDsa | undefined;
    GetMLKemPrivateKey(): MLKem | undefined;
    GetMLKemPublicKey(): MLKem | undefined;
    GetNameInfo(nameType: X509NameType, forIssuer: boolean): string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    GetSlhDsaPrivateKey(): SlhDsa | undefined;
    GetSlhDsaPublicKey(): SlhDsa | undefined;
    Import(rawData: byte[]): void;
    Import(rawData: byte[], password: string, keyStorageFlags: X509KeyStorageFlags): void;
    Import(rawData: byte[], password: SecureString, keyStorageFlags: X509KeyStorageFlags): void;
    Import(fileName: string): void;
    Import(fileName: string, password: string, keyStorageFlags: X509KeyStorageFlags): void;
    Import(fileName: string, password: SecureString, keyStorageFlags: X509KeyStorageFlags): void;
    MatchesHostname(hostname: string, allowWildcards?: boolean, allowCommonName?: boolean): boolean;
    OnDeserialization(sender: unknown): void;
    Reset(): void;
    ToString(): string;
    ToString(verbose: boolean): string;
    TryExportCertificatePem(destination: Span_1<System_Internal.Char>, charsWritten: int): boolean;
    Verify(): boolean;
}


export const X509Certificate2: {
    new(): X509Certificate2;
    new(rawData: byte[]): X509Certificate2;
    new(rawData: byte[], password: string): X509Certificate2;
    new(rawData: byte[], password: SecureString): X509Certificate2;
    new(rawData: byte[], password: string, keyStorageFlags: X509KeyStorageFlags): X509Certificate2;
    new(rawData: byte[], password: SecureString, keyStorageFlags: X509KeyStorageFlags): X509Certificate2;
    new(rawData: ReadOnlySpan_1<System_Internal.Byte>): X509Certificate2;
    new(rawData: ReadOnlySpan_1<System_Internal.Byte>, password: ReadOnlySpan_1<System_Internal.Char>, keyStorageFlags: X509KeyStorageFlags): X509Certificate2;
    new(handle: nint): X509Certificate2;
    new(fileName: string): X509Certificate2;
    new(fileName: string, password: string): X509Certificate2;
    new(fileName: string, password: SecureString): X509Certificate2;
    new(fileName: string, password: string, keyStorageFlags: X509KeyStorageFlags): X509Certificate2;
    new(fileName: string, password: SecureString, keyStorageFlags: X509KeyStorageFlags): X509Certificate2;
    new(fileName: string, password: ReadOnlySpan_1<System_Internal.Char>, keyStorageFlags: X509KeyStorageFlags): X509Certificate2;
    new(certificate: X509Certificate): X509Certificate2;
    CreateFromEncryptedPem(certPem: ReadOnlySpan_1<System_Internal.Char>, keyPem: ReadOnlySpan_1<System_Internal.Char>, password: ReadOnlySpan_1<System_Internal.Char>): X509Certificate2;
    CreateFromEncryptedPemFile(certPemFilePath: string, password: ReadOnlySpan_1<System_Internal.Char>, keyPemFilePath?: string): X509Certificate2;
    CreateFromPem(certPem: ReadOnlySpan_1<System_Internal.Char>, keyPem: ReadOnlySpan_1<System_Internal.Char>): X509Certificate2;
    CreateFromPem(certPem: ReadOnlySpan_1<System_Internal.Char>): X509Certificate2;
    CreateFromPemFile(certPemFilePath: string, keyPemFilePath?: string): X509Certificate2;
    GetCertContentType(rawData: byte[]): X509ContentType;
    GetCertContentType(rawData: ReadOnlySpan_1<System_Internal.Byte>): X509ContentType;
    GetCertContentType(fileName: string): X509ContentType;
};


export interface __X509Certificate2$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface X509Certificate2$instance extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type X509Certificate2 = X509Certificate2$instance & __X509Certificate2$views;


export interface X509Certificate2Collection$instance extends X509CertificateCollection$instance {
    Add(value: X509Certificate): int;
    Add(value: unknown): int;
    AddRange(certificates: X509Certificate2Collection): void;
    AddRange(value: X509Certificate[]): void;
    AddRange(value: X509CertificateCollection): void;
    Clear(): void;
    Contains(value: X509Certificate): boolean;
    Contains(value: unknown): boolean;
    CopyTo(array: X509Certificate[], index: int): void;
    CopyTo(array: ClrArray, index: int): void;
    Export(contentType: X509ContentType): byte[];
    Export(contentType: X509ContentType, password: string): byte[];
    ExportCertificatePems(): string;
    ExportPkcs12(exportParameters: Pkcs12ExportPbeParameters, password: string): byte[];
    ExportPkcs12(exportParameters: PbeParameters, password: string): byte[];
    ExportPkcs7Pem(): string;
    Find(findType: X509FindType, findValue: unknown, validOnly: boolean): X509Certificate2Collection;
    FindByThumbprint(hashAlgorithm: HashAlgorithmName, thumbprintHex: string): X509Certificate2Collection;
    FindByThumbprint(hashAlgorithm: HashAlgorithmName, thumbprintHex: ReadOnlySpan_1<System_Internal.Char>): X509Certificate2Collection;
    FindByThumbprint(hashAlgorithm: HashAlgorithmName, thumbprintBytes: ReadOnlySpan_1<System_Internal.Byte>): X509Certificate2Collection;
    GetEnumerator(): X509CertificateCollection_X509CertificateEnumerator;
    GetEnumerator(): IEnumerator;
    Import(rawData: byte[]): void;
    Import(rawData: ReadOnlySpan_1<System_Internal.Byte>): void;
    Import(rawData: byte[], password: string, keyStorageFlags?: X509KeyStorageFlags): void;
    Import(rawData: ReadOnlySpan_1<System_Internal.Byte>, password: string, keyStorageFlags?: X509KeyStorageFlags): void;
    Import(rawData: ReadOnlySpan_1<System_Internal.Byte>, password: ReadOnlySpan_1<System_Internal.Char>, keyStorageFlags?: X509KeyStorageFlags): void;
    Import(fileName: string): void;
    Import(fileName: string, password: string, keyStorageFlags?: X509KeyStorageFlags): void;
    Import(fileName: string, password: ReadOnlySpan_1<System_Internal.Char>, keyStorageFlags?: X509KeyStorageFlags): void;
    ImportFromPem(certPem: ReadOnlySpan_1<System_Internal.Char>): void;
    ImportFromPemFile(certPemFilePath: string): void;
    IndexOf(value: X509Certificate): int;
    Insert(index: int, value: X509Certificate): void;
    Insert(index: int, value: unknown): void;
    Remove(value: X509Certificate): void;
    Remove(value: unknown): void;
    RemoveAt(index: int): void;
    RemoveRange(certificates: X509Certificate2[]): void;
    RemoveRange(certificates: X509Certificate2Collection): void;
    TryExportCertificatePems(destination: Span_1<System_Internal.Char>, charsWritten: int): boolean;
    TryExportPkcs7Pem(destination: Span_1<System_Internal.Char>, charsWritten: int): boolean;
}


export const X509Certificate2Collection: {
    new(): X509Certificate2Collection;
    new(certificate: X509Certificate2): X509Certificate2Collection;
    new(certificates: X509Certificate2[]): X509Certificate2Collection;
    new(certificates: X509Certificate2Collection): X509Certificate2Collection;
};


export interface __X509Certificate2Collection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<X509Certificate2>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type X509Certificate2Collection = X509Certificate2Collection$instance & __X509Certificate2Collection$views;


export interface X509Certificate2Enumerator$instance {
    readonly Current: X509Certificate2;
    MoveNext(): boolean;
    Reset(): void;
}


export const X509Certificate2Enumerator: {
    new(): X509Certificate2Enumerator;
};


export interface __X509Certificate2Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<X509Certificate2>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type X509Certificate2Enumerator = X509Certificate2Enumerator$instance & __X509Certificate2Enumerator$views;


export interface X509CertificateCollection$instance extends CollectionBase {
    Item: X509Certificate | X509Certificate2;
    Add(value: unknown): int;
    AddRange(value: X509Certificate[]): void;
    AddRange(value: X509CertificateCollection): void;
    Clear(): void;
    Contains(value: unknown): boolean;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator;
    GetHashCode(): int;
    IndexOf(value: X509Certificate): int;
    Insert(index: int, value: unknown): void;
    Remove(value: unknown): void;
    RemoveAt(index: int): void;
}


export const X509CertificateCollection: {
    new(): X509CertificateCollection;
    new(value: X509Certificate[]): X509CertificateCollection;
    new(value: X509CertificateCollection): X509CertificateCollection;
};


export interface __X509CertificateCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type X509CertificateCollection = X509CertificateCollection$instance & __X509CertificateCollection$views;


export interface X509CertificateCollection_X509CertificateEnumerator$instance {
    readonly Current: X509Certificate;
    MoveNext(): boolean;
    Reset(): void;
}


export const X509CertificateCollection_X509CertificateEnumerator: {
    new(mappings: X509CertificateCollection): X509CertificateCollection_X509CertificateEnumerator;
};


export interface __X509CertificateCollection_X509CertificateEnumerator$views {
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type X509CertificateCollection_X509CertificateEnumerator = X509CertificateCollection_X509CertificateEnumerator$instance & __X509CertificateCollection_X509CertificateEnumerator$views;


export interface X509Chain$instance {
    readonly ChainContext: nint;
    readonly ChainElements: X509ChainElementCollection;
    ChainPolicy: X509ChainPolicy;
    readonly ChainStatus: X509ChainStatus[];
    readonly SafeHandle: SafeX509ChainHandle;
    Build(certificate: X509Certificate2): boolean;
    Dispose(): void;
    Reset(): void;
}


export const X509Chain: {
    new(): X509Chain;
    new(useMachineContext: boolean): X509Chain;
    new(chainContext: nint): X509Chain;
    Create(): X509Chain;
};


export interface __X509Chain$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface X509Chain$instance extends System_Internal.IDisposable$instance {}

export type X509Chain = X509Chain$instance & __X509Chain$views;


export interface X509ChainElement$instance {
    readonly Certificate: X509Certificate2;
    readonly ChainElementStatus: X509ChainStatus[];
    readonly Information: string;
}


export const X509ChainElement: {
    new(): X509ChainElement;
};


export type X509ChainElement = X509ChainElement$instance;

export interface X509ChainElementCollection$instance {
    readonly Count: int;
    readonly IsSynchronized: boolean;
    readonly Item: X509ChainElement;
    readonly SyncRoot: unknown;
    CopyTo(array: X509ChainElement[], index: int): void;
    GetEnumerator(): X509ChainElementEnumerator;
}


export const X509ChainElementCollection: {
    new(): X509ChainElementCollection;
};


export interface __X509ChainElementCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<X509ChainElement>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type X509ChainElementCollection = X509ChainElementCollection$instance & __X509ChainElementCollection$views;


export interface X509ChainElementEnumerator$instance {
    readonly Current: X509ChainElement;
    MoveNext(): boolean;
    Reset(): void;
}


export const X509ChainElementEnumerator: {
    new(): X509ChainElementEnumerator;
};


export interface __X509ChainElementEnumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<X509ChainElement>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type X509ChainElementEnumerator = X509ChainElementEnumerator$instance & __X509ChainElementEnumerator$views;


export interface X509ChainPolicy$instance {
    readonly ApplicationPolicy: OidCollection;
    readonly CertificatePolicy: OidCollection;
    readonly CustomTrustStore: X509Certificate2Collection;
    DisableCertificateDownloads: boolean;
    readonly ExtraStore: X509Certificate2Collection;
    RevocationFlag: X509RevocationFlag;
    RevocationMode: X509RevocationMode;
    TrustMode: X509ChainTrustMode;
    UrlRetrievalTimeout: TimeSpan;
    VerificationFlags: X509VerificationFlags;
    VerificationTime: DateTime;
    VerificationTimeIgnored: boolean;
    Clone(): X509ChainPolicy;
    Reset(): void;
}


export const X509ChainPolicy: {
    new(): X509ChainPolicy;
};


export type X509ChainPolicy = X509ChainPolicy$instance;

export interface X509EnhancedKeyUsageExtension$instance extends X509Extension {
    readonly EnhancedKeyUsages: OidCollection;
    CopyFrom(asnEncodedData: AsnEncodedData): void;
}


export const X509EnhancedKeyUsageExtension: {
    new(): X509EnhancedKeyUsageExtension;
    new(encodedEnhancedKeyUsages: AsnEncodedData, critical: boolean): X509EnhancedKeyUsageExtension;
    new(enhancedKeyUsages: OidCollection, critical: boolean): X509EnhancedKeyUsageExtension;
};


export type X509EnhancedKeyUsageExtension = X509EnhancedKeyUsageExtension$instance;

export interface X509Extension$instance extends AsnEncodedData {
    Critical: boolean;
    CopyFrom(asnEncodedData: AsnEncodedData): void;
}


export const X509Extension: {
    new(encodedExtension: AsnEncodedData, critical: boolean): X509Extension;
    new(oid: Oid, rawData: byte[], critical: boolean): X509Extension;
    new(oid: Oid, rawData: ReadOnlySpan_1<System_Internal.Byte>, critical: boolean): X509Extension;
    new(oid: string, rawData: byte[], critical: boolean): X509Extension;
    new(oid: string, rawData: ReadOnlySpan_1<System_Internal.Byte>, critical: boolean): X509Extension;
};


export type X509Extension = X509Extension$instance;

export interface X509ExtensionCollection$instance {
    readonly Count: int;
    readonly IsSynchronized: boolean;
    readonly SyncRoot: unknown;
    Add(extension: X509Extension): int;
    CopyTo(array: X509Extension[], index: int): void;
    get_Item(index: int): X509Extension;
    get_Item(oid: string): X509Extension;
    GetEnumerator(): X509ExtensionEnumerator;
}


export const X509ExtensionCollection: {
    new(): X509ExtensionCollection;
};


export interface __X509ExtensionCollection$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<X509Extension>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type X509ExtensionCollection = X509ExtensionCollection$instance & __X509ExtensionCollection$views;


export interface X509ExtensionEnumerator$instance {
    readonly Current: X509Extension;
    MoveNext(): boolean;
    Reset(): void;
}


export const X509ExtensionEnumerator: {
    new(): X509ExtensionEnumerator;
};


export interface __X509ExtensionEnumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<X509Extension>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type X509ExtensionEnumerator = X509ExtensionEnumerator$instance & __X509ExtensionEnumerator$views;


export interface X509KeyUsageExtension$instance extends X509Extension {
    readonly KeyUsages: X509KeyUsageFlags;
    CopyFrom(asnEncodedData: AsnEncodedData): void;
}


export const X509KeyUsageExtension: {
    new(): X509KeyUsageExtension;
    new(encodedKeyUsage: AsnEncodedData, critical: boolean): X509KeyUsageExtension;
    new(keyUsages: X509KeyUsageFlags, critical: boolean): X509KeyUsageExtension;
};


export type X509KeyUsageExtension = X509KeyUsageExtension$instance;

export interface X509SignatureGenerator$instance {
    readonly PublicKey: PublicKey;
    GetSignatureAlgorithmIdentifier(hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: byte[], hashAlgorithm: HashAlgorithmName): byte[];
}


export const X509SignatureGenerator: {
    CreateForCompositeMLDsa(key: CompositeMLDsa): X509SignatureGenerator;
    CreateForECDsa(key: ECDsa): X509SignatureGenerator;
    CreateForMLDsa(key: MLDsa): X509SignatureGenerator;
    CreateForRSA(key: RSA, signaturePadding: RSASignaturePadding): X509SignatureGenerator;
    CreateForSlhDsa(key: SlhDsa): X509SignatureGenerator;
};


export type X509SignatureGenerator = X509SignatureGenerator$instance;

export interface X509Store$instance {
    readonly Certificates: X509Certificate2Collection;
    readonly IsOpen: boolean;
    readonly Location: StoreLocation;
    readonly Name: string;
    readonly StoreHandle: nint;
    Add(certificate: X509Certificate2): void;
    AddRange(certificates: X509Certificate2Collection): void;
    Close(): void;
    Dispose(): void;
    Open(flags: OpenFlags): void;
    Remove(certificate: X509Certificate2): void;
    RemoveRange(certificates: X509Certificate2Collection): void;
}


export const X509Store: {
    new(): X509Store;
    new(storeName: string): X509Store;
    new(storeName: StoreName): X509Store;
    new(storeLocation: StoreLocation): X509Store;
    new(storeName: StoreName, storeLocation: StoreLocation): X509Store;
    new(storeName: StoreName, storeLocation: StoreLocation, flags: OpenFlags): X509Store;
    new(storeName: string, storeLocation: StoreLocation): X509Store;
    new(storeName: string, storeLocation: StoreLocation, flags: OpenFlags): X509Store;
    new(storeHandle: nint): X509Store;
};


export interface __X509Store$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface X509Store$instance extends System_Internal.IDisposable$instance {}

export type X509Store = X509Store$instance & __X509Store$views;


export interface X509SubjectAlternativeNameExtension$instance extends X509Extension {
    CopyFrom(asnEncodedData: AsnEncodedData): void;
    EnumerateDnsNames(): IEnumerable_1<System_Internal.String>;
    EnumerateIPAddresses(): IEnumerable_1<IPAddress>;
}


export const X509SubjectAlternativeNameExtension: {
    new(): X509SubjectAlternativeNameExtension;
    new(rawData: byte[], critical: boolean): X509SubjectAlternativeNameExtension;
    new(rawData: ReadOnlySpan_1<System_Internal.Byte>, critical: boolean): X509SubjectAlternativeNameExtension;
};


export type X509SubjectAlternativeNameExtension = X509SubjectAlternativeNameExtension$instance;

export interface X509SubjectKeyIdentifierExtension$instance extends X509Extension {
    readonly SubjectKeyIdentifier: string | undefined;
    readonly SubjectKeyIdentifierBytes: ReadOnlyMemory_1<System_Internal.Byte>;
    CopyFrom(asnEncodedData: AsnEncodedData): void;
}


export const X509SubjectKeyIdentifierExtension: {
    new(): X509SubjectKeyIdentifierExtension;
    new(encodedSubjectKeyIdentifier: AsnEncodedData, critical: boolean): X509SubjectKeyIdentifierExtension;
    new(subjectKeyIdentifier: byte[], critical: boolean): X509SubjectKeyIdentifierExtension;
    new(subjectKeyIdentifier: ReadOnlySpan_1<System_Internal.Byte>, critical: boolean): X509SubjectKeyIdentifierExtension;
    new(key: PublicKey, critical: boolean): X509SubjectKeyIdentifierExtension;
    new(key: PublicKey, algorithm: X509SubjectKeyIdentifierHashAlgorithm, critical: boolean): X509SubjectKeyIdentifierExtension;
    new(subjectKeyIdentifier: string, critical: boolean): X509SubjectKeyIdentifierExtension;
};


export type X509SubjectKeyIdentifierExtension = X509SubjectKeyIdentifierExtension$instance;

export abstract class DSACertificateExtensions$instance {
    static CopyWithPrivateKey(certificate: X509Certificate2, privateKey: DSA): X509Certificate2;
    static GetDSAPrivateKey(certificate: X509Certificate2): DSA | undefined;
    static GetDSAPublicKey(certificate: X509Certificate2): DSA | undefined;
}


export type DSACertificateExtensions = DSACertificateExtensions$instance;

export abstract class ECDsaCertificateExtensions$instance {
    static CopyWithPrivateKey(certificate: X509Certificate2, privateKey: ECDsa): X509Certificate2;
    static GetECDsaPrivateKey(certificate: X509Certificate2): ECDsa | undefined;
    static GetECDsaPublicKey(certificate: X509Certificate2): ECDsa | undefined;
}


export type ECDsaCertificateExtensions = ECDsaCertificateExtensions$instance;

export abstract class RSACertificateExtensions$instance {
    static CopyWithPrivateKey(certificate: X509Certificate2, privateKey: RSA): X509Certificate2;
    static GetRSAPrivateKey(certificate: X509Certificate2): RSA | undefined;
    static GetRSAPublicKey(certificate: X509Certificate2): RSA | undefined;
}


export type RSACertificateExtensions = RSACertificateExtensions$instance;

export abstract class X509CertificateLoader$instance {
    static LoadCertificate(data: byte[]): X509Certificate2;
    static LoadCertificate(data: ReadOnlySpan_1<System_Internal.Byte>): X509Certificate2;
    static LoadCertificateFromFile(path: string): X509Certificate2;
    static LoadPkcs12(data: byte[], password: string, keyStorageFlags?: X509KeyStorageFlags, loaderLimits?: Pkcs12LoaderLimits): X509Certificate2;
    static LoadPkcs12(data: ReadOnlySpan_1<System_Internal.Byte>, password: ReadOnlySpan_1<System_Internal.Char>, keyStorageFlags?: X509KeyStorageFlags, loaderLimits?: Pkcs12LoaderLimits): X509Certificate2;
    static LoadPkcs12Collection(data: byte[], password: string, keyStorageFlags?: X509KeyStorageFlags, loaderLimits?: Pkcs12LoaderLimits): X509Certificate2Collection;
    static LoadPkcs12Collection(data: ReadOnlySpan_1<System_Internal.Byte>, password: ReadOnlySpan_1<System_Internal.Char>, keyStorageFlags?: X509KeyStorageFlags, loaderLimits?: Pkcs12LoaderLimits): X509Certificate2Collection;
    static LoadPkcs12CollectionFromFile(path: string, password: ReadOnlySpan_1<System_Internal.Char>, keyStorageFlags?: X509KeyStorageFlags, loaderLimits?: Pkcs12LoaderLimits): X509Certificate2Collection;
    static LoadPkcs12CollectionFromFile(path: string, password: string, keyStorageFlags?: X509KeyStorageFlags, loaderLimits?: Pkcs12LoaderLimits): X509Certificate2Collection;
    static LoadPkcs12FromFile(path: string, password: ReadOnlySpan_1<System_Internal.Char>, keyStorageFlags?: X509KeyStorageFlags, loaderLimits?: Pkcs12LoaderLimits): X509Certificate2;
    static LoadPkcs12FromFile(path: string, password: string, keyStorageFlags?: X509KeyStorageFlags, loaderLimits?: Pkcs12LoaderLimits): X509Certificate2;
}


export type X509CertificateLoader = X509CertificateLoader$instance;


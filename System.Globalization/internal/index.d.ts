// Generated by tsbindgen - Architecture
// Namespace: System.Globalization
// Assembly: System.Private.CoreLib

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IDictionary, IEnumerator } from "../../System.Collections/internal/index.js";
import type { Assembly, MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { Rune } from "../../System.Text/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { ArgumentException, Boolean as ClrBoolean, Byte, Char, DateOnly, DateTime, DayOfWeek, Double, Enum, Exception, Guid, ICloneable, IComparable, IConvertible, IEquatable_1, IFormatProvider, IFormattable, Int32, ISpanFormattable, Nullable_1, Object as ClrObject, ReadOnlySpan_1, Span_1, String as ClrString, StringComparer, TimeSpan, Type, TypeCode, Void } from "../../System/internal/index.js";

export enum CalendarAlgorithmType {
    Unknown = 0,
    SolarCalendar = 1,
    LunarCalendar = 2,
    LunisolarCalendar = 3
}


export enum CalendarWeekRule {
    FirstDay = 0,
    FirstFullWeek = 1,
    FirstFourDayWeek = 2
}


export enum CompareOptions {
    None = 0,
    IgnoreCase = 1,
    IgnoreNonSpace = 2,
    IgnoreSymbols = 4,
    IgnoreKanaType = 8,
    IgnoreWidth = 16,
    NumericOrdering = 32,
    OrdinalIgnoreCase = 268435456,
    StringSort = 536870912,
    Ordinal = 1073741824
}


export enum CultureTypes {
    NeutralCultures = 1,
    SpecificCultures = 2,
    InstalledWin32Cultures = 4,
    AllCultures = 7,
    UserCustomCulture = 8,
    ReplacementCultures = 16,
    WindowsOnlyCultures = 32,
    FrameworkCultures = 64
}


export enum DateTimeStyles {
    None = 0,
    AllowLeadingWhite = 1,
    AllowTrailingWhite = 2,
    AllowInnerWhite = 4,
    AllowWhiteSpaces = 7,
    NoCurrentDateDefault = 8,
    AdjustToUniversal = 16,
    AssumeLocal = 32,
    AssumeUniversal = 64,
    RoundtripKind = 128
}


export enum DigitShapes {
    Context = 0,
    None = 1,
    NativeNational = 2
}


export enum GregorianCalendarTypes {
    Localized = 1,
    USEnglish = 2,
    MiddleEastFrench = 9,
    Arabic = 10,
    TransliteratedEnglish = 11,
    TransliteratedFrench = 12
}


export enum NumberStyles {
    None = 0,
    AllowLeadingWhite = 1,
    AllowTrailingWhite = 2,
    AllowLeadingSign = 4,
    AllowTrailingSign = 8,
    AllowParentheses = 16,
    AllowDecimalPoint = 32,
    AllowThousands = 64,
    AllowExponent = 128,
    AllowCurrencySymbol = 256,
    AllowHexSpecifier = 512,
    AllowBinarySpecifier = 1024,
    Integer = 7,
    HexNumber = 515,
    BinaryNumber = 1027,
    Number = 111,
    Float = 167,
    Currency = 383,
    Any = 511
}


export enum TimeSpanStyles {
    None = 0,
    AssumeNegative = 1
}


export enum UnicodeCategory {
    UppercaseLetter = 0,
    LowercaseLetter = 1,
    TitlecaseLetter = 2,
    ModifierLetter = 3,
    OtherLetter = 4,
    NonSpacingMark = 5,
    SpacingCombiningMark = 6,
    EnclosingMark = 7,
    DecimalDigitNumber = 8,
    LetterNumber = 9,
    OtherNumber = 10,
    SpaceSeparator = 11,
    LineSeparator = 12,
    ParagraphSeparator = 13,
    Control = 14,
    Format = 15,
    Surrogate = 16,
    PrivateUse = 17,
    ConnectorPunctuation = 18,
    DashPunctuation = 19,
    OpenPunctuation = 20,
    ClosePunctuation = 21,
    InitialQuotePunctuation = 22,
    FinalQuotePunctuation = 23,
    OtherPunctuation = 24,
    MathSymbol = 25,
    CurrencySymbol = 26,
    ModifierSymbol = 27,
    OtherSymbol = 28,
    OtherNotAssigned = 29
}


export interface Calendar$instance {
    readonly AlgorithmType: CalendarAlgorithmType;
    readonly Eras: int[];
    readonly IsReadOnly: boolean;
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    TwoDigitYearMax: int;
    AddDays(time: DateTime, days: int): DateTime;
    AddHours(time: DateTime, hours: int): DateTime;
    AddMilliseconds(time: DateTime, milliseconds: double): DateTime;
    AddMinutes(time: DateTime, minutes: int): DateTime;
    AddMonths(time: DateTime, months: int): DateTime;
    AddSeconds(time: DateTime, seconds: int): DateTime;
    AddWeeks(time: DateTime, weeks: int): DateTime;
    AddYears(time: DateTime, years: int): DateTime;
    Clone(): unknown;
    GetDayOfMonth(time: DateTime): int;
    GetDayOfWeek(time: DateTime): DayOfWeek;
    GetDayOfYear(time: DateTime): int;
    GetDaysInMonth(year: int, month: int): int;
    GetDaysInMonth(year: int, month: int, era: int): int;
    GetDaysInYear(year: int): int;
    GetDaysInYear(year: int, era: int): int;
    GetEra(time: DateTime): int;
    GetHour(time: DateTime): int;
    GetLeapMonth(year: int): int;
    GetLeapMonth(year: int, era: int): int;
    GetMilliseconds(time: DateTime): double;
    GetMinute(time: DateTime): int;
    GetMonth(time: DateTime): int;
    GetMonthsInYear(year: int): int;
    GetMonthsInYear(year: int, era: int): int;
    GetSecond(time: DateTime): int;
    GetWeekOfYear(time: DateTime, rule: CalendarWeekRule, firstDayOfWeek: DayOfWeek): int;
    GetYear(time: DateTime): int;
    IsLeapDay(year: int, month: int, day: int): boolean;
    IsLeapDay(year: int, month: int, day: int, era: int): boolean;
    IsLeapMonth(year: int, month: int): boolean;
    IsLeapMonth(year: int, month: int, era: int): boolean;
    IsLeapYear(year: int): boolean;
    IsLeapYear(year: int, era: int): boolean;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    ToFourDigitYear(year: int): int;
}


export const Calendar: {
    readonly CurrentEra: int;
    ReadOnly(calendar: Calendar): Calendar;
};


export interface __Calendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface Calendar$instance extends System_Internal.ICloneable$instance {}

export type Calendar = Calendar$instance & __Calendar$views;


export interface ChineseLunisolarCalendar$instance extends EastAsianLunisolarCalendar$instance {
    readonly Eras: int[];
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    Clone(): unknown;
    GetEra(time: DateTime): int;
}


export const ChineseLunisolarCalendar: {
    new(): ChineseLunisolarCalendar$instance;
    readonly ChineseEra: int;
};


export interface __ChineseLunisolarCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type ChineseLunisolarCalendar = ChineseLunisolarCalendar$instance & __ChineseLunisolarCalendar$views;


export interface CompareInfo$instance {
    readonly LCID: int;
    readonly Name: string;
    readonly Version: SortVersion;
    Compare(string1: string, string2: string): int;
    Compare(string1: string, string2: string, options: CompareOptions): int;
    Compare(string1: string, offset1: int, length1: int, string2: string, offset2: int, length2: int): int;
    Compare(string1: string, offset1: int, string2: string, offset2: int, options: CompareOptions): int;
    Compare(string1: string, offset1: int, string2: string, offset2: int): int;
    Compare(string1: string, offset1: int, length1: int, string2: string, offset2: int, length2: int, options: CompareOptions): int;
    Compare(string1: ReadOnlySpan_1<System_Internal.Char>, string2: ReadOnlySpan_1<System_Internal.Char>, options?: CompareOptions): int;
    Equals(value: unknown): boolean;
    GetHashCode(): int;
    GetHashCode(source: string, options: CompareOptions): int;
    GetHashCode(source: ReadOnlySpan_1<System_Internal.Char>, options: CompareOptions): int;
    GetSortKey(source: string, options: CompareOptions): SortKey;
    GetSortKey(source: string): SortKey;
    GetSortKey(source: ReadOnlySpan_1<System_Internal.Char>, destination: Span_1<System_Internal.Byte>, options?: CompareOptions): int;
    GetSortKeyLength(source: ReadOnlySpan_1<System_Internal.Char>, options?: CompareOptions): int;
    IndexOf(source: string, value: char): int;
    IndexOf(source: string, value: string): int;
    IndexOf(source: string, value: char, options: CompareOptions): int;
    IndexOf(source: string, value: string, options: CompareOptions): int;
    IndexOf(source: string, value: char, startIndex: int): int;
    IndexOf(source: string, value: string, startIndex: int): int;
    IndexOf(source: string, value: char, startIndex: int, options: CompareOptions): int;
    IndexOf(source: string, value: string, startIndex: int, options: CompareOptions): int;
    IndexOf(source: string, value: char, startIndex: int, count: int): int;
    IndexOf(source: string, value: string, startIndex: int, count: int): int;
    IndexOf(source: string, value: char, startIndex: int, count: int, options: CompareOptions): int;
    IndexOf(source: string, value: string, startIndex: int, count: int, options: CompareOptions): int;
    IndexOf(source: ReadOnlySpan_1<System_Internal.Char>, value: ReadOnlySpan_1<System_Internal.Char>, options?: CompareOptions): int;
    IndexOf(source: ReadOnlySpan_1<System_Internal.Char>, value: ReadOnlySpan_1<System_Internal.Char>, options: CompareOptions, matchLength: int): int;
    IndexOf(source: ReadOnlySpan_1<System_Internal.Char>, value: Rune, options?: CompareOptions): int;
    IsPrefix(source: string, prefix: string, options: CompareOptions): boolean;
    IsPrefix(source: ReadOnlySpan_1<System_Internal.Char>, prefix: ReadOnlySpan_1<System_Internal.Char>, options?: CompareOptions): boolean;
    IsPrefix(source: ReadOnlySpan_1<System_Internal.Char>, prefix: ReadOnlySpan_1<System_Internal.Char>, options: CompareOptions, matchLength: int): boolean;
    IsPrefix(source: string, prefix: string): boolean;
    IsSuffix(source: string, suffix: string, options: CompareOptions): boolean;
    IsSuffix(source: ReadOnlySpan_1<System_Internal.Char>, suffix: ReadOnlySpan_1<System_Internal.Char>, options?: CompareOptions): boolean;
    IsSuffix(source: ReadOnlySpan_1<System_Internal.Char>, suffix: ReadOnlySpan_1<System_Internal.Char>, options: CompareOptions, matchLength: int): boolean;
    IsSuffix(source: string, suffix: string): boolean;
    LastIndexOf(source: string, value: char): int;
    LastIndexOf(source: string, value: string): int;
    LastIndexOf(source: string, value: char, options: CompareOptions): int;
    LastIndexOf(source: string, value: string, options: CompareOptions): int;
    LastIndexOf(source: string, value: char, startIndex: int): int;
    LastIndexOf(source: string, value: string, startIndex: int): int;
    LastIndexOf(source: string, value: char, startIndex: int, options: CompareOptions): int;
    LastIndexOf(source: string, value: string, startIndex: int, options: CompareOptions): int;
    LastIndexOf(source: string, value: char, startIndex: int, count: int): int;
    LastIndexOf(source: string, value: string, startIndex: int, count: int): int;
    LastIndexOf(source: string, value: char, startIndex: int, count: int, options: CompareOptions): int;
    LastIndexOf(source: string, value: string, startIndex: int, count: int, options: CompareOptions): int;
    LastIndexOf(source: ReadOnlySpan_1<System_Internal.Char>, value: ReadOnlySpan_1<System_Internal.Char>, options?: CompareOptions): int;
    LastIndexOf(source: ReadOnlySpan_1<System_Internal.Char>, value: ReadOnlySpan_1<System_Internal.Char>, options: CompareOptions, matchLength: int): int;
    LastIndexOf(source: ReadOnlySpan_1<System_Internal.Char>, value: Rune, options?: CompareOptions): int;
    ToString(): string;
}


export const CompareInfo: {
    new(): CompareInfo$instance;
    GetCompareInfo(culture: int, assembly: Assembly): CompareInfo;
    GetCompareInfo(culture: int): CompareInfo;
    GetCompareInfo(name: string, assembly: Assembly): CompareInfo;
    GetCompareInfo(name: string): CompareInfo;
    IsSortable(ch: char): boolean;
    IsSortable(text: ReadOnlySpan_1<System_Internal.Char>): boolean;
    IsSortable(text: string): boolean;
    IsSortable(value: Rune): boolean;
};


export interface __CompareInfo$views {
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
}

export interface CompareInfo$instance extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance {}

export type CompareInfo = CompareInfo$instance & __CompareInfo$views;


export interface CultureInfo$instance {
    readonly Calendar: Calendar;
    readonly CompareInfo: CompareInfo;
    readonly CultureTypes: CultureTypes;
    DateTimeFormat: DateTimeFormatInfo;
    readonly DisplayName: string;
    readonly EnglishName: string;
    readonly IetfLanguageTag: string;
    readonly IsNeutralCulture: boolean;
    readonly IsReadOnly: boolean;
    readonly KeyboardLayoutId: int;
    readonly LCID: int;
    readonly Name: string;
    readonly NativeName: string;
    NumberFormat: NumberFormatInfo;
    readonly OptionalCalendars: Calendar[];
    readonly Parent: CultureInfo;
    readonly TextInfo: TextInfo;
    readonly ThreeLetterISOLanguageName: string;
    readonly ThreeLetterWindowsLanguageName: string;
    readonly TwoLetterISOLanguageName: string;
    readonly UseUserOverride: boolean;
    ClearCachedData(): void;
    Clone(): unknown;
    Equals(value: unknown): boolean;
    GetConsoleFallbackUICulture(): CultureInfo;
    GetFormat(formatType: Type): unknown;
    GetHashCode(): int;
    ToString(): string;
}


export const CultureInfo: {
    new(name: string): CultureInfo$instance;
    new(name: string, useUserOverride: boolean): CultureInfo$instance;
    new(culture: int): CultureInfo$instance;
    new(culture: int, useUserOverride: boolean): CultureInfo$instance;
    CurrentCulture: CultureInfo;
    CurrentUICulture: CultureInfo;
    readonly InstalledUICulture: CultureInfo;
    DefaultThreadCurrentCulture: CultureInfo;
    DefaultThreadCurrentUICulture: CultureInfo;
    readonly InvariantCulture: CultureInfo;
    CreateSpecificCulture(name: string): CultureInfo;
    GetCultureInfo(culture: int): CultureInfo;
    GetCultureInfo(name: string, predefinedOnly: boolean): CultureInfo;
    GetCultureInfo(name: string, altName: string): CultureInfo;
    GetCultureInfo(name: string): CultureInfo;
    GetCultureInfoByIetfLanguageTag(name: string): CultureInfo;
    GetCultures(types: CultureTypes): CultureInfo[];
    ReadOnly(ci: CultureInfo): CultureInfo;
};


export interface __CultureInfo$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IFormatProvider(): System_Internal.IFormatProvider$instance;
}

export interface CultureInfo$instance extends System_Internal.ICloneable$instance, System_Internal.IFormatProvider$instance {}

export type CultureInfo = CultureInfo$instance & __CultureInfo$views;


export interface CultureNotFoundException$instance extends ArgumentException {
    readonly InvalidCultureId: Nullable_1<System_Internal.Int32>;
    readonly InvalidCultureName: string;
    readonly Message: string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const CultureNotFoundException: {
    new(): CultureNotFoundException$instance;
    new(message: string): CultureNotFoundException$instance;
    new(paramName: string, message: string): CultureNotFoundException$instance;
    new(message: string, innerException: Exception): CultureNotFoundException$instance;
    new(paramName: string, invalidCultureName: string, message: string): CultureNotFoundException$instance;
    new(message: string, invalidCultureName: string, innerException: Exception): CultureNotFoundException$instance;
    new(message: string, invalidCultureId: int, innerException: Exception): CultureNotFoundException$instance;
    new(paramName: string, invalidCultureId: int, message: string): CultureNotFoundException$instance;
};


export interface __CultureNotFoundException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type CultureNotFoundException = CultureNotFoundException$instance & __CultureNotFoundException$views;


export interface DateTimeFormatInfo$instance {
    AbbreviatedDayNames: string[];
    AbbreviatedMonthGenitiveNames: string[];
    AbbreviatedMonthNames: string[];
    AMDesignator: string;
    Calendar: Calendar;
    CalendarWeekRule: CalendarWeekRule;
    DateSeparator: string;
    DayNames: string[];
    FirstDayOfWeek: DayOfWeek;
    FullDateTimePattern: string;
    readonly IsReadOnly: boolean;
    LongDatePattern: string;
    LongTimePattern: string;
    MonthDayPattern: string;
    MonthGenitiveNames: string[];
    MonthNames: string[];
    readonly NativeCalendarName: string;
    PMDesignator: string;
    readonly RFC1123Pattern: string;
    ShortDatePattern: string;
    ShortestDayNames: string[];
    ShortTimePattern: string;
    readonly SortableDateTimePattern: string;
    TimeSeparator: string;
    readonly UniversalSortableDateTimePattern: string;
    YearMonthPattern: string;
    Clone(): unknown;
    GetAbbreviatedDayName(dayofweek: DayOfWeek): string;
    GetAbbreviatedEraName(era: int): string;
    GetAbbreviatedMonthName(month: int): string;
    GetAllDateTimePatterns(): string[];
    GetAllDateTimePatterns(format: char): string[];
    GetDayName(dayofweek: DayOfWeek): string;
    GetEra(eraName: string): int;
    GetEraName(era: int): string;
    GetFormat(formatType: Type): unknown;
    GetMonthName(month: int): string;
    GetShortestDayName(dayOfWeek: DayOfWeek): string;
    SetAllDateTimePatterns(patterns: string[], format: char): void;
}


export const DateTimeFormatInfo: {
    new(): DateTimeFormatInfo$instance;
    readonly InvariantInfo: DateTimeFormatInfo;
    readonly CurrentInfo: DateTimeFormatInfo;
    GetInstance(provider: IFormatProvider): DateTimeFormatInfo;
    ReadOnly(dtfi: DateTimeFormatInfo): DateTimeFormatInfo;
};


export interface __DateTimeFormatInfo$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IFormatProvider(): System_Internal.IFormatProvider$instance;
}

export interface DateTimeFormatInfo$instance extends System_Internal.ICloneable$instance, System_Internal.IFormatProvider$instance {}

export type DateTimeFormatInfo = DateTimeFormatInfo$instance & __DateTimeFormatInfo$views;


export interface DaylightTime$instance {
    readonly Delta: TimeSpan;
    readonly End: DateTime;
    readonly Start: DateTime;
}


export const DaylightTime: {
    new(start: DateTime, end: DateTime, delta: TimeSpan): DaylightTime$instance;
};


export type DaylightTime = DaylightTime$instance;

export interface EastAsianLunisolarCalendar$instance extends Calendar$instance {
    readonly AlgorithmType: CalendarAlgorithmType;
    TwoDigitYearMax: int;
    AddMonths(time: DateTime, months: int): DateTime;
    AddYears(time: DateTime, years: int): DateTime;
    Clone(): unknown;
    GetCelestialStem(sexagenaryYear: int): int;
    GetDayOfMonth(time: DateTime): int;
    GetDayOfWeek(time: DateTime): DayOfWeek;
    GetDayOfYear(time: DateTime): int;
    GetDaysInMonth(year: int, month: int, era: int): int;
    GetDaysInMonth(year: int, month: int): int;
    GetDaysInYear(year: int, era: int): int;
    GetDaysInYear(year: int): int;
    GetLeapMonth(year: int, era: int): int;
    GetLeapMonth(year: int): int;
    GetMonth(time: DateTime): int;
    GetMonthsInYear(year: int, era: int): int;
    GetMonthsInYear(year: int): int;
    GetSexagenaryYear(time: DateTime): int;
    GetTerrestrialBranch(sexagenaryYear: int): int;
    GetYear(time: DateTime): int;
    IsLeapDay(year: int, month: int, day: int, era: int): boolean;
    IsLeapDay(year: int, month: int, day: int): boolean;
    IsLeapMonth(year: int, month: int, era: int): boolean;
    IsLeapMonth(year: int, month: int): boolean;
    IsLeapYear(year: int, era: int): boolean;
    IsLeapYear(year: int): boolean;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    ToFourDigitYear(year: int): int;
}


export const EastAsianLunisolarCalendar: {
};


export interface __EastAsianLunisolarCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type EastAsianLunisolarCalendar = EastAsianLunisolarCalendar$instance & __EastAsianLunisolarCalendar$views;


export interface GregorianCalendar$instance extends Calendar$instance {
    readonly AlgorithmType: CalendarAlgorithmType;
    CalendarType: GregorianCalendarTypes;
    readonly Eras: int[];
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    TwoDigitYearMax: int;
    AddMonths(time: DateTime, months: int): DateTime;
    AddYears(time: DateTime, years: int): DateTime;
    Clone(): unknown;
    GetDayOfMonth(time: DateTime): int;
    GetDayOfWeek(time: DateTime): DayOfWeek;
    GetDayOfYear(time: DateTime): int;
    GetDaysInMonth(year: int, month: int, era: int): int;
    GetDaysInMonth(year: int, month: int): int;
    GetDaysInYear(year: int, era: int): int;
    GetDaysInYear(year: int): int;
    GetEra(time: DateTime): int;
    GetLeapMonth(year: int, era: int): int;
    GetLeapMonth(year: int): int;
    GetMonth(time: DateTime): int;
    GetMonthsInYear(year: int, era: int): int;
    GetMonthsInYear(year: int): int;
    GetYear(time: DateTime): int;
    IsLeapDay(year: int, month: int, day: int, era: int): boolean;
    IsLeapDay(year: int, month: int, day: int): boolean;
    IsLeapMonth(year: int, month: int, era: int): boolean;
    IsLeapMonth(year: int, month: int): boolean;
    IsLeapYear(year: int, era: int): boolean;
    IsLeapYear(year: int): boolean;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    ToFourDigitYear(year: int): int;
}


export const GregorianCalendar: {
    new(): GregorianCalendar$instance;
    new(type_: GregorianCalendarTypes): GregorianCalendar$instance;
    readonly ADEra: int;
};


export interface __GregorianCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type GregorianCalendar = GregorianCalendar$instance & __GregorianCalendar$views;


export interface HebrewCalendar$instance extends Calendar$instance {
    readonly AlgorithmType: CalendarAlgorithmType;
    readonly Eras: int[];
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    TwoDigitYearMax: int;
    AddMonths(time: DateTime, months: int): DateTime;
    AddYears(time: DateTime, years: int): DateTime;
    Clone(): unknown;
    GetDayOfMonth(time: DateTime): int;
    GetDayOfWeek(time: DateTime): DayOfWeek;
    GetDayOfYear(time: DateTime): int;
    GetDaysInMonth(year: int, month: int, era: int): int;
    GetDaysInMonth(year: int, month: int): int;
    GetDaysInYear(year: int, era: int): int;
    GetDaysInYear(year: int): int;
    GetEra(time: DateTime): int;
    GetLeapMonth(year: int, era: int): int;
    GetLeapMonth(year: int): int;
    GetMonth(time: DateTime): int;
    GetMonthsInYear(year: int, era: int): int;
    GetMonthsInYear(year: int): int;
    GetYear(time: DateTime): int;
    IsLeapDay(year: int, month: int, day: int, era: int): boolean;
    IsLeapDay(year: int, month: int, day: int): boolean;
    IsLeapMonth(year: int, month: int, era: int): boolean;
    IsLeapMonth(year: int, month: int): boolean;
    IsLeapYear(year: int, era: int): boolean;
    IsLeapYear(year: int): boolean;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    ToFourDigitYear(year: int): int;
}


export const HebrewCalendar: {
    new(): HebrewCalendar$instance;
    readonly HebrewEra: int;
};


export interface __HebrewCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type HebrewCalendar = HebrewCalendar$instance & __HebrewCalendar$views;


export interface HijriCalendar$instance extends Calendar$instance {
    readonly AlgorithmType: CalendarAlgorithmType;
    readonly Eras: int[];
    HijriAdjustment: int;
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    TwoDigitYearMax: int;
    AddMonths(time: DateTime, months: int): DateTime;
    AddYears(time: DateTime, years: int): DateTime;
    Clone(): unknown;
    GetDayOfMonth(time: DateTime): int;
    GetDayOfWeek(time: DateTime): DayOfWeek;
    GetDayOfYear(time: DateTime): int;
    GetDaysInMonth(year: int, month: int, era: int): int;
    GetDaysInMonth(year: int, month: int): int;
    GetDaysInYear(year: int, era: int): int;
    GetDaysInYear(year: int): int;
    GetEra(time: DateTime): int;
    GetLeapMonth(year: int, era: int): int;
    GetLeapMonth(year: int): int;
    GetMonth(time: DateTime): int;
    GetMonthsInYear(year: int, era: int): int;
    GetMonthsInYear(year: int): int;
    GetYear(time: DateTime): int;
    IsLeapDay(year: int, month: int, day: int, era: int): boolean;
    IsLeapDay(year: int, month: int, day: int): boolean;
    IsLeapMonth(year: int, month: int, era: int): boolean;
    IsLeapMonth(year: int, month: int): boolean;
    IsLeapYear(year: int, era: int): boolean;
    IsLeapYear(year: int): boolean;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    ToFourDigitYear(year: int): int;
}


export const HijriCalendar: {
    new(): HijriCalendar$instance;
    readonly HijriEra: int;
};


export interface __HijriCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type HijriCalendar = HijriCalendar$instance & __HijriCalendar$views;


export interface IdnMapping$instance {
    AllowUnassigned: boolean;
    UseStd3AsciiRules: boolean;
    Equals(obj: unknown): boolean;
    GetAscii(unicode: string): string;
    GetAscii(unicode: string, index: int): string;
    GetAscii(unicode: string, index: int, count: int): string;
    GetHashCode(): int;
    GetUnicode(ascii: string): string;
    GetUnicode(ascii: string, index: int): string;
    GetUnicode(ascii: string, index: int, count: int): string;
}


export const IdnMapping: {
    new(): IdnMapping$instance;
};


export type IdnMapping = IdnMapping$instance;

export interface JapaneseCalendar$instance extends Calendar$instance {
    readonly AlgorithmType: CalendarAlgorithmType;
    readonly Eras: int[];
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    TwoDigitYearMax: int;
    AddMonths(time: DateTime, months: int): DateTime;
    AddYears(time: DateTime, years: int): DateTime;
    Clone(): unknown;
    GetDayOfMonth(time: DateTime): int;
    GetDayOfWeek(time: DateTime): DayOfWeek;
    GetDayOfYear(time: DateTime): int;
    GetDaysInMonth(year: int, month: int, era: int): int;
    GetDaysInMonth(year: int, month: int): int;
    GetDaysInYear(year: int, era: int): int;
    GetDaysInYear(year: int): int;
    GetEra(time: DateTime): int;
    GetLeapMonth(year: int, era: int): int;
    GetLeapMonth(year: int): int;
    GetMonth(time: DateTime): int;
    GetMonthsInYear(year: int, era: int): int;
    GetMonthsInYear(year: int): int;
    GetWeekOfYear(time: DateTime, rule: CalendarWeekRule, firstDayOfWeek: DayOfWeek): int;
    GetYear(time: DateTime): int;
    IsLeapDay(year: int, month: int, day: int, era: int): boolean;
    IsLeapDay(year: int, month: int, day: int): boolean;
    IsLeapMonth(year: int, month: int, era: int): boolean;
    IsLeapMonth(year: int, month: int): boolean;
    IsLeapYear(year: int, era: int): boolean;
    IsLeapYear(year: int): boolean;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    ToFourDigitYear(year: int): int;
}


export const JapaneseCalendar: {
    new(): JapaneseCalendar$instance;
};


export interface __JapaneseCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type JapaneseCalendar = JapaneseCalendar$instance & __JapaneseCalendar$views;


export interface JapaneseLunisolarCalendar$instance extends EastAsianLunisolarCalendar$instance {
    readonly Eras: int[];
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    Clone(): unknown;
    GetEra(time: DateTime): int;
}


export const JapaneseLunisolarCalendar: {
    new(): JapaneseLunisolarCalendar$instance;
    readonly JapaneseEra: int;
};


export interface __JapaneseLunisolarCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type JapaneseLunisolarCalendar = JapaneseLunisolarCalendar$instance & __JapaneseLunisolarCalendar$views;


export interface JulianCalendar$instance extends Calendar$instance {
    readonly AlgorithmType: CalendarAlgorithmType;
    readonly Eras: int[];
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    TwoDigitYearMax: int;
    AddMonths(time: DateTime, months: int): DateTime;
    AddYears(time: DateTime, years: int): DateTime;
    Clone(): unknown;
    GetDayOfMonth(time: DateTime): int;
    GetDayOfWeek(time: DateTime): DayOfWeek;
    GetDayOfYear(time: DateTime): int;
    GetDaysInMonth(year: int, month: int, era: int): int;
    GetDaysInMonth(year: int, month: int): int;
    GetDaysInYear(year: int, era: int): int;
    GetDaysInYear(year: int): int;
    GetEra(time: DateTime): int;
    GetLeapMonth(year: int, era: int): int;
    GetLeapMonth(year: int): int;
    GetMonth(time: DateTime): int;
    GetMonthsInYear(year: int, era: int): int;
    GetMonthsInYear(year: int): int;
    GetYear(time: DateTime): int;
    IsLeapDay(year: int, month: int, day: int, era: int): boolean;
    IsLeapDay(year: int, month: int, day: int): boolean;
    IsLeapMonth(year: int, month: int, era: int): boolean;
    IsLeapMonth(year: int, month: int): boolean;
    IsLeapYear(year: int, era: int): boolean;
    IsLeapYear(year: int): boolean;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    ToFourDigitYear(year: int): int;
}


export const JulianCalendar: {
    new(): JulianCalendar$instance;
    readonly JulianEra: int;
};


export interface __JulianCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type JulianCalendar = JulianCalendar$instance & __JulianCalendar$views;


export interface KoreanCalendar$instance extends Calendar$instance {
    readonly AlgorithmType: CalendarAlgorithmType;
    readonly Eras: int[];
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    TwoDigitYearMax: int;
    AddMonths(time: DateTime, months: int): DateTime;
    AddYears(time: DateTime, years: int): DateTime;
    Clone(): unknown;
    GetDayOfMonth(time: DateTime): int;
    GetDayOfWeek(time: DateTime): DayOfWeek;
    GetDayOfYear(time: DateTime): int;
    GetDaysInMonth(year: int, month: int, era: int): int;
    GetDaysInMonth(year: int, month: int): int;
    GetDaysInYear(year: int, era: int): int;
    GetDaysInYear(year: int): int;
    GetEra(time: DateTime): int;
    GetLeapMonth(year: int, era: int): int;
    GetLeapMonth(year: int): int;
    GetMonth(time: DateTime): int;
    GetMonthsInYear(year: int, era: int): int;
    GetMonthsInYear(year: int): int;
    GetWeekOfYear(time: DateTime, rule: CalendarWeekRule, firstDayOfWeek: DayOfWeek): int;
    GetYear(time: DateTime): int;
    IsLeapDay(year: int, month: int, day: int, era: int): boolean;
    IsLeapDay(year: int, month: int, day: int): boolean;
    IsLeapMonth(year: int, month: int, era: int): boolean;
    IsLeapMonth(year: int, month: int): boolean;
    IsLeapYear(year: int, era: int): boolean;
    IsLeapYear(year: int): boolean;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    ToFourDigitYear(year: int): int;
}


export const KoreanCalendar: {
    new(): KoreanCalendar$instance;
    readonly KoreanEra: int;
};


export interface __KoreanCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type KoreanCalendar = KoreanCalendar$instance & __KoreanCalendar$views;


export interface KoreanLunisolarCalendar$instance extends EastAsianLunisolarCalendar$instance {
    readonly Eras: int[];
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    Clone(): unknown;
    GetEra(time: DateTime): int;
}


export const KoreanLunisolarCalendar: {
    new(): KoreanLunisolarCalendar$instance;
    readonly GregorianEra: int;
};


export interface __KoreanLunisolarCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type KoreanLunisolarCalendar = KoreanLunisolarCalendar$instance & __KoreanLunisolarCalendar$views;


export interface NumberFormatInfo$instance {
    CurrencyDecimalDigits: int;
    CurrencyDecimalSeparator: string;
    CurrencyGroupSeparator: string;
    CurrencyGroupSizes: int[];
    CurrencyNegativePattern: int;
    CurrencyPositivePattern: int;
    CurrencySymbol: string;
    DigitSubstitution: DigitShapes;
    readonly IsReadOnly: boolean;
    NaNSymbol: string;
    NativeDigits: string[];
    NegativeInfinitySymbol: string;
    NegativeSign: string;
    NumberDecimalDigits: int;
    NumberDecimalSeparator: string;
    NumberGroupSeparator: string;
    NumberGroupSizes: int[];
    NumberNegativePattern: int;
    PercentDecimalDigits: int;
    PercentDecimalSeparator: string;
    PercentGroupSeparator: string;
    PercentGroupSizes: int[];
    PercentNegativePattern: int;
    PercentPositivePattern: int;
    PercentSymbol: string;
    PerMilleSymbol: string;
    PositiveInfinitySymbol: string;
    PositiveSign: string;
    Clone(): unknown;
    GetFormat(formatType: Type): unknown;
}


export const NumberFormatInfo: {
    new(): NumberFormatInfo$instance;
    readonly InvariantInfo: NumberFormatInfo;
    readonly CurrentInfo: NumberFormatInfo;
    GetInstance(formatProvider: IFormatProvider): NumberFormatInfo;
    ReadOnly(nfi: NumberFormatInfo): NumberFormatInfo;
};


export interface __NumberFormatInfo$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IFormatProvider(): System_Internal.IFormatProvider$instance;
}

export interface NumberFormatInfo$instance extends System_Internal.ICloneable$instance, System_Internal.IFormatProvider$instance {}

export type NumberFormatInfo = NumberFormatInfo$instance & __NumberFormatInfo$views;


export interface PersianCalendar$instance extends Calendar$instance {
    readonly AlgorithmType: CalendarAlgorithmType;
    readonly Eras: int[];
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    TwoDigitYearMax: int;
    AddMonths(time: DateTime, months: int): DateTime;
    AddYears(time: DateTime, years: int): DateTime;
    Clone(): unknown;
    GetDayOfMonth(time: DateTime): int;
    GetDayOfWeek(time: DateTime): DayOfWeek;
    GetDayOfYear(time: DateTime): int;
    GetDaysInMonth(year: int, month: int, era: int): int;
    GetDaysInMonth(year: int, month: int): int;
    GetDaysInYear(year: int, era: int): int;
    GetDaysInYear(year: int): int;
    GetEra(time: DateTime): int;
    GetLeapMonth(year: int, era: int): int;
    GetLeapMonth(year: int): int;
    GetMonth(time: DateTime): int;
    GetMonthsInYear(year: int, era: int): int;
    GetMonthsInYear(year: int): int;
    GetYear(time: DateTime): int;
    IsLeapDay(year: int, month: int, day: int, era: int): boolean;
    IsLeapDay(year: int, month: int, day: int): boolean;
    IsLeapMonth(year: int, month: int, era: int): boolean;
    IsLeapMonth(year: int, month: int): boolean;
    IsLeapYear(year: int, era: int): boolean;
    IsLeapYear(year: int): boolean;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    ToFourDigitYear(year: int): int;
}


export const PersianCalendar: {
    new(): PersianCalendar$instance;
    readonly PersianEra: int;
};


export interface __PersianCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type PersianCalendar = PersianCalendar$instance & __PersianCalendar$views;


export interface RegionInfo$instance {
    readonly CurrencyEnglishName: string;
    readonly CurrencyNativeName: string;
    readonly CurrencySymbol: string;
    readonly DisplayName: string;
    readonly EnglishName: string;
    readonly GeoId: int;
    readonly IsMetric: boolean;
    readonly ISOCurrencySymbol: string;
    readonly Name: string;
    readonly NativeName: string;
    readonly ThreeLetterISORegionName: string;
    readonly ThreeLetterWindowsRegionName: string;
    readonly TwoLetterISORegionName: string;
    Equals(value: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RegionInfo: {
    new(name: string): RegionInfo$instance;
    new(culture: int): RegionInfo$instance;
    readonly CurrentRegion: RegionInfo;
};


export type RegionInfo = RegionInfo$instance;

export interface SortKey$instance {
    readonly KeyData: byte[];
    readonly OriginalString: string;
    Equals(value: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const SortKey: {
    new(): SortKey$instance;
    Compare(sortkey1: SortKey, sortkey2: SortKey): int;
};


export type SortKey = SortKey$instance;

export interface SortVersion$instance {
    readonly FullVersion: int;
    readonly SortId: Guid;
    Equals(obj: unknown): boolean;
    Equals(other: SortVersion): boolean;
    GetHashCode(): int;
}


export const SortVersion: {
    new(fullVersion: int, sortId: Guid): SortVersion$instance;
};


export interface __SortVersion$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SortVersion>;

    // Structural method bridges for numeric interface constraints
    Equals(other: SortVersion): boolean;
}

export type SortVersion = SortVersion$instance & __SortVersion$views;


export interface StringInfo$instance {
    readonly LengthInTextElements: int;
    String: string;
    Equals(value: unknown): boolean;
    GetHashCode(): int;
    SubstringByTextElements(startingTextElement: int): string;
    SubstringByTextElements(startingTextElement: int, lengthInTextElements: int): string;
}


export const StringInfo: {
    new(): StringInfo$instance;
    new(value: string): StringInfo$instance;
    GetNextTextElement(str: string, index: int): string;
    GetNextTextElement(str: string): string;
    GetNextTextElementLength(str: ReadOnlySpan_1<System_Internal.Char>): int;
    GetNextTextElementLength(str: string, index: int): int;
    GetNextTextElementLength(str: string): int;
    GetTextElementEnumerator(str: string, index: int): TextElementEnumerator;
    GetTextElementEnumerator(str: string): TextElementEnumerator;
    ParseCombiningCharacters(str: string): int[];
};


export type StringInfo = StringInfo$instance;

export interface TaiwanCalendar$instance extends Calendar$instance {
    readonly AlgorithmType: CalendarAlgorithmType;
    readonly Eras: int[];
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    TwoDigitYearMax: int;
    AddMonths(time: DateTime, months: int): DateTime;
    AddYears(time: DateTime, years: int): DateTime;
    Clone(): unknown;
    GetDayOfMonth(time: DateTime): int;
    GetDayOfWeek(time: DateTime): DayOfWeek;
    GetDayOfYear(time: DateTime): int;
    GetDaysInMonth(year: int, month: int, era: int): int;
    GetDaysInMonth(year: int, month: int): int;
    GetDaysInYear(year: int, era: int): int;
    GetDaysInYear(year: int): int;
    GetEra(time: DateTime): int;
    GetLeapMonth(year: int, era: int): int;
    GetLeapMonth(year: int): int;
    GetMonth(time: DateTime): int;
    GetMonthsInYear(year: int, era: int): int;
    GetMonthsInYear(year: int): int;
    GetWeekOfYear(time: DateTime, rule: CalendarWeekRule, firstDayOfWeek: DayOfWeek): int;
    GetYear(time: DateTime): int;
    IsLeapDay(year: int, month: int, day: int, era: int): boolean;
    IsLeapDay(year: int, month: int, day: int): boolean;
    IsLeapMonth(year: int, month: int, era: int): boolean;
    IsLeapMonth(year: int, month: int): boolean;
    IsLeapYear(year: int, era: int): boolean;
    IsLeapYear(year: int): boolean;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    ToFourDigitYear(year: int): int;
}


export const TaiwanCalendar: {
    new(): TaiwanCalendar$instance;
};


export interface __TaiwanCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type TaiwanCalendar = TaiwanCalendar$instance & __TaiwanCalendar$views;


export interface TaiwanLunisolarCalendar$instance extends EastAsianLunisolarCalendar$instance {
    readonly Eras: int[];
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    Clone(): unknown;
    GetEra(time: DateTime): int;
}


export const TaiwanLunisolarCalendar: {
    new(): TaiwanLunisolarCalendar$instance;
};


export interface __TaiwanLunisolarCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type TaiwanLunisolarCalendar = TaiwanLunisolarCalendar$instance & __TaiwanLunisolarCalendar$views;


export interface TextElementEnumerator$instance {
    readonly Current: unknown;
    readonly ElementIndex: int;
    GetTextElement(): string;
    MoveNext(): boolean;
    Reset(): void;
}


export const TextElementEnumerator: {
    new(): TextElementEnumerator$instance;
};


export interface __TextElementEnumerator$views {
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export interface TextElementEnumerator$instance extends System_Collections_Internal.IEnumerator$instance {}

export type TextElementEnumerator = TextElementEnumerator$instance & __TextElementEnumerator$views;


export interface TextInfo$instance {
    readonly ANSICodePage: int;
    readonly CultureName: string;
    readonly EBCDICCodePage: int;
    readonly IsReadOnly: boolean;
    readonly IsRightToLeft: boolean;
    readonly LCID: int;
    ListSeparator: string;
    readonly MacCodePage: int;
    readonly OEMCodePage: int;
    Clone(): unknown;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToLower(c: char): char;
    ToLower(str: string): string;
    ToString(): string;
    ToTitleCase(str: string): string;
    ToUpper(c: char): char;
    ToUpper(str: string): string;
}


export const TextInfo: {
    new(): TextInfo$instance;
    ReadOnly(textInfo: TextInfo): TextInfo;
};


export interface __TextInfo$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
}

export interface TextInfo$instance extends System_Internal.ICloneable$instance, System_Runtime_Serialization_Internal.IDeserializationCallback$instance {}

export type TextInfo = TextInfo$instance & __TextInfo$views;


export interface ThaiBuddhistCalendar$instance extends Calendar$instance {
    readonly AlgorithmType: CalendarAlgorithmType;
    readonly Eras: int[];
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    TwoDigitYearMax: int;
    AddMonths(time: DateTime, months: int): DateTime;
    AddYears(time: DateTime, years: int): DateTime;
    Clone(): unknown;
    GetDayOfMonth(time: DateTime): int;
    GetDayOfWeek(time: DateTime): DayOfWeek;
    GetDayOfYear(time: DateTime): int;
    GetDaysInMonth(year: int, month: int, era: int): int;
    GetDaysInMonth(year: int, month: int): int;
    GetDaysInYear(year: int, era: int): int;
    GetDaysInYear(year: int): int;
    GetEra(time: DateTime): int;
    GetLeapMonth(year: int, era: int): int;
    GetLeapMonth(year: int): int;
    GetMonth(time: DateTime): int;
    GetMonthsInYear(year: int, era: int): int;
    GetMonthsInYear(year: int): int;
    GetWeekOfYear(time: DateTime, rule: CalendarWeekRule, firstDayOfWeek: DayOfWeek): int;
    GetYear(time: DateTime): int;
    IsLeapDay(year: int, month: int, day: int, era: int): boolean;
    IsLeapDay(year: int, month: int, day: int): boolean;
    IsLeapMonth(year: int, month: int, era: int): boolean;
    IsLeapMonth(year: int, month: int): boolean;
    IsLeapYear(year: int, era: int): boolean;
    IsLeapYear(year: int): boolean;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    ToFourDigitYear(year: int): int;
}


export const ThaiBuddhistCalendar: {
    new(): ThaiBuddhistCalendar$instance;
    readonly ThaiBuddhistEra: int;
};


export interface __ThaiBuddhistCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type ThaiBuddhistCalendar = ThaiBuddhistCalendar$instance & __ThaiBuddhistCalendar$views;


export interface UmAlQuraCalendar$instance extends Calendar$instance {
    readonly AlgorithmType: CalendarAlgorithmType;
    readonly Eras: int[];
    readonly MaxSupportedDateTime: DateTime;
    readonly MinSupportedDateTime: DateTime;
    TwoDigitYearMax: int;
    AddMonths(time: DateTime, months: int): DateTime;
    AddYears(time: DateTime, years: int): DateTime;
    Clone(): unknown;
    GetDayOfMonth(time: DateTime): int;
    GetDayOfWeek(time: DateTime): DayOfWeek;
    GetDayOfYear(time: DateTime): int;
    GetDaysInMonth(year: int, month: int, era: int): int;
    GetDaysInMonth(year: int, month: int): int;
    GetDaysInYear(year: int, era: int): int;
    GetDaysInYear(year: int): int;
    GetEra(time: DateTime): int;
    GetLeapMonth(year: int, era: int): int;
    GetLeapMonth(year: int): int;
    GetMonth(time: DateTime): int;
    GetMonthsInYear(year: int, era: int): int;
    GetMonthsInYear(year: int): int;
    GetYear(time: DateTime): int;
    IsLeapDay(year: int, month: int, day: int, era: int): boolean;
    IsLeapDay(year: int, month: int, day: int): boolean;
    IsLeapMonth(year: int, month: int, era: int): boolean;
    IsLeapMonth(year: int, month: int): boolean;
    IsLeapYear(year: int, era: int): boolean;
    IsLeapYear(year: int): boolean;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
    ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    ToFourDigitYear(year: int): int;
}


export const UmAlQuraCalendar: {
    new(): UmAlQuraCalendar$instance;
    readonly UmAlQuraEra: int;
};


export interface __UmAlQuraCalendar$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type UmAlQuraCalendar = UmAlQuraCalendar$instance & __UmAlQuraCalendar$views;


export abstract class CharUnicodeInfo$instance {
    static GetDecimalDigitValue(ch: char): int;
    static GetDecimalDigitValue(s: string, index: int): int;
    static GetDigitValue(ch: char): int;
    static GetDigitValue(s: string, index: int): int;
    static GetNumericValue(ch: char): double;
    static GetNumericValue(s: string, index: int): double;
    static GetUnicodeCategory(ch: char): UnicodeCategory;
    static GetUnicodeCategory(codePoint: int): UnicodeCategory;
    static GetUnicodeCategory(s: string, index: int): UnicodeCategory;
}


export type CharUnicodeInfo = CharUnicodeInfo$instance;

export abstract class GlobalizationExtensions$instance {
    static GetStringComparer(compareInfo: CompareInfo, options: CompareOptions): StringComparer;
}


export type GlobalizationExtensions = GlobalizationExtensions$instance;

export abstract class ISOWeek$instance {
    static GetWeekOfYear(date: DateOnly): int;
    static GetWeekOfYear(date: DateTime): int;
    static GetWeeksInYear(year: int): int;
    static GetYear(date: DateOnly): int;
    static GetYear(date: DateTime): int;
    static GetYearEnd(year: int): DateTime;
    static GetYearStart(year: int): DateTime;
    static ToDateOnly(year: int, week: int, dayOfWeek: DayOfWeek): DateOnly;
    static ToDateTime(year: int, week: int, dayOfWeek: DayOfWeek): DateTime;
}


export type ISOWeek = ISOWeek$instance;


// Generated by tsbindgen - Architecture
// Namespace: Microsoft.VisualBasic.CompilerServices
// Assembly: Microsoft.VisualBasic.Core

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr } from "@tsonic/types";

// Import types from other namespaces
import type { CallType, CompareMethod } from "../../Microsoft.VisualBasic/internal/index.js";
import type { IDictionary } from "../../System.Collections/internal/index.js";
import type { CultureInfo, NumberFormatInfo } from "../../System.Globalization/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Attribute, Boolean as ClrBoolean, Byte, Char, DateTime, Decimal, Double, Exception, Int16, Int32, Int64, Object as ClrObject, SByte, Single, String as ClrString, Type, UInt16, UInt32, UInt64, Void } from "../../System/internal/index.js";

export interface BooleanType$instance {
}


export const BooleanType: {
    new(): BooleanType$instance;
    FromObject(Value: unknown): boolean;
    FromString(Value: string): boolean;
};


export type BooleanType = BooleanType$instance;

export interface ByteType$instance {
}


export const ByteType: {
    new(): ByteType$instance;
    FromObject(Value: unknown): byte;
    FromString(Value: string): byte;
};


export type ByteType = ByteType$instance;

export interface CharArrayType$instance {
}


export const CharArrayType: {
    new(): CharArrayType$instance;
    FromObject(Value: unknown): char[];
    FromString(Value: string): char[];
};


export type CharArrayType = CharArrayType$instance;

export interface CharType$instance {
}


export const CharType: {
    new(): CharType$instance;
    FromObject(Value: unknown): char;
    FromString(Value: string): char;
};


export type CharType = CharType$instance;

export interface Conversions$instance {
}


export const Conversions: {
    new(): Conversions$instance;
    ChangeType(Expression: unknown, TargetType: Type): unknown;
    FallbackUserDefinedConversion(Expression: unknown, TargetType: Type): unknown;
    FromCharAndCount(Value: char, Count: int): string;
    FromCharArray(Value: char[]): string;
    FromCharArraySubset(Value: char[], StartIndex: int, Length: int): string;
    ToBoolean(Value: unknown): boolean;
    ToBoolean(Value: string): boolean;
    ToByte(Value: unknown): byte;
    ToByte(Value: string): byte;
    ToChar(Value: unknown): char;
    ToChar(Value: string): char;
    ToCharArrayRankOne(Value: unknown): char[];
    ToCharArrayRankOne(Value: string): char[];
    ToDate(Value: unknown): DateTime;
    ToDate(Value: string): DateTime;
    ToDecimal(Value: boolean): decimal;
    ToDecimal(Value: unknown): decimal;
    ToDecimal(Value: string): decimal;
    ToDouble(Value: unknown): double;
    ToDouble(Value: string): double;
    ToGenericParameter<T>(Value: unknown): T;
    ToInteger(Value: unknown): int;
    ToInteger(Value: string): int;
    ToLong(Value: unknown): long;
    ToLong(Value: string): long;
    ToSByte(Value: unknown): sbyte;
    ToSByte(Value: string): sbyte;
    ToShort(Value: unknown): short;
    ToShort(Value: string): short;
    ToSingle(Value: unknown): float;
    ToSingle(Value: string): float;
    ToString(Value: boolean): string;
    ToString(Value: byte): string;
    ToString(Value: char): string;
    ToString(Value: DateTime): string;
    ToString(Value: decimal, NumberFormat: NumberFormatInfo): string;
    ToString(Value: decimal): string;
    ToString(Value: double, NumberFormat: NumberFormatInfo): string;
    ToString(Value: double): string;
    ToString(Value: short): string;
    ToString(Value: int): string;
    ToString(Value: long): string;
    ToString(Value: unknown): string;
    ToString(Value: float, NumberFormat: NumberFormatInfo): string;
    ToString(Value: float): string;
    ToString(Value: uint): string;
    ToString(Value: ulong): string;
    ToUInteger(Value: unknown): uint;
    ToUInteger(Value: string): uint;
    ToULong(Value: unknown): ulong;
    ToULong(Value: string): ulong;
    ToUShort(Value: unknown): ushort;
    ToUShort(Value: string): ushort;
};


export type Conversions = Conversions$instance;

export interface DateType$instance {
}


export const DateType: {
    new(): DateType$instance;
    FromObject(Value: unknown): DateTime;
    FromString(Value: string, culture: CultureInfo): DateTime;
    FromString(Value: string): DateTime;
};


export type DateType = DateType$instance;

export interface DecimalType$instance {
}


export const DecimalType: {
    new(): DecimalType$instance;
    FromBoolean(Value: boolean): decimal;
    FromObject(Value: unknown, NumberFormat: NumberFormatInfo): decimal;
    FromObject(Value: unknown): decimal;
    FromString(Value: string, NumberFormat: NumberFormatInfo): decimal;
    FromString(Value: string): decimal;
    Parse(Value: string, NumberFormat: NumberFormatInfo): decimal;
};


export type DecimalType = DecimalType$instance;

export interface DesignerGeneratedAttribute$instance extends Attribute {
}


export const DesignerGeneratedAttribute: {
    new(): DesignerGeneratedAttribute$instance;
};


export type DesignerGeneratedAttribute = DesignerGeneratedAttribute$instance;

export interface DoubleType$instance {
}


export const DoubleType: {
    new(): DoubleType$instance;
    FromObject(Value: unknown, NumberFormat: NumberFormatInfo): double;
    FromObject(Value: unknown): double;
    FromString(Value: string, NumberFormat: NumberFormatInfo): double;
    FromString(Value: string): double;
    Parse(Value: string, NumberFormat: NumberFormatInfo): double;
    Parse(Value: string): double;
};


export type DoubleType = DoubleType$instance;

export interface IncompleteInitialization$instance extends Exception {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const IncompleteInitialization: {
    new(): IncompleteInitialization$instance;
};


export interface __IncompleteInitialization$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type IncompleteInitialization = IncompleteInitialization$instance & __IncompleteInitialization$views;


export interface IntegerType$instance {
}


export const IntegerType: {
    new(): IntegerType$instance;
    FromObject(Value: unknown): int;
    FromString(Value: string): int;
};


export type IntegerType = IntegerType$instance;

export interface LateBinding$instance {
}


export const LateBinding: {
    new(): LateBinding$instance;
    LateCall(o: unknown, objType: Type, name: string, args: unknown[], paramnames: string[], CopyBack: boolean[]): void;
    LateGet(o: unknown, objType: Type, name: string, args: unknown[], paramnames: string[], CopyBack: boolean[]): unknown;
    LateIndexGet(o: unknown, args: unknown[], paramnames: string[]): unknown;
    LateIndexSet(o: unknown, args: unknown[], paramnames: string[]): void;
    LateIndexSetComplex(o: unknown, args: unknown[], paramnames: string[], OptimisticSet: boolean, RValueBase: boolean): void;
    LateSet(o: unknown, objType: Type, name: string, args: unknown[], paramnames: string[]): void;
    LateSetComplex(o: unknown, objType: Type, name: string, args: unknown[], paramnames: string[], OptimisticSet: boolean, RValueBase: boolean): void;
};


export type LateBinding = LateBinding$instance;

export interface LikeOperator$instance {
}


export const LikeOperator: {
    new(): LikeOperator$instance;
    LikeObject(Source: unknown, Pattern: unknown, CompareOption: CompareMethod): unknown;
    LikeString(Source: string, Pattern: string, CompareOption: CompareMethod): boolean;
};


export type LikeOperator = LikeOperator$instance;

export interface LongType$instance {
}


export const LongType: {
    new(): LongType$instance;
    FromObject(Value: unknown): long;
    FromString(Value: string): long;
};


export type LongType = LongType$instance;

export interface NewLateBinding$instance {
}


export const NewLateBinding: {
    new(): NewLateBinding$instance;
    FallbackCall(Instance: unknown, MemberName: string, Arguments: unknown[], ArgumentNames: string[], IgnoreReturn: boolean): unknown;
    FallbackGet(Instance: unknown, MemberName: string, Arguments: unknown[], ArgumentNames: string[]): unknown;
    FallbackIndexSet(Instance: unknown, Arguments: unknown[], ArgumentNames: string[]): void;
    FallbackIndexSetComplex(Instance: unknown, Arguments: unknown[], ArgumentNames: string[], OptimisticSet: boolean, RValueBase: boolean): void;
    FallbackInvokeDefault1(Instance: unknown, Arguments: unknown[], ArgumentNames: string[], ReportErrors: boolean): unknown;
    FallbackInvokeDefault2(Instance: unknown, Arguments: unknown[], ArgumentNames: string[], ReportErrors: boolean): unknown;
    FallbackSet(Instance: unknown, MemberName: string, Arguments: unknown[]): void;
    FallbackSetComplex(Instance: unknown, MemberName: string, Arguments: unknown[], OptimisticSet: boolean, RValueBase: boolean): void;
    LateCall(Instance: unknown, Type: Type, MemberName: string, Arguments: unknown[], ArgumentNames: string[], TypeArguments: Type[], CopyBack: boolean[], IgnoreReturn: boolean): unknown;
    LateCallInvokeDefault(Instance: unknown, Arguments: unknown[], ArgumentNames: string[], ReportErrors: boolean): unknown;
    LateGet(Instance: unknown, Type: Type, MemberName: string, Arguments: unknown[], ArgumentNames: string[], TypeArguments: Type[], CopyBack: boolean[]): unknown;
    LateGetInvokeDefault(Instance: unknown, Arguments: unknown[], ArgumentNames: string[], ReportErrors: boolean): unknown;
    LateIndexGet(Instance: unknown, Arguments: unknown[], ArgumentNames: string[]): unknown;
    LateIndexSet(Instance: unknown, Arguments: unknown[], ArgumentNames: string[]): void;
    LateIndexSetComplex(Instance: unknown, Arguments: unknown[], ArgumentNames: string[], OptimisticSet: boolean, RValueBase: boolean): void;
    LateSet(Instance: unknown, Type: Type, MemberName: string, Arguments: unknown[], ArgumentNames: string[], TypeArguments: Type[], OptimisticSet: boolean, RValueBase: boolean, CallType: CallType): void;
    LateSet(Instance: unknown, Type: Type, MemberName: string, Arguments: unknown[], ArgumentNames: string[], TypeArguments: Type[]): void;
    LateSetComplex(Instance: unknown, Type: Type, MemberName: string, Arguments: unknown[], ArgumentNames: string[], TypeArguments: Type[], OptimisticSet: boolean, RValueBase: boolean): void;
};


export type NewLateBinding = NewLateBinding$instance;

export interface ObjectFlowControl$instance {
}


export const ObjectFlowControl: {
    new(): ObjectFlowControl$instance;
    CheckForSyncLockOnValueType(Expression: unknown): void;
};


export type ObjectFlowControl = ObjectFlowControl$instance;

export interface ObjectFlowControl_ForLoopControl$instance {
}


export const ObjectFlowControl_ForLoopControl: {
    new(): ObjectFlowControl_ForLoopControl$instance;
    ForLoopInitObj(Counter: unknown, Start: unknown, Limit: unknown, StepValue: unknown, LoopForResult: unknown, CounterResult: unknown): boolean;
    ForNextCheckDec(count: decimal, limit: decimal, StepValue: decimal): boolean;
    ForNextCheckObj(Counter: unknown, LoopObj: unknown, CounterResult: unknown): boolean;
    ForNextCheckR4(count: float, limit: float, StepValue: float): boolean;
    ForNextCheckR8(count: double, limit: double, StepValue: double): boolean;
};


export type ObjectFlowControl_ForLoopControl = ObjectFlowControl_ForLoopControl$instance;

export interface ObjectType$instance {
}


export const ObjectType: {
    new(): ObjectType$instance;
    AddObj(o1: unknown, o2: unknown): unknown;
    BitAndObj(obj1: unknown, obj2: unknown): unknown;
    BitOrObj(obj1: unknown, obj2: unknown): unknown;
    BitXorObj(obj1: unknown, obj2: unknown): unknown;
    DivObj(o1: unknown, o2: unknown): unknown;
    GetObjectValuePrimitive(o: unknown): unknown;
    IDivObj(o1: unknown, o2: unknown): unknown;
    LikeObj(vLeft: unknown, vRight: unknown, CompareOption: CompareMethod): boolean;
    ModObj(o1: unknown, o2: unknown): unknown;
    MulObj(o1: unknown, o2: unknown): unknown;
    NegObj(obj: unknown): unknown;
    NotObj(obj: unknown): unknown;
    ObjTst(o1: unknown, o2: unknown, TextCompare: boolean): int;
    PlusObj(obj: unknown): unknown;
    PowObj(obj1: unknown, obj2: unknown): unknown;
    ShiftLeftObj(o1: unknown, amount: int): unknown;
    ShiftRightObj(o1: unknown, amount: int): unknown;
    StrCatObj(vLeft: unknown, vRight: unknown): unknown;
    SubObj(o1: unknown, o2: unknown): unknown;
    XorObj(obj1: unknown, obj2: unknown): unknown;
};


export type ObjectType = ObjectType$instance;

export interface Operators$instance {
}


export const Operators: {
    new(): Operators$instance;
    AddObject(Left: unknown, Right: unknown): unknown;
    AndObject(Left: unknown, Right: unknown): unknown;
    CompareObjectEqual(Left: unknown, Right: unknown, TextCompare: boolean): unknown;
    CompareObjectGreater(Left: unknown, Right: unknown, TextCompare: boolean): unknown;
    CompareObjectGreaterEqual(Left: unknown, Right: unknown, TextCompare: boolean): unknown;
    CompareObjectLess(Left: unknown, Right: unknown, TextCompare: boolean): unknown;
    CompareObjectLessEqual(Left: unknown, Right: unknown, TextCompare: boolean): unknown;
    CompareObjectNotEqual(Left: unknown, Right: unknown, TextCompare: boolean): unknown;
    CompareString(Left: string, Right: string, TextCompare: boolean): int;
    ConcatenateObject(Left: unknown, Right: unknown): unknown;
    ConditionalCompareObjectEqual(Left: unknown, Right: unknown, TextCompare: boolean): boolean;
    ConditionalCompareObjectGreater(Left: unknown, Right: unknown, TextCompare: boolean): boolean;
    ConditionalCompareObjectGreaterEqual(Left: unknown, Right: unknown, TextCompare: boolean): boolean;
    ConditionalCompareObjectLess(Left: unknown, Right: unknown, TextCompare: boolean): boolean;
    ConditionalCompareObjectLessEqual(Left: unknown, Right: unknown, TextCompare: boolean): boolean;
    ConditionalCompareObjectNotEqual(Left: unknown, Right: unknown, TextCompare: boolean): boolean;
    DivideObject(Left: unknown, Right: unknown): unknown;
    ExponentObject(Left: unknown, Right: unknown): unknown;
    FallbackInvokeUserDefinedOperator(vbOp: unknown, arguments: unknown[]): unknown;
    IntDivideObject(Left: unknown, Right: unknown): unknown;
    LeftShiftObject(Operand: unknown, Amount: unknown): unknown;
    ModObject(Left: unknown, Right: unknown): unknown;
    MultiplyObject(Left: unknown, Right: unknown): unknown;
    NegateObject(Operand: unknown): unknown;
    NotObject(Operand: unknown): unknown;
    OrObject(Left: unknown, Right: unknown): unknown;
    PlusObject(Operand: unknown): unknown;
    RightShiftObject(Operand: unknown, Amount: unknown): unknown;
    SubtractObject(Left: unknown, Right: unknown): unknown;
    XorObject(Left: unknown, Right: unknown): unknown;
};


export type Operators = Operators$instance;

export interface OptionCompareAttribute$instance extends Attribute {
}


export const OptionCompareAttribute: {
    new(): OptionCompareAttribute$instance;
};


export type OptionCompareAttribute = OptionCompareAttribute$instance;

export interface OptionTextAttribute$instance extends Attribute {
}


export const OptionTextAttribute: {
    new(): OptionTextAttribute$instance;
};


export type OptionTextAttribute = OptionTextAttribute$instance;

export interface ProjectData$instance {
}


export const ProjectData: {
    new(): ProjectData$instance;
    ClearProjectError(): void;
    CreateProjectError(hr: int): Exception;
    EndApp(): void;
    SetProjectError(ex: Exception, lErl: int): void;
    SetProjectError(ex: Exception): void;
};


export type ProjectData = ProjectData$instance;

export interface ShortType$instance {
}


export const ShortType: {
    new(): ShortType$instance;
    FromObject(Value: unknown): short;
    FromString(Value: string): short;
};


export type ShortType = ShortType$instance;

export interface SingleType$instance {
}


export const SingleType: {
    new(): SingleType$instance;
    FromObject(Value: unknown, NumberFormat: NumberFormatInfo): float;
    FromObject(Value: unknown): float;
    FromString(Value: string, NumberFormat: NumberFormatInfo): float;
    FromString(Value: string): float;
};


export type SingleType = SingleType$instance;

export interface StandardModuleAttribute$instance extends Attribute {
}


export const StandardModuleAttribute: {
    new(): StandardModuleAttribute$instance;
};


export type StandardModuleAttribute = StandardModuleAttribute$instance;

export interface StaticLocalInitFlag$instance {
    State: short;
}


export const StaticLocalInitFlag: {
    new(): StaticLocalInitFlag$instance;
};


export type StaticLocalInitFlag = StaticLocalInitFlag$instance;

export interface StringType$instance {
}


export const StringType: {
    new(): StringType$instance;
    FromBoolean(Value: boolean): string;
    FromByte(Value: byte): string;
    FromChar(Value: char): string;
    FromDate(Value: DateTime): string;
    FromDecimal(Value: decimal, NumberFormat: NumberFormatInfo): string;
    FromDecimal(Value: decimal): string;
    FromDouble(Value: double, NumberFormat: NumberFormatInfo): string;
    FromDouble(Value: double): string;
    FromInteger(Value: int): string;
    FromLong(Value: long): string;
    FromObject(Value: unknown): string;
    FromShort(Value: short): string;
    FromSingle(Value: float, NumberFormat: NumberFormatInfo): string;
    FromSingle(Value: float): string;
    MidStmtStr(sDest: string, StartPosition: int, MaxInsertLength: int, sInsert: string): void;
    StrCmp(sLeft: string, sRight: string, TextCompare: boolean): int;
    StrLike(Source: string, Pattern: string, CompareOption: CompareMethod): boolean;
    StrLikeBinary(Source: string, Pattern: string): boolean;
    StrLikeText(Source: string, Pattern: string): boolean;
};


export type StringType = StringType$instance;

export interface Utils$instance {
}


export const Utils: {
    new(): Utils$instance;
    CopyArray(arySrc: ClrArray, aryDest: ClrArray): ClrArray;
    GetResourceString(ResourceKey: string, ...Args: string[]): string;
};


export type Utils = Utils$instance;

export interface Versioned$instance {
}


export const Versioned: {
    new(): Versioned$instance;
    CallByName(Instance: unknown, MethodName: string, UseCallType: CallType, ...Arguments: unknown[]): unknown;
    IsNumeric(Expression: unknown): boolean;
    SystemTypeName(VbName: string): string;
    TypeName(Expression: unknown): string;
    VbTypeName(SystemName: string): string;
};


export type Versioned = Versioned$instance;


// Generated by tsbindgen - Architecture
// Namespace: System.Reflection
// Assembly: System.ObjectModel, System.Private.CoreLib, System.Reflection.DispatchProxy, System.Reflection.Metadata, System.Reflection.TypeExtensions

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { IEnumerable_1, IList_1 } from "../../System.Collections.Generic/internal/index.js";
import type { IDictionary } from "../../System.Collections/internal/index.js";
import type { AssemblyHashAlgorithm as AssemblyHashAlgorithm_Assemblies, AssemblyVersionCompatibility } from "../../System.Configuration.Assemblies/internal/index.js";
import type { CultureInfo } from "../../System.Globalization/internal/index.js";
import type { FileStream, Stream } from "../../System.IO/internal/index.js";
import type { StructLayoutAttribute } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, IObjectReference, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { SecurityRuleSet } from "../../System.Security/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { ApplicationException, Array as ClrArray, AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Delegate, Enum, Exception, FormatException, Guid, IAsyncResult, ICloneable, IComparable, IConvertible, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, MarshalByRefObject, ModuleHandle, MulticastDelegate, Object as ClrObject, ResolveEventArgs, RuntimeFieldHandle, RuntimeMethodHandle, RuntimeTypeHandle, Span_1, String as ClrString, SystemException, Type, TypeCode, TypedReference, UInt32, ValueType, Version, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum AssemblyContentType {
    Default = 0,
    WindowsRuntime = 1
}


export enum AssemblyFlags {
    PublicKey = 1,
    Retargetable = 256,
    WindowsRuntime = 512,
    ContentTypeMask = 3584,
    DisableJitCompileOptimizer = 16384,
    EnableJitCompileTracking = 32768
}


export enum AssemblyHashAlgorithm {
    None = 0,
    MD5 = 32771,
    Sha1 = 32772,
    Sha256 = 32780,
    Sha384 = 32781,
    Sha512 = 32782
}


export enum AssemblyNameFlags {
    None = 0,
    PublicKey = 1,
    EnableJITcompileOptimizer = 16384,
    EnableJITcompileTracking = 32768,
    Retargetable = 256
}


export enum BindingFlags {
    Default = 0,
    IgnoreCase = 1,
    DeclaredOnly = 2,
    Instance = 4,
    Static = 8,
    Public = 16,
    NonPublic = 32,
    FlattenHierarchy = 64,
    InvokeMethod = 256,
    CreateInstance = 512,
    GetField = 1024,
    SetField = 2048,
    GetProperty = 4096,
    SetProperty = 8192,
    PutDispProperty = 16384,
    PutRefDispProperty = 32768,
    ExactBinding = 65536,
    SuppressChangeType = 131072,
    OptionalParamBinding = 262144,
    IgnoreReturn = 16777216,
    DoNotWrapExceptions = 33554432
}


export enum CallingConventions {
    Standard = 1,
    VarArgs = 2,
    Any = 3,
    HasThis = 32,
    ExplicitThis = 64
}


export enum DeclarativeSecurityAction {
    None = 0,
    Demand = 2,
    Assert = 3,
    Deny = 4,
    PermitOnly = 5,
    LinkDemand = 6,
    InheritanceDemand = 7,
    RequestMinimum = 8,
    RequestOptional = 9,
    RequestRefuse = 10
}


export enum EventAttributes {
    None = 0,
    SpecialName = 512,
    RTSpecialName = 1024,
    ReservedMask = 1024
}


export enum ExceptionHandlingClauseOptions {
    Clause = 0,
    Filter = 1,
    Finally = 2,
    Fault = 4
}


export enum FieldAttributes {
    FieldAccessMask = 7,
    PrivateScope = 0,
    Private = 1,
    FamANDAssem = 2,
    Assembly = 3,
    Family = 4,
    FamORAssem = 5,
    Public = 6,
    Static = 16,
    InitOnly = 32,
    Literal = 64,
    NotSerialized = 128,
    SpecialName = 512,
    PinvokeImpl = 8192,
    RTSpecialName = 1024,
    HasFieldMarshal = 4096,
    HasDefault = 32768,
    HasFieldRVA = 256,
    ReservedMask = 38144
}


export enum GenericParameterAttributes {
    None = 0,
    VarianceMask = 3,
    Covariant = 1,
    Contravariant = 2,
    SpecialConstraintMask = 28,
    ReferenceTypeConstraint = 4,
    NotNullableValueTypeConstraint = 8,
    DefaultConstructorConstraint = 16,
    AllowByRefLike = 32
}


export enum ImageFileMachine {
    I386 = 332,
    IA64 = 512,
    AMD64 = 34404,
    ARM = 452
}


export enum ManifestResourceAttributes {
    Public = 1,
    Private = 2,
    VisibilityMask = 7
}


export enum MemberTypes {
    Constructor = 1,
    Event = 2,
    Field = 4,
    Method = 8,
    Property = 16,
    TypeInfo = 32,
    Custom = 64,
    NestedType = 128,
    All = 191
}


export enum MethodAttributes {
    MemberAccessMask = 7,
    PrivateScope = 0,
    Private = 1,
    FamANDAssem = 2,
    Assembly = 3,
    Family = 4,
    FamORAssem = 5,
    Public = 6,
    Static = 16,
    Final = 32,
    Virtual = 64,
    HideBySig = 128,
    CheckAccessOnOverride = 512,
    VtableLayoutMask = 256,
    ReuseSlot = 0,
    NewSlot = 256,
    Abstract = 1024,
    SpecialName = 2048,
    PinvokeImpl = 8192,
    UnmanagedExport = 8,
    RTSpecialName = 4096,
    HasSecurity = 16384,
    RequireSecObject = 32768,
    ReservedMask = 53248
}


export enum MethodImplAttributes {
    CodeTypeMask = 3,
    IL = 0,
    Native = 1,
    OPTIL = 2,
    Runtime = 3,
    ManagedMask = 4,
    Unmanaged = 4,
    Managed = 0,
    ForwardRef = 16,
    PreserveSig = 128,
    InternalCall = 4096,
    Synchronized = 32,
    NoInlining = 8,
    AggressiveInlining = 256,
    NoOptimization = 64,
    AggressiveOptimization = 512,
    Async = 8192,
    MaxMethodImplVal = 65535
}


export enum MethodImportAttributes {
    None = 0,
    ExactSpelling = 1,
    BestFitMappingDisable = 32,
    BestFitMappingEnable = 16,
    BestFitMappingMask = 48,
    CharSetAnsi = 2,
    CharSetUnicode = 4,
    CharSetAuto = 6,
    CharSetMask = 6,
    ThrowOnUnmappableCharEnable = 4096,
    ThrowOnUnmappableCharDisable = 8192,
    ThrowOnUnmappableCharMask = 12288,
    SetLastError = 64,
    CallingConventionWinApi = 256,
    CallingConventionCDecl = 512,
    CallingConventionStdCall = 768,
    CallingConventionThisCall = 1024,
    CallingConventionFastCall = 1280,
    CallingConventionMask = 1792
}


export enum MethodSemanticsAttributes {
    Setter = 1,
    Getter = 2,
    Other = 4,
    Adder = 8,
    Remover = 16,
    Raiser = 32
}


export enum NullabilityState {
    Unknown = 0,
    NotNull = 1,
    Nullable = 2
}


export enum ParameterAttributes {
    None = 0,
    In = 1,
    Out = 2,
    Lcid = 4,
    Retval = 8,
    Optional = 16,
    HasDefault = 4096,
    HasFieldMarshal = 8192,
    Reserved3 = 16384,
    Reserved4 = 32768,
    ReservedMask = 61440
}


export enum PortableExecutableKinds {
    NotAPortableExecutableImage = 0,
    ILOnly = 1,
    Required32Bit = 2,
    PE32Plus = 4,
    Unmanaged32Bit = 8,
    Preferred32Bit = 16
}


export enum ProcessorArchitecture {
    None = 0,
    MSIL = 1,
    X86 = 2,
    IA64 = 3,
    Amd64 = 4,
    Arm = 5
}


export enum PropertyAttributes {
    None = 0,
    SpecialName = 512,
    RTSpecialName = 1024,
    HasDefault = 4096,
    Reserved2 = 8192,
    Reserved3 = 16384,
    Reserved4 = 32768,
    ReservedMask = 62464
}


export enum ResourceAttributes {
    Public = 1,
    Private = 2
}


export enum ResourceLocation {
    ContainedInAnotherAssembly = 2,
    ContainedInManifestFile = 4,
    Embedded = 1
}


export enum TypeAttributes {
    VisibilityMask = 7,
    NotPublic = 0,
    Public = 1,
    NestedPublic = 2,
    NestedPrivate = 3,
    NestedFamily = 4,
    NestedAssembly = 5,
    NestedFamANDAssem = 6,
    NestedFamORAssem = 7,
    LayoutMask = 24,
    AutoLayout = 0,
    SequentialLayout = 8,
    ExplicitLayout = 16,
    ClassSemanticsMask = 32,
    Class = 0,
    Interface = 32,
    Abstract = 128,
    Sealed = 256,
    SpecialName = 1024,
    Import = 4096,
    Serializable = 8192,
    WindowsRuntime = 16384,
    StringFormatMask = 196608,
    AnsiClass = 0,
    UnicodeClass = 65536,
    AutoClass = 131072,
    CustomFormatClass = 196608,
    CustomFormatMask = 12582912,
    BeforeFieldInit = 1048576,
    RTSpecialName = 2048,
    HasSecurity = 262144,
    ReservedMask = 264192
}


export type MemberFilter = (m: MemberInfo, filterCriteria: unknown) => boolean;


export type ModuleResolveEventHandler = (sender: unknown, e: ResolveEventArgs) => Module;


export type TypeFilter = (m: Type, filterCriteria: unknown) => boolean;


export interface ICustomAttributeProvider$instance {
    GetCustomAttributes(inherit: boolean): unknown[];
    GetCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    IsDefined(attributeType: Type, inherit: boolean): boolean;
}


export type ICustomAttributeProvider = ICustomAttributeProvider$instance;

export interface ICustomTypeProvider$instance {
    GetCustomType(): Type;
}


export type ICustomTypeProvider = ICustomTypeProvider$instance;

export interface IReflect$instance {
    readonly UnderlyingSystemType: Type;
    GetField(name: string, bindingAttr: BindingFlags): FieldInfo;
    GetFields(bindingAttr: BindingFlags): FieldInfo[];
    GetMember(name: string, bindingAttr: BindingFlags): MemberInfo[];
    GetMembers(bindingAttr: BindingFlags): MemberInfo[];
    GetMethod(name: string, bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, bindingAttr: BindingFlags): MethodInfo;
    GetMethods(bindingAttr: BindingFlags): MethodInfo[];
    GetProperties(bindingAttr: BindingFlags): PropertyInfo[];
    GetProperty(name: string, bindingAttr: BindingFlags, binder: Binder, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
    GetProperty(name: string, bindingAttr: BindingFlags): PropertyInfo;
    InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: unknown, args: unknown[], modifiers: ParameterModifier[], culture: CultureInfo, namedParameters: string[]): unknown;
}


export type IReflect = IReflect$instance;

export interface IReflectableType$instance {
    GetTypeInfo(): TypeInfo;
}


export type IReflectableType = IReflectableType$instance;

export interface CustomAttributeNamedArgument$instance {
    readonly IsField: boolean;
    readonly MemberInfo: MemberInfo;
    readonly MemberName: string;
    readonly TypedValue: CustomAttributeTypedArgument;
    Equals(obj: unknown): boolean;
    Equals(other: CustomAttributeNamedArgument): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const CustomAttributeNamedArgument: {
    new(memberInfo: MemberInfo, value: unknown): CustomAttributeNamedArgument$instance;
    new(memberInfo: MemberInfo, typedArgument: CustomAttributeTypedArgument): CustomAttributeNamedArgument$instance;
};


export interface __CustomAttributeNamedArgument$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CustomAttributeNamedArgument>;

    // Structural method bridges for numeric interface constraints
    equals(other: CustomAttributeNamedArgument): boolean;
}

export type CustomAttributeNamedArgument = CustomAttributeNamedArgument$instance & __CustomAttributeNamedArgument$views;


export interface CustomAttributeTypedArgument$instance {
    readonly ArgumentType: Type;
    readonly Value: unknown;
    Equals(obj: unknown): boolean;
    Equals(other: CustomAttributeTypedArgument): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const CustomAttributeTypedArgument: {
    new(argumentType: Type, value: unknown): CustomAttributeTypedArgument$instance;
    new(value: unknown): CustomAttributeTypedArgument$instance;
};


export interface __CustomAttributeTypedArgument$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CustomAttributeTypedArgument>;

    // Structural method bridges for numeric interface constraints
    equals(other: CustomAttributeTypedArgument): boolean;
}

export type CustomAttributeTypedArgument = CustomAttributeTypedArgument$instance & __CustomAttributeTypedArgument$views;


export interface InterfaceMapping$instance {
    TargetType: Type;
    InterfaceType: Type;
    TargetMethods: MethodInfo[];
    InterfaceMethods: MethodInfo[];
}


export const InterfaceMapping: {
    new(): InterfaceMapping$instance;
};


export type InterfaceMapping = InterfaceMapping$instance;

export interface ParameterModifier$instance {
    Item: boolean;
}


export const ParameterModifier: {
    new(parameterCount: int): ParameterModifier$instance;
};


export type ParameterModifier = ParameterModifier$instance;

export interface AmbiguousMatchException$instance extends SystemException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const AmbiguousMatchException: {
    new(): AmbiguousMatchException$instance;
    new(message: string): AmbiguousMatchException$instance;
    new(message: string, inner: Exception): AmbiguousMatchException$instance;
};


export interface __AmbiguousMatchException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AmbiguousMatchException = AmbiguousMatchException$instance & __AmbiguousMatchException$views;


export interface Assembly$instance {
    readonly CodeBase: string;
    readonly CustomAttributes: IEnumerable_1<CustomAttributeData>;
    readonly DefinedTypes: IEnumerable_1<TypeInfo>;
    readonly EntryPoint: MethodInfo;
    readonly EscapedCodeBase: string;
    readonly ExportedTypes: IEnumerable_1<Type>;
    readonly FullName: string;
    readonly GlobalAssemblyCache: boolean;
    readonly HostContext: long;
    readonly ImageRuntimeVersion: string;
    readonly IsCollectible: boolean;
    readonly IsDynamic: boolean;
    readonly IsFullyTrusted: boolean;
    readonly Location: string;
    readonly ManifestModule: Module;
    readonly Modules: IEnumerable_1<Module>;
    readonly ReflectionOnly: boolean;
    readonly SecurityRuleSet: SecurityRuleSet;
    CreateInstance(typeName: string): unknown;
    CreateInstance(typeName: string, ignoreCase: boolean): unknown;
    CreateInstance(typeName: string, ignoreCase: boolean, bindingAttr: BindingFlags, binder: Binder, args: unknown[], culture: CultureInfo, activationAttributes: unknown[]): unknown;
    Equals(o: unknown): boolean;
    GetCustomAttributes(inherit: boolean): unknown[];
    GetCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    GetCustomAttributesData(): IList_1<CustomAttributeData>;
    GetExportedTypes(): Type[];
    GetFile(name: string): FileStream;
    GetFiles(): FileStream[];
    GetFiles(getResourceModules: boolean): FileStream[];
    GetForwardedTypes(): Type[];
    GetHashCode(): int;
    GetLoadedModules(): Module[];
    GetLoadedModules(getResourceModules: boolean): Module[];
    GetManifestResourceInfo(resourceName: string): ManifestResourceInfo;
    GetManifestResourceNames(): string[];
    GetManifestResourceStream(name: string): Stream;
    GetManifestResourceStream(type_: Type, name: string): Stream;
    GetModule(name: string): Module;
    GetModules(): Module[];
    GetModules(getResourceModules: boolean): Module[];
    GetName(): AssemblyName;
    GetName(copiedName: boolean): AssemblyName;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    GetReferencedAssemblies(): AssemblyName[];
    GetSatelliteAssembly(culture: CultureInfo): Assembly;
    GetSatelliteAssembly(culture: CultureInfo, version: Version): Assembly;
    GetType(name: string): Type;
    GetType(name: string, throwOnError: boolean): Type;
    GetType(name: string, throwOnError: boolean, ignoreCase: boolean): Type;
    GetTypes(): Type[];
    IsDefined(attributeType: Type, inherit: boolean): boolean;
    LoadModule(moduleName: string, rawModule: byte[]): Module;
    LoadModule(moduleName: string, rawModule: byte[], rawSymbolStore: byte[]): Module;
    ToString(): string;
}


export const Assembly: {
    CreateQualifiedName(assemblyName: string, typeName: string): string;
    GetAssembly(type_: Type): Assembly;
    GetCallingAssembly(): Assembly;
    GetEntryAssembly(): Assembly;
    GetExecutingAssembly(): Assembly;
    Load(rawAssembly: byte[], rawSymbolStore: byte[]): Assembly;
    Load(rawAssembly: byte[]): Assembly;
    Load(assemblyRef: AssemblyName): Assembly;
    Load(assemblyString: string): Assembly;
    LoadFile(path: string): Assembly;
    LoadFrom(assemblyFile: string, hashValue: byte[], hashAlgorithm: AssemblyHashAlgorithm_Assemblies): Assembly;
    LoadFrom(assemblyFile: string): Assembly;
    LoadWithPartialName(partialName: string): Assembly;
    ReflectionOnlyLoad(rawAssembly: byte[]): Assembly;
    ReflectionOnlyLoad(assemblyString: string): Assembly;
    ReflectionOnlyLoadFrom(assemblyFile: string): Assembly;
    SetEntryAssembly(assembly: Assembly): void;
    UnsafeLoadFrom(assemblyFile: string): Assembly;
};


export interface __Assembly$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Assembly$instance extends ICustomAttributeProvider$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Assembly = Assembly$instance & __Assembly$views;


export interface AssemblyAlgorithmIdAttribute$instance extends Attribute {
    readonly AlgorithmId: uint;
}


export const AssemblyAlgorithmIdAttribute: {
    new(algorithmId: AssemblyHashAlgorithm_Assemblies): AssemblyAlgorithmIdAttribute$instance;
    new(algorithmId: uint): AssemblyAlgorithmIdAttribute$instance;
};


export type AssemblyAlgorithmIdAttribute = AssemblyAlgorithmIdAttribute$instance;

export interface AssemblyCompanyAttribute$instance extends Attribute {
    readonly Company: string;
}


export const AssemblyCompanyAttribute: {
    new(company: string): AssemblyCompanyAttribute$instance;
};


export type AssemblyCompanyAttribute = AssemblyCompanyAttribute$instance;

export interface AssemblyConfigurationAttribute$instance extends Attribute {
    readonly Configuration: string;
}


export const AssemblyConfigurationAttribute: {
    new(configuration: string): AssemblyConfigurationAttribute$instance;
};


export type AssemblyConfigurationAttribute = AssemblyConfigurationAttribute$instance;

export interface AssemblyCopyrightAttribute$instance extends Attribute {
    readonly Copyright: string;
}


export const AssemblyCopyrightAttribute: {
    new(copyright: string): AssemblyCopyrightAttribute$instance;
};


export type AssemblyCopyrightAttribute = AssemblyCopyrightAttribute$instance;

export interface AssemblyCultureAttribute$instance extends Attribute {
    readonly Culture: string;
}


export const AssemblyCultureAttribute: {
    new(culture: string): AssemblyCultureAttribute$instance;
};


export type AssemblyCultureAttribute = AssemblyCultureAttribute$instance;

export interface AssemblyDefaultAliasAttribute$instance extends Attribute {
    readonly DefaultAlias: string;
}


export const AssemblyDefaultAliasAttribute: {
    new(defaultAlias: string): AssemblyDefaultAliasAttribute$instance;
};


export type AssemblyDefaultAliasAttribute = AssemblyDefaultAliasAttribute$instance;

export interface AssemblyDelaySignAttribute$instance extends Attribute {
    readonly DelaySign: boolean;
}


export const AssemblyDelaySignAttribute: {
    new(delaySign: boolean): AssemblyDelaySignAttribute$instance;
};


export type AssemblyDelaySignAttribute = AssemblyDelaySignAttribute$instance;

export interface AssemblyDescriptionAttribute$instance extends Attribute {
    readonly Description: string;
}


export const AssemblyDescriptionAttribute: {
    new(description: string): AssemblyDescriptionAttribute$instance;
};


export type AssemblyDescriptionAttribute = AssemblyDescriptionAttribute$instance;

export interface AssemblyFileVersionAttribute$instance extends Attribute {
    readonly Version: string;
}


export const AssemblyFileVersionAttribute: {
    new(version: string): AssemblyFileVersionAttribute$instance;
};


export type AssemblyFileVersionAttribute = AssemblyFileVersionAttribute$instance;

export interface AssemblyFlagsAttribute$instance extends Attribute {
    readonly AssemblyFlags: int;
    readonly Flags: uint;
}


export const AssemblyFlagsAttribute: {
    new(flags: uint): AssemblyFlagsAttribute$instance;
    new(assemblyFlags: int): AssemblyFlagsAttribute$instance;
    new(assemblyFlags: AssemblyNameFlags): AssemblyFlagsAttribute$instance;
};


export type AssemblyFlagsAttribute = AssemblyFlagsAttribute$instance;

export interface AssemblyInformationalVersionAttribute$instance extends Attribute {
    readonly InformationalVersion: string;
}


export const AssemblyInformationalVersionAttribute: {
    new(informationalVersion: string): AssemblyInformationalVersionAttribute$instance;
};


export type AssemblyInformationalVersionAttribute = AssemblyInformationalVersionAttribute$instance;

export interface AssemblyKeyFileAttribute$instance extends Attribute {
    readonly KeyFile: string;
}


export const AssemblyKeyFileAttribute: {
    new(keyFile: string): AssemblyKeyFileAttribute$instance;
};


export type AssemblyKeyFileAttribute = AssemblyKeyFileAttribute$instance;

export interface AssemblyKeyNameAttribute$instance extends Attribute {
    readonly KeyName: string;
}


export const AssemblyKeyNameAttribute: {
    new(keyName: string): AssemblyKeyNameAttribute$instance;
};


export type AssemblyKeyNameAttribute = AssemblyKeyNameAttribute$instance;

export interface AssemblyMetadataAttribute$instance extends Attribute {
    readonly Key: string;
    readonly Value: string;
}


export const AssemblyMetadataAttribute: {
    new(key: string, value: string): AssemblyMetadataAttribute$instance;
};


export type AssemblyMetadataAttribute = AssemblyMetadataAttribute$instance;

export interface AssemblyName$instance {
    CodeBase: string;
    ContentType: AssemblyContentType;
    CultureInfo: CultureInfo;
    CultureName: string;
    readonly EscapedCodeBase: string;
    Flags: AssemblyNameFlags;
    readonly FullName: string;
    HashAlgorithm: AssemblyHashAlgorithm_Assemblies;
    KeyPair: StrongNameKeyPair;
    Name: string;
    ProcessorArchitecture: ProcessorArchitecture;
    Version: Version;
    VersionCompatibility: AssemblyVersionCompatibility;
    Clone(): unknown;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    GetPublicKey(): byte[];
    GetPublicKeyToken(): byte[];
    OnDeserialization(sender: unknown): void;
    SetPublicKey(publicKey: byte[]): void;
    SetPublicKeyToken(publicKeyToken: byte[]): void;
    ToString(): string;
}


export const AssemblyName: {
    new(assemblyName: string): AssemblyName$instance;
    new(): AssemblyName$instance;
    GetAssemblyName(assemblyFile: string): AssemblyName;
    ReferenceMatchesDefinition(reference: AssemblyName, definition: AssemblyName): boolean;
};


export interface __AssemblyName$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface AssemblyName$instance extends System_Internal.ICloneable$instance, System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type AssemblyName = AssemblyName$instance & __AssemblyName$views;


export interface AssemblyNameProxy$instance extends MarshalByRefObject {
    GetAssemblyName(assemblyFile: string): AssemblyName;
}


export const AssemblyNameProxy: {
    new(): AssemblyNameProxy$instance;
};


export type AssemblyNameProxy = AssemblyNameProxy$instance;

export interface AssemblyProductAttribute$instance extends Attribute {
    readonly Product: string;
}


export const AssemblyProductAttribute: {
    new(product: string): AssemblyProductAttribute$instance;
};


export type AssemblyProductAttribute = AssemblyProductAttribute$instance;

export interface AssemblySignatureKeyAttribute$instance extends Attribute {
    readonly Countersignature: string;
    readonly PublicKey: string;
}


export const AssemblySignatureKeyAttribute: {
    new(publicKey: string, countersignature: string): AssemblySignatureKeyAttribute$instance;
};


export type AssemblySignatureKeyAttribute = AssemblySignatureKeyAttribute$instance;

export interface AssemblyTitleAttribute$instance extends Attribute {
    readonly Title: string;
}


export const AssemblyTitleAttribute: {
    new(title: string): AssemblyTitleAttribute$instance;
};


export type AssemblyTitleAttribute = AssemblyTitleAttribute$instance;

export interface AssemblyTrademarkAttribute$instance extends Attribute {
    readonly Trademark: string;
}


export const AssemblyTrademarkAttribute: {
    new(trademark: string): AssemblyTrademarkAttribute$instance;
};


export type AssemblyTrademarkAttribute = AssemblyTrademarkAttribute$instance;

export interface AssemblyVersionAttribute$instance extends Attribute {
    readonly Version: string;
}


export const AssemblyVersionAttribute: {
    new(version: string): AssemblyVersionAttribute$instance;
};


export type AssemblyVersionAttribute = AssemblyVersionAttribute$instance;

export interface Binder$instance {
    BindToField(bindingAttr: BindingFlags, match: FieldInfo[], value: unknown, culture: CultureInfo): FieldInfo;
    BindToMethod(bindingAttr: BindingFlags, match: MethodBase[], args: { value: ref<unknown[]> }, modifiers: ParameterModifier[], culture: CultureInfo, names: string[], state: { value: ref<unknown> }): MethodBase;
    ChangeType(value: unknown, type_: Type, culture: CultureInfo): unknown;
    ReorderArgumentArray(args: { value: ref<unknown[]> }, state: unknown): void;
    SelectMethod(bindingAttr: BindingFlags, match: MethodBase[], types: Type[], modifiers: ParameterModifier[]): MethodBase;
    SelectProperty(bindingAttr: BindingFlags, match: PropertyInfo[], returnType: Type, indexes: Type[], modifiers: ParameterModifier[]): PropertyInfo;
}


export const Binder: {
};


export type Binder = Binder$instance;

export interface ConstructorInfo$instance extends MethodBase$instance {
    readonly MemberType: MemberTypes;
    Equals(obj: unknown): boolean;
    GetCustomAttributes(inherit: boolean): unknown[];
    GetCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    GetHashCode(): int;
    Invoke(obj: unknown, parameters: unknown[]): unknown;
    Invoke(obj: unknown, invokeAttr: BindingFlags, binder: Binder, parameters: unknown[], culture: CultureInfo): unknown;
    IsDefined(attributeType: Type, inherit: boolean): boolean;
}


export const ConstructorInfo: {
    readonly ConstructorName: string;
    readonly TypeConstructorName: string;
};


export interface __ConstructorInfo$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
}

export type ConstructorInfo = ConstructorInfo$instance & __ConstructorInfo$views;


export interface ConstructorInvoker$instance {
    Invoke(): unknown;
    Invoke(arg1: unknown): unknown;
    Invoke(arg1: unknown, arg2: unknown): unknown;
    Invoke(arg1: unknown, arg2: unknown, arg3: unknown): unknown;
    Invoke(arg1: unknown, arg2: unknown, arg3: unknown, arg4: unknown): unknown;
    Invoke(arguments: Span_1<unknown>): unknown;
}


export const ConstructorInvoker: {
    new(): ConstructorInvoker$instance;
    Create(constructor_: ConstructorInfo): ConstructorInvoker;
};


export type ConstructorInvoker = ConstructorInvoker$instance;

export interface CustomAttributeData$instance {
    readonly AttributeType: Type;
    readonly Constructor: ConstructorInfo;
    readonly ConstructorArguments: IList_1<CustomAttributeTypedArgument>;
    readonly NamedArguments: IList_1<CustomAttributeNamedArgument>;
    ToString(): string;
}


export const CustomAttributeData: {
    new(): CustomAttributeData$instance;
    GetCustomAttributes(target: Assembly): IList_1<CustomAttributeData>;
    GetCustomAttributes(target: MemberInfo): IList_1<CustomAttributeData>;
    GetCustomAttributes(target: Module): IList_1<CustomAttributeData>;
    GetCustomAttributes(target: ParameterInfo): IList_1<CustomAttributeData>;
};


export type CustomAttributeData = CustomAttributeData$instance;

export interface CustomAttributeFormatException$instance extends FormatException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const CustomAttributeFormatException: {
    new(): CustomAttributeFormatException$instance;
    new(message: string): CustomAttributeFormatException$instance;
    new(message: string, inner: Exception): CustomAttributeFormatException$instance;
};


export interface __CustomAttributeFormatException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type CustomAttributeFormatException = CustomAttributeFormatException$instance & __CustomAttributeFormatException$views;


export interface DefaultMemberAttribute$instance extends Attribute {
    readonly MemberName: string;
}


export const DefaultMemberAttribute: {
    new(memberName: string): DefaultMemberAttribute$instance;
};


export type DefaultMemberAttribute = DefaultMemberAttribute$instance;

export interface DispatchProxy$instance {
}


export const DispatchProxy: {
    Create<T, TProxy extends DispatchProxy>(): T;
    Create(interfaceType: Type, proxyType: Type): unknown;
};


export type DispatchProxy = DispatchProxy$instance;

export interface EventInfo$instance extends MemberInfo$instance {
    readonly AddMethod: MethodInfo;
    readonly Attributes: EventAttributes;
    readonly EventHandlerType: Type;
    readonly IsMulticast: boolean;
    readonly IsSpecialName: boolean;
    readonly MemberType: MemberTypes;
    readonly RaiseMethod: MethodInfo;
    readonly RemoveMethod: MethodInfo;
    AddEventHandler(target: unknown, handler: Function): void;
    Equals(obj: unknown): boolean;
    GetAddMethod(): MethodInfo;
    GetAddMethod(nonPublic: boolean): MethodInfo;
    GetCustomAttributes(inherit: boolean): unknown[];
    GetCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    GetHashCode(): int;
    GetOtherMethods(): MethodInfo[];
    GetOtherMethods(nonPublic: boolean): MethodInfo[];
    GetRaiseMethod(): MethodInfo;
    GetRaiseMethod(nonPublic: boolean): MethodInfo;
    GetRemoveMethod(): MethodInfo;
    GetRemoveMethod(nonPublic: boolean): MethodInfo;
    IsDefined(attributeType: Type, inherit: boolean): boolean;
    RemoveEventHandler(target: unknown, handler: Function): void;
}


export const EventInfo: {
};


export interface __EventInfo$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
}

export type EventInfo = EventInfo$instance & __EventInfo$views;


export interface ExceptionHandlingClause$instance {
    readonly CatchType: Type;
    readonly FilterOffset: int;
    readonly Flags: ExceptionHandlingClauseOptions;
    readonly HandlerLength: int;
    readonly HandlerOffset: int;
    readonly TryLength: int;
    readonly TryOffset: int;
    ToString(): string;
}


export const ExceptionHandlingClause: {
    new(): ExceptionHandlingClause$instance;
};


export type ExceptionHandlingClause = ExceptionHandlingClause$instance;

export interface FieldInfo$instance extends MemberInfo$instance {
    readonly Attributes: FieldAttributes;
    readonly FieldHandle: RuntimeFieldHandle;
    readonly FieldType: Type;
    readonly IsAssembly: boolean;
    readonly IsFamily: boolean;
    readonly IsFamilyAndAssembly: boolean;
    readonly IsFamilyOrAssembly: boolean;
    readonly IsInitOnly: boolean;
    readonly IsLiteral: boolean;
    readonly IsNotSerialized: boolean;
    readonly IsPinvokeImpl: boolean;
    readonly IsPrivate: boolean;
    readonly IsPublic: boolean;
    readonly IsSecurityCritical: boolean;
    readonly IsSecuritySafeCritical: boolean;
    readonly IsSecurityTransparent: boolean;
    readonly IsSpecialName: boolean;
    readonly IsStatic: boolean;
    readonly MemberType: MemberTypes;
    Equals(obj: unknown): boolean;
    GetCustomAttributes(inherit: boolean): unknown[];
    GetCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    GetHashCode(): int;
    GetModifiedFieldType(): Type;
    GetOptionalCustomModifiers(): Type[];
    GetRawConstantValue(): unknown;
    GetRequiredCustomModifiers(): Type[];
    GetValue(obj: unknown): unknown;
    GetValueDirect(obj: TypedReference): unknown;
    IsDefined(attributeType: Type, inherit: boolean): boolean;
    SetValue(obj: unknown, value: unknown): void;
    SetValue(obj: unknown, value: unknown, invokeAttr: BindingFlags, binder: Binder, culture: CultureInfo): void;
    SetValueDirect(obj: TypedReference, value: unknown): void;
}


export const FieldInfo: {
    GetFieldFromHandle(handle: RuntimeFieldHandle, declaringType: RuntimeTypeHandle): FieldInfo;
    GetFieldFromHandle(handle: RuntimeFieldHandle): FieldInfo;
};


export interface __FieldInfo$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
}

export type FieldInfo = FieldInfo$instance & __FieldInfo$views;


export interface InvalidFilterCriteriaException$instance extends ApplicationException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const InvalidFilterCriteriaException: {
    new(): InvalidFilterCriteriaException$instance;
    new(message: string): InvalidFilterCriteriaException$instance;
    new(message: string, inner: Exception): InvalidFilterCriteriaException$instance;
};


export interface __InvalidFilterCriteriaException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidFilterCriteriaException = InvalidFilterCriteriaException$instance & __InvalidFilterCriteriaException$views;


export interface LocalVariableInfo$instance {
    readonly IsPinned: boolean;
    readonly LocalIndex: int;
    readonly LocalType: Type;
    ToString(): string;
}


export const LocalVariableInfo: {
    new(): LocalVariableInfo$instance;
};


export type LocalVariableInfo = LocalVariableInfo$instance;

export interface ManifestResourceInfo$instance {
    readonly FileName: string;
    readonly ReferencedAssembly: Assembly;
    readonly ResourceLocation: ResourceLocation;
}


export const ManifestResourceInfo: {
    new(containingAssembly: Assembly, containingFileName: string, resourceLocation: ResourceLocation): ManifestResourceInfo$instance;
};


export type ManifestResourceInfo = ManifestResourceInfo$instance;

export interface MemberInfo$instance {
    readonly CustomAttributes: IEnumerable_1<CustomAttributeData>;
    readonly DeclaringType: Type;
    readonly IsCollectible: boolean;
    readonly MemberType: MemberTypes;
    readonly MetadataToken: int;
    readonly Module: Module;
    readonly Name: string;
    readonly ReflectedType: Type;
    Equals(obj: unknown): boolean;
    GetCustomAttributes(inherit: boolean): unknown[];
    GetCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    GetCustomAttributesData(): IList_1<CustomAttributeData>;
    GetHashCode(): int;
    HasSameMetadataDefinitionAs(other: MemberInfo): boolean;
    IsDefined(attributeType: Type, inherit: boolean): boolean;
}


export const MemberInfo: {
};


export interface __MemberInfo$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
}

export interface MemberInfo$instance extends ICustomAttributeProvider$instance {}

export type MemberInfo = MemberInfo$instance & __MemberInfo$views;


export interface MethodBase$instance extends MemberInfo$instance {
    readonly Attributes: MethodAttributes;
    readonly CallingConvention: CallingConventions;
    readonly ContainsGenericParameters: boolean;
    readonly IsAbstract: boolean;
    readonly IsAssembly: boolean;
    readonly IsConstructedGenericMethod: boolean;
    readonly IsConstructor: boolean;
    readonly IsFamily: boolean;
    readonly IsFamilyAndAssembly: boolean;
    readonly IsFamilyOrAssembly: boolean;
    readonly IsFinal: boolean;
    readonly IsGenericMethod: boolean;
    readonly IsGenericMethodDefinition: boolean;
    readonly IsHideBySig: boolean;
    readonly IsPrivate: boolean;
    readonly IsPublic: boolean;
    readonly IsSecurityCritical: boolean;
    readonly IsSecuritySafeCritical: boolean;
    readonly IsSecurityTransparent: boolean;
    readonly IsSpecialName: boolean;
    readonly IsStatic: boolean;
    readonly IsVirtual: boolean;
    readonly MethodHandle: RuntimeMethodHandle;
    readonly MethodImplementationFlags: MethodImplAttributes;
    Equals(obj: unknown): boolean;
    GetCustomAttributes(inherit: boolean): unknown[];
    GetCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    GetGenericArguments(): Type[];
    GetHashCode(): int;
    GetMethodBody(): MethodBody;
    GetMethodImplementationFlags(): MethodImplAttributes;
    GetParameters(): ParameterInfo[];
    Invoke(obj: unknown, parameters: unknown[]): unknown;
    Invoke(obj: unknown, invokeAttr: BindingFlags, binder: Binder, parameters: unknown[], culture: CultureInfo): unknown;
    IsDefined(attributeType: Type, inherit: boolean): boolean;
}


export const MethodBase: {
    GetCurrentMethod(): MethodBase;
    GetMethodFromHandle(handle: RuntimeMethodHandle, declaringType: RuntimeTypeHandle): MethodBase;
    GetMethodFromHandle(handle: RuntimeMethodHandle): MethodBase;
};


export interface __MethodBase$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
}

export type MethodBase = MethodBase$instance & __MethodBase$views;


export interface MethodBody$instance {
    readonly ExceptionHandlingClauses: IList_1<ExceptionHandlingClause>;
    readonly InitLocals: boolean;
    readonly LocalSignatureMetadataToken: int;
    readonly LocalVariables: IList_1<LocalVariableInfo>;
    readonly MaxStackSize: int;
    GetILAsByteArray(): byte[];
}


export const MethodBody: {
    new(): MethodBody$instance;
};


export type MethodBody = MethodBody$instance;

export interface MethodInfo$instance extends MethodBase$instance {
    readonly MemberType: MemberTypes;
    readonly ReturnParameter: ParameterInfo;
    readonly ReturnType: Type;
    readonly ReturnTypeCustomAttributes: ICustomAttributeProvider;
    CreateDelegate(delegateType: Type): Function;
    CreateDelegate(delegateType: Type, target: unknown): Function;
    CreateDelegate<T extends Function>(): T;
    CreateDelegate<T extends Function>(target: unknown): T;
    Equals(obj: unknown): boolean;
    GetBaseDefinition(): MethodInfo;
    GetCustomAttributes(inherit: boolean): unknown[];
    GetCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    GetGenericArguments(): Type[];
    GetGenericMethodDefinition(): MethodInfo;
    GetHashCode(): int;
    IsDefined(attributeType: Type, inherit: boolean): boolean;
    MakeGenericMethod(...typeArguments: Type[]): MethodInfo;
}


export const MethodInfo: {
};


export interface __MethodInfo$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
}

export type MethodInfo = MethodInfo$instance & __MethodInfo$views;


export interface MethodInvoker$instance {
    Invoke(obj: unknown): unknown;
    Invoke(obj: unknown, arg1: unknown): unknown;
    Invoke(obj: unknown, arg1: unknown, arg2: unknown): unknown;
    Invoke(obj: unknown, arg1: unknown, arg2: unknown, arg3: unknown): unknown;
    Invoke(obj: unknown, arg1: unknown, arg2: unknown, arg3: unknown, arg4: unknown): unknown;
    Invoke(obj: unknown, arguments: Span_1<unknown>): unknown;
}


export const MethodInvoker: {
    new(): MethodInvoker$instance;
    Create(method: MethodBase): MethodInvoker;
};


export type MethodInvoker = MethodInvoker$instance;

export interface Missing$instance {
}


export const Missing: {
    new(): Missing$instance;
    readonly Value: Missing;
};


export interface __Missing$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Missing$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Missing = Missing$instance & __Missing$views;


export interface Module$instance {
    readonly Assembly: Assembly;
    readonly CustomAttributes: IEnumerable_1<CustomAttributeData>;
    readonly FullyQualifiedName: string;
    readonly MDStreamVersion: int;
    readonly MetadataToken: int;
    readonly ModuleHandle: ModuleHandle;
    readonly ModuleVersionId: Guid;
    readonly Name: string;
    readonly ScopeName: string;
    Equals(o: unknown): boolean;
    FindTypes(filter: TypeFilter, filterCriteria: unknown): Type[];
    GetCustomAttributes(inherit: boolean): unknown[];
    GetCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    GetCustomAttributesData(): IList_1<CustomAttributeData>;
    GetField(name: string): FieldInfo;
    GetField(name: string, bindingAttr: BindingFlags): FieldInfo;
    GetFields(): FieldInfo[];
    GetFields(bindingFlags: BindingFlags): FieldInfo[];
    GetHashCode(): int;
    GetMethod(name: string): MethodInfo;
    GetMethod(name: string, types: Type[]): MethodInfo;
    GetMethod(name: string, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethods(): MethodInfo[];
    GetMethods(bindingFlags: BindingFlags): MethodInfo[];
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    GetPEKind(peKind: { value: ref<PortableExecutableKinds> }, machine: { value: ref<ImageFileMachine> }): void;
    GetType(className: string): Type;
    GetType(className: string, ignoreCase: boolean): Type;
    GetType(className: string, throwOnError: boolean, ignoreCase: boolean): Type;
    GetTypes(): Type[];
    IsDefined(attributeType: Type, inherit: boolean): boolean;
    IsResource(): boolean;
    ResolveField(metadataToken: int): FieldInfo;
    ResolveField(metadataToken: int, genericTypeArguments: Type[], genericMethodArguments: Type[]): FieldInfo;
    ResolveMember(metadataToken: int): MemberInfo;
    ResolveMember(metadataToken: int, genericTypeArguments: Type[], genericMethodArguments: Type[]): MemberInfo;
    ResolveMethod(metadataToken: int): MethodBase;
    ResolveMethod(metadataToken: int, genericTypeArguments: Type[], genericMethodArguments: Type[]): MethodBase;
    ResolveSignature(metadataToken: int): byte[];
    ResolveString(metadataToken: int): string;
    ResolveType(metadataToken: int): Type;
    ResolveType(metadataToken: int, genericTypeArguments: Type[], genericMethodArguments: Type[]): Type;
    ToString(): string;
}


export const Module: {
    readonly FilterTypeName: TypeFilter;
    readonly FilterTypeNameIgnoreCase: TypeFilter;
};


export interface __Module$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Module$instance extends ICustomAttributeProvider$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Module = Module$instance & __Module$views;


export interface NullabilityInfo$instance {
    readonly ElementType: NullabilityInfo;
    readonly GenericTypeArguments: NullabilityInfo[];
    readonly ReadState: NullabilityState;
    readonly Type: Type;
    readonly WriteState: NullabilityState;
}


export const NullabilityInfo: {
    new(): NullabilityInfo$instance;
};


export type NullabilityInfo = NullabilityInfo$instance;

export interface NullabilityInfoContext$instance {
    Create(parameterInfo: ParameterInfo): NullabilityInfo;
    Create(propertyInfo: PropertyInfo): NullabilityInfo;
    Create(eventInfo: EventInfo): NullabilityInfo;
    Create(fieldInfo: FieldInfo): NullabilityInfo;
}


export const NullabilityInfoContext: {
    new(): NullabilityInfoContext$instance;
};


export type NullabilityInfoContext = NullabilityInfoContext$instance;

export interface ObfuscateAssemblyAttribute$instance extends Attribute {
    readonly AssemblyIsPrivate: boolean;
    StripAfterObfuscation: boolean;
}


export const ObfuscateAssemblyAttribute: {
    new(assemblyIsPrivate: boolean): ObfuscateAssemblyAttribute$instance;
};


export type ObfuscateAssemblyAttribute = ObfuscateAssemblyAttribute$instance;

export interface ObfuscationAttribute$instance extends Attribute {
    ApplyToMembers: boolean;
    Exclude: boolean;
    Feature: string;
    StripAfterObfuscation: boolean;
}


export const ObfuscationAttribute: {
    new(): ObfuscationAttribute$instance;
};


export type ObfuscationAttribute = ObfuscationAttribute$instance;

export interface ParameterInfo$instance {
    readonly Attributes: ParameterAttributes;
    readonly CustomAttributes: IEnumerable_1<CustomAttributeData>;
    readonly DefaultValue: unknown;
    readonly HasDefaultValue: boolean;
    readonly IsIn: boolean;
    readonly IsLcid: boolean;
    readonly IsOptional: boolean;
    readonly IsOut: boolean;
    readonly IsRetval: boolean;
    readonly Member: MemberInfo;
    readonly MetadataToken: int;
    readonly Name: string;
    readonly ParameterType: Type;
    readonly Position: int;
    readonly RawDefaultValue: unknown;
    GetCustomAttributes(inherit: boolean): unknown[];
    GetCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    GetCustomAttributesData(): IList_1<CustomAttributeData>;
    GetModifiedParameterType(): Type;
    GetOptionalCustomModifiers(): Type[];
    GetRealObject(context: StreamingContext): unknown;
    GetRequiredCustomModifiers(): Type[];
    IsDefined(attributeType: Type, inherit: boolean): boolean;
    ToString(): string;
}


export const ParameterInfo: {
    new(): ParameterInfo$instance;
};


export interface __ParameterInfo$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
    As_IObjectReference(): System_Runtime_Serialization_Internal.IObjectReference$instance;
}

export interface ParameterInfo$instance extends ICustomAttributeProvider$instance, System_Runtime_Serialization_Internal.IObjectReference$instance {}

export type ParameterInfo = ParameterInfo$instance & __ParameterInfo$views;


export interface Pointer$instance {
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const Pointer: {
    new(): Pointer$instance;
    Box(ptr: ptr<void>, type_: Type): unknown;
    Unbox(ptr: unknown): ptr<void>;
};


export interface __Pointer$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Pointer$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Pointer = Pointer$instance & __Pointer$views;


export interface PropertyInfo$instance extends MemberInfo$instance {
    readonly Attributes: PropertyAttributes;
    readonly CanRead: boolean;
    readonly CanWrite: boolean;
    readonly GetMethod: MethodInfo;
    readonly IsSpecialName: boolean;
    readonly MemberType: MemberTypes;
    readonly PropertyType: Type;
    readonly SetMethod: MethodInfo;
    Equals(obj: unknown): boolean;
    GetAccessors(): MethodInfo[];
    GetAccessors(nonPublic: boolean): MethodInfo[];
    GetConstantValue(): unknown;
    GetCustomAttributes(inherit: boolean): unknown[];
    GetCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    GetGetMethod(): MethodInfo;
    GetGetMethod(nonPublic: boolean): MethodInfo;
    GetHashCode(): int;
    GetIndexParameters(): ParameterInfo[];
    GetModifiedPropertyType(): Type;
    GetOptionalCustomModifiers(): Type[];
    GetRawConstantValue(): unknown;
    GetRequiredCustomModifiers(): Type[];
    GetSetMethod(): MethodInfo;
    GetSetMethod(nonPublic: boolean): MethodInfo;
    GetValue(obj: unknown): unknown;
    GetValue(obj: unknown, index: unknown[]): unknown;
    GetValue(obj: unknown, invokeAttr: BindingFlags, binder: Binder, index: unknown[], culture: CultureInfo): unknown;
    IsDefined(attributeType: Type, inherit: boolean): boolean;
    SetValue(obj: unknown, value: unknown): void;
    SetValue(obj: unknown, value: unknown, index: unknown[]): void;
    SetValue(obj: unknown, value: unknown, invokeAttr: BindingFlags, binder: Binder, index: unknown[], culture: CultureInfo): void;
}


export const PropertyInfo: {
};


export interface __PropertyInfo$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
}

export type PropertyInfo = PropertyInfo$instance & __PropertyInfo$views;


export interface ReflectionContext$instance {
    GetTypeForObject(value: unknown): TypeInfo;
    MapAssembly(assembly: Assembly): Assembly;
    MapType(type_: TypeInfo): TypeInfo;
}


export const ReflectionContext: {
};


export type ReflectionContext = ReflectionContext$instance;

export interface ReflectionTypeLoadException$instance extends SystemException {
    readonly LoaderExceptions: Exception[];
    readonly Message: string;
    readonly Types: Type[];
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    ToString(): string;
}


export const ReflectionTypeLoadException: {
    new(classes: Type[], exceptions: Exception[]): ReflectionTypeLoadException$instance;
    new(classes: Type[], exceptions: Exception[], message: string): ReflectionTypeLoadException$instance;
};


export interface __ReflectionTypeLoadException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ReflectionTypeLoadException = ReflectionTypeLoadException$instance & __ReflectionTypeLoadException$views;


export interface StrongNameKeyPair$instance {
    readonly PublicKey: byte[];
}


export const StrongNameKeyPair: {
    new(keyPairFile: FileStream): StrongNameKeyPair$instance;
    new(keyPairArray: byte[]): StrongNameKeyPair$instance;
    new(keyPairContainer: string): StrongNameKeyPair$instance;
};


export interface __StrongNameKeyPair$views {
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface StrongNameKeyPair$instance extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type StrongNameKeyPair = StrongNameKeyPair$instance & __StrongNameKeyPair$views;


export interface TargetException$instance extends ApplicationException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TargetException: {
    new(): TargetException$instance;
    new(message: string): TargetException$instance;
    new(message: string, inner: Exception): TargetException$instance;
};


export interface __TargetException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TargetException = TargetException$instance & __TargetException$views;


export interface TargetInvocationException$instance extends ApplicationException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TargetInvocationException: {
    new(inner: Exception): TargetInvocationException$instance;
    new(message: string, inner: Exception): TargetInvocationException$instance;
};


export interface __TargetInvocationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TargetInvocationException = TargetInvocationException$instance & __TargetInvocationException$views;


export interface TargetParameterCountException$instance extends ApplicationException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TargetParameterCountException: {
    new(): TargetParameterCountException$instance;
    new(message: string): TargetParameterCountException$instance;
    new(message: string, inner: Exception): TargetParameterCountException$instance;
};


export interface __TargetParameterCountException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TargetParameterCountException = TargetParameterCountException$instance & __TargetParameterCountException$views;


export interface TypeDelegator$instance extends TypeInfo$instance {
    readonly Assembly: Assembly;
    readonly AssemblyQualifiedName: string;
    readonly BaseType: Type;
    readonly FullName: string;
    readonly GUID: Guid;
    readonly IsByRefLike: boolean;
    readonly IsCollectible: boolean;
    readonly IsConstructedGenericType: boolean;
    readonly IsFunctionPointer: boolean;
    readonly IsGenericMethodParameter: boolean;
    readonly IsGenericTypeParameter: boolean;
    readonly IsSZArray: boolean;
    readonly IsTypeDefinition: boolean;
    readonly IsUnmanagedFunctionPointer: boolean;
    readonly IsVariableBoundArray: boolean;
    readonly MetadataToken: int;
    readonly Module: Module;
    readonly Name: string;
    readonly Namespace: string;
    readonly TypeHandle: RuntimeTypeHandle;
    readonly UnderlyingSystemType: Type;
    GetArrayRank(): int;
    GetConstructors(bindingAttr: BindingFlags): ConstructorInfo[];
    GetConstructors(): ConstructorInfo[];
    GetCustomAttributes(inherit: boolean): unknown[];
    GetCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    GetElementType(): Type;
    GetEvent(name: string, bindingAttr: BindingFlags): EventInfo;
    GetEvent(name: string): EventInfo;
    GetEvents(): EventInfo[];
    GetEvents(bindingAttr: BindingFlags): EventInfo[];
    GetField(name: string, bindingAttr: BindingFlags): FieldInfo;
    GetField(name: string): FieldInfo;
    GetFields(bindingAttr: BindingFlags): FieldInfo[];
    GetFields(): FieldInfo[];
    GetFunctionPointerCallingConventions(): Type[];
    GetFunctionPointerParameterTypes(): Type[];
    GetFunctionPointerReturnType(): Type;
    GetInterface(name: string, ignoreCase: boolean): Type;
    GetInterface(name: string): Type;
    GetInterfaceMap(interfaceType: Type): InterfaceMapping;
    GetInterfaces(): Type[];
    GetMember(name: string, type_: MemberTypes, bindingAttr: BindingFlags): MemberInfo[];
    GetMember(name: string, bindingAttr: BindingFlags): MemberInfo[];
    GetMember(name: string): MemberInfo[];
    GetMembers(bindingAttr: BindingFlags): MemberInfo[];
    GetMembers(): MemberInfo[];
    GetMemberWithSameMetadataDefinitionAs(member: MemberInfo): MemberInfo;
    GetMethod(name: string, bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, bindingAttr: BindingFlags): MethodInfo;
    GetMethod(name: string): MethodInfo;
    GetMethod(name: string, bindingAttr: BindingFlags, types: Type[]): MethodInfo;
    GetMethod(name: string, types: Type[]): MethodInfo;
    GetMethod(name: string, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, types: Type[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, types: Type[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethods(bindingAttr: BindingFlags): MethodInfo[];
    GetMethods(): MethodInfo[];
    GetNestedType(name: string, bindingAttr: BindingFlags): Type;
    GetNestedType(name: string): Type;
    GetNestedTypes(bindingAttr: BindingFlags): Type[];
    GetNestedTypes(): Type[];
    GetProperties(bindingAttr: BindingFlags): PropertyInfo[];
    GetProperties(): PropertyInfo[];
    GetProperty(name: string, bindingAttr: BindingFlags): PropertyInfo;
    GetProperty(name: string, bindingAttr: BindingFlags, binder: Binder, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
    GetProperty(name: string): PropertyInfo;
    GetProperty(name: string, returnType: Type): PropertyInfo;
    GetProperty(name: string, types: Type[]): PropertyInfo;
    GetProperty(name: string, returnType: Type, types: Type[]): PropertyInfo;
    GetProperty(name: string, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
    GetTypeInfo(): TypeInfo;
    InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: unknown, args: unknown[], modifiers: ParameterModifier[], culture: CultureInfo, namedParameters: string[]): unknown;
    InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: unknown, args: unknown[]): unknown;
    InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: unknown, args: unknown[], culture: CultureInfo): unknown;
    IsAssignableFrom(typeInfo: TypeInfo): boolean;
    IsAssignableFrom(c: Type): boolean;
    IsDefined(attributeType: Type, inherit: boolean): boolean;
}


export const TypeDelegator: {
    new(delegatingType: Type): TypeDelegator$instance;
};


export interface __TypeDelegator$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
    As_IReflect(): IReflect$instance;
    As_IReflectableType(): IReflectableType$instance;
}

export interface TypeDelegator$instance extends IReflectableType$instance {}

export type TypeDelegator = TypeDelegator$instance & __TypeDelegator$views;


export interface TypeInfo$instance extends Type {
    readonly DeclaredConstructors: IEnumerable_1<ConstructorInfo>;
    readonly DeclaredEvents: IEnumerable_1<EventInfo>;
    readonly DeclaredFields: IEnumerable_1<FieldInfo>;
    readonly DeclaredMembers: IEnumerable_1<MemberInfo>;
    readonly DeclaredMethods: IEnumerable_1<MethodInfo>;
    readonly DeclaredNestedTypes: IEnumerable_1<TypeInfo>;
    readonly DeclaredProperties: IEnumerable_1<PropertyInfo>;
    readonly GenericTypeParameters: Type[];
    readonly ImplementedInterfaces: IEnumerable_1<Type>;
    AsType(): Type;
    GetCustomAttributes(inherit: boolean): unknown[];
    GetCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    GetDeclaredEvent(name: string): EventInfo;
    GetDeclaredField(name: string): FieldInfo;
    GetDeclaredMethod(name: string): MethodInfo;
    GetDeclaredMethods(name: string): IEnumerable_1<MethodInfo>;
    GetDeclaredNestedType(name: string): TypeInfo;
    GetDeclaredProperty(name: string): PropertyInfo;
    GetField(name: string): FieldInfo;
    GetField(name: string, bindingAttr: BindingFlags): FieldInfo;
    GetFields(): FieldInfo[];
    GetFields(bindingAttr: BindingFlags): FieldInfo[];
    GetMember(name: string): MemberInfo[];
    GetMember(name: string, bindingAttr: BindingFlags): MemberInfo[];
    GetMember(name: string, type_: MemberTypes, bindingAttr: BindingFlags): MemberInfo[];
    GetMembers(): MemberInfo[];
    GetMembers(bindingAttr: BindingFlags): MemberInfo[];
    GetMethod(name: string): MethodInfo;
    GetMethod(name: string, bindingAttr: BindingFlags): MethodInfo;
    GetMethod(name: string, bindingAttr: BindingFlags, types: Type[]): MethodInfo;
    GetMethod(name: string, types: Type[]): MethodInfo;
    GetMethod(name: string, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, types: Type[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, types: Type[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
    GetMethods(): MethodInfo[];
    GetMethods(bindingAttr: BindingFlags): MethodInfo[];
    GetProperties(): PropertyInfo[];
    GetProperties(bindingAttr: BindingFlags): PropertyInfo[];
    GetProperty(name: string): PropertyInfo;
    GetProperty(name: string, bindingAttr: BindingFlags): PropertyInfo;
    GetProperty(name: string, returnType: Type): PropertyInfo;
    GetProperty(name: string, types: Type[]): PropertyInfo;
    GetProperty(name: string, returnType: Type, types: Type[]): PropertyInfo;
    GetProperty(name: string, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
    GetProperty(name: string, bindingAttr: BindingFlags, binder: Binder, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
    InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: unknown, args: unknown[]): unknown;
    InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: unknown, args: unknown[], culture: CultureInfo): unknown;
    InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: unknown, args: unknown[], modifiers: ParameterModifier[], culture: CultureInfo, namedParameters: string[]): unknown;
    IsAssignableFrom(c: Type): boolean;
    IsDefined(attributeType: Type, inherit: boolean): boolean;
}


export const TypeInfo: {
};


export interface __TypeInfo$views {
    As_ICustomAttributeProvider(): ICustomAttributeProvider$instance;
    As_IReflect(): IReflect$instance;
    As_IReflectableType(): IReflectableType$instance;
}

export interface TypeInfo$instance extends IReflectableType$instance {}

export type TypeInfo = TypeInfo$instance & __TypeInfo$views;


export abstract class AssemblyExtensions$instance {
    static GetExportedTypes(assembly: Assembly): Type[];
    static GetModules(assembly: Assembly): Module[];
    static GetTypes(assembly: Assembly): Type[];
}


export type AssemblyExtensions = AssemblyExtensions$instance;

export abstract class CustomAttributeExtensions$instance {
    static GetCustomAttribute(element: Assembly, attributeType: Type): Attribute;
    static GetCustomAttribute<T extends Attribute>(element: Assembly): T;
    static GetCustomAttribute<T extends Attribute>(element: MemberInfo, inherit: boolean): T;
    static GetCustomAttribute(element: MemberInfo, attributeType: Type, inherit: boolean): Attribute;
    static GetCustomAttribute(element: MemberInfo, attributeType: Type): Attribute;
    static GetCustomAttribute<T extends Attribute>(element: MemberInfo): T;
    static GetCustomAttribute(element: Module, attributeType: Type): Attribute;
    static GetCustomAttribute<T extends Attribute>(element: Module): T;
    static GetCustomAttribute<T extends Attribute>(element: ParameterInfo, inherit: boolean): T;
    static GetCustomAttribute(element: ParameterInfo, attributeType: Type, inherit: boolean): Attribute;
    static GetCustomAttribute(element: ParameterInfo, attributeType: Type): Attribute;
    static GetCustomAttribute<T extends Attribute>(element: ParameterInfo): T;
    static GetCustomAttributes(element: Assembly, attributeType: Type): IEnumerable_1<Attribute>;
    static GetCustomAttributes<T extends Attribute>(element: Assembly): IEnumerable_1<T>;
    static GetCustomAttributes(element: Assembly): IEnumerable_1<Attribute>;
    static GetCustomAttributes<T extends Attribute>(element: MemberInfo, inherit: boolean): IEnumerable_1<T>;
    static GetCustomAttributes(element: MemberInfo, inherit: boolean): IEnumerable_1<Attribute>;
    static GetCustomAttributes(element: MemberInfo, attributeType: Type, inherit: boolean): IEnumerable_1<Attribute>;
    static GetCustomAttributes(element: MemberInfo, attributeType: Type): IEnumerable_1<Attribute>;
    static GetCustomAttributes<T extends Attribute>(element: MemberInfo): IEnumerable_1<T>;
    static GetCustomAttributes(element: MemberInfo): IEnumerable_1<Attribute>;
    static GetCustomAttributes(element: Module, attributeType: Type): IEnumerable_1<Attribute>;
    static GetCustomAttributes<T extends Attribute>(element: Module): IEnumerable_1<T>;
    static GetCustomAttributes(element: Module): IEnumerable_1<Attribute>;
    static GetCustomAttributes<T extends Attribute>(element: ParameterInfo, inherit: boolean): IEnumerable_1<T>;
    static GetCustomAttributes(element: ParameterInfo, inherit: boolean): IEnumerable_1<Attribute>;
    static GetCustomAttributes(element: ParameterInfo, attributeType: Type, inherit: boolean): IEnumerable_1<Attribute>;
    static GetCustomAttributes(element: ParameterInfo, attributeType: Type): IEnumerable_1<Attribute>;
    static GetCustomAttributes<T extends Attribute>(element: ParameterInfo): IEnumerable_1<T>;
    static GetCustomAttributes(element: ParameterInfo): IEnumerable_1<Attribute>;
    static IsDefined(element: Assembly, attributeType: Type): boolean;
    static IsDefined(element: MemberInfo, attributeType: Type, inherit: boolean): boolean;
    static IsDefined(element: MemberInfo, attributeType: Type): boolean;
    static IsDefined(element: Module, attributeType: Type): boolean;
    static IsDefined(element: ParameterInfo, attributeType: Type, inherit: boolean): boolean;
    static IsDefined(element: ParameterInfo, attributeType: Type): boolean;
}


export type CustomAttributeExtensions = CustomAttributeExtensions$instance;

export abstract class EventInfoExtensions$instance {
    static GetAddMethod(eventInfo: EventInfo, nonPublic: boolean): MethodInfo;
    static GetAddMethod(eventInfo: EventInfo): MethodInfo;
    static GetRaiseMethod(eventInfo: EventInfo, nonPublic: boolean): MethodInfo;
    static GetRaiseMethod(eventInfo: EventInfo): MethodInfo;
    static GetRemoveMethod(eventInfo: EventInfo, nonPublic: boolean): MethodInfo;
    static GetRemoveMethod(eventInfo: EventInfo): MethodInfo;
}


export type EventInfoExtensions = EventInfoExtensions$instance;

export abstract class IntrospectionExtensions$instance {
    static GetTypeInfo(type_: Type): TypeInfo;
}


export type IntrospectionExtensions = IntrospectionExtensions$instance;

export abstract class MemberInfoExtensions$instance {
    static GetMetadataToken(member: MemberInfo): int;
    static HasMetadataToken(member: MemberInfo): boolean;
}


export type MemberInfoExtensions = MemberInfoExtensions$instance;

export abstract class MethodInfoExtensions$instance {
    static GetBaseDefinition(method: MethodInfo): MethodInfo;
}


export type MethodInfoExtensions = MethodInfoExtensions$instance;

export abstract class ModuleExtensions$instance {
    static GetModuleVersionId(module_: Module): Guid;
    static HasModuleVersionId(module_: Module): boolean;
}


export type ModuleExtensions = ModuleExtensions$instance;

export abstract class PropertyInfoExtensions$instance {
    static GetAccessors(property: PropertyInfo, nonPublic: boolean): MethodInfo[];
    static GetAccessors(property: PropertyInfo): MethodInfo[];
    static GetGetMethod(property: PropertyInfo, nonPublic: boolean): MethodInfo;
    static GetGetMethod(property: PropertyInfo): MethodInfo;
    static GetSetMethod(property: PropertyInfo, nonPublic: boolean): MethodInfo;
    static GetSetMethod(property: PropertyInfo): MethodInfo;
}


export type PropertyInfoExtensions = PropertyInfoExtensions$instance;

export abstract class RuntimeReflectionExtensions$instance {
    static GetMethodInfo(del: Function): MethodInfo;
    static GetRuntimeBaseDefinition(method: MethodInfo): MethodInfo;
    static GetRuntimeEvent(type_: Type, name: string): EventInfo;
    static GetRuntimeEvents(type_: Type): IEnumerable_1<EventInfo>;
    static GetRuntimeField(type_: Type, name: string): FieldInfo;
    static GetRuntimeFields(type_: Type): IEnumerable_1<FieldInfo>;
    static GetRuntimeInterfaceMap(typeInfo: TypeInfo, interfaceType: Type): InterfaceMapping;
    static GetRuntimeMethod(type_: Type, name: string, parameters: Type[]): MethodInfo;
    static GetRuntimeMethods(type_: Type): IEnumerable_1<MethodInfo>;
    static GetRuntimeProperties(type_: Type): IEnumerable_1<PropertyInfo>;
    static GetRuntimeProperty(type_: Type, name: string): PropertyInfo;
}


export type RuntimeReflectionExtensions = RuntimeReflectionExtensions$instance;

export abstract class TypeExtensions$instance {
    static GetConstructor(type_: Type, types: Type[]): ConstructorInfo;
    static GetConstructors(type_: Type, bindingAttr: BindingFlags): ConstructorInfo[];
    static GetConstructors(type_: Type): ConstructorInfo[];
    static GetDefaultMembers(type_: Type): MemberInfo[];
    static GetEvent(type_: Type, name: string, bindingAttr: BindingFlags): EventInfo;
    static GetEvent(type_: Type, name: string): EventInfo;
    static GetEvents(type_: Type, bindingAttr: BindingFlags): EventInfo[];
    static GetEvents(type_: Type): EventInfo[];
    static GetField(type_: Type, name: string, bindingAttr: BindingFlags): FieldInfo;
    static GetField(type_: Type, name: string): FieldInfo;
    static GetFields(type_: Type, bindingAttr: BindingFlags): FieldInfo[];
    static GetFields(type_: Type): FieldInfo[];
    static GetGenericArguments(type_: Type): Type[];
    static GetInterfaces(type_: Type): Type[];
    static GetMember(type_: Type, name: string, bindingAttr: BindingFlags): MemberInfo[];
    static GetMember(type_: Type, name: string): MemberInfo[];
    static GetMembers(type_: Type, bindingAttr: BindingFlags): MemberInfo[];
    static GetMembers(type_: Type): MemberInfo[];
    static GetMethod(type_: Type, name: string, bindingAttr: BindingFlags): MethodInfo;
    static GetMethod(type_: Type, name: string, types: Type[]): MethodInfo;
    static GetMethod(type_: Type, name: string): MethodInfo;
    static GetMethods(type_: Type, bindingAttr: BindingFlags): MethodInfo[];
    static GetMethods(type_: Type): MethodInfo[];
    static GetNestedType(type_: Type, name: string, bindingAttr: BindingFlags): Type;
    static GetNestedTypes(type_: Type, bindingAttr: BindingFlags): Type[];
    static GetProperties(type_: Type, bindingAttr: BindingFlags): PropertyInfo[];
    static GetProperties(type_: Type): PropertyInfo[];
    static GetProperty(type_: Type, name: string, bindingAttr: BindingFlags): PropertyInfo;
    static GetProperty(type_: Type, name: string, returnType: Type, types: Type[]): PropertyInfo;
    static GetProperty(type_: Type, name: string, returnType: Type): PropertyInfo;
    static GetProperty(type_: Type, name: string): PropertyInfo;
    static IsAssignableFrom(type_: Type, c: Type): boolean;
    static IsInstanceOfType(type_: Type, o: unknown): boolean;
}


export type TypeExtensions = TypeExtensions$instance;


// Generated by tsbindgen - Architecture
// Namespace: System.Text
// Assembly: System.Memory, System.Private.CoreLib, System.Text.Encoding.CodePages

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { IBufferWriter_1, OperationStatus, ReadOnlySequence_1 } from "../../System.Buffers/internal/index.js";
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { IEnumerable_1, IEnumerator_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { CultureInfo, UnicodeCategory } from "../../System.Globalization/internal/index.js";
import type { Stream } from "../../System.IO/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { ArgumentException, Boolean as ClrBoolean, Byte, Char, Decimal, Double, Enum, Exception, ICloneable, IComparable, IComparable_1, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, ISpanFormattable, IUtf8SpanFormattable, IUtf8SpanParsable_1, Object as ClrObject, Range, ReadOnlyMemory_1, ReadOnlySpan_1, SByte, Single, Span_1, String as ClrString, Type, TypeCode, UInt16, UInt32, UInt64, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum NormalizationForm {
    FormC = 1,
    FormD = 2,
    FormKC = 5,
    FormKD = 6
}


export interface Rune$instance {
    readonly IsAscii: boolean;
    readonly IsBmp: boolean;
    readonly Plane: int;
    readonly Utf16SequenceLength: int;
    readonly Utf8SequenceLength: int;
    readonly Value: int;
    CompareTo(other: Rune): int;
    EncodeToUtf16(destination: Span_1<CLROf<char>>): int;
    EncodeToUtf8(destination: Span_1<CLROf<byte>>): int;
    Equals(obj: unknown): boolean;
    Equals(other: Rune): boolean;
    GetHashCode(): int;
    ToString(): string;
    TryEncodeToUtf16(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    TryEncodeToUtf8(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export const Rune: {
    new(ch: char): Rune$instance;
    new(highSurrogate: char, lowSurrogate: char): Rune$instance;
    new(value: int): Rune$instance;
    new(value: uint): Rune$instance;
    readonly ReplacementChar: Rune;
    DecodeFromUtf16(source: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<Rune> }, charsConsumed: { value: ref<int> }): OperationStatus;
    DecodeFromUtf8(source: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<Rune> }, bytesConsumed: { value: ref<int> }): OperationStatus;
    DecodeLastFromUtf16(source: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<Rune> }, charsConsumed: { value: ref<int> }): OperationStatus;
    DecodeLastFromUtf8(source: ReadOnlySpan_1<CLROf<byte>>, value: { value: ref<Rune> }, bytesConsumed: { value: ref<int> }): OperationStatus;
    GetNumericValue(value: Rune): double;
    GetRuneAt(input: string, index: int): Rune;
    GetUnicodeCategory(value: Rune): UnicodeCategory;
    IsControl(value: Rune): boolean;
    IsDigit(value: Rune): boolean;
    IsLetter(value: Rune): boolean;
    IsLetterOrDigit(value: Rune): boolean;
    IsLower(value: Rune): boolean;
    IsNumber(value: Rune): boolean;
    IsPunctuation(value: Rune): boolean;
    IsSeparator(value: Rune): boolean;
    IsSymbol(value: Rune): boolean;
    IsUpper(value: Rune): boolean;
    IsValid(value: int): boolean;
    IsValid(value: uint): boolean;
    IsWhiteSpace(value: Rune): boolean;
    ToLower(value: Rune, culture: CultureInfo): Rune;
    ToLowerInvariant(value: Rune): Rune;
    ToUpper(value: Rune, culture: CultureInfo): Rune;
    ToUpperInvariant(value: Rune): Rune;
    TryCreate(highSurrogate: char, lowSurrogate: char, result: { value: ref<Rune> }): boolean;
    TryCreate(ch: char, result: { value: ref<Rune> }): boolean;
    TryCreate(value: int, result: { value: ref<Rune> }): boolean;
    TryCreate(value: uint, result: { value: ref<Rune> }): boolean;
    TryGetRuneAt(input: string, index: int, value: { value: ref<Rune> }): boolean;
};


export interface __Rune$views {
    As_IComparable(): System_Internal.IComparable$instance;
    As_IComparable_1(): System_Internal.IComparable_1$instance<Rune>;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Rune>;
    As_IFormattable(): System_Internal.IFormattable$instance;
    As_ISpanFormattable(): System_Internal.ISpanFormattable$instance;
    As_IUtf8SpanFormattable(): System_Internal.IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): System_Internal.IUtf8SpanParsable_1$instance<Rune>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Rune): boolean;
    CompareTo(obj: unknown): int;
}

export interface Rune$instance extends System_Internal.IComparable_1$instance<Rune>, System_Internal.IUtf8SpanFormattable$instance, System_Internal.IUtf8SpanParsable_1$instance<Rune> {}

export type Rune = Rune$instance & __Rune$views;


export interface SpanLineEnumerator$instance {
    readonly Current: ReadOnlySpan_1<CLROf<char>>;
    GetEnumerator(): SpanLineEnumerator;
    MoveNext(): boolean;
    Reset(): void;
}


export const SpanLineEnumerator: {
    new(): SpanLineEnumerator$instance;
};


export interface __SpanLineEnumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<ReadOnlySpan_1<CLROf<char>>>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type SpanLineEnumerator = SpanLineEnumerator$instance & __SpanLineEnumerator$views;


export interface SpanRuneEnumerator$instance {
    readonly Current: Rune;
    GetEnumerator(): SpanRuneEnumerator;
    MoveNext(): boolean;
    Reset(): void;
}


export const SpanRuneEnumerator: {
    new(): SpanRuneEnumerator$instance;
};


export interface __SpanRuneEnumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<Rune>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type SpanRuneEnumerator = SpanRuneEnumerator$instance & __SpanRuneEnumerator$views;


export interface StringBuilder_AppendInterpolatedStringHandler$instance {
    AppendFormatted<T>(value: T): void;
    AppendFormatted<T>(value: T, format: string): void;
    AppendFormatted<T>(value: T, alignment: int): void;
    AppendFormatted<T>(value: T, alignment: int, format: string): void;
    AppendFormatted(value: ReadOnlySpan_1<CLROf<char>>): void;
    AppendFormatted(value: ReadOnlySpan_1<CLROf<char>>, alignment?: int, format?: string): void;
    AppendFormatted(value: string): void;
    AppendFormatted(value: string, alignment?: int, format?: string): void;
    AppendFormatted(value: unknown, alignment?: int, format?: string): void;
    AppendLiteral(value: string): void;
}


export const StringBuilder_AppendInterpolatedStringHandler: {
    new(literalLength: int, formattedCount: int, stringBuilder: StringBuilder): StringBuilder_AppendInterpolatedStringHandler$instance;
    new(literalLength: int, formattedCount: int, stringBuilder: StringBuilder, provider: IFormatProvider): StringBuilder_AppendInterpolatedStringHandler$instance;
};


export type StringBuilder_AppendInterpolatedStringHandler = StringBuilder_AppendInterpolatedStringHandler$instance;

export interface StringBuilder_ChunkEnumerator$instance {
    readonly Current: ReadOnlyMemory_1<CLROf<char>>;
    GetEnumerator(): StringBuilder_ChunkEnumerator;
    MoveNext(): boolean;
}


export const StringBuilder_ChunkEnumerator: {
    new(): StringBuilder_ChunkEnumerator$instance;
};


export type StringBuilder_ChunkEnumerator = StringBuilder_ChunkEnumerator$instance;

export interface StringRuneEnumerator$instance {
    readonly Current: Rune;
    GetEnumerator(): StringRuneEnumerator;
    MoveNext(): boolean;
    Reset(): void;
}


export const StringRuneEnumerator: {
    new(): StringRuneEnumerator$instance;
};


export interface __StringRuneEnumerator$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<Rune>;
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<Rune>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type StringRuneEnumerator = StringRuneEnumerator$instance & __StringRuneEnumerator$views;


export interface ASCIIEncoding$instance extends Encoding$instance {
    readonly IsSingleByte: boolean;
    Clone(): unknown;
    GetByteCount(chars: char[], index: int, count: int): int;
    GetByteCount(chars: string): int;
    GetByteCount(chars: ptr<char>, count: int): int;
    GetByteCount(chars: ReadOnlySpan_1<CLROf<char>>): int;
    GetByteCount(chars: char[]): int;
    GetByteCount(s: string, index: int, count: int): int;
    GetByteCount(chars: ReadOnlySpan_1<CLROf<char>>): int;
    GetBytes(chars: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    GetBytes(chars: char[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    GetBytes(chars: ptr<char>, charCount: int, bytes: ptr<byte>, byteCount: int): int;
    GetBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>): int;
    GetBytes(chars: char[]): byte[];
    GetBytes(chars: char[], index: int, count: int): byte[];
    GetBytes(s: string): byte[];
    GetBytes(s: string, index: int, count: int): byte[];
    GetBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>): int;
    GetCharCount(bytes: byte[], index: int, count: int): int;
    GetCharCount(bytes: ptr<byte>, count: int): int;
    GetCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    GetCharCount(bytes: byte[]): int;
    GetCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    GetChars(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int): int;
    GetChars(bytes: ptr<byte>, byteCount: int, chars: ptr<char>, charCount: int): int;
    GetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>): int;
    GetChars(bytes: byte[]): char[];
    GetChars(bytes: byte[], index: int, count: int): char[];
    GetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>): int;
    GetDecoder(): Decoder;
    GetEncoder(): Encoder;
    GetMaxByteCount(charCount: int): int;
    GetMaxCharCount(byteCount: int): int;
    GetString(bytes: byte[], byteIndex: int, byteCount: int): string;
    GetString(bytes: ptr<byte>, byteCount: int): string;
    GetString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    GetString(bytes: byte[]): string;
    TryGetBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryGetBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryGetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    TryGetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
}


export const ASCIIEncoding: {
    new(): ASCIIEncoding$instance;
};


export interface __ASCIIEncoding$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type ASCIIEncoding = ASCIIEncoding$instance & __ASCIIEncoding$views;


export interface CodePagesEncodingProvider$instance extends EncodingProvider {
    GetEncoding(codepage: int): Encoding;
    GetEncoding(name: string): Encoding;
    GetEncoding(name: string, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    GetEncoding(codepage: int, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    GetEncodings(): IEnumerable_1<EncodingInfo>;
    GetEncodings(): IEnumerable_1<EncodingInfo>;
}


export const CodePagesEncodingProvider: {
    new(): CodePagesEncodingProvider$instance;
    readonly Instance: EncodingProvider;
};


export type CodePagesEncodingProvider = CodePagesEncodingProvider$instance;

export interface CompositeFormat$instance {
    readonly Format: string;
    readonly MinimumArgumentCount: int;
}


export const CompositeFormat: {
    new(): CompositeFormat$instance;
    Parse(format: string): CompositeFormat;
};


export type CompositeFormat = CompositeFormat$instance;

export interface Decoder$instance {
    Fallback: DecoderFallback;
    readonly FallbackBuffer: DecoderFallbackBuffer;
    Convert(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int, charCount: int, flush: boolean, bytesUsed: { value: ref<int> }, charsUsed: { value: ref<int> }, completed: { value: ref<boolean> }): void;
    Convert(bytes: ptr<byte>, byteCount: int, chars: ptr<char>, charCount: int, flush: boolean, bytesUsed: { value: ref<int> }, charsUsed: { value: ref<int> }, completed: { value: ref<boolean> }): void;
    Convert(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>, flush: boolean, bytesUsed: { value: ref<int> }, charsUsed: { value: ref<int> }, completed: { value: ref<boolean> }): void;
    GetCharCount(bytes: byte[], index: int, count: int): int;
    GetCharCount(bytes: byte[], index: int, count: int, flush: boolean): int;
    GetCharCount(bytes: ptr<byte>, count: int, flush: boolean): int;
    GetCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>, flush: boolean): int;
    GetChars(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int): int;
    GetChars(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int, flush: boolean): int;
    GetChars(bytes: ptr<byte>, byteCount: int, chars: ptr<char>, charCount: int, flush: boolean): int;
    GetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>, flush: boolean): int;
    Reset(): void;
}


export const Decoder: {
};


export type Decoder = Decoder$instance;

export interface DecoderExceptionFallback$instance extends DecoderFallback {
    readonly MaxCharCount: int;
    CreateFallbackBuffer(): DecoderFallbackBuffer;
    Equals(value: unknown): boolean;
    GetHashCode(): int;
}


export const DecoderExceptionFallback: {
    new(): DecoderExceptionFallback$instance;
};


export type DecoderExceptionFallback = DecoderExceptionFallback$instance;

export interface DecoderExceptionFallbackBuffer$instance extends DecoderFallbackBuffer {
    readonly Remaining: int;
    Fallback(bytesUnknown: byte[], index: int): boolean;
    GetNextChar(): char;
    MovePrevious(): boolean;
}


export const DecoderExceptionFallbackBuffer: {
    new(): DecoderExceptionFallbackBuffer$instance;
};


export type DecoderExceptionFallbackBuffer = DecoderExceptionFallbackBuffer$instance;

export interface DecoderFallback$instance {
    readonly MaxCharCount: int;
    CreateFallbackBuffer(): DecoderFallbackBuffer;
}


export const DecoderFallback: {
    readonly ReplacementFallback: DecoderFallback;
    readonly ExceptionFallback: DecoderFallback;
};


export type DecoderFallback = DecoderFallback$instance;

export interface DecoderFallbackBuffer$instance {
    readonly Remaining: int;
    Fallback(bytesUnknown: byte[], index: int): boolean;
    GetNextChar(): char;
    MovePrevious(): boolean;
    Reset(): void;
}


export const DecoderFallbackBuffer: {
};


export type DecoderFallbackBuffer = DecoderFallbackBuffer$instance;

export interface DecoderFallbackException$instance extends ArgumentException {
    readonly BytesUnknown: byte[];
    readonly Index: int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const DecoderFallbackException: {
    new(): DecoderFallbackException$instance;
    new(message: string): DecoderFallbackException$instance;
    new(message: string, innerException: Exception): DecoderFallbackException$instance;
    new(message: string, bytesUnknown: byte[], index: int): DecoderFallbackException$instance;
};


export interface __DecoderFallbackException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DecoderFallbackException = DecoderFallbackException$instance & __DecoderFallbackException$views;


export interface DecoderReplacementFallback$instance extends DecoderFallback {
    readonly DefaultString: string;
    readonly MaxCharCount: int;
    CreateFallbackBuffer(): DecoderFallbackBuffer;
    Equals(value: unknown): boolean;
    GetHashCode(): int;
}


export const DecoderReplacementFallback: {
    new(): DecoderReplacementFallback$instance;
    new(replacement: string): DecoderReplacementFallback$instance;
};


export type DecoderReplacementFallback = DecoderReplacementFallback$instance;

export interface DecoderReplacementFallbackBuffer$instance extends DecoderFallbackBuffer {
    readonly Remaining: int;
    Fallback(bytesUnknown: byte[], index: int): boolean;
    GetNextChar(): char;
    MovePrevious(): boolean;
    Reset(): void;
}


export const DecoderReplacementFallbackBuffer: {
    new(fallback: DecoderReplacementFallback): DecoderReplacementFallbackBuffer$instance;
};


export type DecoderReplacementFallbackBuffer = DecoderReplacementFallbackBuffer$instance;

export interface Encoder$instance {
    Fallback: EncoderFallback;
    readonly FallbackBuffer: EncoderFallbackBuffer;
    Convert(chars: char[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int, byteCount: int, flush: boolean, charsUsed: { value: ref<int> }, bytesUsed: { value: ref<int> }, completed: { value: ref<boolean> }): void;
    Convert(chars: ptr<char>, charCount: int, bytes: ptr<byte>, byteCount: int, flush: boolean, charsUsed: { value: ref<int> }, bytesUsed: { value: ref<int> }, completed: { value: ref<boolean> }): void;
    Convert(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>, flush: boolean, charsUsed: { value: ref<int> }, bytesUsed: { value: ref<int> }, completed: { value: ref<boolean> }): void;
    GetByteCount(chars: char[], index: int, count: int, flush: boolean): int;
    GetByteCount(chars: ptr<char>, count: int, flush: boolean): int;
    GetByteCount(chars: ReadOnlySpan_1<CLROf<char>>, flush: boolean): int;
    GetBytes(chars: char[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int, flush: boolean): int;
    GetBytes(chars: ptr<char>, charCount: int, bytes: ptr<byte>, byteCount: int, flush: boolean): int;
    GetBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>, flush: boolean): int;
    Reset(): void;
}


export const Encoder: {
};


export type Encoder = Encoder$instance;

export interface EncoderExceptionFallback$instance extends EncoderFallback {
    readonly MaxCharCount: int;
    CreateFallbackBuffer(): EncoderFallbackBuffer;
    Equals(value: unknown): boolean;
    GetHashCode(): int;
}


export const EncoderExceptionFallback: {
    new(): EncoderExceptionFallback$instance;
};


export type EncoderExceptionFallback = EncoderExceptionFallback$instance;

export interface EncoderExceptionFallbackBuffer$instance extends EncoderFallbackBuffer {
    readonly Remaining: int;
    Fallback(charUnknown: char, index: int): boolean;
    Fallback(charUnknownHigh: char, charUnknownLow: char, index: int): boolean;
    GetNextChar(): char;
    MovePrevious(): boolean;
}


export const EncoderExceptionFallbackBuffer: {
    new(): EncoderExceptionFallbackBuffer$instance;
};


export type EncoderExceptionFallbackBuffer = EncoderExceptionFallbackBuffer$instance;

export interface EncoderFallback$instance {
    readonly MaxCharCount: int;
    CreateFallbackBuffer(): EncoderFallbackBuffer;
}


export const EncoderFallback: {
    readonly ReplacementFallback: EncoderFallback;
    readonly ExceptionFallback: EncoderFallback;
};


export type EncoderFallback = EncoderFallback$instance;

export interface EncoderFallbackBuffer$instance {
    readonly Remaining: int;
    Fallback(charUnknown: char, index: int): boolean;
    Fallback(charUnknownHigh: char, charUnknownLow: char, index: int): boolean;
    GetNextChar(): char;
    MovePrevious(): boolean;
    Reset(): void;
}


export const EncoderFallbackBuffer: {
};


export type EncoderFallbackBuffer = EncoderFallbackBuffer$instance;

export interface EncoderFallbackException$instance extends ArgumentException {
    readonly CharUnknown: char;
    readonly CharUnknownHigh: char;
    readonly CharUnknownLow: char;
    readonly Index: int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    IsUnknownSurrogate(): boolean;
}


export const EncoderFallbackException: {
    new(): EncoderFallbackException$instance;
    new(message: string): EncoderFallbackException$instance;
    new(message: string, innerException: Exception): EncoderFallbackException$instance;
};


export interface __EncoderFallbackException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type EncoderFallbackException = EncoderFallbackException$instance & __EncoderFallbackException$views;


export interface EncoderReplacementFallback$instance extends EncoderFallback {
    readonly DefaultString: string;
    readonly MaxCharCount: int;
    CreateFallbackBuffer(): EncoderFallbackBuffer;
    Equals(value: unknown): boolean;
    GetHashCode(): int;
}


export const EncoderReplacementFallback: {
    new(): EncoderReplacementFallback$instance;
    new(replacement: string): EncoderReplacementFallback$instance;
};


export type EncoderReplacementFallback = EncoderReplacementFallback$instance;

export interface EncoderReplacementFallbackBuffer$instance extends EncoderFallbackBuffer {
    readonly Remaining: int;
    Fallback(charUnknown: char, index: int): boolean;
    Fallback(charUnknownHigh: char, charUnknownLow: char, index: int): boolean;
    GetNextChar(): char;
    MovePrevious(): boolean;
    Reset(): void;
}


export const EncoderReplacementFallbackBuffer: {
    new(fallback: EncoderReplacementFallback): EncoderReplacementFallbackBuffer$instance;
};


export type EncoderReplacementFallbackBuffer = EncoderReplacementFallbackBuffer$instance;

export interface Encoding$instance {
    readonly BodyName: string;
    readonly CodePage: int;
    DecoderFallback: DecoderFallback;
    EncoderFallback: EncoderFallback;
    readonly EncodingName: string;
    readonly HeaderName: string;
    readonly IsBrowserDisplay: boolean;
    readonly IsBrowserSave: boolean;
    readonly IsMailNewsDisplay: boolean;
    readonly IsMailNewsSave: boolean;
    readonly IsReadOnly: boolean;
    readonly IsSingleByte: boolean;
    readonly Preamble: ReadOnlySpan_1<CLROf<byte>>;
    readonly WebName: string;
    readonly WindowsCodePage: int;
    Clone(): unknown;
    Equals(value: unknown): boolean;
    GetByteCount(chars: char[]): int;
    GetByteCount(s: string): int;
    GetByteCount(chars: char[], index: int, count: int): int;
    GetByteCount(s: string, index: int, count: int): int;
    GetByteCount(chars: ptr<char>, count: int): int;
    GetByteCount(chars: ReadOnlySpan_1<CLROf<char>>): int;
    GetBytes(chars: char[]): byte[];
    GetBytes(chars: char[], index: int, count: int): byte[];
    GetBytes(chars: char[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    GetBytes(s: string): byte[];
    GetBytes(s: string, index: int, count: int): byte[];
    GetBytes(s: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    GetBytes(chars: ptr<char>, charCount: int, bytes: ptr<byte>, byteCount: int): int;
    GetBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>): int;
    GetCharCount(bytes: byte[]): int;
    GetCharCount(bytes: byte[], index: int, count: int): int;
    GetCharCount(bytes: ptr<byte>, count: int): int;
    GetCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    GetChars(bytes: byte[]): char[];
    GetChars(bytes: byte[], index: int, count: int): char[];
    GetChars(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int): int;
    GetChars(bytes: ptr<byte>, byteCount: int, chars: ptr<char>, charCount: int): int;
    GetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>): int;
    GetDecoder(): Decoder;
    GetEncoder(): Encoder;
    GetHashCode(): int;
    GetMaxByteCount(charCount: int): int;
    GetMaxCharCount(byteCount: int): int;
    GetPreamble(): byte[];
    GetString(bytes: ptr<byte>, byteCount: int): string;
    GetString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    GetString(bytes: byte[]): string;
    GetString(bytes: byte[], index: int, count: int): string;
    IsAlwaysNormalized(): boolean;
    IsAlwaysNormalized(form: NormalizationForm): boolean;
    TryGetBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryGetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
}


export const Encoding: {
    readonly Default: Encoding;
    readonly ASCII: Encoding;
    readonly Latin1: Encoding;
    readonly Unicode: Encoding;
    readonly BigEndianUnicode: Encoding;
    readonly UTF7: Encoding;
    readonly UTF8: Encoding;
    readonly UTF32: Encoding;
    Convert(srcEncoding: Encoding, dstEncoding: Encoding, bytes: byte[], index: int, count: int): byte[];
    Convert(srcEncoding: Encoding, dstEncoding: Encoding, bytes: byte[]): byte[];
    CreateTranscodingStream(innerStream: Stream, innerStreamEncoding: Encoding, outerStreamEncoding: Encoding, leaveOpen?: boolean): Stream;
    GetEncoding(codepage: int, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    GetEncoding(codepage: int): Encoding;
    GetEncoding(name: string, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    GetEncoding(name: string): Encoding;
    GetEncodings(): EncodingInfo[];
    RegisterProvider(provider: EncodingProvider): void;
};


export interface __Encoding$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface Encoding$instance extends System_Internal.ICloneable$instance {}

export type Encoding = Encoding$instance & __Encoding$views;


export interface EncodingInfo$instance {
    readonly CodePage: int;
    readonly DisplayName: string;
    readonly Name: string;
    Equals(value: unknown): boolean;
    GetEncoding(): Encoding;
    GetHashCode(): int;
}


export const EncodingInfo: {
    new(provider: EncodingProvider, codePage: int, name: string, displayName: string): EncodingInfo$instance;
};


export type EncodingInfo = EncodingInfo$instance;

export interface EncodingProvider$instance {
    GetEncoding(name: string): Encoding;
    GetEncoding(codepage: int): Encoding;
    GetEncoding(name: string, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    GetEncoding(codepage: int, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
    GetEncodings(): IEnumerable_1<EncodingInfo>;
}


export const EncodingProvider: {
    new(): EncodingProvider$instance;
};


export type EncodingProvider = EncodingProvider$instance;

export interface StringBuilder$instance {
    Capacity: int;
    Chars: char;
    Length: int;
    readonly MaxCapacity: int;
    Append(value: char, repeatCount: int): StringBuilder;
    Append(value: char[], startIndex: int, charCount: int): StringBuilder;
    Append(value: string): StringBuilder;
    Append(value: string, startIndex: int, count: int): StringBuilder;
    Append(value: StringBuilder): StringBuilder;
    Append(value: StringBuilder, startIndex: int, count: int): StringBuilder;
    Append(value: boolean): StringBuilder;
    Append(value: char): StringBuilder;
    Append(value: sbyte): StringBuilder;
    Append(value: byte): StringBuilder;
    Append(value: short): StringBuilder;
    Append(value: int): StringBuilder;
    Append(value: long): StringBuilder;
    Append(value: float): StringBuilder;
    Append(value: double): StringBuilder;
    Append(value: decimal): StringBuilder;
    Append(value: ushort): StringBuilder;
    Append(value: uint): StringBuilder;
    Append(value: ulong): StringBuilder;
    Append(value: unknown): StringBuilder;
    Append(value: char[]): StringBuilder;
    Append(value: ReadOnlySpan_1<CLROf<char>>): StringBuilder;
    Append(value: ReadOnlyMemory_1<CLROf<char>>): StringBuilder;
    Append(handler: { value: ref<StringBuilder_AppendInterpolatedStringHandler> }): StringBuilder;
    Append(provider: IFormatProvider, handler: { value: ref<StringBuilder_AppendInterpolatedStringHandler> }): StringBuilder;
    Append(value: ptr<char>, valueCount: int): StringBuilder;
    AppendFormat(format: string, arg0: unknown): StringBuilder;
    AppendFormat(format: string, arg0: unknown, arg1: unknown): StringBuilder;
    AppendFormat(format: string, arg0: unknown, arg1: unknown, arg2: unknown): StringBuilder;
    AppendFormat(format: string, args: unknown[]): StringBuilder;
    AppendFormat(format: string, args: ReadOnlySpan_1<unknown>): StringBuilder;
    AppendFormat(provider: IFormatProvider, format: string, arg0: unknown): StringBuilder;
    AppendFormat(provider: IFormatProvider, format: string, arg0: unknown, arg1: unknown): StringBuilder;
    AppendFormat(provider: IFormatProvider, format: string, arg0: unknown, arg1: unknown, arg2: unknown): StringBuilder;
    AppendFormat(provider: IFormatProvider, format: string, args: unknown[]): StringBuilder;
    AppendFormat(provider: IFormatProvider, format: string, args: ReadOnlySpan_1<unknown>): StringBuilder;
    AppendFormat<TArg0>(provider: IFormatProvider, format: CompositeFormat, arg0: TArg0): StringBuilder;
    AppendFormat<TArg0, TArg1>(provider: IFormatProvider, format: CompositeFormat, arg0: TArg0, arg1: TArg1): StringBuilder;
    AppendFormat<TArg0, TArg1, TArg2>(provider: IFormatProvider, format: CompositeFormat, arg0: TArg0, arg1: TArg1, arg2: TArg2): StringBuilder;
    AppendFormat(provider: IFormatProvider, format: CompositeFormat, args: unknown[]): StringBuilder;
    AppendFormat(provider: IFormatProvider, format: CompositeFormat, args: ReadOnlySpan_1<unknown>): StringBuilder;
    AppendJoin(separator: string, values: unknown[]): StringBuilder;
    AppendJoin(separator: string, values: ReadOnlySpan_1<unknown>): StringBuilder;
    AppendJoin<T>(separator: string, values: IEnumerable_1<T>): StringBuilder;
    AppendJoin(separator: string, values: string[]): StringBuilder;
    AppendJoin(separator: string, values: ReadOnlySpan_1<CLROf<string>>): StringBuilder;
    AppendJoin(separator: char, values: unknown[]): StringBuilder;
    AppendJoin(separator: char, values: ReadOnlySpan_1<unknown>): StringBuilder;
    AppendJoin<T>(separator: char, values: IEnumerable_1<T>): StringBuilder;
    AppendJoin(separator: char, values: string[]): StringBuilder;
    AppendJoin(separator: char, values: ReadOnlySpan_1<CLROf<string>>): StringBuilder;
    AppendLine(): StringBuilder;
    AppendLine(value: string): StringBuilder;
    AppendLine(handler: { value: ref<StringBuilder_AppendInterpolatedStringHandler> }): StringBuilder;
    AppendLine(provider: IFormatProvider, handler: { value: ref<StringBuilder_AppendInterpolatedStringHandler> }): StringBuilder;
    Clear(): StringBuilder;
    CopyTo(sourceIndex: int, destination: char[], destinationIndex: int, count: int): void;
    CopyTo(sourceIndex: int, destination: Span_1<CLROf<char>>, count: int): void;
    EnsureCapacity(capacity: int): int;
    Equals(sb: StringBuilder): boolean;
    Equals(span: ReadOnlySpan_1<CLROf<char>>): boolean;
    GetChunks(): StringBuilder_ChunkEnumerator;
    Insert(index: int, value: string, count: int): StringBuilder;
    Insert(index: int, value: string): StringBuilder;
    Insert(index: int, value: boolean): StringBuilder;
    Insert(index: int, value: sbyte): StringBuilder;
    Insert(index: int, value: byte): StringBuilder;
    Insert(index: int, value: short): StringBuilder;
    Insert(index: int, value: char): StringBuilder;
    Insert(index: int, value: char[]): StringBuilder;
    Insert(index: int, value: char[], startIndex: int, charCount: int): StringBuilder;
    Insert(index: int, value: int): StringBuilder;
    Insert(index: int, value: long): StringBuilder;
    Insert(index: int, value: float): StringBuilder;
    Insert(index: int, value: double): StringBuilder;
    Insert(index: int, value: decimal): StringBuilder;
    Insert(index: int, value: ushort): StringBuilder;
    Insert(index: int, value: uint): StringBuilder;
    Insert(index: int, value: ulong): StringBuilder;
    Insert(index: int, value: unknown): StringBuilder;
    Insert(index: int, value: ReadOnlySpan_1<CLROf<char>>): StringBuilder;
    Remove(startIndex: int, length: int): StringBuilder;
    Replace(oldValue: string, newValue: string): StringBuilder;
    Replace(oldValue: ReadOnlySpan_1<CLROf<char>>, newValue: ReadOnlySpan_1<CLROf<char>>): StringBuilder;
    Replace(oldValue: string, newValue: string, startIndex: int, count: int): StringBuilder;
    Replace(oldValue: ReadOnlySpan_1<CLROf<char>>, newValue: ReadOnlySpan_1<CLROf<char>>, startIndex: int, count: int): StringBuilder;
    Replace(oldChar: char, newChar: char): StringBuilder;
    Replace(oldChar: char, newChar: char, startIndex: int, count: int): StringBuilder;
    ToString(): string;
    ToString(startIndex: int, length: int): string;
}


export const StringBuilder: {
    new(): StringBuilder$instance;
    new(capacity: int): StringBuilder$instance;
    new(value: string): StringBuilder$instance;
    new(value: string, capacity: int): StringBuilder$instance;
    new(value: string, startIndex: int, length: int, capacity: int): StringBuilder$instance;
    new(capacity: int, maxCapacity: int): StringBuilder$instance;
};


export interface __StringBuilder$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface StringBuilder$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type StringBuilder = StringBuilder$instance & __StringBuilder$views;


export interface UnicodeEncoding$instance extends Encoding$instance {
    readonly Preamble: ReadOnlySpan_1<CLROf<byte>>;
    Clone(): unknown;
    Equals(value: unknown): boolean;
    GetByteCount(chars: char[], index: int, count: int): int;
    GetByteCount(s: string): int;
    GetByteCount(chars: ptr<char>, count: int): int;
    GetByteCount(chars: char[]): int;
    GetByteCount(s: string, index: int, count: int): int;
    GetByteCount(chars: ReadOnlySpan_1<CLROf<char>>): int;
    GetBytes(s: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    GetBytes(chars: char[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    GetBytes(chars: ptr<char>, charCount: int, bytes: ptr<byte>, byteCount: int): int;
    GetBytes(chars: char[]): byte[];
    GetBytes(chars: char[], index: int, count: int): byte[];
    GetBytes(s: string): byte[];
    GetBytes(s: string, index: int, count: int): byte[];
    GetBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>): int;
    GetCharCount(bytes: byte[], index: int, count: int): int;
    GetCharCount(bytes: ptr<byte>, count: int): int;
    GetCharCount(bytes: byte[]): int;
    GetCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    GetChars(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int): int;
    GetChars(bytes: ptr<byte>, byteCount: int, chars: ptr<char>, charCount: int): int;
    GetChars(bytes: byte[]): char[];
    GetChars(bytes: byte[], index: int, count: int): char[];
    GetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>): int;
    GetDecoder(): Decoder;
    GetEncoder(): Encoder;
    GetHashCode(): int;
    GetMaxByteCount(charCount: int): int;
    GetMaxCharCount(byteCount: int): int;
    GetPreamble(): byte[];
    GetString(bytes: byte[], index: int, count: int): string;
    GetString(bytes: ptr<byte>, byteCount: int): string;
    GetString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    GetString(bytes: byte[]): string;
}


export const UnicodeEncoding: {
    new(): UnicodeEncoding$instance;
    new(bigEndian: boolean, byteOrderMark: boolean): UnicodeEncoding$instance;
    new(bigEndian: boolean, byteOrderMark: boolean, throwOnInvalidBytes: boolean): UnicodeEncoding$instance;
    readonly CharSize: int;
};


export interface __UnicodeEncoding$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type UnicodeEncoding = UnicodeEncoding$instance & __UnicodeEncoding$views;


export interface UTF32Encoding$instance extends Encoding$instance {
    readonly Preamble: ReadOnlySpan_1<CLROf<byte>>;
    Clone(): unknown;
    Equals(value: unknown): boolean;
    GetByteCount(chars: char[], index: int, count: int): int;
    GetByteCount(s: string): int;
    GetByteCount(chars: ptr<char>, count: int): int;
    GetByteCount(chars: char[]): int;
    GetByteCount(s: string, index: int, count: int): int;
    GetByteCount(chars: ReadOnlySpan_1<CLROf<char>>): int;
    GetBytes(s: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    GetBytes(chars: char[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    GetBytes(chars: ptr<char>, charCount: int, bytes: ptr<byte>, byteCount: int): int;
    GetBytes(chars: char[]): byte[];
    GetBytes(chars: char[], index: int, count: int): byte[];
    GetBytes(s: string): byte[];
    GetBytes(s: string, index: int, count: int): byte[];
    GetBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>): int;
    GetCharCount(bytes: byte[], index: int, count: int): int;
    GetCharCount(bytes: ptr<byte>, count: int): int;
    GetCharCount(bytes: byte[]): int;
    GetCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    GetChars(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int): int;
    GetChars(bytes: ptr<byte>, byteCount: int, chars: ptr<char>, charCount: int): int;
    GetChars(bytes: byte[]): char[];
    GetChars(bytes: byte[], index: int, count: int): char[];
    GetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>): int;
    GetDecoder(): Decoder;
    GetEncoder(): Encoder;
    GetHashCode(): int;
    GetMaxByteCount(charCount: int): int;
    GetMaxCharCount(byteCount: int): int;
    GetPreamble(): byte[];
    GetString(bytes: byte[], index: int, count: int): string;
    GetString(bytes: ptr<byte>, byteCount: int): string;
    GetString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    GetString(bytes: byte[]): string;
}


export const UTF32Encoding: {
    new(): UTF32Encoding$instance;
    new(bigEndian: boolean, byteOrderMark: boolean): UTF32Encoding$instance;
    new(bigEndian: boolean, byteOrderMark: boolean, throwOnInvalidCharacters: boolean): UTF32Encoding$instance;
};


export interface __UTF32Encoding$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type UTF32Encoding = UTF32Encoding$instance & __UTF32Encoding$views;


export interface UTF7Encoding$instance extends Encoding$instance {
    Clone(): unknown;
    Equals(value: unknown): boolean;
    GetByteCount(chars: char[], index: int, count: int): int;
    GetByteCount(s: string): int;
    GetByteCount(chars: ptr<char>, count: int): int;
    GetByteCount(chars: char[]): int;
    GetByteCount(s: string, index: int, count: int): int;
    GetByteCount(chars: ReadOnlySpan_1<CLROf<char>>): int;
    GetBytes(s: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    GetBytes(chars: char[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    GetBytes(chars: ptr<char>, charCount: int, bytes: ptr<byte>, byteCount: int): int;
    GetBytes(chars: char[]): byte[];
    GetBytes(chars: char[], index: int, count: int): byte[];
    GetBytes(s: string): byte[];
    GetBytes(s: string, index: int, count: int): byte[];
    GetBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>): int;
    GetCharCount(bytes: byte[], index: int, count: int): int;
    GetCharCount(bytes: ptr<byte>, count: int): int;
    GetCharCount(bytes: byte[]): int;
    GetCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    GetChars(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int): int;
    GetChars(bytes: ptr<byte>, byteCount: int, chars: ptr<char>, charCount: int): int;
    GetChars(bytes: byte[]): char[];
    GetChars(bytes: byte[], index: int, count: int): char[];
    GetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>): int;
    GetDecoder(): Decoder;
    GetEncoder(): Encoder;
    GetHashCode(): int;
    GetMaxByteCount(charCount: int): int;
    GetMaxCharCount(byteCount: int): int;
    GetString(bytes: byte[], index: int, count: int): string;
    GetString(bytes: ptr<byte>, byteCount: int): string;
    GetString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    GetString(bytes: byte[]): string;
}


export const UTF7Encoding: {
    new(): UTF7Encoding$instance;
    new(allowOptionals: boolean): UTF7Encoding$instance;
};


export interface __UTF7Encoding$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type UTF7Encoding = UTF7Encoding$instance & __UTF7Encoding$views;


export interface UTF8Encoding$instance extends Encoding$instance {
    readonly Preamble: ReadOnlySpan_1<CLROf<byte>>;
    Clone(): unknown;
    Equals(value: unknown): boolean;
    GetByteCount(chars: char[], index: int, count: int): int;
    GetByteCount(chars: string): int;
    GetByteCount(chars: ptr<char>, count: int): int;
    GetByteCount(chars: ReadOnlySpan_1<CLROf<char>>): int;
    GetByteCount(chars: char[]): int;
    GetByteCount(s: string, index: int, count: int): int;
    GetByteCount(chars: ReadOnlySpan_1<CLROf<char>>): int;
    GetBytes(s: string, charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    GetBytes(chars: char[], charIndex: int, charCount: int, bytes: byte[], byteIndex: int): int;
    GetBytes(chars: ptr<char>, charCount: int, bytes: ptr<byte>, byteCount: int): int;
    GetBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>): int;
    GetBytes(chars: char[]): byte[];
    GetBytes(chars: char[], index: int, count: int): byte[];
    GetBytes(s: string): byte[];
    GetBytes(s: string, index: int, count: int): byte[];
    GetBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>): int;
    GetCharCount(bytes: byte[], index: int, count: int): int;
    GetCharCount(bytes: ptr<byte>, count: int): int;
    GetCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    GetCharCount(bytes: byte[]): int;
    GetCharCount(bytes: ReadOnlySpan_1<CLROf<byte>>): int;
    GetChars(bytes: byte[], byteIndex: int, byteCount: int, chars: char[], charIndex: int): int;
    GetChars(bytes: ptr<byte>, byteCount: int, chars: ptr<char>, charCount: int): int;
    GetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>): int;
    GetChars(bytes: byte[]): char[];
    GetChars(bytes: byte[], index: int, count: int): char[];
    GetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>): int;
    GetDecoder(): Decoder;
    GetEncoder(): Encoder;
    GetHashCode(): int;
    GetMaxByteCount(charCount: int): int;
    GetMaxCharCount(byteCount: int): int;
    GetPreamble(): byte[];
    GetString(bytes: byte[], index: int, count: int): string;
    GetString(bytes: ptr<byte>, byteCount: int): string;
    GetString(bytes: ReadOnlySpan_1<CLROf<byte>>): string;
    GetString(bytes: byte[]): string;
    TryGetBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryGetBytes(chars: ReadOnlySpan_1<CLROf<char>>, bytes: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryGetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    TryGetChars(bytes: ReadOnlySpan_1<CLROf<byte>>, chars: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
}


export const UTF8Encoding: {
    new(): UTF8Encoding$instance;
    new(encoderShouldEmitUTF8Identifier: boolean): UTF8Encoding$instance;
    new(encoderShouldEmitUTF8Identifier: boolean, throwOnInvalidBytes: boolean): UTF8Encoding$instance;
};


export interface __UTF8Encoding$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type UTF8Encoding = UTF8Encoding$instance & __UTF8Encoding$views;


export abstract class Ascii$instance {
    static Equals(left: ReadOnlySpan_1<CLROf<byte>>, right: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static Equals(left: ReadOnlySpan_1<CLROf<byte>>, right: ReadOnlySpan_1<CLROf<char>>): boolean;
    static Equals(left: ReadOnlySpan_1<CLROf<char>>, right: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static Equals(left: ReadOnlySpan_1<CLROf<char>>, right: ReadOnlySpan_1<CLROf<char>>): boolean;
    static EqualsIgnoreCase(left: ReadOnlySpan_1<CLROf<byte>>, right: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static EqualsIgnoreCase(left: ReadOnlySpan_1<CLROf<byte>>, right: ReadOnlySpan_1<CLROf<char>>): boolean;
    static EqualsIgnoreCase(left: ReadOnlySpan_1<CLROf<char>>, right: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static EqualsIgnoreCase(left: ReadOnlySpan_1<CLROf<char>>, right: ReadOnlySpan_1<CLROf<char>>): boolean;
    static FromUtf16(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static IsValid(value: byte): boolean;
    static IsValid(value: char): boolean;
    static IsValid(value: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static IsValid(value: ReadOnlySpan_1<CLROf<char>>): boolean;
    static ToLower(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static ToLower(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): OperationStatus;
    static ToLower(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static ToLower(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): OperationStatus;
    static ToLowerInPlace(value: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static ToLowerInPlace(value: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): OperationStatus;
    static ToUpper(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static ToUpper(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): OperationStatus;
    static ToUpper(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static ToUpper(source: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): OperationStatus;
    static ToUpperInPlace(value: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): OperationStatus;
    static ToUpperInPlace(value: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): OperationStatus;
    static ToUtf16(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): OperationStatus;
    static Trim(value: ReadOnlySpan_1<CLROf<byte>>): Range;
    static Trim(value: ReadOnlySpan_1<CLROf<char>>): Range;
    static TrimEnd(value: ReadOnlySpan_1<CLROf<byte>>): Range;
    static TrimEnd(value: ReadOnlySpan_1<CLROf<char>>): Range;
    static TrimStart(value: ReadOnlySpan_1<CLROf<byte>>): Range;
    static TrimStart(value: ReadOnlySpan_1<CLROf<char>>): Range;
}


export type Ascii = Ascii$instance;

export abstract class EncodingExtensions$instance {
    static Convert(decoder: Decoder, bytes: { value: ref<ReadOnlySequence_1<CLROf<byte>>> }, writer: IBufferWriter_1<CLROf<char>>, flush: boolean, charsUsed: { value: ref<long> }, completed: { value: ref<boolean> }): void;
    static Convert(decoder: Decoder, bytes: ReadOnlySpan_1<CLROf<byte>>, writer: IBufferWriter_1<CLROf<char>>, flush: boolean, charsUsed: { value: ref<long> }, completed: { value: ref<boolean> }): void;
    static Convert(encoder: Encoder, chars: { value: ref<ReadOnlySequence_1<CLROf<char>>> }, writer: IBufferWriter_1<CLROf<byte>>, flush: boolean, bytesUsed: { value: ref<long> }, completed: { value: ref<boolean> }): void;
    static Convert(encoder: Encoder, chars: ReadOnlySpan_1<CLROf<char>>, writer: IBufferWriter_1<CLROf<byte>>, flush: boolean, bytesUsed: { value: ref<long> }, completed: { value: ref<boolean> }): void;
    static GetBytes(encoding: Encoding, chars: { value: ref<ReadOnlySequence_1<CLROf<char>>> }, writer: IBufferWriter_1<CLROf<byte>>): long;
    static GetBytes(encoding: Encoding, chars: { value: ref<ReadOnlySequence_1<CLROf<char>>> }, bytes: Span_1<CLROf<byte>>): int;
    static GetBytes(encoding: Encoding, chars: { value: ref<ReadOnlySequence_1<CLROf<char>>> }): byte[];
    static GetBytes(encoding: Encoding, chars: ReadOnlySpan_1<CLROf<char>>, writer: IBufferWriter_1<CLROf<byte>>): long;
    static GetChars(encoding: Encoding, bytes: { value: ref<ReadOnlySequence_1<CLROf<byte>>> }, writer: IBufferWriter_1<CLROf<char>>): long;
    static GetChars(encoding: Encoding, bytes: { value: ref<ReadOnlySequence_1<CLROf<byte>>> }, chars: Span_1<CLROf<char>>): int;
    static GetChars(encoding: Encoding, bytes: ReadOnlySpan_1<CLROf<byte>>, writer: IBufferWriter_1<CLROf<char>>): long;
    static GetString(encoding: Encoding, bytes: { value: ref<ReadOnlySequence_1<CLROf<byte>>> }): string;
}


export type EncodingExtensions = EncodingExtensions$instance;


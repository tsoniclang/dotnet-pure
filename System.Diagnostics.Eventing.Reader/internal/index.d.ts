// Generated by tsbindgen - Architecture
// Namespace: System.Diagnostics.Eventing.Reader
// Assembly: System.Diagnostics.EventLog

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import type { IEnumerable_1, IList_1 } from "../../System.Collections.Generic/internal/index.js";
import type { IDictionary } from "../../System.Collections/internal/index.js";
import type { CultureInfo } from "../../System.Globalization/internal/index.js";
import type { SeekOrigin } from "../../System.IO/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { SecurityIdentifier } from "../../System.Security.Principal/internal/index.js";
import type { SecureString } from "../../System.Security/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Byte, DateTime, Enum, EventArgs, EventHandler_1, Exception, Guid, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int16, Int32, Int64, ISpanFormattable, Nullable_1, Object as ClrObject, String as ClrString, TimeSpan, Type, TypeCode, Uri, Void } from "../../System/internal/index.js";

export enum EventLogIsolation {
    Application = 0,
    System = 1,
    Custom = 2
}


export enum EventLogMode {
    Circular = 0,
    AutoBackup = 1,
    Retain = 2
}


export enum EventLogType {
    Administrative = 0,
    Operational = 1,
    Analytical = 2,
    Debug = 3
}


export enum PathType {
    LogName = 1,
    FilePath = 2
}


export enum SessionAuthentication {
    Default = 0,
    Negotiate = 1,
    Kerberos = 2,
    Ntlm = 3
}


export enum StandardEventKeywords {
    None = 0,
    ResponseTime = 281474976710656,
    WdiContext = 562949953421312,
    WdiDiagnostic = 1125899906842624,
    Sqm = 2251799813685248,
    AuditFailure = 4503599627370496,
    CorrelationHint = 4503599627370496,
    AuditSuccess = 9007199254740992,
    CorrelationHint2 = 18014398509481984,
    EventLogClassic = 36028797018963968
}


export enum StandardEventLevel {
    LogAlways = 0,
    Critical = 1,
    Error = 2,
    Warning = 3,
    Informational = 4,
    Verbose = 5
}


export enum StandardEventOpcode {
    Info = 0,
    Start = 1,
    Stop = 2,
    DataCollectionStart = 3,
    DataCollectionStop = 4,
    Extension = 5,
    Reply = 6,
    Resume = 7,
    Suspend = 8,
    Send = 9,
    Receive = 240
}


export enum StandardEventTask {
    None = 0
}


export interface EventBookmark$instance {
    readonly BookmarkXml: string;
}


export const EventBookmark: {
    new(bookmarkXml: string): EventBookmark;
};


export type EventBookmark = EventBookmark$instance;

export interface EventKeyword$instance {
    readonly DisplayName: string;
    readonly Name: string;
    readonly Value: long;
}


export const EventKeyword: {
    new(): EventKeyword;
};


export type EventKeyword = EventKeyword$instance;

export interface EventLevel$instance {
    readonly DisplayName: string;
    readonly Name: string;
    readonly Value: int;
}


export const EventLevel: {
    new(): EventLevel;
};


export type EventLevel = EventLevel$instance;

export interface EventLogConfiguration$instance {
    readonly IsClassicLog: boolean;
    IsEnabled: boolean;
    LogFilePath: string;
    readonly LogIsolation: EventLogIsolation;
    LogMode: EventLogMode;
    readonly LogName: string;
    readonly LogType: EventLogType;
    MaximumSizeInBytes: long;
    readonly OwningProviderName: string;
    readonly ProviderBufferSize: Nullable_1<System_Internal.Int32>;
    readonly ProviderControlGuid: Nullable_1<Guid>;
    ProviderKeywords: Nullable_1<System_Internal.Int64>;
    readonly ProviderLatency: Nullable_1<System_Internal.Int32>;
    ProviderLevel: Nullable_1<System_Internal.Int32>;
    readonly ProviderMaximumNumberOfBuffers: Nullable_1<System_Internal.Int32>;
    readonly ProviderMinimumNumberOfBuffers: Nullable_1<System_Internal.Int32>;
    readonly ProviderNames: IEnumerable_1<System_Internal.String>;
    SecurityDescriptor: string;
    Dispose(): void;
    SaveChanges(): void;
}


export const EventLogConfiguration: {
    new(logName: string): EventLogConfiguration;
    new(logName: string, session: EventLogSession): EventLogConfiguration;
};


export interface __EventLogConfiguration$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface EventLogConfiguration$instance extends System_Internal.IDisposable$instance {}

export type EventLogConfiguration = EventLogConfiguration$instance & __EventLogConfiguration$views;


export interface EventLogException$instance extends Exception {
    readonly Message: string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const EventLogException: {
    new(): EventLogException;
    new(message: string): EventLogException;
    new(message: string, innerException: Exception): EventLogException;
};


export interface __EventLogException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type EventLogException = EventLogException$instance & __EventLogException$views;


export interface EventLogInformation$instance {
    readonly Attributes: Nullable_1<System_Internal.Int32>;
    readonly CreationTime: Nullable_1<DateTime>;
    readonly FileSize: Nullable_1<System_Internal.Int64>;
    readonly IsLogFull: Nullable_1<System_Internal.Boolean>;
    readonly LastAccessTime: Nullable_1<DateTime>;
    readonly LastWriteTime: Nullable_1<DateTime>;
    readonly OldestRecordNumber: Nullable_1<System_Internal.Int64>;
    readonly RecordCount: Nullable_1<System_Internal.Int64>;
}


export const EventLogInformation: {
    new(): EventLogInformation;
};


export type EventLogInformation = EventLogInformation$instance;

export interface EventLogInvalidDataException$instance extends EventLogException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const EventLogInvalidDataException: {
    new(): EventLogInvalidDataException;
    new(message: string): EventLogInvalidDataException;
    new(message: string, innerException: Exception): EventLogInvalidDataException;
};


export interface __EventLogInvalidDataException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type EventLogInvalidDataException = EventLogInvalidDataException$instance & __EventLogInvalidDataException$views;


export interface EventLogLink$instance {
    readonly DisplayName: string;
    readonly IsImported: boolean;
    readonly LogName: string;
}


export const EventLogLink: {
    new(): EventLogLink;
};


export type EventLogLink = EventLogLink$instance;

export interface EventLogNotFoundException$instance extends EventLogException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const EventLogNotFoundException: {
    new(): EventLogNotFoundException;
    new(message: string): EventLogNotFoundException;
    new(message: string, innerException: Exception): EventLogNotFoundException;
};


export interface __EventLogNotFoundException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type EventLogNotFoundException = EventLogNotFoundException$instance & __EventLogNotFoundException$views;


export interface EventLogPropertySelector$instance {
    Dispose(): void;
}


export const EventLogPropertySelector: {
    new(propertyQueries: IEnumerable_1<System_Internal.String>): EventLogPropertySelector;
};


export interface __EventLogPropertySelector$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface EventLogPropertySelector$instance extends System_Internal.IDisposable$instance {}

export type EventLogPropertySelector = EventLogPropertySelector$instance & __EventLogPropertySelector$views;


export interface EventLogProviderDisabledException$instance extends EventLogException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const EventLogProviderDisabledException: {
    new(): EventLogProviderDisabledException;
    new(message: string): EventLogProviderDisabledException;
    new(message: string, innerException: Exception): EventLogProviderDisabledException;
};


export interface __EventLogProviderDisabledException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type EventLogProviderDisabledException = EventLogProviderDisabledException$instance & __EventLogProviderDisabledException$views;


export interface EventLogQuery$instance {
    ReverseDirection: boolean;
    Session: EventLogSession;
    TolerateQueryErrors: boolean;
}


export const EventLogQuery: {
    new(path: string, pathType: PathType): EventLogQuery;
    new(path: string, pathType: PathType, query: string): EventLogQuery;
};


export type EventLogQuery = EventLogQuery$instance;

export interface EventLogReader$instance {
    BatchSize: int;
    readonly LogStatus: IList_1<EventLogStatus>;
    CancelReading(): void;
    Dispose(): void;
    ReadEvent(): EventRecord;
    ReadEvent(timeout: TimeSpan): EventRecord;
    Seek(bookmark: EventBookmark): void;
    Seek(bookmark: EventBookmark, offset: long): void;
    Seek(origin: SeekOrigin, offset: long): void;
}


export const EventLogReader: {
    new(eventQuery: EventLogQuery): EventLogReader;
    new(eventQuery: EventLogQuery, bookmark: EventBookmark): EventLogReader;
    new(path: string): EventLogReader;
    new(path: string, pathType: PathType): EventLogReader;
};


export interface __EventLogReader$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface EventLogReader$instance extends System_Internal.IDisposable$instance {}

export type EventLogReader = EventLogReader$instance & __EventLogReader$views;


export interface EventLogReadingException$instance extends EventLogException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const EventLogReadingException: {
    new(): EventLogReadingException;
    new(message: string): EventLogReadingException;
    new(message: string, innerException: Exception): EventLogReadingException;
};


export interface __EventLogReadingException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type EventLogReadingException = EventLogReadingException$instance & __EventLogReadingException$views;


export interface EventLogRecord$instance extends EventRecord$instance {
    readonly ActivityId: Nullable_1<Guid>;
    readonly Bookmark: EventBookmark;
    readonly ContainerLog: string;
    readonly Id: int;
    readonly Keywords: Nullable_1<System_Internal.Int64>;
    readonly KeywordsDisplayNames: IEnumerable_1<System_Internal.String>;
    readonly Level: Nullable_1<System_Internal.Byte>;
    readonly LevelDisplayName: string;
    readonly LogName: string;
    readonly MachineName: string;
    readonly MatchedQueryIds: IEnumerable_1<System_Internal.Int32>;
    readonly Opcode: Nullable_1<System_Internal.Int16>;
    readonly OpcodeDisplayName: string;
    readonly ProcessId: Nullable_1<System_Internal.Int32>;
    readonly Properties: IList_1<EventProperty>;
    readonly ProviderId: Nullable_1<Guid>;
    readonly ProviderName: string;
    readonly Qualifiers: Nullable_1<System_Internal.Int32>;
    readonly RecordId: Nullable_1<System_Internal.Int64>;
    readonly RelatedActivityId: Nullable_1<Guid>;
    readonly Task: Nullable_1<System_Internal.Int32>;
    readonly TaskDisplayName: string;
    readonly ThreadId: Nullable_1<System_Internal.Int32>;
    readonly TimeCreated: Nullable_1<DateTime>;
    readonly UserId: SecurityIdentifier;
    readonly Version: Nullable_1<System_Internal.Byte>;
    Dispose(): void;
    FormatDescription(): string;
    FormatDescription(values: IEnumerable_1<unknown>): string;
    GetPropertyValues(propertySelector: EventLogPropertySelector): IList_1<unknown>;
    ToXml(): string | undefined;
}


export const EventLogRecord: {
    new(): EventLogRecord;
};


export interface __EventLogRecord$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type EventLogRecord = EventLogRecord$instance & __EventLogRecord$views;


export interface EventLogSession$instance {
    CancelCurrentOperations(): void;
    ClearLog(logName: string): void;
    ClearLog(logName: string, backupPath: string): void;
    Dispose(): void;
    ExportLog(path: string, pathType: PathType, query: string, targetFilePath: string): void;
    ExportLog(path: string, pathType: PathType, query: string, targetFilePath: string, tolerateQueryErrors: boolean): void;
    ExportLogAndMessages(path: string, pathType: PathType, query: string, targetFilePath: string): void;
    ExportLogAndMessages(path: string, pathType: PathType, query: string, targetFilePath: string, tolerateQueryErrors: boolean, targetCultureInfo: CultureInfo): void;
    GetLogInformation(logName: string, pathType: PathType): EventLogInformation;
    GetLogNames(): IEnumerable_1<System_Internal.String>;
    GetProviderNames(): IEnumerable_1<System_Internal.String>;
}


export const EventLogSession: {
    new(): EventLogSession;
    new(server: string): EventLogSession;
    new(server: string, domain: string, user: string, password: SecureString, logOnType: SessionAuthentication): EventLogSession;
    readonly GlobalSession: EventLogSession;
};


export interface __EventLogSession$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface EventLogSession$instance extends System_Internal.IDisposable$instance {}

export type EventLogSession = EventLogSession$instance & __EventLogSession$views;


export interface EventLogStatus$instance {
    readonly LogName: string;
    readonly StatusCode: int;
}


export const EventLogStatus: {
    new(): EventLogStatus;
};


export type EventLogStatus = EventLogStatus$instance;

export interface EventLogWatcher$instance {
    Enabled: boolean;
    Dispose(): void;
}


export const EventLogWatcher: {
    new(eventQuery: EventLogQuery): EventLogWatcher;
    new(eventQuery: EventLogQuery, bookmark: EventBookmark): EventLogWatcher;
    new(eventQuery: EventLogQuery, bookmark: EventBookmark, readExistingEvents: boolean): EventLogWatcher;
    new(path: string): EventLogWatcher;
};


export interface __EventLogWatcher$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface EventLogWatcher$instance extends System_Internal.IDisposable$instance {}

export type EventLogWatcher = EventLogWatcher$instance & __EventLogWatcher$views;


export interface EventMetadata$instance {
    readonly Description: string;
    readonly Id: long;
    readonly Keywords: IEnumerable_1<EventKeyword>;
    readonly Level: EventLevel;
    readonly LogLink: EventLogLink;
    readonly Opcode: EventOpcode;
    readonly Task: EventTask;
    readonly Template: string;
    readonly Version: byte;
}


export const EventMetadata: {
    new(): EventMetadata;
};


export type EventMetadata = EventMetadata$instance;

export interface EventOpcode$instance {
    readonly DisplayName: string;
    readonly Name: string;
    readonly Value: int;
}


export const EventOpcode: {
    new(): EventOpcode;
};


export type EventOpcode = EventOpcode$instance;

export interface EventProperty$instance {
    readonly Value: unknown;
}


export const EventProperty: {
    new(): EventProperty;
};


export type EventProperty = EventProperty$instance;

export interface EventRecord$instance {
    readonly ActivityId: Nullable_1<Guid>;
    readonly Bookmark: EventBookmark;
    readonly Id: int;
    readonly Keywords: Nullable_1<System_Internal.Int64>;
    readonly KeywordsDisplayNames: IEnumerable_1<System_Internal.String>;
    readonly Level: Nullable_1<System_Internal.Byte>;
    readonly LevelDisplayName: string;
    readonly LogName: string;
    readonly MachineName: string;
    readonly Opcode: Nullable_1<System_Internal.Int16>;
    readonly OpcodeDisplayName: string;
    readonly ProcessId: Nullable_1<System_Internal.Int32>;
    readonly Properties: IList_1<EventProperty>;
    readonly ProviderId: Nullable_1<Guid>;
    readonly ProviderName: string;
    readonly Qualifiers: Nullable_1<System_Internal.Int32>;
    readonly RecordId: Nullable_1<System_Internal.Int64>;
    readonly RelatedActivityId: Nullable_1<Guid>;
    readonly Task: Nullable_1<System_Internal.Int32>;
    readonly TaskDisplayName: string;
    readonly ThreadId: Nullable_1<System_Internal.Int32>;
    readonly TimeCreated: Nullable_1<DateTime>;
    readonly UserId: SecurityIdentifier;
    readonly Version: Nullable_1<System_Internal.Byte>;
    Dispose(): void;
    FormatDescription(): string;
    FormatDescription(values: IEnumerable_1<unknown>): string;
    ToXml(): string | undefined;
}


export const EventRecord: {
};


export interface __EventRecord$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface EventRecord$instance extends System_Internal.IDisposable$instance {}

export type EventRecord = EventRecord$instance & __EventRecord$views;


export interface EventRecordWrittenEventArgs$instance extends EventArgs {
    readonly EventException: Exception;
    readonly EventRecord: EventRecord;
}


export const EventRecordWrittenEventArgs: {
    new(): EventRecordWrittenEventArgs;
};


export type EventRecordWrittenEventArgs = EventRecordWrittenEventArgs$instance;

export interface EventTask$instance {
    readonly DisplayName: string;
    readonly EventGuid: Guid;
    readonly Name: string;
    readonly Value: int;
}


export const EventTask: {
    new(): EventTask;
};


export type EventTask = EventTask$instance;

export interface ProviderMetadata$instance {
    readonly DisplayName: string;
    readonly Events: IEnumerable_1<EventMetadata>;
    readonly HelpLink: Uri | undefined;
    readonly Id: Guid;
    readonly Keywords: IList_1<EventKeyword>;
    readonly Levels: IList_1<EventLevel>;
    readonly LogLinks: IList_1<EventLogLink>;
    readonly MessageFilePath: string;
    readonly Name: string;
    readonly Opcodes: IList_1<EventOpcode>;
    readonly ParameterFilePath: string;
    readonly ResourceFilePath: string;
    readonly Tasks: IList_1<EventTask>;
    Dispose(): void;
}


export const ProviderMetadata: {
    new(providerName: string): ProviderMetadata;
    new(providerName: string, session: EventLogSession, targetCultureInfo: CultureInfo): ProviderMetadata;
};


export interface __ProviderMetadata$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ProviderMetadata$instance extends System_Internal.IDisposable$instance {}

export type ProviderMetadata = ProviderMetadata$instance & __ProviderMetadata$views;



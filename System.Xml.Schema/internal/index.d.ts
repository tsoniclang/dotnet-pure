// Generated by tsbindgen - Architecture
// Namespace: System.Xml.Schema
// Assembly: System.Private.Xml, System.Private.Xml.Linq

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ArrayList, CollectionBase, ICollection, IDictionary, IDictionaryEnumerator, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import type { Stream, TextReader, TextWriter } from "../../System.IO/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { XAttribute, XDocument, XElement } from "../../System.Xml.Linq/internal/index.js";
import type { XmlSerializerNamespaces } from "../../System.Xml.Serialization/internal/index.js";
import * as System_Xml_XPath_Internal from "../../System.Xml.XPath/internal/index.js";
import type { XPathItem } from "../../System.Xml.XPath/internal/index.js";
import type { IXmlLineInfo, IXmlNamespaceResolver, XmlAttribute, XmlNamespaceManager, XmlNameTable, XmlNode, XmlQualifiedName, XmlReader, XmlResolver, XmlTokenizedType, XmlWriter } from "../../System.Xml/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, AsyncCallback, Boolean as ClrBoolean, DateTime, Decimal, Delegate, Double, Enum, EventArgs, Exception, IAsyncResult, ICloneable, IComparable, IConvertible, IFormatProvider, IFormattable, Int32, Int64, IntPtr, ISpanFormattable, MulticastDelegate, Object as ClrObject, String as ClrString, SystemException, Type, TypeCode, Uri, Void } from "../../System/internal/index.js";

export enum XmlSchemaContentProcessing {
    None = 0,
    Skip = 1,
    Lax = 2,
    Strict = 3
}


export enum XmlSchemaContentType {
    TextOnly = 0,
    Empty = 1,
    ElementOnly = 2,
    Mixed = 3
}


export enum XmlSchemaDatatypeVariety {
    Atomic = 0,
    List = 1,
    Union = 2
}


export enum XmlSchemaDerivationMethod {
    Empty = 0,
    Substitution = 1,
    Extension = 2,
    Restriction = 4,
    List = 8,
    Union = 16,
    All = 255,
    None = 256
}


export enum XmlSchemaForm {
    None = 0,
    Qualified = 1,
    Unqualified = 2
}


export enum XmlSchemaInference_InferenceOption {
    Restricted = 0,
    Relaxed = 1
}


export enum XmlSchemaUse {
    None = 0,
    Optional = 1,
    Prohibited = 2,
    Required = 3
}


export enum XmlSchemaValidationFlags {
    None = 0,
    ProcessInlineSchema = 1,
    ProcessSchemaLocation = 2,
    ReportValidationWarnings = 4,
    ProcessIdentityConstraints = 8,
    AllowXmlAttributes = 16
}


export enum XmlSchemaValidity {
    NotKnown = 0,
    Valid = 1,
    Invalid = 2
}


export enum XmlSeverityType {
    Error = 0,
    Warning = 1
}


export enum XmlTypeCode {
    None = 0,
    Item = 1,
    Node = 2,
    Document = 3,
    Element = 4,
    Attribute = 5,
    Namespace = 6,
    ProcessingInstruction = 7,
    Comment = 8,
    Text = 9,
    AnyAtomicType = 10,
    UntypedAtomic = 11,
    String = 12,
    Boolean = 13,
    Decimal = 14,
    Float = 15,
    Double = 16,
    Duration = 17,
    DateTime = 18,
    Time = 19,
    Date = 20,
    GYearMonth = 21,
    GYear = 22,
    GMonthDay = 23,
    GDay = 24,
    GMonth = 25,
    HexBinary = 26,
    Base64Binary = 27,
    AnyUri = 28,
    QName = 29,
    Notation = 30,
    NormalizedString = 31,
    Token = 32,
    Language = 33,
    NmToken = 34,
    Name = 35,
    NCName = 36,
    Id = 37,
    Idref = 38,
    Entity = 39,
    Integer = 40,
    NonPositiveInteger = 41,
    NegativeInteger = 42,
    Long = 43,
    Int = 44,
    Short = 45,
    Byte = 46,
    NonNegativeInteger = 47,
    UnsignedLong = 48,
    UnsignedInt = 49,
    UnsignedShort = 50,
    UnsignedByte = 51,
    PositiveInteger = 52,
    YearMonthDuration = 53,
    DayTimeDuration = 54
}


export type ValidationEventHandler = (sender: unknown, e: ValidationEventArgs) => void;


export type XmlValueGetter = () => unknown;


export interface IXmlSchemaInfo$instance {
    readonly Validity: XmlSchemaValidity;
    readonly IsDefault: boolean;
    readonly IsNil: boolean;
    readonly MemberType: XmlSchemaSimpleType | undefined;
    readonly SchemaType: XmlSchemaType | undefined;
    readonly SchemaElement: XmlSchemaElement | undefined;
    readonly SchemaAttribute: XmlSchemaAttribute | undefined;
}


export type IXmlSchemaInfo = IXmlSchemaInfo$instance;

export interface ValidationEventArgs$instance extends EventArgs {
    readonly Exception: XmlSchemaException;
    readonly Message: string;
    readonly Severity: XmlSeverityType;
}


export const ValidationEventArgs: {
    new(): ValidationEventArgs;
};


export type ValidationEventArgs = ValidationEventArgs$instance;

export interface XmlAtomicValue$instance extends XPathItem {
    readonly IsNode: boolean;
    readonly TypedValue: unknown;
    readonly Value: string;
    readonly ValueAsBoolean: boolean;
    readonly ValueAsDateTime: DateTime;
    readonly ValueAsDouble: double;
    readonly ValueAsInt: int;
    readonly ValueAsLong: long;
    readonly ValueType: Type;
    readonly XmlType: XmlSchemaType | XmlSchemaType | undefined;
    Clone(): XmlAtomicValue;
    ToString(): string;
    ValueAs(type: Type, nsResolver: IXmlNamespaceResolver): unknown;
    ValueAs(returnType: Type): unknown;
}


export const XmlAtomicValue: {
    new(): XmlAtomicValue;
};


export interface __XmlAtomicValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export type XmlAtomicValue = XmlAtomicValue$instance & __XmlAtomicValue$views;


export interface XmlSchema$instance extends XmlSchemaObject {
    AttributeFormDefault: XmlSchemaForm;
    readonly AttributeGroups: XmlSchemaObjectTable;
    readonly Attributes: XmlSchemaObjectTable;
    BlockDefault: XmlSchemaDerivationMethod;
    ElementFormDefault: XmlSchemaForm;
    readonly Elements: XmlSchemaObjectTable;
    FinalDefault: XmlSchemaDerivationMethod;
    readonly Groups: XmlSchemaObjectTable;
    Id: string;
    readonly Includes: XmlSchemaObjectCollection;
    readonly IsCompiled: boolean;
    readonly Items: XmlSchemaObjectCollection;
    readonly Notations: XmlSchemaObjectTable;
    readonly SchemaTypes: XmlSchemaObjectTable;
    get TargetNamespace(): string | undefined;
    set TargetNamespace(value: string);
    get UnhandledAttributes(): XmlAttribute[] | undefined;
    set UnhandledAttributes(value: XmlAttribute[]);
    Version: string;
    Compile(validationEventHandler: ValidationEventHandler): void;
    Compile(validationEventHandler: ValidationEventHandler, resolver: XmlResolver): void;
    Write(stream: Stream): void;
    Write(stream: Stream, namespaceManager: XmlNamespaceManager): void;
    Write(writer: TextWriter): void;
    Write(writer: TextWriter, namespaceManager: XmlNamespaceManager): void;
    Write(writer: XmlWriter): void;
    Write(writer: XmlWriter, namespaceManager: XmlNamespaceManager): void;
}


export const XmlSchema: {
    new(): XmlSchema;
    readonly Namespace: string;
    readonly InstanceNamespace: string;
    Read(stream: Stream, validationEventHandler: ValidationEventHandler): XmlSchema | undefined;
    Read(reader: TextReader, validationEventHandler: ValidationEventHandler): XmlSchema | undefined;
    Read(reader: XmlReader, validationEventHandler: ValidationEventHandler): XmlSchema | undefined;
};


export type XmlSchema = XmlSchema$instance;

export interface XmlSchemaAll$instance extends XmlSchemaGroupBase {
    readonly Items: XmlSchemaObjectCollection;
}


export const XmlSchemaAll: {
    new(): XmlSchemaAll;
};


export type XmlSchemaAll = XmlSchemaAll$instance;

export interface XmlSchemaAnnotated$instance extends XmlSchemaObject {
    get Annotation(): XmlSchemaAnnotation | undefined;
    set Annotation(value: XmlSchemaAnnotation);
    Id: string;
    get UnhandledAttributes(): XmlAttribute[] | undefined;
    set UnhandledAttributes(value: XmlAttribute[]);
}


export const XmlSchemaAnnotated: {
    new(): XmlSchemaAnnotated;
};


export type XmlSchemaAnnotated = XmlSchemaAnnotated$instance;

export interface XmlSchemaAnnotation$instance extends XmlSchemaObject {
    Id: string;
    readonly Items: XmlSchemaObjectCollection;
    get UnhandledAttributes(): XmlAttribute[] | undefined;
    set UnhandledAttributes(value: XmlAttribute[]);
}


export const XmlSchemaAnnotation: {
    new(): XmlSchemaAnnotation;
};


export type XmlSchemaAnnotation = XmlSchemaAnnotation$instance;

export interface XmlSchemaAny$instance extends XmlSchemaParticle {
    Namespace: string;
    ProcessContents: XmlSchemaContentProcessing;
}


export const XmlSchemaAny: {
    new(): XmlSchemaAny;
};


export type XmlSchemaAny = XmlSchemaAny$instance;

export interface XmlSchemaAnyAttribute$instance extends XmlSchemaAnnotated {
    Namespace: string;
    ProcessContents: XmlSchemaContentProcessing;
}


export const XmlSchemaAnyAttribute: {
    new(): XmlSchemaAnyAttribute;
};


export type XmlSchemaAnyAttribute = XmlSchemaAnyAttribute$instance;

export interface XmlSchemaAppInfo$instance extends XmlSchemaObject {
    get Markup(): (XmlNode | undefined)[] | undefined;
    set Markup(value: (XmlNode | undefined)[]);
    Source: string;
}


export const XmlSchemaAppInfo: {
    new(): XmlSchemaAppInfo;
};


export type XmlSchemaAppInfo = XmlSchemaAppInfo$instance;

export interface XmlSchemaAttribute$instance extends XmlSchemaAnnotated {
    readonly AttributeSchemaType: XmlSchemaSimpleType | undefined;
    readonly AttributeType: unknown;
    DefaultValue: string;
    get FixedValue(): string | undefined;
    set FixedValue(value: string);
    Form: XmlSchemaForm;
    Name: string;
    readonly QualifiedName: XmlQualifiedName;
    RefName: XmlQualifiedName;
    get SchemaType(): XmlSchemaSimpleType | undefined;
    set SchemaType(value: XmlSchemaSimpleType);
    SchemaTypeName: XmlQualifiedName;
    Use: XmlSchemaUse;
}


export const XmlSchemaAttribute: {
    new(): XmlSchemaAttribute;
};


export type XmlSchemaAttribute = XmlSchemaAttribute$instance;

export interface XmlSchemaAttributeGroup$instance extends XmlSchemaAnnotated {
    get AnyAttribute(): XmlSchemaAnyAttribute | undefined;
    set AnyAttribute(value: XmlSchemaAnyAttribute);
    readonly Attributes: XmlSchemaObjectCollection;
    Name: string;
    readonly QualifiedName: XmlQualifiedName;
    readonly RedefinedAttributeGroup: XmlSchemaAttributeGroup | undefined;
}


export const XmlSchemaAttributeGroup: {
    new(): XmlSchemaAttributeGroup;
};


export type XmlSchemaAttributeGroup = XmlSchemaAttributeGroup$instance;

export interface XmlSchemaAttributeGroupRef$instance extends XmlSchemaAnnotated {
    RefName: XmlQualifiedName;
}


export const XmlSchemaAttributeGroupRef: {
    new(): XmlSchemaAttributeGroupRef;
};


export type XmlSchemaAttributeGroupRef = XmlSchemaAttributeGroupRef$instance;

export interface XmlSchemaChoice$instance extends XmlSchemaGroupBase {
    readonly Items: XmlSchemaObjectCollection;
}


export const XmlSchemaChoice: {
    new(): XmlSchemaChoice;
};


export type XmlSchemaChoice = XmlSchemaChoice$instance;

export interface XmlSchemaCollection$instance {
    readonly Count: int;
    readonly Item: XmlSchema;
    readonly NameTable: XmlNameTable;
    Add(ns: string, uri: string): XmlSchema;
    Add(ns: string, reader: XmlReader): XmlSchema | undefined;
    Add(ns: string, reader: XmlReader, resolver: XmlResolver): XmlSchema | undefined;
    Add(schema: XmlSchema): XmlSchema | undefined;
    Add(schema: XmlSchema, resolver: XmlResolver): XmlSchema | undefined;
    Add(schema: XmlSchemaCollection): void;
    Contains(schema: XmlSchema): boolean;
    Contains(ns: string): boolean;
    CopyTo(array: XmlSchema[], index: int): void;
    GetEnumerator(): XmlSchemaCollectionEnumerator;
}


export const XmlSchemaCollection: {
    new(): XmlSchemaCollection;
    new(nametable: XmlNameTable): XmlSchemaCollection;
};


export interface __XmlSchemaCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type XmlSchemaCollection = XmlSchemaCollection$instance & __XmlSchemaCollection$views;


export interface XmlSchemaCollectionEnumerator$instance {
    readonly Current: XmlSchema;
    MoveNext(): boolean;
    Reset(): void;
}


export const XmlSchemaCollectionEnumerator: {
    new(): XmlSchemaCollectionEnumerator;
};


export interface __XmlSchemaCollectionEnumerator$views {
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type XmlSchemaCollectionEnumerator = XmlSchemaCollectionEnumerator$instance & __XmlSchemaCollectionEnumerator$views;


export interface XmlSchemaCompilationSettings$instance {
    EnableUpaCheck: boolean;
}


export const XmlSchemaCompilationSettings: {
    new(): XmlSchemaCompilationSettings;
};


export type XmlSchemaCompilationSettings = XmlSchemaCompilationSettings$instance;

export interface XmlSchemaComplexContent$instance extends XmlSchemaContentModel {
    Content: XmlSchemaContent;
    IsMixed: boolean;
}


export const XmlSchemaComplexContent: {
    new(): XmlSchemaComplexContent;
};


export type XmlSchemaComplexContent = XmlSchemaComplexContent$instance;

export interface XmlSchemaComplexContentExtension$instance extends XmlSchemaContent {
    get AnyAttribute(): XmlSchemaAnyAttribute | undefined;
    set AnyAttribute(value: XmlSchemaAnyAttribute);
    readonly Attributes: XmlSchemaObjectCollection;
    BaseTypeName: XmlQualifiedName;
    get Particle(): XmlSchemaParticle | undefined;
    set Particle(value: XmlSchemaParticle);
}


export const XmlSchemaComplexContentExtension: {
    new(): XmlSchemaComplexContentExtension;
};


export type XmlSchemaComplexContentExtension = XmlSchemaComplexContentExtension$instance;

export interface XmlSchemaComplexContentRestriction$instance extends XmlSchemaContent {
    get AnyAttribute(): XmlSchemaAnyAttribute | undefined;
    set AnyAttribute(value: XmlSchemaAnyAttribute);
    readonly Attributes: XmlSchemaObjectCollection;
    BaseTypeName: XmlQualifiedName;
    get Particle(): XmlSchemaParticle | undefined;
    set Particle(value: XmlSchemaParticle);
}


export const XmlSchemaComplexContentRestriction: {
    new(): XmlSchemaComplexContentRestriction;
};


export type XmlSchemaComplexContentRestriction = XmlSchemaComplexContentRestriction$instance;

export interface XmlSchemaComplexType$instance extends XmlSchemaType {
    get AnyAttribute(): XmlSchemaAnyAttribute | undefined;
    set AnyAttribute(value: XmlSchemaAnyAttribute);
    readonly Attributes: XmlSchemaObjectCollection;
    readonly AttributeUses: XmlSchemaObjectTable;
    readonly AttributeWildcard: XmlSchemaAnyAttribute | undefined;
    Block: XmlSchemaDerivationMethod;
    readonly BlockResolved: XmlSchemaDerivationMethod;
    get ContentModel(): XmlSchemaContentModel | undefined;
    set ContentModel(value: XmlSchemaContentModel);
    readonly ContentType: XmlSchemaContentType;
    readonly ContentTypeParticle: XmlSchemaParticle;
    IsAbstract: boolean;
    IsMixed: boolean;
    get Particle(): XmlSchemaParticle | undefined;
    set Particle(value: XmlSchemaParticle);
}


export const XmlSchemaComplexType: {
    new(): XmlSchemaComplexType;
};


export type XmlSchemaComplexType = XmlSchemaComplexType$instance;

export interface XmlSchemaContent$instance extends XmlSchemaAnnotated {
}


export const XmlSchemaContent: {
};


export type XmlSchemaContent = XmlSchemaContent$instance;

export interface XmlSchemaContentModel$instance extends XmlSchemaAnnotated {
    Content: XmlSchemaContent;
}


export const XmlSchemaContentModel: {
};


export type XmlSchemaContentModel = XmlSchemaContentModel$instance;

export interface XmlSchemaDatatype$instance {
    readonly TokenizedType: XmlTokenizedType;
    readonly TypeCode: XmlTypeCode;
    readonly ValueType: Type;
    readonly Variety: XmlSchemaDatatypeVariety;
    ChangeType(value: unknown, targetType: Type): unknown;
    ChangeType(value: unknown, targetType: Type, namespaceResolver: IXmlNamespaceResolver): unknown;
    IsDerivedFrom(datatype: XmlSchemaDatatype): boolean;
    ParseValue(s: string, nameTable: XmlNameTable, nsmgr: IXmlNamespaceResolver): unknown;
}


export const XmlSchemaDatatype: {
};


export type XmlSchemaDatatype = XmlSchemaDatatype$instance;

export interface XmlSchemaDocumentation$instance extends XmlSchemaObject {
    get Language(): string | undefined;
    set Language(value: string);
    get Markup(): (XmlNode | undefined)[] | undefined;
    set Markup(value: (XmlNode | undefined)[]);
    Source: string;
}


export const XmlSchemaDocumentation: {
    new(): XmlSchemaDocumentation;
};


export type XmlSchemaDocumentation = XmlSchemaDocumentation$instance;

export interface XmlSchemaElement$instance extends XmlSchemaParticle {
    Block: XmlSchemaDerivationMethod;
    readonly BlockResolved: XmlSchemaDerivationMethod;
    readonly Constraints: XmlSchemaObjectCollection;
    DefaultValue: string;
    readonly ElementSchemaType: XmlSchemaType | undefined;
    readonly ElementType: unknown;
    Final: XmlSchemaDerivationMethod;
    readonly FinalResolved: XmlSchemaDerivationMethod;
    get FixedValue(): string | undefined;
    set FixedValue(value: string);
    Form: XmlSchemaForm;
    IsAbstract: boolean;
    IsNillable: boolean;
    Name: string;
    readonly QualifiedName: XmlQualifiedName;
    RefName: XmlQualifiedName;
    get SchemaType(): XmlSchemaType | undefined;
    set SchemaType(value: XmlSchemaType);
    SchemaTypeName: XmlQualifiedName;
    SubstitutionGroup: XmlQualifiedName;
}


export const XmlSchemaElement: {
    new(): XmlSchemaElement;
};


export type XmlSchemaElement = XmlSchemaElement$instance;

export interface XmlSchemaEnumerationFacet$instance extends XmlSchemaFacet {
}


export const XmlSchemaEnumerationFacet: {
    new(): XmlSchemaEnumerationFacet;
};


export type XmlSchemaEnumerationFacet = XmlSchemaEnumerationFacet$instance;

export interface XmlSchemaException$instance extends SystemException {
    readonly LineNumber: int;
    readonly LinePosition: int;
    readonly Message: string;
    readonly SourceSchemaObject: XmlSchemaObject | undefined;
    readonly SourceUri: string | undefined;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const XmlSchemaException: {
    new(): XmlSchemaException;
    new(message: string): XmlSchemaException;
    new(message: string, innerException: Exception): XmlSchemaException;
    new(message: string, innerException: Exception, lineNumber: int, linePosition: int): XmlSchemaException;
};


export interface __XmlSchemaException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XmlSchemaException = XmlSchemaException$instance & __XmlSchemaException$views;


export interface XmlSchemaExternal$instance extends XmlSchemaObject {
    Id: string;
    get Schema(): XmlSchema | undefined;
    set Schema(value: XmlSchema);
    get SchemaLocation(): string | undefined;
    set SchemaLocation(value: string);
    get UnhandledAttributes(): XmlAttribute[] | undefined;
    set UnhandledAttributes(value: XmlAttribute[]);
}


export const XmlSchemaExternal: {
};


export type XmlSchemaExternal = XmlSchemaExternal$instance;

export interface XmlSchemaFacet$instance extends XmlSchemaAnnotated {
    IsFixed: boolean;
    Value: string;
}


export const XmlSchemaFacet: {
};


export type XmlSchemaFacet = XmlSchemaFacet$instance;

export interface XmlSchemaFractionDigitsFacet$instance extends XmlSchemaNumericFacet {
}


export const XmlSchemaFractionDigitsFacet: {
    new(): XmlSchemaFractionDigitsFacet;
};


export type XmlSchemaFractionDigitsFacet = XmlSchemaFractionDigitsFacet$instance;

export interface XmlSchemaGroup$instance extends XmlSchemaAnnotated {
    Name: string;
    get Particle(): XmlSchemaGroupBase | undefined;
    set Particle(value: XmlSchemaGroupBase);
    readonly QualifiedName: XmlQualifiedName;
}


export const XmlSchemaGroup: {
    new(): XmlSchemaGroup;
};


export type XmlSchemaGroup = XmlSchemaGroup$instance;

export interface XmlSchemaGroupBase$instance extends XmlSchemaParticle {
    readonly Items: XmlSchemaObjectCollection;
}


export const XmlSchemaGroupBase: {
};


export type XmlSchemaGroupBase = XmlSchemaGroupBase$instance;

export interface XmlSchemaGroupRef$instance extends XmlSchemaParticle {
    readonly Particle: XmlSchemaGroupBase | undefined;
    RefName: XmlQualifiedName;
}


export const XmlSchemaGroupRef: {
    new(): XmlSchemaGroupRef;
};


export type XmlSchemaGroupRef = XmlSchemaGroupRef$instance;

export interface XmlSchemaIdentityConstraint$instance extends XmlSchemaAnnotated {
    readonly Fields: XmlSchemaObjectCollection;
    Name: string;
    readonly QualifiedName: XmlQualifiedName;
    get Selector(): XmlSchemaXPath | undefined;
    set Selector(value: XmlSchemaXPath);
}


export const XmlSchemaIdentityConstraint: {
    new(): XmlSchemaIdentityConstraint;
};


export type XmlSchemaIdentityConstraint = XmlSchemaIdentityConstraint$instance;

export interface XmlSchemaImport$instance extends XmlSchemaExternal {
    get Annotation(): XmlSchemaAnnotation | undefined;
    set Annotation(value: XmlSchemaAnnotation);
    Namespace: string;
}


export const XmlSchemaImport: {
    new(): XmlSchemaImport;
};


export type XmlSchemaImport = XmlSchemaImport$instance;

export interface XmlSchemaInclude$instance extends XmlSchemaExternal {
    get Annotation(): XmlSchemaAnnotation | undefined;
    set Annotation(value: XmlSchemaAnnotation);
}


export const XmlSchemaInclude: {
    new(): XmlSchemaInclude;
};


export type XmlSchemaInclude = XmlSchemaInclude$instance;

export interface XmlSchemaInference$instance {
    Occurrence: XmlSchemaInference_InferenceOption;
    TypeInference: XmlSchemaInference_InferenceOption;
    InferSchema(instanceDocument: XmlReader): XmlSchemaSet;
    InferSchema(instanceDocument: XmlReader, schemas: XmlSchemaSet): XmlSchemaSet;
}


export const XmlSchemaInference: {
    new(): XmlSchemaInference;
};


export type XmlSchemaInference = XmlSchemaInference$instance;

export interface XmlSchemaInferenceException$instance extends XmlSchemaException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const XmlSchemaInferenceException: {
    new(): XmlSchemaInferenceException;
    new(message: string): XmlSchemaInferenceException;
    new(message: string, innerException: Exception): XmlSchemaInferenceException;
    new(message: string, innerException: Exception, lineNumber: int, linePosition: int): XmlSchemaInferenceException;
};


export interface __XmlSchemaInferenceException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XmlSchemaInferenceException = XmlSchemaInferenceException$instance & __XmlSchemaInferenceException$views;


export interface XmlSchemaInfo$instance {
    ContentType: XmlSchemaContentType;
    IsDefault: boolean;
    IsNil: boolean;
    get MemberType(): XmlSchemaSimpleType | undefined;
    set MemberType(value: XmlSchemaSimpleType);
    get SchemaAttribute(): XmlSchemaAttribute | undefined;
    set SchemaAttribute(value: XmlSchemaAttribute);
    get SchemaElement(): XmlSchemaElement | undefined;
    set SchemaElement(value: XmlSchemaElement);
    get SchemaType(): XmlSchemaType | undefined;
    set SchemaType(value: XmlSchemaType);
    Validity: XmlSchemaValidity;
}


export const XmlSchemaInfo: {
    new(): XmlSchemaInfo;
};


export interface __XmlSchemaInfo$views {
    As_IXmlSchemaInfo(): IXmlSchemaInfo$instance;
}

export type XmlSchemaInfo = XmlSchemaInfo$instance & __XmlSchemaInfo$views;


export interface XmlSchemaKey$instance extends XmlSchemaIdentityConstraint {
}


export const XmlSchemaKey: {
    new(): XmlSchemaKey;
};


export type XmlSchemaKey = XmlSchemaKey$instance;

export interface XmlSchemaKeyref$instance extends XmlSchemaIdentityConstraint {
    Refer: XmlQualifiedName;
}


export const XmlSchemaKeyref: {
    new(): XmlSchemaKeyref;
};


export type XmlSchemaKeyref = XmlSchemaKeyref$instance;

export interface XmlSchemaLengthFacet$instance extends XmlSchemaNumericFacet {
}


export const XmlSchemaLengthFacet: {
    new(): XmlSchemaLengthFacet;
};


export type XmlSchemaLengthFacet = XmlSchemaLengthFacet$instance;

export interface XmlSchemaMaxExclusiveFacet$instance extends XmlSchemaFacet {
}


export const XmlSchemaMaxExclusiveFacet: {
    new(): XmlSchemaMaxExclusiveFacet;
};


export type XmlSchemaMaxExclusiveFacet = XmlSchemaMaxExclusiveFacet$instance;

export interface XmlSchemaMaxInclusiveFacet$instance extends XmlSchemaFacet {
}


export const XmlSchemaMaxInclusiveFacet: {
    new(): XmlSchemaMaxInclusiveFacet;
};


export type XmlSchemaMaxInclusiveFacet = XmlSchemaMaxInclusiveFacet$instance;

export interface XmlSchemaMaxLengthFacet$instance extends XmlSchemaNumericFacet {
}


export const XmlSchemaMaxLengthFacet: {
    new(): XmlSchemaMaxLengthFacet;
};


export type XmlSchemaMaxLengthFacet = XmlSchemaMaxLengthFacet$instance;

export interface XmlSchemaMinExclusiveFacet$instance extends XmlSchemaFacet {
}


export const XmlSchemaMinExclusiveFacet: {
    new(): XmlSchemaMinExclusiveFacet;
};


export type XmlSchemaMinExclusiveFacet = XmlSchemaMinExclusiveFacet$instance;

export interface XmlSchemaMinInclusiveFacet$instance extends XmlSchemaFacet {
}


export const XmlSchemaMinInclusiveFacet: {
    new(): XmlSchemaMinInclusiveFacet;
};


export type XmlSchemaMinInclusiveFacet = XmlSchemaMinInclusiveFacet$instance;

export interface XmlSchemaMinLengthFacet$instance extends XmlSchemaNumericFacet {
}


export const XmlSchemaMinLengthFacet: {
    new(): XmlSchemaMinLengthFacet;
};


export type XmlSchemaMinLengthFacet = XmlSchemaMinLengthFacet$instance;

export interface XmlSchemaNotation$instance extends XmlSchemaAnnotated {
    Name: string;
    get Public(): string | undefined;
    set Public(value: string);
    get System(): string | undefined;
    set System(value: string);
}


export const XmlSchemaNotation: {
    new(): XmlSchemaNotation;
};


export type XmlSchemaNotation = XmlSchemaNotation$instance;

export interface XmlSchemaNumericFacet$instance extends XmlSchemaFacet {
}


export const XmlSchemaNumericFacet: {
};


export type XmlSchemaNumericFacet = XmlSchemaNumericFacet$instance;

export interface XmlSchemaObject$instance {
    LineNumber: int;
    LinePosition: int;
    Namespaces: XmlSerializerNamespaces;
    Parent: XmlSchemaObject;
    get SourceUri(): string | undefined;
    set SourceUri(value: string);
}


export const XmlSchemaObject: {
};


export type XmlSchemaObject = XmlSchemaObject$instance;

export interface XmlSchemaObjectCollection$instance extends CollectionBase {
    Item: XmlSchemaObject;
    Add(value: unknown): int;
    Clear(): void;
    Contains(value: unknown): boolean;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator;
    IndexOf(item: XmlSchemaObject): int;
    Insert(index: int, value: unknown): void;
    Remove(value: unknown): void;
    RemoveAt(index: int): void;
}


export const XmlSchemaObjectCollection: {
    new(): XmlSchemaObjectCollection;
    new(parent: XmlSchemaObject): XmlSchemaObjectCollection;
};


export interface __XmlSchemaObjectCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type XmlSchemaObjectCollection = XmlSchemaObjectCollection$instance & __XmlSchemaObjectCollection$views;


export interface XmlSchemaObjectEnumerator$instance {
    readonly Current: XmlSchemaObject;
    MoveNext(): boolean;
    Reset(): void;
}


export const XmlSchemaObjectEnumerator: {
    new(): XmlSchemaObjectEnumerator;
};


export interface __XmlSchemaObjectEnumerator$views {
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type XmlSchemaObjectEnumerator = XmlSchemaObjectEnumerator$instance & __XmlSchemaObjectEnumerator$views;


export interface XmlSchemaObjectTable$instance {
    readonly Count: int;
    readonly Item: XmlSchemaObject | undefined;
    readonly Names: ICollection;
    readonly Values: ICollection;
    Contains(name: XmlQualifiedName): boolean;
    GetEnumerator(): IDictionaryEnumerator;
}


export const XmlSchemaObjectTable: {
    new(): XmlSchemaObjectTable;
};


export type XmlSchemaObjectTable = XmlSchemaObjectTable$instance;

export interface XmlSchemaParticle$instance extends XmlSchemaAnnotated {
    MaxOccurs: decimal;
    get MaxOccursString(): string | undefined;
    set MaxOccursString(value: string);
    MinOccurs: decimal;
    get MinOccursString(): string | undefined;
    set MinOccursString(value: string);
}


export const XmlSchemaParticle: {
};


export type XmlSchemaParticle = XmlSchemaParticle$instance;

export interface XmlSchemaPatternFacet$instance extends XmlSchemaFacet {
}


export const XmlSchemaPatternFacet: {
    new(): XmlSchemaPatternFacet;
};


export type XmlSchemaPatternFacet = XmlSchemaPatternFacet$instance;

export interface XmlSchemaRedefine$instance extends XmlSchemaExternal {
    readonly AttributeGroups: XmlSchemaObjectTable;
    readonly Groups: XmlSchemaObjectTable;
    readonly Items: XmlSchemaObjectCollection;
    readonly SchemaTypes: XmlSchemaObjectTable;
}


export const XmlSchemaRedefine: {
    new(): XmlSchemaRedefine;
};


export type XmlSchemaRedefine = XmlSchemaRedefine$instance;

export interface XmlSchemaSequence$instance extends XmlSchemaGroupBase {
    readonly Items: XmlSchemaObjectCollection;
}


export const XmlSchemaSequence: {
    new(): XmlSchemaSequence;
};


export type XmlSchemaSequence = XmlSchemaSequence$instance;

export interface XmlSchemaSet$instance {
    CompilationSettings: XmlSchemaCompilationSettings;
    readonly Count: int;
    readonly GlobalAttributes: XmlSchemaObjectTable;
    readonly GlobalElements: XmlSchemaObjectTable;
    readonly GlobalTypes: XmlSchemaObjectTable;
    readonly IsCompiled: boolean;
    readonly NameTable: XmlNameTable;
    XmlResolver: XmlResolver;
    Add(targetNamespace: string, schemaUri: string): XmlSchema;
    Add(targetNamespace: string, schemaDocument: XmlReader): XmlSchema | undefined;
    Add(schemas: XmlSchemaSet): void;
    Add(schema: XmlSchema): XmlSchema | undefined;
    Compile(): void;
    Contains(targetNamespace: string): boolean;
    Contains(schema: XmlSchema): boolean;
    CopyTo(schemas: XmlSchema[], index: int): void;
    Remove(schema: XmlSchema): XmlSchema | undefined;
    RemoveRecursive(schemaToRemove: XmlSchema): boolean;
    Reprocess(schema: XmlSchema): XmlSchema;
    Schemas(): ICollection;
    Schemas(targetNamespace: string): ICollection;
}


export const XmlSchemaSet: {
    new(): XmlSchemaSet;
    new(nameTable: XmlNameTable): XmlSchemaSet;
};


export type XmlSchemaSet = XmlSchemaSet$instance;

export interface XmlSchemaSimpleContent$instance extends XmlSchemaContentModel {
    Content: XmlSchemaContent;
}


export const XmlSchemaSimpleContent: {
    new(): XmlSchemaSimpleContent;
};


export type XmlSchemaSimpleContent = XmlSchemaSimpleContent$instance;

export interface XmlSchemaSimpleContentExtension$instance extends XmlSchemaContent {
    get AnyAttribute(): XmlSchemaAnyAttribute | undefined;
    set AnyAttribute(value: XmlSchemaAnyAttribute);
    readonly Attributes: XmlSchemaObjectCollection;
    BaseTypeName: XmlQualifiedName;
}


export const XmlSchemaSimpleContentExtension: {
    new(): XmlSchemaSimpleContentExtension;
};


export type XmlSchemaSimpleContentExtension = XmlSchemaSimpleContentExtension$instance;

export interface XmlSchemaSimpleContentRestriction$instance extends XmlSchemaContent {
    get AnyAttribute(): XmlSchemaAnyAttribute | undefined;
    set AnyAttribute(value: XmlSchemaAnyAttribute);
    readonly Attributes: XmlSchemaObjectCollection;
    get BaseType(): XmlSchemaSimpleType | undefined;
    set BaseType(value: XmlSchemaSimpleType);
    BaseTypeName: XmlQualifiedName;
    readonly Facets: XmlSchemaObjectCollection;
}


export const XmlSchemaSimpleContentRestriction: {
    new(): XmlSchemaSimpleContentRestriction;
};


export type XmlSchemaSimpleContentRestriction = XmlSchemaSimpleContentRestriction$instance;

export interface XmlSchemaSimpleType$instance extends XmlSchemaType {
    Content: XmlSchemaSimpleTypeContent;
}


export const XmlSchemaSimpleType: {
    new(): XmlSchemaSimpleType;
};


export type XmlSchemaSimpleType = XmlSchemaSimpleType$instance;

export interface XmlSchemaSimpleTypeContent$instance extends XmlSchemaAnnotated {
}


export const XmlSchemaSimpleTypeContent: {
};


export type XmlSchemaSimpleTypeContent = XmlSchemaSimpleTypeContent$instance;

export interface XmlSchemaSimpleTypeList$instance extends XmlSchemaSimpleTypeContent {
    get BaseItemType(): XmlSchemaSimpleType | undefined;
    set BaseItemType(value: XmlSchemaSimpleType);
    get ItemType(): XmlSchemaSimpleType | undefined;
    set ItemType(value: XmlSchemaSimpleType);
    ItemTypeName: XmlQualifiedName;
}


export const XmlSchemaSimpleTypeList: {
    new(): XmlSchemaSimpleTypeList;
};


export type XmlSchemaSimpleTypeList = XmlSchemaSimpleTypeList$instance;

export interface XmlSchemaSimpleTypeRestriction$instance extends XmlSchemaSimpleTypeContent {
    get BaseType(): XmlSchemaSimpleType | undefined;
    set BaseType(value: XmlSchemaSimpleType);
    BaseTypeName: XmlQualifiedName;
    readonly Facets: XmlSchemaObjectCollection;
}


export const XmlSchemaSimpleTypeRestriction: {
    new(): XmlSchemaSimpleTypeRestriction;
};


export type XmlSchemaSimpleTypeRestriction = XmlSchemaSimpleTypeRestriction$instance;

export interface XmlSchemaSimpleTypeUnion$instance extends XmlSchemaSimpleTypeContent {
    readonly BaseMemberTypes: XmlSchemaSimpleType[] | undefined;
    readonly BaseTypes: XmlSchemaObjectCollection;
    get MemberTypes(): XmlQualifiedName[] | undefined;
    set MemberTypes(value: XmlQualifiedName[]);
}


export const XmlSchemaSimpleTypeUnion: {
    new(): XmlSchemaSimpleTypeUnion;
};


export type XmlSchemaSimpleTypeUnion = XmlSchemaSimpleTypeUnion$instance;

export interface XmlSchemaTotalDigitsFacet$instance extends XmlSchemaNumericFacet {
}


export const XmlSchemaTotalDigitsFacet: {
    new(): XmlSchemaTotalDigitsFacet;
};


export type XmlSchemaTotalDigitsFacet = XmlSchemaTotalDigitsFacet$instance;

export interface XmlSchemaType$instance extends XmlSchemaAnnotated {
    readonly BaseSchemaType: unknown | undefined;
    readonly BaseXmlSchemaType: XmlSchemaType | undefined;
    readonly Datatype: XmlSchemaDatatype | undefined;
    readonly DerivedBy: XmlSchemaDerivationMethod;
    Final: XmlSchemaDerivationMethod;
    readonly FinalResolved: XmlSchemaDerivationMethod;
    IsMixed: boolean;
    Name: string;
    readonly QualifiedName: XmlQualifiedName;
    readonly TypeCode: XmlTypeCode;
}


export const XmlSchemaType: {
    new(): XmlSchemaType;
    GetBuiltInComplexType(typeCode: XmlTypeCode): XmlSchemaComplexType | undefined;
    GetBuiltInComplexType(qualifiedName: XmlQualifiedName): XmlSchemaComplexType | undefined;
    GetBuiltInSimpleType(typeCode: XmlTypeCode): XmlSchemaSimpleType;
    GetBuiltInSimpleType(qualifiedName: XmlQualifiedName): XmlSchemaSimpleType | undefined;
    IsDerivedFrom(derivedType: XmlSchemaType, baseType: XmlSchemaType, except: XmlSchemaDerivationMethod): boolean;
};


export type XmlSchemaType = XmlSchemaType$instance;

export interface XmlSchemaUnique$instance extends XmlSchemaIdentityConstraint {
}


export const XmlSchemaUnique: {
    new(): XmlSchemaUnique;
};


export type XmlSchemaUnique = XmlSchemaUnique$instance;

export interface XmlSchemaValidationException$instance extends XmlSchemaException$instance {
    readonly SourceObject: unknown | undefined;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const XmlSchemaValidationException: {
    new(): XmlSchemaValidationException;
    new(message: string): XmlSchemaValidationException;
    new(message: string, innerException: Exception): XmlSchemaValidationException;
    new(message: string, innerException: Exception, lineNumber: int, linePosition: int): XmlSchemaValidationException;
};


export interface __XmlSchemaValidationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type XmlSchemaValidationException = XmlSchemaValidationException$instance & __XmlSchemaValidationException$views;


export interface XmlSchemaValidator$instance {
    LineInfoProvider: IXmlLineInfo;
    get SourceUri(): Uri | undefined;
    set SourceUri(value: Uri);
    ValidationEventSender: unknown;
    XmlResolver: XmlResolver;
    AddSchema(schema: XmlSchema): void;
    EndValidation(): void;
    GetExpectedAttributes(): XmlSchemaAttribute[];
    GetExpectedParticles(): XmlSchemaParticle[];
    GetUnspecifiedDefaultAttributes(defaultAttributes: ArrayList): void;
    Initialize(): void;
    Initialize(partialValidationType: XmlSchemaObject): void;
    SkipToEndElement(schemaInfo: XmlSchemaInfo): void;
    ValidateAttribute(localName: string, namespaceUri: string, attributeValue: string, schemaInfo: XmlSchemaInfo): unknown | undefined;
    ValidateAttribute(localName: string, namespaceUri: string, attributeValue: XmlValueGetter, schemaInfo: XmlSchemaInfo): unknown | undefined;
    ValidateElement(localName: string, namespaceUri: string, schemaInfo: XmlSchemaInfo): void;
    ValidateElement(localName: string, namespaceUri: string, schemaInfo: XmlSchemaInfo, xsiType: string, xsiNil: string, xsiSchemaLocation: string, xsiNoNamespaceSchemaLocation: string): void;
    ValidateEndElement(schemaInfo: XmlSchemaInfo): unknown | undefined;
    ValidateEndElement(schemaInfo: XmlSchemaInfo, typedValue: unknown): unknown | undefined;
    ValidateEndOfAttributes(schemaInfo: XmlSchemaInfo): void;
    ValidateText(elementValue: string): void;
    ValidateText(elementValue: XmlValueGetter): void;
    ValidateWhitespace(elementValue: string): void;
    ValidateWhitespace(elementValue: XmlValueGetter): void;
}


export const XmlSchemaValidator: {
    new(nameTable: XmlNameTable, schemas: XmlSchemaSet, namespaceResolver: IXmlNamespaceResolver, validationFlags: XmlSchemaValidationFlags): XmlSchemaValidator;
};


export type XmlSchemaValidator = XmlSchemaValidator$instance;

export interface XmlSchemaWhiteSpaceFacet$instance extends XmlSchemaFacet {
}


export const XmlSchemaWhiteSpaceFacet: {
    new(): XmlSchemaWhiteSpaceFacet;
};


export type XmlSchemaWhiteSpaceFacet = XmlSchemaWhiteSpaceFacet$instance;

export interface XmlSchemaXPath$instance extends XmlSchemaAnnotated {
    get XPath(): string | undefined;
    set XPath(value: string);
}


export const XmlSchemaXPath: {
    new(): XmlSchemaXPath;
};


export type XmlSchemaXPath = XmlSchemaXPath$instance;

export abstract class Extensions$instance {
    static GetSchemaInfo(source: XAttribute): IXmlSchemaInfo | undefined;
    static GetSchemaInfo(source: XElement): IXmlSchemaInfo | undefined;
    static Validate(source: XAttribute, partialValidationType: XmlSchemaObject, schemas: XmlSchemaSet, validationEventHandler: ValidationEventHandler, addSchemaInfo: boolean): void;
    static Validate(source: XAttribute, partialValidationType: XmlSchemaObject, schemas: XmlSchemaSet, validationEventHandler: ValidationEventHandler): void;
    static Validate(source: XDocument, schemas: XmlSchemaSet, validationEventHandler: ValidationEventHandler, addSchemaInfo: boolean): void;
    static Validate(source: XDocument, schemas: XmlSchemaSet, validationEventHandler: ValidationEventHandler): void;
    static Validate(source: XElement, partialValidationType: XmlSchemaObject, schemas: XmlSchemaSet, validationEventHandler: ValidationEventHandler, addSchemaInfo: boolean): void;
    static Validate(source: XElement, partialValidationType: XmlSchemaObject, schemas: XmlSchemaSet, validationEventHandler: ValidationEventHandler): void;
}


export type Extensions = Extensions$instance;


// Generated by tsbindgen - Architecture
// Namespace: System.Collections.Concurrent
// Assembly: System.Collections.Concurrent, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IDictionary_2, IEnumerable_1, IEnumerator_1, IEqualityComparer_1, IList_1, IReadOnlyCollection_1, IReadOnlyDictionary_2, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IDictionaryEnumerator, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Boolean as ClrBoolean, Enum, Func_2, Func_3, Func_4, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, Int64, ISpanFormattable, Object as ClrObject, String as ClrString, TimeSpan, Tuple_2, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

export enum EnumerablePartitionerOptions {
    None = 0,
    NoBuffering = 1
}


export interface IProducerConsumerCollection_1$instance<T> extends IEnumerable_1<T>, IEnumerable, ICollection {
    readonly Count: int;
    readonly SyncRoot: unknown;
    readonly IsSynchronized: boolean;
    CopyTo(array: T[], index: int): void;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
    ToArray(): T[];
    TryAdd(item: T): boolean;
    TryTake(item: T): boolean;
    GetEnumerator2(): IEnumerator;
}


export type IProducerConsumerCollection_1<T> = IProducerConsumerCollection_1$instance<T>;

export interface ConcurrentDictionary_2_AlternateLookup_1$instance<TKey, TValue, TAlternateKey> {
    readonly Dictionary: ConcurrentDictionary_2<TKey, TValue>;
    Item: TValue;
    ContainsKey(key: TAlternateKey): boolean;
    TryAdd(key: TAlternateKey, value: TValue): boolean;
    TryGetValue(key: TAlternateKey, value: TValue): boolean;
    TryGetValue(key: TAlternateKey, actualKey: TKey, value: TValue): boolean;
    TryRemove(key: TAlternateKey, value: TValue): boolean;
    TryRemove(key: TAlternateKey, actualKey: TKey, value: TValue): boolean;
}


export const ConcurrentDictionary_2_AlternateLookup_1: {
    new<TKey, TValue, TAlternateKey>(): ConcurrentDictionary_2_AlternateLookup_1$instance<TKey, TValue, TAlternateKey>;
};


export type ConcurrentDictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey> = ConcurrentDictionary_2_AlternateLookup_1$instance<TKey, TValue, TAlternateKey>;

export interface BlockingCollection_1$instance<T> {
    readonly BoundedCapacity: int;
    readonly Count: int;
    readonly IsAddingCompleted: boolean;
    readonly IsCompleted: boolean;
    Add(item: T): void;
    Add(item: T, cancellationToken: CancellationToken): void;
    CompleteAdding(): void;
    CopyTo(array: T[], index: int): void;
    Dispose(): void;
    GetConsumingEnumerable(): IEnumerable_1<T>;
    GetConsumingEnumerable(cancellationToken: CancellationToken): IEnumerable_1<T>;
    Take(): T;
    Take(cancellationToken: CancellationToken): T;
    ToArray(): T[];
    TryAdd(item: T): boolean;
    TryAdd(item: T, timeout: TimeSpan): boolean;
    TryAdd(item: T, millisecondsTimeout: int): boolean;
    TryAdd(item: T, millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
    TryTake(item: T): boolean;
    TryTake(item: T, timeout: TimeSpan): boolean;
    TryTake(item: T, millisecondsTimeout: int): boolean;
    TryTake(item: T, millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
}


export const BlockingCollection_1: {
    new<T>(): BlockingCollection_1$instance<T>;
    new<T>(boundedCapacity: int): BlockingCollection_1$instance<T>;
    new<T>(collection: IProducerConsumerCollection_1<T>, boundedCapacity: int): BlockingCollection_1$instance<T>;
    new<T>(collection: IProducerConsumerCollection_1<T>): BlockingCollection_1$instance<T>;
    AddToAny<T>(collections: BlockingCollection_1<T>[], item: T, cancellationToken: CancellationToken): int;
    AddToAny<T>(collections: BlockingCollection_1<T>[], item: T): int;
    TakeFromAny<T>(collections: BlockingCollection_1<T>[], item: T, cancellationToken: CancellationToken): int;
    TakeFromAny<T>(collections: BlockingCollection_1<T>[], item: T): int;
    TryAddToAny<T>(collections: BlockingCollection_1<T>[], item: T, millisecondsTimeout: int, cancellationToken: CancellationToken): int;
    TryAddToAny<T>(collections: BlockingCollection_1<T>[], item: T, millisecondsTimeout: int): int;
    TryAddToAny<T>(collections: BlockingCollection_1<T>[], item: T, timeout: TimeSpan): int;
    TryAddToAny<T>(collections: BlockingCollection_1<T>[], item: T): int;
    TryTakeFromAny<T>(collections: BlockingCollection_1<T>[], item: T, millisecondsTimeout: int, cancellationToken: CancellationToken): int;
    TryTakeFromAny<T>(collections: BlockingCollection_1<T>[], item: T, millisecondsTimeout: int): int;
    TryTakeFromAny<T>(collections: BlockingCollection_1<T>[], item: T, timeout: TimeSpan): int;
    TryTakeFromAny<T>(collections: BlockingCollection_1<T>[], item: T): int;
};


export interface __BlockingCollection_1$views<T> {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface BlockingCollection_1$instance<T> extends System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>, System_Internal.IDisposable$instance {}

export type BlockingCollection_1<T> = BlockingCollection_1$instance<T> & __BlockingCollection_1$views<T>;


export interface ConcurrentBag_1$instance<T> {
    readonly Count: int;
    readonly IsEmpty: boolean;
    Add(item: T): void;
    Clear(): void;
    CopyTo(array: T[], index: int): void;
    GetEnumerator(): IEnumerator_1<T>;
    ToArray(): T[];
    TryPeek(result: T): boolean;
    TryTake(result: T): boolean;
}


export const ConcurrentBag_1: {
    new<T>(): ConcurrentBag_1$instance<T>;
    new<T>(collection: IEnumerable_1<T>): ConcurrentBag_1$instance<T>;
};


export interface __ConcurrentBag_1$views<T> {
    As_IProducerConsumerCollection_1(): IProducerConsumerCollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ConcurrentBag_1<T> = ConcurrentBag_1$instance<T> & __ConcurrentBag_1$views<T>;


export interface ConcurrentDictionary_2$instance<TKey, TValue> {
    readonly Comparer: IEqualityComparer_1<TKey>;
    readonly Count: int;
    readonly IsEmpty: boolean;
    Item: TValue;
    readonly Keys: ICollection_1<TKey>;
    readonly Values: ICollection_1<TValue>;
    AddOrUpdate<TArg>(key: TKey, addValueFactory: Func_3<TKey, TArg, TValue>, updateValueFactory: Func_4<TKey, TValue, TArg, TValue>, factoryArgument: TArg): TValue;
    AddOrUpdate(key: TKey, addValueFactory: Func_2<TKey, TValue>, updateValueFactory: Func_3<TKey, TValue, TValue>): TValue;
    AddOrUpdate(key: TKey, addValue: TValue, updateValueFactory: Func_3<TKey, TValue, TValue>): TValue;
    Clear(): void;
    ContainsKey(key: TKey): boolean;
    GetAlternateLookup<TAlternateKey>(): ConcurrentDictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>;
    GetEnumerator(): IEnumerator_1<KeyValuePair_2<TKey, TValue>>;
    GetOrAdd(key: TKey, valueFactory: Func_2<TKey, TValue>): TValue;
    GetOrAdd<TArg>(key: TKey, valueFactory: Func_3<TKey, TArg, TValue>, factoryArgument: TArg): TValue;
    GetOrAdd(key: TKey, value: TValue): TValue;
    ToArray(): KeyValuePair_2<TKey, TValue>[];
    TryAdd(key: TKey, value: TValue): boolean;
    TryGetAlternateLookup<TAlternateKey>(lookup: ConcurrentDictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>): boolean;
    TryGetValue(key: TKey, value: TValue): boolean;
    TryRemove(key: TKey, value: TValue): boolean;
    TryRemove(item: KeyValuePair_2<TKey, TValue>): boolean;
    TryUpdate(key: TKey, newValue: TValue, comparisonValue: TValue): boolean;
}


export const ConcurrentDictionary_2: {
    new<TKey, TValue>(): ConcurrentDictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(concurrencyLevel: int, capacity: int): ConcurrentDictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(collection: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): ConcurrentDictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(comparer: IEqualityComparer_1<TKey>): ConcurrentDictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(collection: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, comparer: IEqualityComparer_1<TKey>): ConcurrentDictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(concurrencyLevel: int, collection: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, comparer: IEqualityComparer_1<TKey>): ConcurrentDictionary_2$instance<TKey, TValue>;
    new<TKey, TValue>(concurrencyLevel: int, capacity: int, comparer: IEqualityComparer_1<TKey>): ConcurrentDictionary_2$instance<TKey, TValue>;
};


export interface __ConcurrentDictionary_2$views<TKey, TValue> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionary_2(): System_Collections_Generic_Internal.IDictionary_2$instance<TKey, TValue>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyDictionary_2(): System_Collections_Generic_Internal.IReadOnlyDictionary_2$instance<TKey, TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ConcurrentDictionary_2<TKey, TValue> = ConcurrentDictionary_2$instance<TKey, TValue> & __ConcurrentDictionary_2$views<TKey, TValue>;


export interface ConcurrentQueue_1$instance<T> {
    readonly Count: int;
    readonly IsEmpty: boolean;
    Clear(): void;
    CopyTo(array: T[], index: int): void;
    Enqueue(item: T): void;
    GetEnumerator(): IEnumerator_1<T>;
    ToArray(): T[];
    TryDequeue(result: T): boolean;
    TryPeek(result: T): boolean;
}


export const ConcurrentQueue_1: {
    new<T>(): ConcurrentQueue_1$instance<T>;
    new<T>(collection: IEnumerable_1<T>): ConcurrentQueue_1$instance<T>;
};


export interface __ConcurrentQueue_1$views<T> {
    As_IProducerConsumerCollection_1(): IProducerConsumerCollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ConcurrentQueue_1<T> = ConcurrentQueue_1$instance<T> & __ConcurrentQueue_1$views<T>;


export interface ConcurrentStack_1$instance<T> {
    readonly Count: int;
    readonly IsEmpty: boolean;
    Clear(): void;
    CopyTo(array: T[], index: int): void;
    GetEnumerator(): IEnumerator_1<T>;
    Push(item: T): void;
    PushRange(items: T[]): void;
    PushRange(items: T[], startIndex: int, count: int): void;
    ToArray(): T[];
    TryPeek(result: T): boolean;
    TryPop(result: T): boolean;
    TryPopRange(items: T[]): int;
    TryPopRange(items: T[], startIndex: int, count: int): int;
}


export const ConcurrentStack_1: {
    new<T>(): ConcurrentStack_1$instance<T>;
    new<T>(collection: IEnumerable_1<T>): ConcurrentStack_1$instance<T>;
};


export interface __ConcurrentStack_1$views<T> {
    As_IProducerConsumerCollection_1(): IProducerConsumerCollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ConcurrentStack_1<T> = ConcurrentStack_1$instance<T> & __ConcurrentStack_1$views<T>;


export interface OrderablePartitioner_1$instance<TSource> extends Partitioner_1<TSource> {
    readonly KeysNormalized: boolean;
    readonly KeysOrderedAcrossPartitions: boolean;
    readonly KeysOrderedInEachPartition: boolean;
    GetDynamicPartitions(): IEnumerable_1<TSource>;
    GetDynamicPartitions(): IEnumerable_1<TSource>;
    GetOrderableDynamicPartitions(): IEnumerable_1<KeyValuePair_2<System_Internal.Int64, TSource>>;
    GetOrderablePartitions(partitionCount: int): IList_1<IEnumerator_1<KeyValuePair_2<System_Internal.Int64, TSource>>>;
    GetPartitions(partitionCount: int): IList_1<IEnumerator_1<TSource>>;
    GetPartitions(partitionCount: int): IList_1<IEnumerator_1<TSource>>;
}


export const OrderablePartitioner_1: {
};


export type OrderablePartitioner_1<TSource> = OrderablePartitioner_1$instance<TSource>;

export interface Partitioner_1$instance<TSource> {
    readonly SupportsDynamicPartitions: boolean;
    GetDynamicPartitions(): IEnumerable_1<TSource>;
    GetPartitions(partitionCount: int): IList_1<IEnumerator_1<TSource>>;
}


export const Partitioner_1: {
};


export type Partitioner_1<TSource> = Partitioner_1$instance<TSource>;

export abstract class Partitioner$instance {
    static Create<TSource>(source: IEnumerable_1<TSource>, partitionerOptions: EnumerablePartitionerOptions): OrderablePartitioner_1<TSource>;
    static Create<TSource>(source: IEnumerable_1<TSource>): OrderablePartitioner_1<TSource>;
    static Create<TSource>(list: IList_1<TSource>, loadBalance: boolean): OrderablePartitioner_1<TSource>;
    static Create(fromInclusive: int, toExclusive: int, rangeSize: int): OrderablePartitioner_1<Tuple_2<System_Internal.Int32, System_Internal.Int32>>;
    static Create(fromInclusive: int, toExclusive: int): OrderablePartitioner_1<Tuple_2<System_Internal.Int32, System_Internal.Int32>>;
    static Create(fromInclusive: long, toExclusive: long, rangeSize: long): OrderablePartitioner_1<Tuple_2<System_Internal.Int64, System_Internal.Int64>>;
    static Create(fromInclusive: long, toExclusive: long): OrderablePartitioner_1<Tuple_2<System_Internal.Int64, System_Internal.Int64>>;
    static Create<TSource>(array: TSource[], loadBalance: boolean): OrderablePartitioner_1<TSource>;
}


export type Partitioner = Partitioner$instance;


// Generated by tsbindgen - Architecture
// Namespace: System.Net.Http.Headers
// Assembly: System.Net.Http

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IReadOnlyCollection_1, IReadOnlyDictionary_2, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Byte, DateTimeOffset, Double, ICloneable, IDisposable, Int32, Int64, Nullable_1, Object as ClrObject, String as ClrString, TimeSpan, Type, Uri, ValueType, Void } from "../../System/internal/index.js";

export interface HeaderStringValues$instance {
    readonly Count: int;
    GetEnumerator(): HeaderStringValues_Enumerator;
    ToString(): string;
}


export const HeaderStringValues: {
    new(): HeaderStringValues$instance;
};


export interface __HeaderStringValues$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<System_Internal.String>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<System_Internal.String>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type HeaderStringValues = HeaderStringValues$instance & __HeaderStringValues$views;


export interface HeaderStringValues_Enumerator$instance extends IDisposable {
    readonly Current: string;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export const HeaderStringValues_Enumerator: {
    new(): HeaderStringValues_Enumerator$instance;
};


export interface __HeaderStringValues_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<System_Internal.String>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type HeaderStringValues_Enumerator = HeaderStringValues_Enumerator$instance & __HeaderStringValues_Enumerator$views;


export interface HttpHeadersNonValidated$instance {
    readonly Count: int;
    readonly Item: HeaderStringValues;
    Contains(headerName: string): boolean;
    GetEnumerator(): HttpHeadersNonValidated_Enumerator;
    TryGetValues(headerName: string, values: HeaderStringValues): boolean;
}


export const HttpHeadersNonValidated: {
    new(): HttpHeadersNonValidated$instance;
};


export interface __HttpHeadersNonValidated$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<System_Internal.String, HeaderStringValues>>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<KeyValuePair_2<System_Internal.String, HeaderStringValues>>;
    As_IReadOnlyDictionary_2(): System_Collections_Generic_Internal.IReadOnlyDictionary_2$instance<System_Internal.String, HeaderStringValues>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type HttpHeadersNonValidated = HttpHeadersNonValidated$instance & __HttpHeadersNonValidated$views;


export interface HttpHeadersNonValidated_Enumerator$instance extends IDisposable {
    readonly Current: KeyValuePair_2<System_Internal.String, HeaderStringValues>;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export const HttpHeadersNonValidated_Enumerator: {
    new(): HttpHeadersNonValidated_Enumerator$instance;
};


export interface __HttpHeadersNonValidated_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<KeyValuePair_2<System_Internal.String, HeaderStringValues>>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type HttpHeadersNonValidated_Enumerator = HttpHeadersNonValidated_Enumerator$instance & __HttpHeadersNonValidated_Enumerator$views;


export interface AuthenticationHeaderValue$instance {
    readonly Parameter: string;
    readonly Scheme: string;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const AuthenticationHeaderValue: {
    new(scheme: string): AuthenticationHeaderValue$instance;
    new(scheme: string, parameter: string): AuthenticationHeaderValue$instance;
    Parse(input: string): AuthenticationHeaderValue;
    TryParse(input: string, parsedValue: AuthenticationHeaderValue): boolean;
};


export interface __AuthenticationHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface AuthenticationHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type AuthenticationHeaderValue = AuthenticationHeaderValue$instance & __AuthenticationHeaderValue$views;


export interface CacheControlHeaderValue$instance {
    readonly Extensions: ICollection_1<NameValueHeaderValue>;
    MaxAge: Nullable_1<TimeSpan>;
    MaxStale: boolean;
    MaxStaleLimit: Nullable_1<TimeSpan>;
    MinFresh: Nullable_1<TimeSpan>;
    MustRevalidate: boolean;
    NoCache: boolean;
    readonly NoCacheHeaders: ICollection_1<System_Internal.String>;
    NoStore: boolean;
    NoTransform: boolean;
    OnlyIfCached: boolean;
    Private: boolean;
    readonly PrivateHeaders: ICollection_1<System_Internal.String>;
    ProxyRevalidate: boolean;
    Public: boolean;
    SharedMaxAge: Nullable_1<TimeSpan>;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const CacheControlHeaderValue: {
    new(): CacheControlHeaderValue$instance;
    Parse(input: string): CacheControlHeaderValue;
    TryParse(input: string, parsedValue: CacheControlHeaderValue): boolean;
};


export interface __CacheControlHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface CacheControlHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type CacheControlHeaderValue = CacheControlHeaderValue$instance & __CacheControlHeaderValue$views;


export interface ContentDispositionHeaderValue$instance {
    CreationDate: Nullable_1<DateTimeOffset>;
    DispositionType: string;
    FileName: string;
    FileNameStar: string;
    ModificationDate: Nullable_1<DateTimeOffset>;
    Name: string;
    readonly Parameters: ICollection_1<NameValueHeaderValue>;
    ReadDate: Nullable_1<DateTimeOffset>;
    Size: Nullable_1<System_Internal.Int64>;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ContentDispositionHeaderValue: {
    new(dispositionType: string): ContentDispositionHeaderValue$instance;
    Parse(input: string): ContentDispositionHeaderValue;
    TryParse(input: string, parsedValue: ContentDispositionHeaderValue): boolean;
};


export interface __ContentDispositionHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface ContentDispositionHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type ContentDispositionHeaderValue = ContentDispositionHeaderValue$instance & __ContentDispositionHeaderValue$views;


export interface ContentRangeHeaderValue$instance {
    readonly From: Nullable_1<System_Internal.Int64>;
    readonly HasLength: boolean;
    readonly HasRange: boolean;
    readonly Length: Nullable_1<System_Internal.Int64>;
    readonly To: Nullable_1<System_Internal.Int64>;
    Unit: string;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ContentRangeHeaderValue: {
    new(from_: long, to: long, length: long): ContentRangeHeaderValue$instance;
    new(length: long): ContentRangeHeaderValue$instance;
    new(from_: long, to: long): ContentRangeHeaderValue$instance;
    Parse(input: string): ContentRangeHeaderValue;
    TryParse(input: string, parsedValue: ContentRangeHeaderValue): boolean;
};


export interface __ContentRangeHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface ContentRangeHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type ContentRangeHeaderValue = ContentRangeHeaderValue$instance & __ContentRangeHeaderValue$views;


export interface EntityTagHeaderValue$instance {
    readonly IsWeak: boolean;
    readonly Tag: string;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const EntityTagHeaderValue: {
    new(tag: string): EntityTagHeaderValue$instance;
    new(tag: string, isWeak: boolean): EntityTagHeaderValue$instance;
    readonly Any: EntityTagHeaderValue;
    Parse(input: string): EntityTagHeaderValue;
    TryParse(input: string, parsedValue: EntityTagHeaderValue): boolean;
};


export interface __EntityTagHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface EntityTagHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type EntityTagHeaderValue = EntityTagHeaderValue$instance & __EntityTagHeaderValue$views;


export interface HttpContentHeaders$instance extends HttpHeaders$instance {
    readonly Allow: ICollection_1<System_Internal.String>;
    ContentDisposition: ContentDispositionHeaderValue;
    readonly ContentEncoding: ICollection_1<System_Internal.String>;
    readonly ContentLanguage: ICollection_1<System_Internal.String>;
    ContentLength: Nullable_1<System_Internal.Int64>;
    ContentLocation: Uri;
    ContentMD5: byte[];
    ContentRange: ContentRangeHeaderValue;
    ContentType: MediaTypeHeaderValue;
    Expires: Nullable_1<DateTimeOffset>;
    LastModified: Nullable_1<DateTimeOffset>;
    GetEnumerator(): IEnumerator_1<KeyValuePair_2<System_Internal.String, IEnumerable_1<System_Internal.String>>>;
    GetEnumerator(): IEnumerator;
}


export const HttpContentHeaders: {
    new(): HttpContentHeaders$instance;
};


export interface __HttpContentHeaders$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<System_Internal.String, IEnumerable_1<System_Internal.String>>>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type HttpContentHeaders = HttpContentHeaders$instance & __HttpContentHeaders$views;


export interface HttpHeaders$instance {
    readonly NonValidated: HttpHeadersNonValidated;
    Add(name: string, value: string): void;
    Add(name: string, values: IEnumerable_1<System_Internal.String>): void;
    Clear(): void;
    Contains(name: string): boolean;
    GetEnumerator(): IEnumerator_1<KeyValuePair_2<System_Internal.String, IEnumerable_1<System_Internal.String>>>;
    GetValues(name: string): IEnumerable_1<System_Internal.String>;
    Remove(name: string): boolean;
    ToString(): string;
    TryAddWithoutValidation(name: string, value: string): boolean;
    TryAddWithoutValidation(name: string, values: IEnumerable_1<System_Internal.String>): boolean;
    TryGetValues(name: string, values: IEnumerable_1<System_Internal.String>): boolean;
}


export const HttpHeaders: {
};


export interface __HttpHeaders$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<System_Internal.String, IEnumerable_1<System_Internal.String>>>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type HttpHeaders = HttpHeaders$instance & __HttpHeaders$views;


export interface HttpHeaderValueCollection_1$instance<T> {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    Add(item: T): void;
    Clear(): void;
    Contains(item: T): boolean;
    CopyTo(array: T[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator_1<T>;
    ParseAdd(input: string): void;
    Remove(item: T): boolean;
    ToString(): string;
    TryParseAdd(input: string): boolean;
}


export const HttpHeaderValueCollection_1: {
    new<T>(): HttpHeaderValueCollection_1$instance<T>;
};


export interface __HttpHeaderValueCollection_1$views<T> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type HttpHeaderValueCollection_1<T> = HttpHeaderValueCollection_1$instance<T> & __HttpHeaderValueCollection_1$views<T>;


export interface HttpRequestHeaders$instance extends HttpHeaders$instance {
    readonly Accept: HttpHeaderValueCollection_1<MediaTypeWithQualityHeaderValue>;
    readonly AcceptCharset: HttpHeaderValueCollection_1<StringWithQualityHeaderValue>;
    readonly AcceptEncoding: HttpHeaderValueCollection_1<StringWithQualityHeaderValue>;
    readonly AcceptLanguage: HttpHeaderValueCollection_1<StringWithQualityHeaderValue>;
    Authorization: AuthenticationHeaderValue;
    CacheControl: CacheControlHeaderValue;
    readonly Connection: HttpHeaderValueCollection_1<System_Internal.String>;
    ConnectionClose: Nullable_1<System_Internal.Boolean>;
    Date: Nullable_1<DateTimeOffset>;
    readonly Expect: HttpHeaderValueCollection_1<NameValueWithParametersHeaderValue>;
    ExpectContinue: Nullable_1<System_Internal.Boolean>;
    From: string;
    Host: string;
    readonly IfMatch: HttpHeaderValueCollection_1<EntityTagHeaderValue>;
    IfModifiedSince: Nullable_1<DateTimeOffset>;
    readonly IfNoneMatch: HttpHeaderValueCollection_1<EntityTagHeaderValue>;
    IfRange: RangeConditionHeaderValue;
    IfUnmodifiedSince: Nullable_1<DateTimeOffset>;
    MaxForwards: Nullable_1<System_Internal.Int32>;
    readonly Pragma: HttpHeaderValueCollection_1<NameValueHeaderValue>;
    Protocol: string;
    ProxyAuthorization: AuthenticationHeaderValue;
    Range: RangeHeaderValue;
    Referrer: Uri;
    readonly TE: HttpHeaderValueCollection_1<TransferCodingWithQualityHeaderValue>;
    readonly Trailer: HttpHeaderValueCollection_1<System_Internal.String>;
    readonly TransferEncoding: HttpHeaderValueCollection_1<TransferCodingHeaderValue>;
    TransferEncodingChunked: Nullable_1<System_Internal.Boolean>;
    readonly Upgrade: HttpHeaderValueCollection_1<ProductHeaderValue>;
    readonly UserAgent: HttpHeaderValueCollection_1<ProductInfoHeaderValue>;
    readonly Via: HttpHeaderValueCollection_1<ViaHeaderValue>;
    readonly Warning: HttpHeaderValueCollection_1<WarningHeaderValue>;
    GetEnumerator(): IEnumerator_1<KeyValuePair_2<System_Internal.String, IEnumerable_1<System_Internal.String>>>;
    GetEnumerator(): IEnumerator;
}


export const HttpRequestHeaders: {
    new(): HttpRequestHeaders$instance;
};


export interface __HttpRequestHeaders$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<System_Internal.String, IEnumerable_1<System_Internal.String>>>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type HttpRequestHeaders = HttpRequestHeaders$instance & __HttpRequestHeaders$views;


export interface HttpResponseHeaders$instance extends HttpHeaders$instance {
    readonly AcceptRanges: HttpHeaderValueCollection_1<System_Internal.String>;
    Age: Nullable_1<TimeSpan>;
    CacheControl: CacheControlHeaderValue;
    readonly Connection: HttpHeaderValueCollection_1<System_Internal.String>;
    ConnectionClose: Nullable_1<System_Internal.Boolean>;
    Date: Nullable_1<DateTimeOffset>;
    ETag: EntityTagHeaderValue;
    Location: Uri;
    readonly Pragma: HttpHeaderValueCollection_1<NameValueHeaderValue>;
    readonly ProxyAuthenticate: HttpHeaderValueCollection_1<AuthenticationHeaderValue>;
    RetryAfter: RetryConditionHeaderValue;
    readonly Server: HttpHeaderValueCollection_1<ProductInfoHeaderValue>;
    readonly Trailer: HttpHeaderValueCollection_1<System_Internal.String>;
    readonly TransferEncoding: HttpHeaderValueCollection_1<TransferCodingHeaderValue>;
    TransferEncodingChunked: Nullable_1<System_Internal.Boolean>;
    readonly Upgrade: HttpHeaderValueCollection_1<ProductHeaderValue>;
    readonly Vary: HttpHeaderValueCollection_1<System_Internal.String>;
    readonly Via: HttpHeaderValueCollection_1<ViaHeaderValue>;
    readonly Warning: HttpHeaderValueCollection_1<WarningHeaderValue>;
    readonly WwwAuthenticate: HttpHeaderValueCollection_1<AuthenticationHeaderValue>;
    GetEnumerator(): IEnumerator_1<KeyValuePair_2<System_Internal.String, IEnumerable_1<System_Internal.String>>>;
    GetEnumerator(): IEnumerator;
}


export const HttpResponseHeaders: {
    new(): HttpResponseHeaders$instance;
};


export interface __HttpResponseHeaders$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<System_Internal.String, IEnumerable_1<System_Internal.String>>>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type HttpResponseHeaders = HttpResponseHeaders$instance & __HttpResponseHeaders$views;


export interface MediaTypeHeaderValue$instance {
    CharSet: string;
    MediaType: string;
    readonly Parameters: ICollection_1<NameValueHeaderValue>;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const MediaTypeHeaderValue: {
    new(mediaType: string): MediaTypeHeaderValue$instance;
    new(mediaType: string, charSet: string): MediaTypeHeaderValue$instance;
    Parse(input: string): MediaTypeHeaderValue;
    TryParse(input: string, parsedValue: MediaTypeHeaderValue): boolean;
};


export interface __MediaTypeHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface MediaTypeHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type MediaTypeHeaderValue = MediaTypeHeaderValue$instance & __MediaTypeHeaderValue$views;


export interface MediaTypeWithQualityHeaderValue$instance extends MediaTypeHeaderValue$instance {
    Quality: Nullable_1<System_Internal.Double>;
    Clone(): unknown;
}


export const MediaTypeWithQualityHeaderValue: {
    new(mediaType: string): MediaTypeWithQualityHeaderValue$instance;
    new(mediaType: string, quality: double): MediaTypeWithQualityHeaderValue$instance;
};


export interface __MediaTypeWithQualityHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface MediaTypeWithQualityHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type MediaTypeWithQualityHeaderValue = MediaTypeWithQualityHeaderValue$instance & __MediaTypeWithQualityHeaderValue$views;


export interface NameValueHeaderValue$instance {
    readonly Name: string;
    Value: string;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const NameValueHeaderValue: {
    new(name: string): NameValueHeaderValue$instance;
    new(name: string, value: string): NameValueHeaderValue$instance;
    Parse(input: string): NameValueHeaderValue;
    TryParse(input: string, parsedValue: NameValueHeaderValue): boolean;
};


export interface __NameValueHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface NameValueHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type NameValueHeaderValue = NameValueHeaderValue$instance & __NameValueHeaderValue$views;


export interface NameValueWithParametersHeaderValue$instance extends NameValueHeaderValue$instance {
    readonly Parameters: ICollection_1<NameValueHeaderValue>;
    Clone(): unknown;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const NameValueWithParametersHeaderValue: {
    new(name: string): NameValueWithParametersHeaderValue$instance;
    new(name: string, value: string): NameValueWithParametersHeaderValue$instance;
};


export interface __NameValueWithParametersHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface NameValueWithParametersHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type NameValueWithParametersHeaderValue = NameValueWithParametersHeaderValue$instance & __NameValueWithParametersHeaderValue$views;


export interface ProductHeaderValue$instance {
    readonly Name: string;
    readonly Version: string;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ProductHeaderValue: {
    new(name: string): ProductHeaderValue$instance;
    new(name: string, version: string): ProductHeaderValue$instance;
    Parse(input: string): ProductHeaderValue;
    TryParse(input: string, parsedValue: ProductHeaderValue): boolean;
};


export interface __ProductHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface ProductHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type ProductHeaderValue = ProductHeaderValue$instance & __ProductHeaderValue$views;


export interface ProductInfoHeaderValue$instance {
    readonly Comment: string;
    readonly Product: ProductHeaderValue;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ProductInfoHeaderValue: {
    new(productName: string, productVersion: string): ProductInfoHeaderValue$instance;
    new(product: ProductHeaderValue): ProductInfoHeaderValue$instance;
    new(comment: string): ProductInfoHeaderValue$instance;
    Parse(input: string): ProductInfoHeaderValue;
    TryParse(input: string, parsedValue: ProductInfoHeaderValue): boolean;
};


export interface __ProductInfoHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface ProductInfoHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type ProductInfoHeaderValue = ProductInfoHeaderValue$instance & __ProductInfoHeaderValue$views;


export interface RangeConditionHeaderValue$instance {
    readonly Date: Nullable_1<DateTimeOffset>;
    readonly EntityTag: EntityTagHeaderValue;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RangeConditionHeaderValue: {
    new(date: DateTimeOffset): RangeConditionHeaderValue$instance;
    new(entityTag: EntityTagHeaderValue): RangeConditionHeaderValue$instance;
    new(entityTag: string): RangeConditionHeaderValue$instance;
    Parse(input: string): RangeConditionHeaderValue;
    TryParse(input: string, parsedValue: RangeConditionHeaderValue): boolean;
};


export interface __RangeConditionHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface RangeConditionHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type RangeConditionHeaderValue = RangeConditionHeaderValue$instance & __RangeConditionHeaderValue$views;


export interface RangeHeaderValue$instance {
    readonly Ranges: ICollection_1<RangeItemHeaderValue>;
    Unit: string;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RangeHeaderValue: {
    new(): RangeHeaderValue$instance;
    new(from_: Nullable_1<System_Internal.Int64>, to: Nullable_1<System_Internal.Int64>): RangeHeaderValue$instance;
    Parse(input: string): RangeHeaderValue;
    TryParse(input: string, parsedValue: RangeHeaderValue): boolean;
};


export interface __RangeHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface RangeHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type RangeHeaderValue = RangeHeaderValue$instance & __RangeHeaderValue$views;


export interface RangeItemHeaderValue$instance {
    readonly From: Nullable_1<System_Internal.Int64>;
    readonly To: Nullable_1<System_Internal.Int64>;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RangeItemHeaderValue: {
    new(from_: Nullable_1<System_Internal.Int64>, to: Nullable_1<System_Internal.Int64>): RangeItemHeaderValue$instance;
};


export interface __RangeItemHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface RangeItemHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type RangeItemHeaderValue = RangeItemHeaderValue$instance & __RangeItemHeaderValue$views;


export interface RetryConditionHeaderValue$instance {
    readonly Date: Nullable_1<DateTimeOffset>;
    readonly Delta: Nullable_1<TimeSpan>;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RetryConditionHeaderValue: {
    new(date: DateTimeOffset): RetryConditionHeaderValue$instance;
    new(delta: TimeSpan): RetryConditionHeaderValue$instance;
    Parse(input: string): RetryConditionHeaderValue;
    TryParse(input: string, parsedValue: RetryConditionHeaderValue): boolean;
};


export interface __RetryConditionHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface RetryConditionHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type RetryConditionHeaderValue = RetryConditionHeaderValue$instance & __RetryConditionHeaderValue$views;


export interface StringWithQualityHeaderValue$instance {
    readonly Quality: Nullable_1<System_Internal.Double>;
    readonly Value: string;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const StringWithQualityHeaderValue: {
    new(value: string): StringWithQualityHeaderValue$instance;
    new(value: string, quality: double): StringWithQualityHeaderValue$instance;
    Parse(input: string): StringWithQualityHeaderValue;
    TryParse(input: string, parsedValue: StringWithQualityHeaderValue): boolean;
};


export interface __StringWithQualityHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface StringWithQualityHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type StringWithQualityHeaderValue = StringWithQualityHeaderValue$instance & __StringWithQualityHeaderValue$views;


export interface TransferCodingHeaderValue$instance {
    readonly Parameters: ICollection_1<NameValueHeaderValue>;
    readonly Value: string;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const TransferCodingHeaderValue: {
    new(value: string): TransferCodingHeaderValue$instance;
    Parse(input: string): TransferCodingHeaderValue;
    TryParse(input: string, parsedValue: TransferCodingHeaderValue): boolean;
};


export interface __TransferCodingHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface TransferCodingHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type TransferCodingHeaderValue = TransferCodingHeaderValue$instance & __TransferCodingHeaderValue$views;


export interface TransferCodingWithQualityHeaderValue$instance extends TransferCodingHeaderValue$instance {
    Quality: Nullable_1<System_Internal.Double>;
    Clone(): unknown;
}


export const TransferCodingWithQualityHeaderValue: {
    new(value: string): TransferCodingWithQualityHeaderValue$instance;
    new(value: string, quality: double): TransferCodingWithQualityHeaderValue$instance;
};


export interface __TransferCodingWithQualityHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface TransferCodingWithQualityHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type TransferCodingWithQualityHeaderValue = TransferCodingWithQualityHeaderValue$instance & __TransferCodingWithQualityHeaderValue$views;


export interface ViaHeaderValue$instance {
    readonly Comment: string;
    readonly ProtocolName: string;
    readonly ProtocolVersion: string;
    readonly ReceivedBy: string;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ViaHeaderValue: {
    new(protocolVersion: string, receivedBy: string): ViaHeaderValue$instance;
    new(protocolVersion: string, receivedBy: string, protocolName: string): ViaHeaderValue$instance;
    new(protocolVersion: string, receivedBy: string, protocolName: string, comment: string): ViaHeaderValue$instance;
    Parse(input: string): ViaHeaderValue;
    TryParse(input: string, parsedValue: ViaHeaderValue): boolean;
};


export interface __ViaHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface ViaHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type ViaHeaderValue = ViaHeaderValue$instance & __ViaHeaderValue$views;


export interface WarningHeaderValue$instance {
    readonly Agent: string;
    readonly Code: int;
    readonly Date: Nullable_1<DateTimeOffset>;
    readonly Text: string;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const WarningHeaderValue: {
    new(code: int, agent: string, text: string): WarningHeaderValue$instance;
    new(code: int, agent: string, text: string, date: DateTimeOffset): WarningHeaderValue$instance;
    Parse(input: string): WarningHeaderValue;
    TryParse(input: string, parsedValue: WarningHeaderValue): boolean;
};


export interface __WarningHeaderValue$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface WarningHeaderValue$instance extends System_Internal.ICloneable$instance {}

export type WarningHeaderValue = WarningHeaderValue$instance & __WarningHeaderValue$views;



// Generated by tsbindgen - Architecture
// Namespace: System.Runtime.InteropServices.Marshalling
// Assembly: System.Private.CoreLib, System.Runtime.InteropServices

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { IFloatingPointIeee754_1, INumber_1 } from "../../System.Numerics/internal/index.js";
import * as System_Runtime_InteropServices_Internal from "../../System.Runtime.InteropServices/internal/index.js";
import type { ComWrappers, ComWrappers_ComInterfaceEntry, CreateComInterfaceFlags, CreateObjectFlags, IDynamicInterfaceCastable, SafeHandle, StringMarshalling, VarEnum } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Attribute, Boolean as ClrBoolean, Byte, Char, Enum, Exception, Guid, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, Object as ClrObject, ReadOnlySpan_1, RuntimeTypeHandle, Span_1, String as ClrString, Type, TypeCode, UInt16, ValueType, Void } from "../../System/internal/index.js";

export enum ComInterfaceOptions {
    None = 0,
    ManagedObjectWrapper = 1,
    ComObjectWrapper = 2
}


export enum MarshalMode {
    Default = 0,
    ManagedToUnmanagedIn = 1,
    ManagedToUnmanagedRef = 2,
    ManagedToUnmanagedOut = 3,
    UnmanagedToManagedIn = 4,
    UnmanagedToManagedRef = 5,
    UnmanagedToManagedOut = 6,
    ElementIn = 7,
    ElementRef = 8,
    ElementOut = 9
}


export interface IComExposedClass$instance {
}


export type IComExposedClass = IComExposedClass$instance;

export interface IComExposedDetails$instance {
    GetComInterfaceEntries(count: int): ptr<ComWrappers_ComInterfaceEntry>;
}


export type IComExposedDetails = IComExposedDetails$instance;

export interface IIUnknownCacheStrategy$instance {
    Clear(unknownStrategy: IIUnknownStrategy): void;
    ConstructTableInfo(handle: RuntimeTypeHandle, interfaceDetails: IIUnknownDerivedDetails, ptr: ptr<void>): IIUnknownCacheStrategy_TableInfo;
    TryGetTableInfo(handle: RuntimeTypeHandle, info: IIUnknownCacheStrategy_TableInfo): boolean;
    TrySetTableInfo(handle: RuntimeTypeHandle, info: IIUnknownCacheStrategy_TableInfo): boolean;
}


export type IIUnknownCacheStrategy = IIUnknownCacheStrategy$instance;

export interface IIUnknownDerivedDetails$instance {
    readonly Iid: Guid;
    readonly Implementation: Type;
    readonly ManagedVirtualMethodTable: ptr<void>;
}


export type IIUnknownDerivedDetails = IIUnknownDerivedDetails$instance;

export interface IIUnknownInterfaceDetailsStrategy$instance {
    GetComExposedTypeDetails(type_: RuntimeTypeHandle): IComExposedDetails;
    GetIUnknownDerivedDetails(type_: RuntimeTypeHandle): IIUnknownDerivedDetails;
}


export type IIUnknownInterfaceDetailsStrategy = IIUnknownInterfaceDetailsStrategy$instance;

export interface IIUnknownInterfaceType$instance {
}


export type IIUnknownInterfaceType = IIUnknownInterfaceType$instance;

export interface IIUnknownStrategy$instance {
    CreateInstancePointer(unknown_: ptr<void>): ptr<void>;
    QueryInterface(instancePtr: ptr<void>, iid: Guid, ppObj: ptr<void>): int;
    Release(instancePtr: ptr<void>): int;
}


export type IIUnknownStrategy = IIUnknownStrategy$instance;

export interface IUnmanagedVirtualMethodTableProvider$instance {
    GetVirtualMethodTableInfoForKey(type_: Type): VirtualMethodTableInfo;
}


export type IUnmanagedVirtualMethodTableProvider = IUnmanagedVirtualMethodTableProvider$instance;

export interface AnsiStringMarshaller_ManagedToUnmanagedIn$instance {
    Free(): void;
    FromManaged(managed: string, buffer: Span_1<System_Internal.Byte>): void;
    ToUnmanaged(): ptr<byte>;
}


export const AnsiStringMarshaller_ManagedToUnmanagedIn: {
    new(): AnsiStringMarshaller_ManagedToUnmanagedIn;
    readonly BufferSize: int;
};


export type AnsiStringMarshaller_ManagedToUnmanagedIn = AnsiStringMarshaller_ManagedToUnmanagedIn$instance;

export interface ArrayMarshaller_2_ManagedToUnmanagedIn$instance<T, TUnmanagedElement extends unknown> {
    Free(): void;
    FromManaged(array: T[], buffer: Span_1<TUnmanagedElement>): void;
    GetManagedValuesSource(): ReadOnlySpan_1<T>;
    GetPinnableReference(): TUnmanagedElement;
    GetUnmanagedValuesDestination(): Span_1<TUnmanagedElement>;
    ToUnmanaged(): ptr<TUnmanagedElement>;
}


export const ArrayMarshaller_2_ManagedToUnmanagedIn: {
    new<T, TUnmanagedElement extends unknown>(): ArrayMarshaller_2_ManagedToUnmanagedIn<T, TUnmanagedElement>;
    readonly BufferSize: int;
    GetPinnableReference<T, TUnmanagedElement extends unknown>(array: T[]): T;
};


export type ArrayMarshaller_2_ManagedToUnmanagedIn<T, TUnmanagedElement> = ArrayMarshaller_2_ManagedToUnmanagedIn$instance<T, TUnmanagedElement>;

export interface BStrStringMarshaller_ManagedToUnmanagedIn$instance {
    Free(): void;
    FromManaged(managed: string, buffer: Span_1<System_Internal.Byte>): void;
    ToUnmanaged(): ptr<ushort>;
}


export const BStrStringMarshaller_ManagedToUnmanagedIn: {
    new(): BStrStringMarshaller_ManagedToUnmanagedIn;
    readonly BufferSize: int;
};


export type BStrStringMarshaller_ManagedToUnmanagedIn = BStrStringMarshaller_ManagedToUnmanagedIn$instance;

export interface ComVariant$instance {
    readonly VarType: VarEnum;
    As<T>(): T;
    Dispose(): void;
    GetRawDataRef<T extends unknown>(): T;
}


export const ComVariant: {
    new(): ComVariant;
    readonly Null: ComVariant;
    Create<T>(value: T): ComVariant;
    CreateRaw<T extends unknown>(vt: VarEnum, rawValue: T): ComVariant;
};


export interface __ComVariant$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ComVariant$instance extends System_Internal.IDisposable$instance {}

export type ComVariant = ComVariant$instance & __ComVariant$views;


export interface ComVariantMarshaller_RefPropagate$instance {
    Free(): void;
    FromManaged(managed: unknown): void;
    FromUnmanaged(unmanaged: ComVariant): void;
    ToManaged(): unknown;
    ToUnmanaged(): ComVariant;
}


export const ComVariantMarshaller_RefPropagate: {
    new(): ComVariantMarshaller_RefPropagate;
};


export type ComVariantMarshaller_RefPropagate = ComVariantMarshaller_RefPropagate$instance;

export interface CustomMarshallerAttribute_GenericPlaceholder$instance {
}


export const CustomMarshallerAttribute_GenericPlaceholder: {
    new(): CustomMarshallerAttribute_GenericPlaceholder;
};


export type CustomMarshallerAttribute_GenericPlaceholder = CustomMarshallerAttribute_GenericPlaceholder$instance;

export interface IIUnknownCacheStrategy_TableInfo$instance {
    ManagedType: RuntimeTypeHandle;
    Table: ptr<void>;
    ThisPtr: ptr<void>;
}


export const IIUnknownCacheStrategy_TableInfo: {
    new(): IIUnknownCacheStrategy_TableInfo;
};


export type IIUnknownCacheStrategy_TableInfo = IIUnknownCacheStrategy_TableInfo$instance;

export interface PointerArrayMarshaller_2_ManagedToUnmanagedIn$instance<T extends unknown, TUnmanagedElement extends unknown> {
    Free(): void;
    FromManaged(array: ptr<T>[], buffer: Span_1<TUnmanagedElement>): void;
    GetManagedValuesSource(): ReadOnlySpan_1<System_Internal.IntPtr>;
    GetPinnableReference(): TUnmanagedElement;
    GetUnmanagedValuesDestination(): Span_1<TUnmanagedElement>;
    ToUnmanaged(): ptr<TUnmanagedElement>;
}


export const PointerArrayMarshaller_2_ManagedToUnmanagedIn: {
    new<T extends unknown, TUnmanagedElement extends unknown>(): PointerArrayMarshaller_2_ManagedToUnmanagedIn<T, TUnmanagedElement>;
    readonly BufferSize: int;
    GetPinnableReference<T extends unknown, TUnmanagedElement extends unknown>(array: ptr<T>[]): byte;
};


export type PointerArrayMarshaller_2_ManagedToUnmanagedIn<T, TUnmanagedElement> = PointerArrayMarshaller_2_ManagedToUnmanagedIn$instance<T, TUnmanagedElement>;

export interface ReadOnlySpanMarshaller_2_ManagedToUnmanagedIn$instance<T, TUnmanagedElement extends unknown> {
    Free(): void;
    FromManaged(managed: ReadOnlySpan_1<T>, buffer: Span_1<TUnmanagedElement>): void;
    GetManagedValuesSource(): ReadOnlySpan_1<T>;
    GetPinnableReference(): TUnmanagedElement;
    GetUnmanagedValuesDestination(): Span_1<TUnmanagedElement>;
    ToUnmanaged(): ptr<TUnmanagedElement>;
}


export const ReadOnlySpanMarshaller_2_ManagedToUnmanagedIn: {
    new<T, TUnmanagedElement extends unknown>(): ReadOnlySpanMarshaller_2_ManagedToUnmanagedIn<T, TUnmanagedElement>;
    readonly BufferSize: int;
    GetPinnableReference<T, TUnmanagedElement extends unknown>(managed: ReadOnlySpan_1<T>): T;
};


export type ReadOnlySpanMarshaller_2_ManagedToUnmanagedIn<T, TUnmanagedElement> = ReadOnlySpanMarshaller_2_ManagedToUnmanagedIn$instance<T, TUnmanagedElement>;

export interface ReadOnlySpanMarshaller_2_ManagedToUnmanagedOut$instance<T, TUnmanagedElement extends unknown> {
    Free(): void;
    FromUnmanaged(unmanaged: ptr<TUnmanagedElement>): void;
    GetManagedValuesDestination(numElements: int): Span_1<T>;
    GetUnmanagedValuesSource(numElements: int): ReadOnlySpan_1<TUnmanagedElement>;
    ToManaged(): ReadOnlySpan_1<T>;
}


export const ReadOnlySpanMarshaller_2_ManagedToUnmanagedOut: {
    new<T, TUnmanagedElement extends unknown>(): ReadOnlySpanMarshaller_2_ManagedToUnmanagedOut<T, TUnmanagedElement>;
};


export type ReadOnlySpanMarshaller_2_ManagedToUnmanagedOut<T, TUnmanagedElement> = ReadOnlySpanMarshaller_2_ManagedToUnmanagedOut$instance<T, TUnmanagedElement>;

export interface SafeHandleMarshaller_1_ManagedToUnmanagedIn$instance<T extends SafeHandle> {
    Free(): void;
    FromManaged(handle: T): void;
    ToUnmanaged(): nint;
}


export const SafeHandleMarshaller_1_ManagedToUnmanagedIn: {
    new<T extends SafeHandle>(): SafeHandleMarshaller_1_ManagedToUnmanagedIn<T>;
};


export type SafeHandleMarshaller_1_ManagedToUnmanagedIn<T extends SafeHandle> = SafeHandleMarshaller_1_ManagedToUnmanagedIn$instance<T>;

export interface SafeHandleMarshaller_1_ManagedToUnmanagedOut$instance<T extends SafeHandle> {
    Free(): void;
    FromUnmanaged(value: nint): void;
    ToManaged(): T;
}


export const SafeHandleMarshaller_1_ManagedToUnmanagedOut: {
    new<T extends SafeHandle>(): SafeHandleMarshaller_1_ManagedToUnmanagedOut<T>;
};


export type SafeHandleMarshaller_1_ManagedToUnmanagedOut<T extends SafeHandle> = SafeHandleMarshaller_1_ManagedToUnmanagedOut$instance<T>;

export interface SafeHandleMarshaller_1_ManagedToUnmanagedRef$instance<T extends SafeHandle> {
    Free(): void;
    FromManaged(handle: T): void;
    FromUnmanaged(value: nint): void;
    OnInvoked(): void;
    ToManagedFinally(): T;
    ToUnmanaged(): nint;
}


export const SafeHandleMarshaller_1_ManagedToUnmanagedRef: {
    new<T extends SafeHandle>(): SafeHandleMarshaller_1_ManagedToUnmanagedRef<T>;
};


export type SafeHandleMarshaller_1_ManagedToUnmanagedRef<T extends SafeHandle> = SafeHandleMarshaller_1_ManagedToUnmanagedRef$instance<T>;

export interface SpanMarshaller_2_ManagedToUnmanagedIn$instance<T, TUnmanagedElement extends unknown> {
    Free(): void;
    FromManaged(managed: Span_1<T>, buffer: Span_1<TUnmanagedElement>): void;
    GetManagedValuesSource(): ReadOnlySpan_1<T>;
    GetPinnableReference(): TUnmanagedElement;
    GetUnmanagedValuesDestination(): Span_1<TUnmanagedElement>;
    ToUnmanaged(): ptr<TUnmanagedElement>;
}


export const SpanMarshaller_2_ManagedToUnmanagedIn: {
    new<T, TUnmanagedElement extends unknown>(): SpanMarshaller_2_ManagedToUnmanagedIn<T, TUnmanagedElement>;
    readonly BufferSize: int;
    GetPinnableReference<T, TUnmanagedElement extends unknown>(managed: Span_1<T>): T;
};


export type SpanMarshaller_2_ManagedToUnmanagedIn<T, TUnmanagedElement> = SpanMarshaller_2_ManagedToUnmanagedIn$instance<T, TUnmanagedElement>;

export interface Utf8StringMarshaller_ManagedToUnmanagedIn$instance {
    Free(): void;
    FromManaged(managed: string, buffer: Span_1<System_Internal.Byte>): void;
    ToUnmanaged(): ptr<byte>;
}


export const Utf8StringMarshaller_ManagedToUnmanagedIn: {
    new(): Utf8StringMarshaller_ManagedToUnmanagedIn;
    readonly BufferSize: int;
};


export type Utf8StringMarshaller_ManagedToUnmanagedIn = Utf8StringMarshaller_ManagedToUnmanagedIn$instance;

export interface VirtualMethodTableInfo$instance {
    readonly ThisPointer: ptr<void>;
    readonly VirtualMethodTable: ptr<void>;
    Deconstruct(thisPointer: ptr<void>, virtualMethodTable: ptr<void>): void;
}


export const VirtualMethodTableInfo: {
    new(thisPointer: ptr<void>, virtualMethodTable: ptr<void>): VirtualMethodTableInfo;
};


export type VirtualMethodTableInfo = VirtualMethodTableInfo$instance;

export interface ComExposedClassAttribute_1$instance<T extends IComExposedClass> extends Attribute {
    GetComInterfaceEntries(count: int): ptr<ComWrappers_ComInterfaceEntry>;
}


export const ComExposedClassAttribute_1: {
    new<T extends IComExposedClass>(): ComExposedClassAttribute_1<T>;
};


export interface __ComExposedClassAttribute_1$views<T extends IComExposedClass> {
    As_IComExposedDetails(): IComExposedDetails$instance;
}

export interface ComExposedClassAttribute_1$instance<T extends IComExposedClass> extends IComExposedDetails$instance {}

export type ComExposedClassAttribute_1<T extends IComExposedClass> = ComExposedClassAttribute_1$instance<T> & __ComExposedClassAttribute_1$views<T>;


export interface ComObject$instance {
    FinalRelease(): void;
}


export const ComObject: {
    new(): ComObject;
};


export interface __ComObject$views {
    As_IDynamicInterfaceCastable(): System_Runtime_InteropServices_Internal.IDynamicInterfaceCastable$instance;
    As_IUnmanagedVirtualMethodTableProvider(): IUnmanagedVirtualMethodTableProvider$instance;
}

export interface ComObject$instance extends System_Runtime_InteropServices_Internal.IDynamicInterfaceCastable$instance, IUnmanagedVirtualMethodTableProvider$instance {}

export type ComObject = ComObject$instance & __ComObject$views;


export interface ContiguousCollectionMarshallerAttribute$instance extends Attribute {
}


export const ContiguousCollectionMarshallerAttribute: {
    new(): ContiguousCollectionMarshallerAttribute;
};


export type ContiguousCollectionMarshallerAttribute = ContiguousCollectionMarshallerAttribute$instance;

export interface CustomMarshallerAttribute$instance extends Attribute {
    readonly ManagedType: Type;
    readonly MarshallerType: Type;
    readonly MarshalMode: MarshalMode;
}


export const CustomMarshallerAttribute: {
    new(managedType: Type, marshalMode: MarshalMode, marshallerType: Type): CustomMarshallerAttribute;
};


export type CustomMarshallerAttribute = CustomMarshallerAttribute$instance;

export interface GeneratedComClassAttribute$instance extends Attribute {
}


export const GeneratedComClassAttribute: {
    new(): GeneratedComClassAttribute;
};


export type GeneratedComClassAttribute = GeneratedComClassAttribute$instance;

export interface GeneratedComInterfaceAttribute$instance extends Attribute {
    ExceptionToUnmanagedMarshaller: Type;
    Options: ComInterfaceOptions;
    StringMarshalling: StringMarshalling;
    StringMarshallingCustomType: Type;
}


export const GeneratedComInterfaceAttribute: {
    new(): GeneratedComInterfaceAttribute;
};


export type GeneratedComInterfaceAttribute = GeneratedComInterfaceAttribute$instance;

export interface IUnknownDerivedAttribute_2$instance<T extends IIUnknownInterfaceType, TImpl> extends Attribute {
    readonly Iid: Guid;
    readonly Implementation: Type;
    readonly ManagedVirtualMethodTable: ptr<void>;
}


export const IUnknownDerivedAttribute_2: {
    new<T extends IIUnknownInterfaceType, TImpl>(): IUnknownDerivedAttribute_2<T, TImpl>;
};


export interface __IUnknownDerivedAttribute_2$views<T extends IIUnknownInterfaceType, TImpl> {
    As_IIUnknownDerivedDetails(): IIUnknownDerivedDetails$instance;
}

export interface IUnknownDerivedAttribute_2$instance<T extends IIUnknownInterfaceType, TImpl> extends IIUnknownDerivedDetails$instance {}

export type IUnknownDerivedAttribute_2<T extends IIUnknownInterfaceType, TImpl> = IUnknownDerivedAttribute_2$instance<T, TImpl> & __IUnknownDerivedAttribute_2$views<T, TImpl>;


export interface MarshalUsingAttribute$instance extends Attribute {
    ConstantElementCount: int;
    CountElementName: string;
    ElementIndirectionDepth: int;
    readonly NativeType: Type;
}


export const MarshalUsingAttribute: {
    new(): MarshalUsingAttribute;
    new(nativeType: Type): MarshalUsingAttribute;
    readonly ReturnsCountValue: string;
};


export type MarshalUsingAttribute = MarshalUsingAttribute$instance;

export interface NativeMarshallingAttribute$instance extends Attribute {
    readonly NativeType: Type;
}


export const NativeMarshallingAttribute: {
    new(nativeType: Type): NativeMarshallingAttribute;
};


export type NativeMarshallingAttribute = NativeMarshallingAttribute$instance;

export interface StrategyBasedComWrappers$instance extends ComWrappers {
}


export const StrategyBasedComWrappers: {
    new(): StrategyBasedComWrappers;
    readonly DefaultIUnknownInterfaceDetailsStrategy: IIUnknownInterfaceDetailsStrategy;
    readonly DefaultIUnknownStrategy: IIUnknownStrategy;
};


export type StrategyBasedComWrappers = StrategyBasedComWrappers$instance;

export abstract class AnsiStringMarshaller$instance {
    static ConvertToManaged(unmanaged: ptr<byte>): string;
    static ConvertToUnmanaged(managed: string): ptr<byte>;
    static Free(unmanaged: ptr<byte>): void;
}


export type AnsiStringMarshaller = AnsiStringMarshaller$instance;

export abstract class ArrayMarshaller_2$instance {
    static AllocateContainerForManagedElements<T, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>, numElements: int): T[];
    static AllocateContainerForUnmanagedElements<T, TUnmanagedElement extends unknown>(managed: T[], numElements: int): ptr<TUnmanagedElement>;
    static Free<T, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>): void;
    static GetManagedValuesDestination<T, TUnmanagedElement extends unknown>(managed: T[]): Span_1<T>;
    static GetManagedValuesSource<T, TUnmanagedElement extends unknown>(managed: T[]): ReadOnlySpan_1<T>;
    static GetUnmanagedValuesDestination<T, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>, numElements: int): Span_1<TUnmanagedElement>;
    static GetUnmanagedValuesSource<T, TUnmanagedElement extends unknown>(unmanagedValue: ptr<TUnmanagedElement>, numElements: int): ReadOnlySpan_1<TUnmanagedElement>;
}


export abstract class BStrStringMarshaller$instance {
    static ConvertToManaged(unmanaged: ptr<ushort>): string;
    static ConvertToUnmanaged(managed: string): ptr<ushort>;
    static Free(unmanaged: ptr<ushort>): void;
}


export type BStrStringMarshaller = BStrStringMarshaller$instance;

export abstract class ComInterfaceMarshaller_1$instance {
    static ConvertToManaged<T>(unmanaged: ptr<void>): T;
    static ConvertToUnmanaged<T>(managed: T): ptr<void>;
    static Free<T>(unmanaged: ptr<void>): void;
}


export abstract class ComVariantMarshaller$instance {
    static ConvertToManaged(unmanaged: ComVariant): unknown;
    static ConvertToUnmanaged(managed: unknown): ComVariant;
    static Free(unmanaged: ComVariant): void;
}


export type ComVariantMarshaller = ComVariantMarshaller$instance;

export abstract class ExceptionAsDefaultMarshaller_1$instance {
    static ConvertToUnmanaged<T extends unknown>(e: Exception): T;
}


export abstract class ExceptionAsHResultMarshaller_1$instance {
    static ConvertToUnmanaged<T extends INumber_1<T>>(e: Exception): T;
}


export abstract class ExceptionAsNaNMarshaller_1$instance {
    static ConvertToUnmanaged<T extends IFloatingPointIeee754_1<T>>(e: Exception): T;
}


export abstract class ExceptionAsVoidMarshaller$instance {
    static ConvertToUnmanaged(e: Exception): void;
}


export type ExceptionAsVoidMarshaller = ExceptionAsVoidMarshaller$instance;

export abstract class PointerArrayMarshaller_2$instance {
    static AllocateContainerForManagedElements<T extends unknown, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>, numElements: int): ptr<T>[];
    static AllocateContainerForUnmanagedElements<T extends unknown, TUnmanagedElement extends unknown>(managed: ptr<T>[], numElements: int): ptr<TUnmanagedElement>;
    static Free<T extends unknown, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>): void;
    static GetManagedValuesDestination<T extends unknown, TUnmanagedElement extends unknown>(managed: ptr<T>[]): Span_1<System_Internal.IntPtr>;
    static GetManagedValuesSource<T extends unknown, TUnmanagedElement extends unknown>(managed: ptr<T>[]): ReadOnlySpan_1<System_Internal.IntPtr>;
    static GetUnmanagedValuesDestination<T extends unknown, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>, numElements: int): Span_1<TUnmanagedElement>;
    static GetUnmanagedValuesSource<T extends unknown, TUnmanagedElement extends unknown>(unmanagedValue: ptr<TUnmanagedElement>, numElements: int): ReadOnlySpan_1<TUnmanagedElement>;
}


export abstract class ReadOnlySpanMarshaller_2$instance {
}


export abstract class ReadOnlySpanMarshaller_2_UnmanagedToManagedOut$instance {
    static AllocateContainerForUnmanagedElements<T, TUnmanagedElement extends unknown>(managed: ReadOnlySpan_1<T>, numElements: int): ptr<TUnmanagedElement>;
    static GetManagedValuesSource<T, TUnmanagedElement extends unknown>(managed: ReadOnlySpan_1<T>): ReadOnlySpan_1<T>;
    static GetUnmanagedValuesDestination<T, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>, numElements: int): Span_1<TUnmanagedElement>;
}


export abstract class SafeHandleMarshaller_1$instance {
}


export abstract class SpanMarshaller_2$instance {
    static AllocateContainerForManagedElements<T, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>, numElements: int): Span_1<T>;
    static AllocateContainerForUnmanagedElements<T, TUnmanagedElement extends unknown>(managed: Span_1<T>, numElements: int): ptr<TUnmanagedElement>;
    static Free<T, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>): void;
    static GetManagedValuesDestination<T, TUnmanagedElement extends unknown>(managed: Span_1<T>): Span_1<T>;
    static GetManagedValuesSource<T, TUnmanagedElement extends unknown>(managed: Span_1<T>): ReadOnlySpan_1<T>;
    static GetUnmanagedValuesDestination<T, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>, numElements: int): Span_1<TUnmanagedElement>;
    static GetUnmanagedValuesSource<T, TUnmanagedElement extends unknown>(unmanaged: ptr<TUnmanagedElement>, numElements: int): ReadOnlySpan_1<TUnmanagedElement>;
}


export abstract class UniqueComInterfaceMarshaller_1$instance {
    static ConvertToManaged<T>(unmanaged: ptr<void>): T;
    static ConvertToUnmanaged<T>(managed: T): ptr<void>;
    static Free<T>(unmanaged: ptr<void>): void;
}


export abstract class Utf16StringMarshaller$instance {
    static ConvertToManaged(unmanaged: ptr<ushort>): string;
    static ConvertToUnmanaged(managed: string): ptr<ushort>;
    static Free(unmanaged: ptr<ushort>): void;
    static GetPinnableReference(str: string): char;
}


export type Utf16StringMarshaller = Utf16StringMarshaller$instance;

export abstract class Utf8StringMarshaller$instance {
    static ConvertToManaged(unmanaged: ptr<byte>): string;
    static ConvertToUnmanaged(managed: string): ptr<byte>;
    static Free(unmanaged: ptr<byte>): void;
}


export type Utf8StringMarshaller = Utf8StringMarshaller$instance;


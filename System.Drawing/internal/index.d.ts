// Generated by tsbindgen - Architecture
// Namespace: System.Drawing
// Assembly: System.ComponentModel.TypeConverter, System.Drawing.Primitives

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { ICollection, IDictionary } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { ITypeDescriptorContext, PropertyDescriptorCollection, TypeConverter, TypeConverter_StandardValuesCollection } from "../../System.ComponentModel/internal/index.js";
import type { CultureInfo } from "../../System.Globalization/internal/index.js";
import type { Vector2, Vector4 } from "../../System.Numerics/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Attribute, Boolean as ClrBoolean, Byte, Enum, IComparable, IConvertible, IEquatable_1, IFormatProvider, IFormattable, Int32, ISpanFormattable, Object as ClrObject, Single, String as ClrString, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

export enum KnownColor {
    ActiveBorder = 1,
    ActiveCaption = 2,
    ActiveCaptionText = 3,
    AppWorkspace = 4,
    Control = 5,
    ControlDark = 6,
    ControlDarkDark = 7,
    ControlLight = 8,
    ControlLightLight = 9,
    ControlText = 10,
    Desktop = 11,
    GrayText = 12,
    Highlight = 13,
    HighlightText = 14,
    HotTrack = 15,
    InactiveBorder = 16,
    InactiveCaption = 17,
    InactiveCaptionText = 18,
    Info = 19,
    InfoText = 20,
    Menu = 21,
    MenuText = 22,
    ScrollBar = 23,
    Window = 24,
    WindowFrame = 25,
    WindowText = 26,
    Transparent = 27,
    AliceBlue = 28,
    AntiqueWhite = 29,
    Aqua = 30,
    Aquamarine = 31,
    Azure = 32,
    Beige = 33,
    Bisque = 34,
    Black = 35,
    BlanchedAlmond = 36,
    Blue = 37,
    BlueViolet = 38,
    Brown = 39,
    BurlyWood = 40,
    CadetBlue = 41,
    Chartreuse = 42,
    Chocolate = 43,
    Coral = 44,
    CornflowerBlue = 45,
    Cornsilk = 46,
    Crimson = 47,
    Cyan = 48,
    DarkBlue = 49,
    DarkCyan = 50,
    DarkGoldenrod = 51,
    DarkGray = 52,
    DarkGreen = 53,
    DarkKhaki = 54,
    DarkMagenta = 55,
    DarkOliveGreen = 56,
    DarkOrange = 57,
    DarkOrchid = 58,
    DarkRed = 59,
    DarkSalmon = 60,
    DarkSeaGreen = 61,
    DarkSlateBlue = 62,
    DarkSlateGray = 63,
    DarkTurquoise = 64,
    DarkViolet = 65,
    DeepPink = 66,
    DeepSkyBlue = 67,
    DimGray = 68,
    DodgerBlue = 69,
    Firebrick = 70,
    FloralWhite = 71,
    ForestGreen = 72,
    Fuchsia = 73,
    Gainsboro = 74,
    GhostWhite = 75,
    Gold = 76,
    Goldenrod = 77,
    Gray = 78,
    Green = 79,
    GreenYellow = 80,
    Honeydew = 81,
    HotPink = 82,
    IndianRed = 83,
    Indigo = 84,
    Ivory = 85,
    Khaki = 86,
    Lavender = 87,
    LavenderBlush = 88,
    LawnGreen = 89,
    LemonChiffon = 90,
    LightBlue = 91,
    LightCoral = 92,
    LightCyan = 93,
    LightGoldenrodYellow = 94,
    LightGray = 95,
    LightGreen = 96,
    LightPink = 97,
    LightSalmon = 98,
    LightSeaGreen = 99,
    LightSkyBlue = 100,
    LightSlateGray = 101,
    LightSteelBlue = 102,
    LightYellow = 103,
    Lime = 104,
    LimeGreen = 105,
    Linen = 106,
    Magenta = 107,
    Maroon = 108,
    MediumAquamarine = 109,
    MediumBlue = 110,
    MediumOrchid = 111,
    MediumPurple = 112,
    MediumSeaGreen = 113,
    MediumSlateBlue = 114,
    MediumSpringGreen = 115,
    MediumTurquoise = 116,
    MediumVioletRed = 117,
    MidnightBlue = 118,
    MintCream = 119,
    MistyRose = 120,
    Moccasin = 121,
    NavajoWhite = 122,
    Navy = 123,
    OldLace = 124,
    Olive = 125,
    OliveDrab = 126,
    Orange = 127,
    OrangeRed = 128,
    Orchid = 129,
    PaleGoldenrod = 130,
    PaleGreen = 131,
    PaleTurquoise = 132,
    PaleVioletRed = 133,
    PapayaWhip = 134,
    PeachPuff = 135,
    Peru = 136,
    Pink = 137,
    Plum = 138,
    PowderBlue = 139,
    Purple = 140,
    Red = 141,
    RosyBrown = 142,
    RoyalBlue = 143,
    SaddleBrown = 144,
    Salmon = 145,
    SandyBrown = 146,
    SeaGreen = 147,
    SeaShell = 148,
    Sienna = 149,
    Silver = 150,
    SkyBlue = 151,
    SlateBlue = 152,
    SlateGray = 153,
    Snow = 154,
    SpringGreen = 155,
    SteelBlue = 156,
    Tan = 157,
    Teal = 158,
    Thistle = 159,
    Tomato = 160,
    Turquoise = 161,
    Violet = 162,
    Wheat = 163,
    White = 164,
    WhiteSmoke = 165,
    Yellow = 166,
    YellowGreen = 167,
    ButtonFace = 168,
    ButtonHighlight = 169,
    ButtonShadow = 170,
    GradientActiveCaption = 171,
    GradientInactiveCaption = 172,
    MenuBar = 173,
    MenuHighlight = 174,
    RebeccaPurple = 175
}


export interface Color$instance {
    readonly A: byte;
    readonly B: byte;
    readonly G: byte;
    readonly IsEmpty: boolean;
    readonly IsKnownColor: boolean;
    readonly IsNamedColor: boolean;
    readonly IsSystemColor: boolean;
    readonly Name: string;
    readonly R: byte;
    Equals(obj: unknown): boolean;
    Equals(other: Color): boolean;
    GetBrightness(): float;
    GetHashCode(): int;
    GetHue(): float;
    GetSaturation(): float;
    ToArgb(): int;
    ToKnownColor(): KnownColor;
    ToString(): string;
}


export const Color: {
    new(): Color$instance;
    readonly Empty: Color;
    readonly Transparent: Color;
    readonly AliceBlue: Color;
    readonly AntiqueWhite: Color;
    readonly Aqua: Color;
    readonly Aquamarine: Color;
    readonly Azure: Color;
    readonly Beige: Color;
    readonly Bisque: Color;
    readonly Black: Color;
    readonly BlanchedAlmond: Color;
    readonly Blue: Color;
    readonly BlueViolet: Color;
    readonly Brown: Color;
    readonly BurlyWood: Color;
    readonly CadetBlue: Color;
    readonly Chartreuse: Color;
    readonly Chocolate: Color;
    readonly Coral: Color;
    readonly CornflowerBlue: Color;
    readonly Cornsilk: Color;
    readonly Crimson: Color;
    readonly Cyan: Color;
    readonly DarkBlue: Color;
    readonly DarkCyan: Color;
    readonly DarkGoldenrod: Color;
    readonly DarkGray: Color;
    readonly DarkGreen: Color;
    readonly DarkKhaki: Color;
    readonly DarkMagenta: Color;
    readonly DarkOliveGreen: Color;
    readonly DarkOrange: Color;
    readonly DarkOrchid: Color;
    readonly DarkRed: Color;
    readonly DarkSalmon: Color;
    readonly DarkSeaGreen: Color;
    readonly DarkSlateBlue: Color;
    readonly DarkSlateGray: Color;
    readonly DarkTurquoise: Color;
    readonly DarkViolet: Color;
    readonly DeepPink: Color;
    readonly DeepSkyBlue: Color;
    readonly DimGray: Color;
    readonly DodgerBlue: Color;
    readonly Firebrick: Color;
    readonly FloralWhite: Color;
    readonly ForestGreen: Color;
    readonly Fuchsia: Color;
    readonly Gainsboro: Color;
    readonly GhostWhite: Color;
    readonly Gold: Color;
    readonly Goldenrod: Color;
    readonly Gray: Color;
    readonly Green: Color;
    readonly GreenYellow: Color;
    readonly Honeydew: Color;
    readonly HotPink: Color;
    readonly IndianRed: Color;
    readonly Indigo: Color;
    readonly Ivory: Color;
    readonly Khaki: Color;
    readonly Lavender: Color;
    readonly LavenderBlush: Color;
    readonly LawnGreen: Color;
    readonly LemonChiffon: Color;
    readonly LightBlue: Color;
    readonly LightCoral: Color;
    readonly LightCyan: Color;
    readonly LightGoldenrodYellow: Color;
    readonly LightGreen: Color;
    readonly LightGray: Color;
    readonly LightPink: Color;
    readonly LightSalmon: Color;
    readonly LightSeaGreen: Color;
    readonly LightSkyBlue: Color;
    readonly LightSlateGray: Color;
    readonly LightSteelBlue: Color;
    readonly LightYellow: Color;
    readonly Lime: Color;
    readonly LimeGreen: Color;
    readonly Linen: Color;
    readonly Magenta: Color;
    readonly Maroon: Color;
    readonly MediumAquamarine: Color;
    readonly MediumBlue: Color;
    readonly MediumOrchid: Color;
    readonly MediumPurple: Color;
    readonly MediumSeaGreen: Color;
    readonly MediumSlateBlue: Color;
    readonly MediumSpringGreen: Color;
    readonly MediumTurquoise: Color;
    readonly MediumVioletRed: Color;
    readonly MidnightBlue: Color;
    readonly MintCream: Color;
    readonly MistyRose: Color;
    readonly Moccasin: Color;
    readonly NavajoWhite: Color;
    readonly Navy: Color;
    readonly OldLace: Color;
    readonly Olive: Color;
    readonly OliveDrab: Color;
    readonly Orange: Color;
    readonly OrangeRed: Color;
    readonly Orchid: Color;
    readonly PaleGoldenrod: Color;
    readonly PaleGreen: Color;
    readonly PaleTurquoise: Color;
    readonly PaleVioletRed: Color;
    readonly PapayaWhip: Color;
    readonly PeachPuff: Color;
    readonly Peru: Color;
    readonly Pink: Color;
    readonly Plum: Color;
    readonly PowderBlue: Color;
    readonly Purple: Color;
    readonly RebeccaPurple: Color;
    readonly Red: Color;
    readonly RosyBrown: Color;
    readonly RoyalBlue: Color;
    readonly SaddleBrown: Color;
    readonly Salmon: Color;
    readonly SandyBrown: Color;
    readonly SeaGreen: Color;
    readonly SeaShell: Color;
    readonly Sienna: Color;
    readonly Silver: Color;
    readonly SkyBlue: Color;
    readonly SlateBlue: Color;
    readonly SlateGray: Color;
    readonly Snow: Color;
    readonly SpringGreen: Color;
    readonly SteelBlue: Color;
    readonly Tan: Color;
    readonly Teal: Color;
    readonly Thistle: Color;
    readonly Tomato: Color;
    readonly Turquoise: Color;
    readonly Violet: Color;
    readonly Wheat: Color;
    readonly White: Color;
    readonly WhiteSmoke: Color;
    readonly Yellow: Color;
    readonly YellowGreen: Color;
    FromArgb(alpha: int, baseColor: Color): Color;
    FromArgb(alpha: int, red: int, green: int, blue: int): Color;
    FromArgb(red: int, green: int, blue: int): Color;
    FromArgb(argb: int): Color;
    FromKnownColor(color: KnownColor): Color;
    FromName(name: string): Color;
};


export interface __Color$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Color>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Color): boolean;
}

export type Color = Color$instance & __Color$views;


export interface Point$instance {
    readonly IsEmpty: boolean;
    X: int;
    Y: int;
    Equals(obj: unknown): boolean;
    Equals(other: Point): boolean;
    GetHashCode(): int;
    Offset(dx: int, dy: int): void;
    Offset(p: Point): void;
    ToString(): string;
}


export const Point: {
    new(x: int, y: int): Point$instance;
    new(sz: Size): Point$instance;
    new(dw: int): Point$instance;
    readonly Empty: Point;
    Add(pt: Point, sz: Size): Point;
    Ceiling(value: PointF): Point;
    Round(value: PointF): Point;
    Subtract(pt: Point, sz: Size): Point;
    Truncate(value: PointF): Point;
};


export interface __Point$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Point>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Point): boolean;
}

export type Point = Point$instance & __Point$views;


export interface PointF$instance {
    readonly IsEmpty: boolean;
    X: float;
    Y: float;
    Equals(obj: unknown): boolean;
    Equals(other: PointF): boolean;
    GetHashCode(): int;
    ToString(): string;
    ToVector2(): Vector2;
}


export const PointF: {
    new(x: float, y: float): PointF$instance;
    new(vector: Vector2): PointF$instance;
    readonly Empty: PointF;
    Add(pt: PointF, sz: Size): PointF;
    Add(pt: PointF, sz: SizeF): PointF;
    Subtract(pt: PointF, sz: Size): PointF;
    Subtract(pt: PointF, sz: SizeF): PointF;
};


export interface __PointF$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<PointF>;

    // Structural method bridges for numeric interface constraints
    Equals(other: PointF): boolean;
}

export type PointF = PointF$instance & __PointF$views;


export interface Rectangle$instance {
    readonly Bottom: int;
    Height: int;
    readonly IsEmpty: boolean;
    readonly Left: int;
    Location: Point;
    readonly Right: int;
    Size: Size;
    readonly Top: int;
    Width: int;
    X: int;
    Y: int;
    Contains(x: int, y: int): boolean;
    Contains(pt: Point): boolean;
    Contains(rect: Rectangle): boolean;
    Equals(obj: unknown): boolean;
    Equals(other: Rectangle): boolean;
    GetHashCode(): int;
    Inflate(width: int, height: int): void;
    Inflate(size: Size): void;
    Intersect(rect: Rectangle): void;
    IntersectsWith(rect: Rectangle): boolean;
    Offset(pos: Point): void;
    Offset(x: int, y: int): void;
    ToString(): string;
}


export const Rectangle: {
    new(x: int, y: int, width: int, height: int): Rectangle$instance;
    new(location: Point, size: Size): Rectangle$instance;
    readonly Empty: Rectangle;
    Ceiling(value: RectangleF): Rectangle;
    FromLTRB(left: int, top: int, right: int, bottom: int): Rectangle;
    Inflate(rect: Rectangle, x: int, y: int): Rectangle;
    Intersect(a: Rectangle, b: Rectangle): Rectangle;
    Round(value: RectangleF): Rectangle;
    Truncate(value: RectangleF): Rectangle;
    Union(a: Rectangle, b: Rectangle): Rectangle;
};


export interface __Rectangle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Rectangle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Rectangle): boolean;
}

export type Rectangle = Rectangle$instance & __Rectangle$views;


export interface RectangleF$instance {
    readonly Bottom: float;
    Height: float;
    readonly IsEmpty: boolean;
    readonly Left: float;
    Location: PointF;
    readonly Right: float;
    Size: SizeF;
    readonly Top: float;
    Width: float;
    X: float;
    Y: float;
    Contains(x: float, y: float): boolean;
    Contains(pt: PointF): boolean;
    Contains(rect: RectangleF): boolean;
    Equals(obj: unknown): boolean;
    Equals(other: RectangleF): boolean;
    GetHashCode(): int;
    Inflate(x: float, y: float): void;
    Inflate(size: SizeF): void;
    Intersect(rect: RectangleF): void;
    IntersectsWith(rect: RectangleF): boolean;
    Offset(pos: PointF): void;
    Offset(x: float, y: float): void;
    ToString(): string;
    ToVector4(): Vector4;
}


export const RectangleF: {
    new(x: float, y: float, width: float, height: float): RectangleF$instance;
    new(location: PointF, size: SizeF): RectangleF$instance;
    new(vector: Vector4): RectangleF$instance;
    readonly Empty: RectangleF;
    FromLTRB(left: float, top: float, right: float, bottom: float): RectangleF;
    Inflate(rect: RectangleF, x: float, y: float): RectangleF;
    Intersect(a: RectangleF, b: RectangleF): RectangleF;
    Union(a: RectangleF, b: RectangleF): RectangleF;
};


export interface __RectangleF$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<RectangleF>;

    // Structural method bridges for numeric interface constraints
    Equals(other: RectangleF): boolean;
}

export type RectangleF = RectangleF$instance & __RectangleF$views;


export interface Size$instance {
    Height: int;
    readonly IsEmpty: boolean;
    Width: int;
    Equals(obj: unknown): boolean;
    Equals(other: Size): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const Size: {
    new(pt: Point): Size$instance;
    new(width: int, height: int): Size$instance;
    readonly Empty: Size;
    Add(sz1: Size, sz2: Size): Size;
    Ceiling(value: SizeF): Size;
    Round(value: SizeF): Size;
    Subtract(sz1: Size, sz2: Size): Size;
    Truncate(value: SizeF): Size;
};


export interface __Size$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<Size>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Size): boolean;
}

export type Size = Size$instance & __Size$views;


export interface SizeF$instance {
    Height: float;
    readonly IsEmpty: boolean;
    Width: float;
    Equals(obj: unknown): boolean;
    Equals(other: SizeF): boolean;
    GetHashCode(): int;
    ToPointF(): PointF;
    ToSize(): Size;
    ToString(): string;
    ToVector2(): Vector2;
}


export const SizeF: {
    new(size: SizeF): SizeF$instance;
    new(pt: PointF): SizeF$instance;
    new(vector: Vector2): SizeF$instance;
    new(width: float, height: float): SizeF$instance;
    readonly Empty: SizeF;
    Add(sz1: SizeF, sz2: SizeF): SizeF;
    Subtract(sz1: SizeF, sz2: SizeF): SizeF;
};


export interface __SizeF$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SizeF>;

    // Structural method bridges for numeric interface constraints
    Equals(other: SizeF): boolean;
}

export type SizeF = SizeF$instance & __SizeF$views;


export interface ColorConverter$instance extends TypeConverter {
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFrom(value: unknown): unknown;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
    GetStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    GetStandardValues(): ICollection;
    GetStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    GetStandardValuesSupported(): boolean;
}


export const ColorConverter: {
    new(): ColorConverter$instance;
};


export type ColorConverter = ColorConverter$instance;

export interface PointConverter$instance extends TypeConverter {
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFrom(value: unknown): unknown;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
    CreateInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): unknown;
    CreateInstance(propertyValues: IDictionary): unknown;
    GetCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    GetCreateInstanceSupported(): boolean;
    GetProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    GetProperties(value: unknown): PropertyDescriptorCollection;
    GetProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    GetPropertiesSupported(context: ITypeDescriptorContext): boolean;
    GetPropertiesSupported(): boolean;
}


export const PointConverter: {
    new(): PointConverter$instance;
};


export type PointConverter = PointConverter$instance;

export interface RectangleConverter$instance extends TypeConverter {
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFrom(value: unknown): unknown;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
    CreateInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): unknown;
    CreateInstance(propertyValues: IDictionary): unknown;
    GetCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    GetCreateInstanceSupported(): boolean;
    GetProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    GetProperties(value: unknown): PropertyDescriptorCollection;
    GetProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    GetPropertiesSupported(context: ITypeDescriptorContext): boolean;
    GetPropertiesSupported(): boolean;
}


export const RectangleConverter: {
    new(): RectangleConverter$instance;
};


export type RectangleConverter = RectangleConverter$instance;

export interface SizeConverter$instance extends TypeConverter {
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFrom(value: unknown): unknown;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
    CreateInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): unknown;
    CreateInstance(propertyValues: IDictionary): unknown;
    GetCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    GetCreateInstanceSupported(): boolean;
    GetProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    GetProperties(value: unknown): PropertyDescriptorCollection;
    GetProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    GetPropertiesSupported(context: ITypeDescriptorContext): boolean;
    GetPropertiesSupported(): boolean;
}


export const SizeConverter: {
    new(): SizeConverter$instance;
};


export type SizeConverter = SizeConverter$instance;

export interface SizeFConverter$instance extends TypeConverter {
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFrom(value: unknown): unknown;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
    CreateInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): unknown;
    CreateInstance(propertyValues: IDictionary): unknown;
    GetCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    GetCreateInstanceSupported(): boolean;
    GetProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    GetProperties(value: unknown): PropertyDescriptorCollection;
    GetProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    GetPropertiesSupported(context: ITypeDescriptorContext): boolean;
    GetPropertiesSupported(): boolean;
}


export const SizeFConverter: {
    new(): SizeFConverter$instance;
};


export type SizeFConverter = SizeFConverter$instance;

export abstract class ColorTranslator$instance {
    static FromHtml(htmlColor: string): Color;
    static FromOle(oleColor: int): Color;
    static FromWin32(win32Color: int): Color;
    static ToHtml(c: Color): string;
    static ToOle(c: Color): int;
    static ToWin32(c: Color): int;
}


export type ColorTranslator = ColorTranslator$instance;

export abstract class SystemColors$instance {
    static readonly ActiveBorder: Color;
    static readonly ActiveCaption: Color;
    static readonly ActiveCaptionText: Color;
    static readonly AppWorkspace: Color;
    static readonly ButtonFace: Color;
    static readonly ButtonHighlight: Color;
    static readonly ButtonShadow: Color;
    static readonly Control: Color;
    static readonly ControlDark: Color;
    static readonly ControlDarkDark: Color;
    static readonly ControlLight: Color;
    static readonly ControlLightLight: Color;
    static readonly ControlText: Color;
    static readonly Desktop: Color;
    static readonly GradientActiveCaption: Color;
    static readonly GradientInactiveCaption: Color;
    static readonly GrayText: Color;
    static readonly Highlight: Color;
    static readonly HighlightText: Color;
    static readonly HotTrack: Color;
    static readonly InactiveBorder: Color;
    static readonly InactiveCaption: Color;
    static readonly InactiveCaptionText: Color;
    static readonly Info: Color;
    static readonly InfoText: Color;
    static readonly Menu: Color;
    static readonly MenuBar: Color;
    static readonly MenuHighlight: Color;
    static readonly MenuText: Color;
    static readonly ScrollBar: Color;
    static readonly Window: Color;
    static readonly WindowFrame: Color;
    static readonly WindowText: Color;
    static UseAlternativeColorSet: boolean;
}


export type SystemColors = SystemColors$instance;


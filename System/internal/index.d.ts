// Generated by tsbindgen - Architecture
// Namespace: System
// Assembly: System.ComponentModel, System.ComponentModel.TypeConverter, System.Console, System.Memory, System.Private.CoreLib, System.Private.Uri

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { MemoryHandle, OperationStatus, SearchValues_1, SpanAction_2 } from "../../System.Buffers/internal/index.js";
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { IAlternateEqualityComparer_2, ICollection_1, IComparer_1, IEnumerable_1, IEnumerator_1, IEqualityComparer_1, IList_1, IReadOnlyCollection_1, IReadOnlyDictionary_2, IReadOnlyList_1 } from "../../System.Collections.Generic/internal/index.js";
import type { ReadOnlyCollection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IComparer, IDictionary, IEnumerable, IEnumerator, IEqualityComparer, IList, IStructuralComparable, IStructuralEquatable } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { ITypeDescriptorContext, PropertyDescriptorCollection, TypeConverter, TypeConverter_StandardValuesCollection } from "../../System.ComponentModel/internal/index.js";
import type { AssemblyHashAlgorithm } from "../../System.Configuration.Assemblies/internal/index.js";
import type { Calendar, CompareInfo, CompareOptions, CultureInfo, DateTimeStyles, DaylightTime, NumberStyles, TimeSpanStyles, UnicodeCategory } from "../../System.Globalization/internal/index.js";
import type { Stream, TextReader, TextWriter } from "../../System.IO/internal/index.js";
import * as System_Numerics_Internal from "../../System.Numerics/internal/index.js";
import type { IAdditionOperators_3, IAdditiveIdentity_2, IBinaryFloatingPointIeee754_1, IBinaryInteger_1, IBinaryNumber_1, IBitwiseOperators_3, IComparisonOperators_3, IDecrementOperators_1, IDivisionOperators_3, IEqualityOperators_3, IExponentialFunctions_1, IFloatingPoint_1, IFloatingPointConstants_1, IFloatingPointIeee754_1, IHyperbolicFunctions_1, IIncrementOperators_1, ILogarithmicFunctions_1, IMinMaxValue_1, IModulusOperators_3, IMultiplicativeIdentity_2, IMultiplyOperators_3, INumber_1, INumberBase_1, IPowerFunctions_1, IRootFunctions_1, IShiftOperators_3, ISignedNumber_1, ISubtractionOperators_3, ITrigonometricFunctions_1, IUnaryNegationOperators_2, IUnaryPlusOperators_2, IUnsignedNumber_1 } from "../../System.Numerics/internal/index.js";
import { MemberInfo } from "../../System.Reflection/internal/index.js";
import * as System_Reflection_Internal from "../../System.Reflection/internal/index.js";
import type { Assembly, AssemblyName, Binder, BindingFlags, CallingConventions, ConstructorInfo, CustomAttributeData, EventInfo, FieldInfo, GenericParameterAttributes, ICustomAttributeProvider, InterfaceMapping, IReflect, MemberFilter, MemberTypes, MethodBase, MethodInfo, Module, ParameterInfo, ParameterModifier, PropertyInfo, TypeAttributes, TypeFilter } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_CompilerServices_Internal from "../../System.Runtime.CompilerServices/internal/index.js";
import type { DefaultInterpolatedStringHandler, ITuple } from "../../System.Runtime.CompilerServices/internal/index.js";
import type { FirstChanceExceptionEventArgs } from "../../System.Runtime.ExceptionServices/internal/index.js";
import type { StructLayoutAttribute } from "../../System.Runtime.InteropServices/internal/index.js";
import type { ObjectHandle } from "../../System.Runtime.Remoting/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, IObjectReference, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { IPrincipal, PrincipalPolicy } from "../../System.Security.Principal/internal/index.js";
import type { PermissionSet } from "../../System.Security/internal/index.js";
import type { CompositeFormat, Encoding, NormalizationForm, SpanLineEnumerator, SpanRuneEnumerator, StringRuneEnumerator } from "../../System.Text/internal/index.js";
import type { ValueTask } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken, ITimer, LazyThreadSafetyMode, TimerCallback, WaitHandle } from "../../System.Threading/internal/index.js";

export enum AttributeTargets {
    Assembly = 1,
    Module = 2,
    Class = 4,
    Struct = 8,
    Enum = 16,
    Constructor = 32,
    Method = 64,
    Property = 128,
    Field = 256,
    Event = 512,
    Interface = 1024,
    Parameter = 2048,
    Delegate = 4096,
    ReturnValue = 8192,
    GenericParameter = 16384,
    All = 32767
}


export enum Base64FormattingOptions {
    None = 0,
    InsertLineBreaks = 1
}


export enum ConsoleColor {
    Black = 0,
    DarkBlue = 1,
    DarkGreen = 2,
    DarkCyan = 3,
    DarkRed = 4,
    DarkMagenta = 5,
    DarkYellow = 6,
    Gray = 7,
    DarkGray = 8,
    Blue = 9,
    Green = 10,
    Cyan = 11,
    Red = 12,
    Magenta = 13,
    Yellow = 14,
    White = 15
}


export enum ConsoleKey {
    None = 0,
    Backspace = 8,
    Tab = 9,
    Clear = 12,
    Enter = 13,
    Pause = 19,
    Escape = 27,
    Spacebar = 32,
    PageUp = 33,
    PageDown = 34,
    End = 35,
    Home = 36,
    LeftArrow = 37,
    UpArrow = 38,
    RightArrow = 39,
    DownArrow = 40,
    Select = 41,
    Print = 42,
    Execute = 43,
    PrintScreen = 44,
    Insert = 45,
    Delete = 46,
    Help = 47,
    D0 = 48,
    D1 = 49,
    D2 = 50,
    D3 = 51,
    D4 = 52,
    D5 = 53,
    D6 = 54,
    D7 = 55,
    D8 = 56,
    D9 = 57,
    A = 65,
    B = 66,
    C = 67,
    D = 68,
    E = 69,
    F = 70,
    G = 71,
    H = 72,
    I = 73,
    J = 74,
    K = 75,
    L = 76,
    M = 77,
    N = 78,
    O = 79,
    P = 80,
    Q = 81,
    R = 82,
    S = 83,
    T = 84,
    U = 85,
    V = 86,
    W = 87,
    X = 88,
    Y = 89,
    Z = 90,
    LeftWindows = 91,
    RightWindows = 92,
    Applications = 93,
    Sleep = 95,
    NumPad0 = 96,
    NumPad1 = 97,
    NumPad2 = 98,
    NumPad3 = 99,
    NumPad4 = 100,
    NumPad5 = 101,
    NumPad6 = 102,
    NumPad7 = 103,
    NumPad8 = 104,
    NumPad9 = 105,
    Multiply = 106,
    Add = 107,
    Separator = 108,
    Subtract = 109,
    Decimal = 110,
    Divide = 111,
    F1 = 112,
    F2 = 113,
    F3 = 114,
    F4 = 115,
    F5 = 116,
    F6 = 117,
    F7 = 118,
    F8 = 119,
    F9 = 120,
    F10 = 121,
    F11 = 122,
    F12 = 123,
    F13 = 124,
    F14 = 125,
    F15 = 126,
    F16 = 127,
    F17 = 128,
    F18 = 129,
    F19 = 130,
    F20 = 131,
    F21 = 132,
    F22 = 133,
    F23 = 134,
    F24 = 135,
    BrowserBack = 166,
    BrowserForward = 167,
    BrowserRefresh = 168,
    BrowserStop = 169,
    BrowserSearch = 170,
    BrowserFavorites = 171,
    BrowserHome = 172,
    VolumeMute = 173,
    VolumeDown = 174,
    VolumeUp = 175,
    MediaNext = 176,
    MediaPrevious = 177,
    MediaStop = 178,
    MediaPlay = 179,
    LaunchMail = 180,
    LaunchMediaSelect = 181,
    LaunchApp1 = 182,
    LaunchApp2 = 183,
    Oem1 = 186,
    OemPlus = 187,
    OemComma = 188,
    OemMinus = 189,
    OemPeriod = 190,
    Oem2 = 191,
    Oem3 = 192,
    Oem4 = 219,
    Oem5 = 220,
    Oem6 = 221,
    Oem7 = 222,
    Oem8 = 223,
    Oem102 = 226,
    Process = 229,
    Packet = 231,
    Attention = 246,
    CrSel = 247,
    ExSel = 248,
    EraseEndOfFile = 249,
    Play = 250,
    Zoom = 251,
    NoName = 252,
    Pa1 = 253,
    OemClear = 254
}


export enum ConsoleModifiers {
    None = 0,
    Alt = 1,
    Shift = 2,
    Control = 4
}


export enum ConsoleSpecialKey {
    ControlC = 0,
    ControlBreak = 1
}


export enum DateTimeKind {
    Unspecified = 0,
    Utc = 1,
    Local = 2
}


export enum DayOfWeek {
    Sunday = 0,
    Monday = 1,
    Tuesday = 2,
    Wednesday = 3,
    Thursday = 4,
    Friday = 5,
    Saturday = 6
}


export enum Environment_SpecialFolder {
    ApplicationData = 26,
    CommonApplicationData = 35,
    LocalApplicationData = 28,
    Cookies = 33,
    Desktop = 0,
    Favorites = 6,
    History = 34,
    InternetCache = 32,
    Programs = 2,
    MyComputer = 17,
    MyMusic = 13,
    MyPictures = 39,
    MyVideos = 14,
    Recent = 8,
    SendTo = 9,
    StartMenu = 11,
    Startup = 7,
    System = 37,
    Templates = 21,
    DesktopDirectory = 16,
    Personal = 5,
    MyDocuments = 5,
    ProgramFiles = 38,
    CommonProgramFiles = 43,
    AdminTools = 48,
    CDBurning = 59,
    CommonAdminTools = 47,
    CommonDocuments = 46,
    CommonMusic = 53,
    CommonOemLinks = 58,
    CommonPictures = 54,
    CommonStartMenu = 22,
    CommonPrograms = 23,
    CommonStartup = 24,
    CommonDesktopDirectory = 25,
    CommonTemplates = 45,
    CommonVideos = 55,
    Fonts = 20,
    NetworkShortcuts = 19,
    PrinterShortcuts = 27,
    UserProfile = 40,
    CommonProgramFilesX86 = 44,
    ProgramFilesX86 = 42,
    Resources = 56,
    LocalizedResources = 57,
    SystemX86 = 41,
    Windows = 36
}


export enum Environment_SpecialFolderOption {
    None = 0,
    Create = 32768,
    DoNotVerify = 16384
}


export enum EnvironmentVariableTarget {
    Process = 0,
    User = 1,
    Machine = 2
}


export enum GCCollectionMode {
    Default = 0,
    Forced = 1,
    Optimized = 2,
    Aggressive = 3
}


export enum GCKind {
    Any = 0,
    Ephemeral = 1,
    FullBlocking = 2,
    Background = 3
}


export enum GCNotificationStatus {
    Succeeded = 0,
    Failed = 1,
    Canceled = 2,
    Timeout = 3,
    NotApplicable = 4
}


export enum GenericUriParserOptions {
    Default = 0,
    GenericAuthority = 1,
    AllowEmptyAuthority = 2,
    NoUserInfo = 4,
    NoPort = 8,
    NoQuery = 16,
    NoFragment = 32,
    DontConvertPathBackslashes = 64,
    DontCompressPath = 128,
    DontUnescapePathDotsAndSlashes = 256,
    Idn = 512,
    IriParsing = 1024
}


export enum LoaderOptimization {
    DisallowBindings = 4,
    DomainMask = 3,
    MultiDomain = 2,
    MultiDomainHost = 3,
    NotSpecified = 0,
    SingleDomain = 1
}


export enum MidpointRounding {
    ToEven = 0,
    AwayFromZero = 1,
    ToZero = 2,
    ToNegativeInfinity = 3,
    ToPositiveInfinity = 4
}


export enum PlatformID {
    Win32S = 0,
    Win32Windows = 1,
    Win32NT = 2,
    WinCE = 3,
    Unix = 4,
    Xbox = 5,
    MacOSX = 6,
    Other = 7
}


export enum StringComparison {
    CurrentCulture = 0,
    CurrentCultureIgnoreCase = 1,
    InvariantCulture = 2,
    InvariantCultureIgnoreCase = 3,
    Ordinal = 4,
    OrdinalIgnoreCase = 5
}


export enum StringSplitOptions {
    None = 0,
    RemoveEmptyEntries = 1,
    TrimEntries = 2
}


export enum TypeCode {
    Empty = 0,
    Object = 1,
    DBNull = 2,
    Boolean = 3,
    Char = 4,
    SByte = 5,
    Byte = 6,
    Int16 = 7,
    UInt16 = 8,
    Int32 = 9,
    UInt32 = 10,
    Int64 = 11,
    UInt64 = 12,
    Single = 13,
    Double = 14,
    Decimal = 15,
    DateTime = 16,
    String = 18
}


export enum UriComponents {
    Scheme = 1,
    UserInfo = 2,
    Host = 4,
    Port = 8,
    Path = 16,
    Query = 32,
    Fragment = 64,
    StrongPort = 128,
    NormalizedHost = 256,
    KeepDelimiter = 1073741824,
    SerializationInfoString = -2147483648,
    AbsoluteUri = 127,
    HostAndPort = 132,
    StrongAuthority = 134,
    SchemeAndServer = 13,
    HttpRequestUrl = 61,
    PathAndQuery = 48
}


export enum UriFormat {
    UriEscaped = 1,
    Unescaped = 2,
    SafeUnescaped = 3
}


export enum UriHostNameType {
    Unknown = 0,
    Basic = 1,
    Dns = 2,
    IPv4 = 3,
    IPv6 = 4
}


export enum UriKind {
    RelativeOrAbsolute = 0,
    Absolute = 1,
    Relative = 2
}


export enum UriPartial {
    Scheme = 0,
    Authority = 1,
    Path = 2,
    Query = 3
}


export type Action = () => void;


export type Action_1<T> = (obj: T) => void;


export type Action_10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10) => void;


export type Action_11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11) => void;


export type Action_12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12) => void;


export type Action_13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13) => void;


export type Action_14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14) => void;


export type Action_15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15) => void;


export type Action_16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15, arg16: T16) => void;


export type Action_2<T1, T2> = (arg1: T1, arg2: T2) => void;


export type Action_3<T1, T2, T3> = (arg1: T1, arg2: T2, arg3: T3) => void;


export type Action_4<T1, T2, T3, T4> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => void;


export type Action_5<T1, T2, T3, T4, T5> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => void;


export type Action_6<T1, T2, T3, T4, T5, T6> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) => void;


export type Action_7<T1, T2, T3, T4, T5, T6, T7> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7) => void;


export type Action_8<T1, T2, T3, T4, T5, T6, T7, T8> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8) => void;


export type Action_9<T1, T2, T3, T4, T5, T6, T7, T8, T9> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9) => void;


export type AssemblyLoadEventHandler = (sender: unknown | undefined, args: AssemblyLoadEventArgs) => void;


export type AsyncCallback = (ar: IAsyncResult) => void;


export type Comparison_1<T> = (x: T, y: T) => int;


export type ConsoleCancelEventHandler = (sender: unknown | undefined, e: ConsoleCancelEventArgs) => void;


export type Converter_2<TInput, TOutput> = (input: TInput) => TOutput;


export type EventHandler = (sender: unknown | undefined, e: EventArgs) => void;


export type EventHandler_1<TEventArgs> = (sender: unknown | undefined, e: TEventArgs) => void;


export type EventHandler_2<TSender, TEventArgs> = (sender: TSender, e: TEventArgs) => void;


export type Func_1<TResult> = () => TResult;


export type Func_10<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9) => TResult;


export type Func_11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10) => TResult;


export type Func_12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11) => TResult;


export type Func_13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12) => TResult;


export type Func_14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13) => TResult;


export type Func_15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14) => TResult;


export type Func_16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15) => TResult;


export type Func_17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8, arg9: T9, arg10: T10, arg11: T11, arg12: T12, arg13: T13, arg14: T14, arg15: T15, arg16: T16) => TResult;


export type Func_2<T, TResult> = (arg: T) => TResult;


export type Func_3<T1, T2, TResult> = (arg1: T1, arg2: T2) => TResult;


export type Func_4<T1, T2, T3, TResult> = (arg1: T1, arg2: T2, arg3: T3) => TResult;


export type Func_5<T1, T2, T3, T4, TResult> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => TResult;


export type Func_6<T1, T2, T3, T4, T5, TResult> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => TResult;


export type Func_7<T1, T2, T3, T4, T5, T6, TResult> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) => TResult;


export type Func_8<T1, T2, T3, T4, T5, T6, T7, TResult> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7) => TResult;


export type Func_9<T1, T2, T3, T4, T5, T6, T7, T8, TResult> = (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, arg7: T7, arg8: T8) => TResult;


export type Predicate_1<T> = (obj: T) => boolean;


export type ResolveEventHandler = (sender: unknown | undefined, args: ResolveEventArgs) => Assembly;


export type UnhandledExceptionEventHandler = (sender: unknown, e: UnhandledExceptionEventArgs) => void;


export interface IAsyncDisposable$instance {
    DisposeAsync(): ValueTask;
}


export type IAsyncDisposable = IAsyncDisposable$instance;

export interface IAsyncResult$instance {
    readonly IsCompleted: boolean;
    readonly AsyncWaitHandle: WaitHandle;
    readonly AsyncState: unknown | undefined;
    readonly CompletedSynchronously: boolean;
}


export type IAsyncResult = IAsyncResult$instance;

export interface ICloneable$instance {
    Clone(): unknown;
}


export type ICloneable = ICloneable$instance;

export interface IComparable$instance {
    CompareTo(obj: unknown | undefined): int;
}


export type IComparable = IComparable$instance;

export interface IComparable_1$instance<T> {
    CompareTo(other: T | undefined): int;
}


export type IComparable_1<T> = IComparable_1$instance<T>;

export interface IConvertible$instance {
    GetTypeCode(): TypeCode;
    ToBoolean(provider: IFormatProvider | undefined): boolean;
    ToByte(provider: IFormatProvider | undefined): byte;
    ToChar(provider: IFormatProvider | undefined): char;
    ToDateTime(provider: IFormatProvider | undefined): DateTime;
    ToDecimal(provider: IFormatProvider | undefined): decimal;
    ToDouble(provider: IFormatProvider | undefined): double;
    ToInt16(provider: IFormatProvider | undefined): short;
    ToInt32(provider: IFormatProvider | undefined): int;
    ToInt64(provider: IFormatProvider | undefined): long;
    ToSByte(provider: IFormatProvider | undefined): sbyte;
    ToSingle(provider: IFormatProvider | undefined): float;
    ToString(provider: IFormatProvider | undefined): string;
    ToType(conversionType: Type, provider: IFormatProvider | undefined): unknown;
    ToUInt16(provider: IFormatProvider | undefined): ushort;
    ToUInt32(provider: IFormatProvider | undefined): uint;
    ToUInt64(provider: IFormatProvider | undefined): ulong;
}


export type IConvertible = IConvertible$instance;

export interface ICustomFormatter$instance {
    Format(format: string | undefined, arg: unknown | undefined, formatProvider: IFormatProvider | undefined): string;
}


export type ICustomFormatter = ICustomFormatter$instance;

export interface IDisposable$instance {
    Dispose(): void;
}


export type IDisposable = IDisposable$instance;

export interface IEquatable_1$instance<T> {
    Equals(other: T | undefined): boolean;
}


export type IEquatable_1<T> = IEquatable_1$instance<T>;

export interface IFormatProvider$instance {
    GetFormat(formatType: Type | undefined): unknown | undefined;
}


export type IFormatProvider = IFormatProvider$instance;

export interface IFormattable$instance {
    ToString(format: string | undefined, formatProvider: IFormatProvider | undefined): string;
}


export type IFormattable = IFormattable$instance;

export interface IObservable_1$instance<T> {
    Subscribe(observer: IObserver_1<T>): IDisposable;
}


export type IObservable_1<T> = IObservable_1$instance<T>;

export interface IObserver_1$instance<T> {
    OnCompleted(): void;
    OnError(error: Exception): void;
    OnNext(value: T): void;
}


export type IObserver_1<T> = IObserver_1$instance<T>;

export interface IParsable_1$instance<TSelf extends IParsable_1<TSelf>> {
}


export type IParsable_1<TSelf extends IParsable_1<TSelf>> = IParsable_1$instance<TSelf>;

export interface IProgress_1$instance<T> {
    Report(value: T): void;
}


export type IProgress_1<T> = IProgress_1$instance<T>;

export interface IServiceProvider$instance {
    GetService(serviceType: Type): unknown | undefined;
}


export type IServiceProvider = IServiceProvider$instance;

export interface ISpanFormattable$instance extends IFormattable {
    ToString(format: string | undefined, formatProvider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined): boolean;
}


export interface ISpanFormattable$instance extends IFormattable$instance {}

export type ISpanFormattable = ISpanFormattable$instance;

export interface ISpanParsable_1$instance<TSelf extends ISpanParsable_1<TSelf>> extends IParsable_1<TSelf> {
}


export interface ISpanParsable_1$instance<TSelf extends ISpanParsable_1<TSelf>> extends IParsable_1$instance<TSelf> {}

export type ISpanParsable_1<TSelf extends ISpanParsable_1<TSelf>> = ISpanParsable_1$instance<TSelf>;

export interface IUtf8SpanFormattable$instance {
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined): boolean;
}


export type IUtf8SpanFormattable = IUtf8SpanFormattable$instance;

export interface IUtf8SpanParsable_1$instance<TSelf extends IUtf8SpanParsable_1<TSelf>> {
}


export type IUtf8SpanParsable_1<TSelf extends IUtf8SpanParsable_1<TSelf>> = IUtf8SpanParsable_1$instance<TSelf>;

export interface ArgIterator$instance {
    End(): void;
    Equals(o: unknown | undefined): boolean;
    GetHashCode(): int;
    GetNextArg(): TypedReference;
    GetNextArg(rth: RuntimeTypeHandle): TypedReference;
    GetNextArgType(): RuntimeTypeHandle;
    GetRemainingCount(): int;
}


export const ArgIterator: {
    new(arglist: RuntimeArgumentHandle): ArgIterator;
    new(arglist: RuntimeArgumentHandle, ptr: ptr<void>): ArgIterator;
};


export type ArgIterator = ArgIterator$instance;

export interface ArraySegment_1$instance<T> {
    readonly Array: T[] | undefined;
    readonly Count: int;
    Item: T;
    readonly Offset: int;
    CopyTo(destination: T[]): void;
    CopyTo(destination: T[], destinationIndex: int): void;
    CopyTo(destination: ArraySegment_1<T>): void;
    Equals(obj: unknown | undefined): boolean;
    Equals(obj: ArraySegment_1<T>): boolean;
    GetEnumerator(): ArraySegment_1_Enumerator<T>;
    GetHashCode(): int;
    Slice(index: int): ArraySegment_1<T>;
    Slice(index: int, count: int): ArraySegment_1<T>;
    ToArray(): T[];
}


export const ArraySegment_1: {
    new<T>(array: T[]): ArraySegment_1<T>;
    new<T>(array: T[], offset: int, count: int): ArraySegment_1<T>;
    readonly Empty: unknown;
};


export interface __ArraySegment_1$views<T> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ArraySegment_1<T> = ArraySegment_1$instance<T> & __ArraySegment_1$views<T>;


export interface ArraySegment_1_Enumerator$instance<T> extends IDisposable {
    readonly Current: T;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export const ArraySegment_1_Enumerator: {
    new<T>(): ArraySegment_1_Enumerator<T>;
};


export interface __ArraySegment_1_Enumerator$views<T> {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<T>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type ArraySegment_1_Enumerator<T> = ArraySegment_1_Enumerator$instance<T> & __ArraySegment_1_Enumerator$views<T>;


export interface Boolean$instance {
    CompareTo(obj: unknown | undefined): int;
    CompareTo(value: boolean): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(obj: boolean): boolean;
    GetHashCode(): int;
    GetTypeCode(): TypeCode;
    ToString(): string;
    ToString(provider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int): boolean;
}


export const Boolean: {
    new(): Boolean;
    readonly TrueString: string;
    readonly FalseString: string;
    Parse(value: ReadOnlySpan_1<Char>): boolean;
    Parse(value: string): boolean;
    TryParse(value: ReadOnlySpan_1<Char>, result: boolean): boolean;
    TryParse(value: string | undefined, result: boolean): boolean;
};


export interface __Boolean$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<Boolean>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<Boolean>;
    As_IParsable_1(): IParsable_1$instance<Boolean>;
    As_ISpanParsable_1(): ISpanParsable_1$instance<Boolean>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Boolean): boolean;
    CompareTo(obj: unknown): int;
}

export interface Boolean$instance extends ISpanParsable_1$instance<Boolean> {}

export type Boolean = boolean | (boolean & Boolean$instance & __Boolean$views);


export interface Byte$instance extends IBitwiseOperators_3<Byte, Byte, Byte>, IComparisonOperators_3<Byte, Byte, Boolean>, IEqualityOperators_3<Byte, Byte, Boolean>, IModulusOperators_3<Byte, Byte, Byte>, IAdditionOperators_3<Byte, Byte, Byte>, IDecrementOperators_1<Byte>, IDivisionOperators_3<Byte, Byte, Byte>, IIncrementOperators_1<Byte>, IMultiplyOperators_3<Byte, Byte, Byte>, ISubtractionOperators_3<Byte, Byte, Byte>, IUnaryPlusOperators_2<Byte, Byte>, IUnaryNegationOperators_2<Byte, Byte>, IShiftOperators_3<Byte, Int32, Byte> {
    CompareTo(value: unknown | undefined): int;
    CompareTo(value: byte): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(obj: byte): boolean;
    GetHashCode(): int;
    GetTypeCode(): TypeCode;
    ToString(): string;
    ToString(format: string | undefined): string;
    ToString(provider: IFormatProvider | undefined): string;
    ToString(format: string | undefined, provider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
}


export const Byte: {
    new(): Byte;
    readonly MaxValue: byte;
    readonly MinValue: byte;
    Clamp(value: byte, min: byte, max: byte): byte;
    CreateChecked<TOther extends INumberBase_1<TOther>>(value: TOther): byte;
    CreateSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): byte;
    CreateTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): byte;
    DivRem(left: byte, right: byte): ValueTuple_2<Byte, Byte>;
    IsEvenInteger(value: byte): boolean;
    IsOddInteger(value: byte): boolean;
    IsPow2(value: byte): boolean;
    LeadingZeroCount(value: byte): byte;
    Log2(value: byte): byte;
    Max(x: byte, y: byte): byte;
    Min(x: byte, y: byte): byte;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, style?: NumberStyles, provider?: IFormatProvider | undefined): byte;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined): byte;
    Parse(s: ReadOnlySpan_1<Char>, style?: NumberStyles, provider?: IFormatProvider | undefined): byte;
    Parse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined): byte;
    Parse(s: string, style: NumberStyles, provider: IFormatProvider | undefined): byte;
    Parse(s: string, style: NumberStyles): byte;
    Parse(s: string, provider: IFormatProvider | undefined): byte;
    Parse(s: string): byte;
    PopCount(value: byte): byte;
    RotateLeft(value: byte, rotateAmount: int): byte;
    RotateRight(value: byte, rotateAmount: int): byte;
    Sign(value: byte): int;
    TrailingZeroCount(value: byte): byte;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, result: byte): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, style: NumberStyles, provider: IFormatProvider | undefined, result: byte): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined, result: byte): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, result: byte): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, style: NumberStyles, provider: IFormatProvider | undefined, result: byte): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, result: byte): boolean;
    TryParse(s: string | undefined, result: byte): boolean;
    TryParse(s: string | undefined, style: NumberStyles, provider: IFormatProvider | undefined, result: byte): boolean;
    TryParse(s: string | undefined, provider: IFormatProvider | undefined, result: byte): boolean;
};


export interface __Byte$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<Byte>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<Byte>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<Byte>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<Byte>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<Byte>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<Byte, Byte>;
    As_IBinaryInteger_1(): System_Numerics_Internal.IBinaryInteger_1$instance<Byte>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<Byte>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<Byte>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<Byte>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Byte): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: Span_1<Byte>, bytesWritten: int): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<Byte>): int;
}

export interface Byte$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<Byte> {}

export type Byte = number & Byte$instance & __Byte$views;


export interface Char$instance extends IBitwiseOperators_3<Char, Char, Char>, IComparisonOperators_3<Char, Char, Boolean>, IEqualityOperators_3<Char, Char, Boolean>, IModulusOperators_3<Char, Char, Char>, IAdditionOperators_3<Char, Char, Char>, IDecrementOperators_1<Char>, IDivisionOperators_3<Char, Char, Char>, IIncrementOperators_1<Char>, IMultiplyOperators_3<Char, Char, Char>, ISubtractionOperators_3<Char, Char, Char>, IUnaryPlusOperators_2<Char, Char>, IUnaryNegationOperators_2<Char, Char>, IShiftOperators_3<Char, Int32, Char> {
    CompareTo(value: unknown | undefined): int;
    CompareTo(value: char): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(obj: char): boolean;
    GetHashCode(): int;
    GetTypeCode(): TypeCode;
    ToString(): string;
    ToString(provider: IFormatProvider | undefined): string;
}


export const Char: {
    new(): Char;
    readonly MaxValue: char;
    readonly MinValue: char;
    ConvertFromUtf32(utf32: int): string;
    ConvertToUtf32(highSurrogate: char, lowSurrogate: char): int;
    ConvertToUtf32(s: string, index: int): int;
    GetNumericValue(c: char): double;
    GetNumericValue(s: string, index: int): double;
    GetUnicodeCategory(c: char): UnicodeCategory;
    GetUnicodeCategory(s: string, index: int): UnicodeCategory;
    IsAscii(c: char): boolean;
    IsAsciiDigit(c: char): boolean;
    IsAsciiHexDigit(c: char): boolean;
    IsAsciiHexDigitLower(c: char): boolean;
    IsAsciiHexDigitUpper(c: char): boolean;
    IsAsciiLetter(c: char): boolean;
    IsAsciiLetterLower(c: char): boolean;
    IsAsciiLetterOrDigit(c: char): boolean;
    IsAsciiLetterUpper(c: char): boolean;
    IsBetween(c: char, minInclusive: char, maxInclusive: char): boolean;
    IsControl(c: char): boolean;
    IsControl(s: string, index: int): boolean;
    IsDigit(c: char): boolean;
    IsDigit(s: string, index: int): boolean;
    IsHighSurrogate(c: char): boolean;
    IsHighSurrogate(s: string, index: int): boolean;
    IsLetter(c: char): boolean;
    IsLetter(s: string, index: int): boolean;
    IsLetterOrDigit(c: char): boolean;
    IsLetterOrDigit(s: string, index: int): boolean;
    IsLower(c: char): boolean;
    IsLower(s: string, index: int): boolean;
    IsLowSurrogate(c: char): boolean;
    IsLowSurrogate(s: string, index: int): boolean;
    IsNumber(c: char): boolean;
    IsNumber(s: string, index: int): boolean;
    IsPunctuation(c: char): boolean;
    IsPunctuation(s: string, index: int): boolean;
    IsSeparator(c: char): boolean;
    IsSeparator(s: string, index: int): boolean;
    IsSurrogate(c: char): boolean;
    IsSurrogate(s: string, index: int): boolean;
    IsSurrogatePair(highSurrogate: char, lowSurrogate: char): boolean;
    IsSurrogatePair(s: string, index: int): boolean;
    IsSymbol(c: char): boolean;
    IsSymbol(s: string, index: int): boolean;
    IsUpper(c: char): boolean;
    IsUpper(s: string, index: int): boolean;
    IsWhiteSpace(c: char): boolean;
    IsWhiteSpace(s: string, index: int): boolean;
    Parse(s: string): char;
    ToLower(c: char, culture: CultureInfo): char;
    ToLower(c: char): char;
    ToLowerInvariant(c: char): char;
    ToString(c: char): string;
    ToUpper(c: char, culture: CultureInfo): char;
    ToUpper(c: char): char;
    ToUpperInvariant(c: char): char;
    TryParse(s: string | undefined, result: char): boolean;
};


export interface __Char$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<Char>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<Char>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<Char>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<Char>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<Char>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<Char, Char>;
    As_IBinaryInteger_1(): System_Numerics_Internal.IBinaryInteger_1$instance<Char>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<Char>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<Char>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<Char>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Char): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: Span_1<Byte>, bytesWritten: int): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<Byte>): int;
}

export interface Char$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<Char> {}

export type Char = string & Char$instance & __Char$views;


export interface ConsoleKeyInfo$instance {
    readonly Key: ConsoleKey;
    readonly KeyChar: char;
    readonly Modifiers: ConsoleModifiers;
    Equals(value: unknown | undefined): boolean;
    Equals(obj: ConsoleKeyInfo): boolean;
    GetHashCode(): int;
}


export const ConsoleKeyInfo: {
    new(keyChar: char, key: ConsoleKey, shift: boolean, alt: boolean, control: boolean): ConsoleKeyInfo;
};


export interface __ConsoleKeyInfo$views {
    As_IEquatable_1(): IEquatable_1$instance<ConsoleKeyInfo>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ConsoleKeyInfo): boolean;
}

export type ConsoleKeyInfo = ConsoleKeyInfo$instance & __ConsoleKeyInfo$views;


export interface DateOnly$instance {
    readonly Day: int;
    readonly DayNumber: int;
    readonly DayOfWeek: DayOfWeek;
    readonly DayOfYear: int;
    readonly Month: int;
    readonly Year: int;
    AddDays(value: int): DateOnly;
    AddMonths(value: int): DateOnly;
    AddYears(value: int): DateOnly;
    CompareTo(value: DateOnly): int;
    CompareTo(value: unknown | undefined): int;
    Deconstruct(year: int, month: int, day: int): void;
    Equals(value: DateOnly): boolean;
    Equals(value: unknown | undefined): boolean;
    GetHashCode(): int;
    ToDateTime(time: TimeOnly): DateTime;
    ToDateTime(time: TimeOnly, kind: DateTimeKind): DateTime;
    ToLongDateString(): string;
    ToShortDateString(): string;
    ToString(): string;
    ToString(format: string | undefined): string;
    ToString(provider: IFormatProvider | undefined): string;
    ToString(format: string | undefined, provider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
}


export const DateOnly: {
    new(year: int, month: int, day: int): DateOnly;
    new(year: int, month: int, day: int, calendar: Calendar): DateOnly;
    readonly MinValue: DateOnly;
    readonly MaxValue: DateOnly;
    FromDateTime(dateTime: DateTime): DateOnly;
    FromDayNumber(dayNumber: int): DateOnly;
    Parse(s: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined, style?: DateTimeStyles): DateOnly;
    Parse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined): DateOnly;
    Parse(s: string, provider: IFormatProvider | undefined, style?: DateTimeStyles): DateOnly;
    Parse(s: string, provider: IFormatProvider | undefined): DateOnly;
    Parse(s: string): DateOnly;
    ParseExact(s: ReadOnlySpan_1<Char>, format: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined, style?: DateTimeStyles): DateOnly;
    ParseExact(s: ReadOnlySpan_1<Char>, formats: string[], provider: IFormatProvider | undefined, style?: DateTimeStyles): DateOnly;
    ParseExact(s: ReadOnlySpan_1<Char>, formats: string[]): DateOnly;
    ParseExact(s: string, format: string, provider: IFormatProvider | undefined, style?: DateTimeStyles): DateOnly;
    ParseExact(s: string, format: string): DateOnly;
    ParseExact(s: string, formats: string[], provider: IFormatProvider | undefined, style?: DateTimeStyles): DateOnly;
    ParseExact(s: string, formats: string[]): DateOnly;
    TryParse(s: ReadOnlySpan_1<Char>, result: DateOnly): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, result: DateOnly): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, style: DateTimeStyles, result: DateOnly): boolean;
    TryParse(s: string | undefined, result: DateOnly): boolean;
    TryParse(s: string | undefined, provider: IFormatProvider | undefined, result: DateOnly): boolean;
    TryParse(s: string | undefined, provider: IFormatProvider | undefined, style: DateTimeStyles, result: DateOnly): boolean;
    TryParseExact(s: ReadOnlySpan_1<Char>, format: ReadOnlySpan_1<Char>, result: DateOnly): boolean;
    TryParseExact(s: ReadOnlySpan_1<Char>, format: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, style: DateTimeStyles, result: DateOnly): boolean;
    TryParseExact(s: ReadOnlySpan_1<Char>, formats: (string | undefined)[] | undefined, result: DateOnly): boolean;
    TryParseExact(s: ReadOnlySpan_1<Char>, formats: (string | undefined)[] | undefined, provider: IFormatProvider | undefined, style: DateTimeStyles, result: DateOnly): boolean;
    TryParseExact(s: string | undefined, format: string | undefined, result: DateOnly): boolean;
    TryParseExact(s: string | undefined, format: string | undefined, provider: IFormatProvider | undefined, style: DateTimeStyles, result: DateOnly): boolean;
    TryParseExact(s: string | undefined, formats: (string | undefined)[] | undefined, result: DateOnly): boolean;
    TryParseExact(s: string | undefined, formats: (string | undefined)[] | undefined, provider: IFormatProvider | undefined, style: DateTimeStyles, result: DateOnly): boolean;
};


export interface __DateOnly$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<DateOnly>;
    As_IEquatable_1(): IEquatable_1$instance<DateOnly>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<DateOnly>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<DateOnly>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: DateOnly): boolean;
    CompareTo(obj: unknown): int;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
}

export interface DateOnly$instance extends IComparable_1$instance<DateOnly>, ISpanParsable_1$instance<DateOnly> {}

export type DateOnly = DateOnly$instance & __DateOnly$views;


export interface DateTime$instance {
    readonly Date: DateTime;
    readonly Day: int;
    readonly DayOfWeek: DayOfWeek;
    readonly DayOfYear: int;
    readonly Hour: int;
    readonly Kind: DateTimeKind;
    readonly Microsecond: int;
    readonly Millisecond: int;
    readonly Minute: int;
    readonly Month: int;
    readonly Nanosecond: int;
    readonly Second: int;
    readonly Ticks: long;
    readonly TimeOfDay: TimeSpan;
    readonly Year: int;
    Add(value: TimeSpan): DateTime;
    AddDays(value: double): DateTime;
    AddHours(value: double): DateTime;
    AddMicroseconds(value: double): DateTime;
    AddMilliseconds(value: double): DateTime;
    AddMinutes(value: double): DateTime;
    AddMonths(months: int): DateTime;
    AddSeconds(value: double): DateTime;
    AddTicks(value: long): DateTime;
    AddYears(value: int): DateTime;
    CompareTo(value: unknown | undefined): int;
    CompareTo(value: DateTime): int;
    Deconstruct(date: DateOnly, time: TimeOnly): void;
    Deconstruct(year: int, month: int, day: int): void;
    Equals(value: unknown | undefined): boolean;
    Equals(value: DateTime): boolean;
    GetDateTimeFormats(): string[];
    GetDateTimeFormats(provider: IFormatProvider | undefined): string[];
    GetDateTimeFormats(format: char): string[];
    GetDateTimeFormats(format: char, provider: IFormatProvider | undefined): string[];
    GetHashCode(): int;
    GetTypeCode(): TypeCode;
    IsDaylightSavingTime(): boolean;
    Subtract(value: DateTime): TimeSpan;
    Subtract(value: TimeSpan): DateTime;
    ToBinary(): long;
    ToFileTime(): long;
    ToFileTimeUtc(): long;
    ToLocalTime(): DateTime;
    ToLongDateString(): string;
    ToLongTimeString(): string;
    ToOADate(): double;
    ToShortDateString(): string;
    ToShortTimeString(): string;
    ToString(): string;
    ToString(format: string | undefined): string;
    ToString(provider: IFormatProvider | undefined): string;
    ToString(format: string | undefined, provider: IFormatProvider | undefined): string;
    ToUniversalTime(): DateTime;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
}


export const DateTime: {
    new(ticks: long): DateTime;
    new(ticks: long, kind: DateTimeKind): DateTime;
    new(date: DateOnly, time: TimeOnly): DateTime;
    new(date: DateOnly, time: TimeOnly, kind: DateTimeKind): DateTime;
    new(year: int, month: int, day: int): DateTime;
    new(year: int, month: int, day: int, calendar: Calendar): DateTime;
    new(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, calendar: Calendar, kind: DateTimeKind): DateTime;
    new(year: int, month: int, day: int, hour: int, minute: int, second: int): DateTime;
    new(year: int, month: int, day: int, hour: int, minute: int, second: int, kind: DateTimeKind): DateTime;
    new(year: int, month: int, day: int, hour: int, minute: int, second: int, calendar: Calendar): DateTime;
    new(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
    new(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, kind: DateTimeKind): DateTime;
    new(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, calendar: Calendar): DateTime;
    new(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, microsecond: int): DateTime;
    new(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, microsecond: int, kind: DateTimeKind): DateTime;
    new(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, microsecond: int, calendar: Calendar): DateTime;
    new(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, microsecond: int, calendar: Calendar, kind: DateTimeKind): DateTime;
    readonly MinValue: DateTime;
    readonly MaxValue: DateTime;
    readonly UnixEpoch: DateTime;
    readonly Now: DateTime;
    readonly Today: DateTime;
    readonly UtcNow: DateTime;
    Compare(t1: DateTime, t2: DateTime): int;
    DaysInMonth(year: int, month: int): int;
    Equals(t1: DateTime, t2: DateTime): boolean;
    FromBinary(dateData: long): DateTime;
    FromFileTime(fileTime: long): DateTime;
    FromFileTimeUtc(fileTime: long): DateTime;
    FromOADate(d: double): DateTime;
    IsLeapYear(year: int): boolean;
    Parse(s: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined, styles?: DateTimeStyles): DateTime;
    Parse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined): DateTime;
    Parse(s: string, provider: IFormatProvider | undefined, styles: DateTimeStyles): DateTime;
    Parse(s: string, provider: IFormatProvider | undefined): DateTime;
    Parse(s: string): DateTime;
    ParseExact(s: ReadOnlySpan_1<Char>, format: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, style?: DateTimeStyles): DateTime;
    ParseExact(s: ReadOnlySpan_1<Char>, formats: string[], provider: IFormatProvider | undefined, style?: DateTimeStyles): DateTime;
    ParseExact(s: string, format: string, provider: IFormatProvider | undefined, style: DateTimeStyles): DateTime;
    ParseExact(s: string, format: string, provider: IFormatProvider | undefined): DateTime;
    ParseExact(s: string, formats: string[], provider: IFormatProvider | undefined, style: DateTimeStyles): DateTime;
    SpecifyKind(value: DateTime, kind: DateTimeKind): DateTime;
    TryParse(s: ReadOnlySpan_1<Char>, result: DateTime): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, result: DateTime): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, styles: DateTimeStyles, result: DateTime): boolean;
    TryParse(s: string | undefined, result: DateTime): boolean;
    TryParse(s: string | undefined, provider: IFormatProvider | undefined, result: DateTime): boolean;
    TryParse(s: string | undefined, provider: IFormatProvider | undefined, styles: DateTimeStyles, result: DateTime): boolean;
    TryParseExact(s: ReadOnlySpan_1<Char>, format: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, style: DateTimeStyles, result: DateTime): boolean;
    TryParseExact(s: ReadOnlySpan_1<Char>, formats: (string | undefined)[] | undefined, provider: IFormatProvider | undefined, style: DateTimeStyles, result: DateTime): boolean;
    TryParseExact(s: string | undefined, format: string | undefined, provider: IFormatProvider | undefined, style: DateTimeStyles, result: DateTime): boolean;
    TryParseExact(s: string | undefined, formats: (string | undefined)[] | undefined, provider: IFormatProvider | undefined, style: DateTimeStyles, result: DateTime): boolean;
};


export interface __DateTime$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<DateTime>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<DateTime>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<DateTime>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<DateTime>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: DateTime): boolean;
    CompareTo(obj: unknown): int;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
}

export interface DateTime$instance extends IComparable_1$instance<DateTime>, ISpanParsable_1$instance<DateTime>, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type DateTime = DateTime$instance & __DateTime$views;


export interface DateTimeOffset$instance {
    readonly Date: DateTime;
    readonly DateTime: DateTime;
    readonly Day: int;
    readonly DayOfWeek: DayOfWeek;
    readonly DayOfYear: int;
    readonly Hour: int;
    readonly LocalDateTime: DateTime;
    readonly Microsecond: int;
    readonly Millisecond: int;
    readonly Minute: int;
    readonly Month: int;
    readonly Nanosecond: int;
    readonly Offset: TimeSpan;
    readonly Second: int;
    readonly Ticks: long;
    readonly TimeOfDay: TimeSpan;
    readonly TotalOffsetMinutes: int;
    readonly UtcDateTime: DateTime;
    readonly UtcTicks: long;
    readonly Year: int;
    Add(timeSpan: TimeSpan): DateTimeOffset;
    AddDays(days: double): DateTimeOffset;
    AddHours(hours: double): DateTimeOffset;
    AddMicroseconds(microseconds: double): DateTimeOffset;
    AddMilliseconds(milliseconds: double): DateTimeOffset;
    AddMinutes(minutes: double): DateTimeOffset;
    AddMonths(months: int): DateTimeOffset;
    AddSeconds(seconds: double): DateTimeOffset;
    AddTicks(ticks: long): DateTimeOffset;
    AddYears(years: int): DateTimeOffset;
    CompareTo(other: DateTimeOffset): int;
    Deconstruct(date: DateOnly, time: TimeOnly, offset: TimeSpan): void;
    Equals(obj: unknown | undefined): boolean;
    Equals(other: DateTimeOffset): boolean;
    EqualsExact(other: DateTimeOffset): boolean;
    GetHashCode(): int;
    Subtract(value: DateTimeOffset): TimeSpan;
    Subtract(value: TimeSpan): DateTimeOffset;
    ToFileTime(): long;
    ToLocalTime(): DateTimeOffset;
    ToOffset(offset: TimeSpan): DateTimeOffset;
    ToString(): string;
    ToString(format: string | undefined): string;
    ToString(formatProvider: IFormatProvider | undefined): string;
    ToString(format: string | undefined, formatProvider: IFormatProvider | undefined): string;
    ToUniversalTime(): DateTimeOffset;
    ToUnixTimeMilliseconds(): long;
    ToUnixTimeSeconds(): long;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format?: ReadOnlySpan_1<Char>, formatProvider?: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format?: ReadOnlySpan_1<Char>, formatProvider?: IFormatProvider | undefined): boolean;
}


export const DateTimeOffset: {
    new(ticks: long, offset: TimeSpan): DateTimeOffset;
    new(dateTime: DateTime): DateTimeOffset;
    new(dateTime: DateTime, offset: TimeSpan): DateTimeOffset;
    new(date: DateOnly, time: TimeOnly, offset: TimeSpan): DateTimeOffset;
    new(year: int, month: int, day: int, hour: int, minute: int, second: int, offset: TimeSpan): DateTimeOffset;
    new(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, offset: TimeSpan): DateTimeOffset;
    new(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, calendar: Calendar, offset: TimeSpan): DateTimeOffset;
    new(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, microsecond: int, offset: TimeSpan): DateTimeOffset;
    new(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, microsecond: int, calendar: Calendar, offset: TimeSpan): DateTimeOffset;
    readonly MinValue: DateTimeOffset;
    readonly MaxValue: DateTimeOffset;
    readonly UnixEpoch: DateTimeOffset;
    readonly UtcNow: DateTimeOffset;
    readonly Now: DateTimeOffset;
    Compare(first: DateTimeOffset, second: DateTimeOffset): int;
    Equals(first: DateTimeOffset, second: DateTimeOffset): boolean;
    FromFileTime(fileTime: long): DateTimeOffset;
    FromUnixTimeMilliseconds(milliseconds: long): DateTimeOffset;
    FromUnixTimeSeconds(seconds: long): DateTimeOffset;
    Parse(input: ReadOnlySpan_1<Char>, formatProvider?: IFormatProvider | undefined, styles?: DateTimeStyles): DateTimeOffset;
    Parse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined): DateTimeOffset;
    Parse(input: string, formatProvider: IFormatProvider | undefined, styles: DateTimeStyles): DateTimeOffset;
    Parse(input: string, formatProvider: IFormatProvider | undefined): DateTimeOffset;
    Parse(input: string): DateTimeOffset;
    ParseExact(input: ReadOnlySpan_1<Char>, format: ReadOnlySpan_1<Char>, formatProvider: IFormatProvider | undefined, styles?: DateTimeStyles): DateTimeOffset;
    ParseExact(input: ReadOnlySpan_1<Char>, formats: string[], formatProvider: IFormatProvider | undefined, styles?: DateTimeStyles): DateTimeOffset;
    ParseExact(input: string, format: string, formatProvider: IFormatProvider | undefined, styles: DateTimeStyles): DateTimeOffset;
    ParseExact(input: string, format: string, formatProvider: IFormatProvider | undefined): DateTimeOffset;
    ParseExact(input: string, formats: string[], formatProvider: IFormatProvider | undefined, styles: DateTimeStyles): DateTimeOffset;
    TryParse(input: ReadOnlySpan_1<Char>, result: DateTimeOffset): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, result: DateTimeOffset): boolean;
    TryParse(input: ReadOnlySpan_1<Char>, formatProvider: IFormatProvider | undefined, styles: DateTimeStyles, result: DateTimeOffset): boolean;
    TryParse(input: string | undefined, result: DateTimeOffset): boolean;
    TryParse(s: string | undefined, provider: IFormatProvider | undefined, result: DateTimeOffset): boolean;
    TryParse(input: string | undefined, formatProvider: IFormatProvider | undefined, styles: DateTimeStyles, result: DateTimeOffset): boolean;
    TryParseExact(input: ReadOnlySpan_1<Char>, format: ReadOnlySpan_1<Char>, formatProvider: IFormatProvider | undefined, styles: DateTimeStyles, result: DateTimeOffset): boolean;
    TryParseExact(input: ReadOnlySpan_1<Char>, formats: (string | undefined)[] | undefined, formatProvider: IFormatProvider | undefined, styles: DateTimeStyles, result: DateTimeOffset): boolean;
    TryParseExact(input: string | undefined, format: string | undefined, formatProvider: IFormatProvider | undefined, styles: DateTimeStyles, result: DateTimeOffset): boolean;
    TryParseExact(input: string | undefined, formats: (string | undefined)[] | undefined, formatProvider: IFormatProvider | undefined, styles: DateTimeStyles, result: DateTimeOffset): boolean;
};


export interface __DateTimeOffset$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<DateTimeOffset>;
    As_IEquatable_1(): IEquatable_1$instance<DateTimeOffset>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<DateTimeOffset>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<DateTimeOffset>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: DateTimeOffset): boolean;
    CompareTo(obj: unknown): int;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
}

export interface DateTimeOffset$instance extends IComparable_1$instance<DateTimeOffset>, ISpanParsable_1$instance<DateTimeOffset>, System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type DateTimeOffset = DateTimeOffset$instance & __DateTimeOffset$views;


export interface Decimal$instance extends IAdditionOperators_3<Decimal, Decimal, Decimal>, IDecrementOperators_1<Decimal>, IDivisionOperators_3<Decimal, Decimal, Decimal>, IEqualityOperators_3<Decimal, Decimal, Boolean>, IIncrementOperators_1<Decimal>, IMultiplyOperators_3<Decimal, Decimal, Decimal>, ISubtractionOperators_3<Decimal, Decimal, Decimal>, IUnaryPlusOperators_2<Decimal, Decimal>, IUnaryNegationOperators_2<Decimal, Decimal>, IComparisonOperators_3<Decimal, Decimal, Boolean>, IModulusOperators_3<Decimal, Decimal, Decimal> {
    readonly Scale: byte;
    CompareTo(value: unknown | undefined): int;
    CompareTo(value: decimal): int;
    Equals(value: unknown | undefined): boolean;
    Equals(value: decimal): boolean;
    GetHashCode(): int;
    GetTypeCode(): TypeCode;
    ToString(): string;
    ToString(format: string | undefined): string;
    ToString(provider: IFormatProvider | undefined): string;
    ToString(format: string | undefined, provider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
}


export const Decimal: {
    new(value: int): Decimal;
    new(value: uint): Decimal;
    new(value: long): Decimal;
    new(value: ulong): Decimal;
    new(value: float): Decimal;
    new(value: double): Decimal;
    new(bits: int[]): Decimal;
    new(bits: ReadOnlySpan_1<Int32>): Decimal;
    new(lo: int, mid: int, hi: int, isNegative: boolean, scale: byte): Decimal;
    readonly Zero: decimal;
    readonly One: decimal;
    readonly MinusOne: decimal;
    readonly MaxValue: decimal;
    readonly MinValue: decimal;
    Abs(value: decimal): decimal;
    Add(d1: decimal, d2: decimal): decimal;
    Ceiling(d: decimal): decimal;
    Clamp(value: decimal, min: decimal, max: decimal): decimal;
    Compare(d1: decimal, d2: decimal): int;
    ConvertToInteger<TInteger extends IBinaryInteger_1<TInteger>>(value: decimal): TInteger;
    ConvertToIntegerNative<TInteger extends IBinaryInteger_1<TInteger>>(value: decimal): TInteger;
    CopySign(value: decimal, sign: decimal): decimal;
    CreateChecked<TOther extends INumberBase_1<TOther>>(value: TOther): decimal;
    CreateSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): decimal;
    CreateTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): decimal;
    Divide(d1: decimal, d2: decimal): decimal;
    Equals(d1: decimal, d2: decimal): boolean;
    Floor(d: decimal): decimal;
    FromOACurrency(cy: long): decimal;
    GetBits(d: decimal, destination: Span_1<Int32>): int;
    GetBits(d: decimal): int[];
    IsCanonical(value: decimal): boolean;
    IsEvenInteger(value: decimal): boolean;
    IsInteger(value: decimal): boolean;
    IsNegative(value: decimal): boolean;
    IsOddInteger(value: decimal): boolean;
    IsPositive(value: decimal): boolean;
    Max(x: decimal, y: decimal): decimal;
    MaxMagnitude(x: decimal, y: decimal): decimal;
    Min(x: decimal, y: decimal): decimal;
    MinMagnitude(x: decimal, y: decimal): decimal;
    Multiply(d1: decimal, d2: decimal): decimal;
    Negate(d: decimal): decimal;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, style?: NumberStyles, provider?: IFormatProvider | undefined): decimal;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined): decimal;
    Parse(s: ReadOnlySpan_1<Char>, style?: NumberStyles, provider?: IFormatProvider | undefined): decimal;
    Parse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined): decimal;
    Parse(s: string, style: NumberStyles, provider: IFormatProvider | undefined): decimal;
    Parse(s: string, style: NumberStyles): decimal;
    Parse(s: string, provider: IFormatProvider | undefined): decimal;
    Parse(s: string): decimal;
    Remainder(d1: decimal, d2: decimal): decimal;
    Round(d: decimal, decimals: int, mode: MidpointRounding): decimal;
    Round(d: decimal, decimals: int): decimal;
    Round(d: decimal, mode: MidpointRounding): decimal;
    Round(d: decimal): decimal;
    Sign(d: decimal): int;
    Subtract(d1: decimal, d2: decimal): decimal;
    ToByte(value: decimal): byte;
    ToDouble(d: decimal): double;
    ToInt16(value: decimal): short;
    ToInt32(d: decimal): int;
    ToInt64(d: decimal): long;
    ToOACurrency(value: decimal): long;
    ToSByte(value: decimal): sbyte;
    ToSingle(d: decimal): float;
    ToUInt16(value: decimal): ushort;
    ToUInt32(d: decimal): uint;
    ToUInt64(d: decimal): ulong;
    Truncate(d: decimal): decimal;
    TryGetBits(d: decimal, destination: Span_1<Int32>, valuesWritten: int): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, result: decimal): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, style: NumberStyles, provider: IFormatProvider | undefined, result: decimal): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined, result: decimal): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, result: decimal): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, style: NumberStyles, provider: IFormatProvider | undefined, result: decimal): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, result: decimal): boolean;
    TryParse(s: string | undefined, result: decimal): boolean;
    TryParse(s: string | undefined, style: NumberStyles, provider: IFormatProvider | undefined, result: decimal): boolean;
    TryParse(s: string | undefined, provider: IFormatProvider | undefined, result: decimal): boolean;
};


export interface __Decimal$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<Decimal>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<Decimal>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<Decimal>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<Decimal>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<Decimal>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<Decimal, Decimal>;
    As_IFloatingPoint_1(): System_Numerics_Internal.IFloatingPoint_1$instance<Decimal>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<Decimal>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<Decimal>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<Decimal>;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: Decimal): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    GetExponentByteCount(): int;
    GetExponentShortestBitLength(): int;
    TryWriteExponentBigEndian(destination: Span_1<Byte>, bytesWritten: int): boolean;
    WriteExponentBigEndian(destination: byte[], startIndex: int): int;
    WriteExponentBigEndian(destination: byte[]): int;
    WriteExponentBigEndian(destination: Span_1<Byte>): int;
}

export interface Decimal$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<Decimal>, System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Decimal = number & Decimal$instance & __Decimal$views;


export interface Delegate_InvocationListEnumerator_1$instance<TDelegate extends Function> {
    readonly Current: TDelegate;
    GetEnumerator(): Delegate_InvocationListEnumerator_1<TDelegate>;
    MoveNext(): boolean;
}


export const Delegate_InvocationListEnumerator_1: {
    new<TDelegate extends Function>(): Delegate_InvocationListEnumerator_1<TDelegate>;
};


export type Delegate_InvocationListEnumerator_1<TDelegate extends Function> = Delegate_InvocationListEnumerator_1$instance<TDelegate>;

export interface Double$instance extends IBitwiseOperators_3<Double, Double, Double>, IComparisonOperators_3<Double, Double, Boolean>, IEqualityOperators_3<Double, Double, Boolean>, IModulusOperators_3<Double, Double, Double>, IAdditionOperators_3<Double, Double, Double>, IDecrementOperators_1<Double>, IDivisionOperators_3<Double, Double, Double>, IIncrementOperators_1<Double>, IMultiplyOperators_3<Double, Double, Double>, ISubtractionOperators_3<Double, Double, Double>, IUnaryPlusOperators_2<Double, Double>, IUnaryNegationOperators_2<Double, Double> {
    CompareTo(value: unknown | undefined): int;
    CompareTo(value: double): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(obj: double): boolean;
    GetHashCode(): int;
    GetTypeCode(): TypeCode;
    ToString(): string;
    ToString(format: string | undefined): string;
    ToString(provider: IFormatProvider | undefined): string;
    ToString(format: string | undefined, provider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
}


export const Double: {
    new(): Double;
    readonly MinValue: double;
    readonly MaxValue: double;
    readonly Epsilon: double;
    readonly NegativeInfinity: double;
    readonly PositiveInfinity: double;
    readonly NaN: double;
    readonly NegativeZero: double;
    readonly E: double;
    readonly Pi: double;
    readonly Tau: double;
    Abs(value: double): double;
    Acos(x: double): double;
    Acosh(x: double): double;
    AcosPi(x: double): double;
    Asin(x: double): double;
    Asinh(x: double): double;
    AsinPi(x: double): double;
    Atan(x: double): double;
    Atan2(y: double, x: double): double;
    Atan2Pi(y: double, x: double): double;
    Atanh(x: double): double;
    AtanPi(x: double): double;
    BitDecrement(x: double): double;
    BitIncrement(x: double): double;
    Cbrt(x: double): double;
    Ceiling(x: double): double;
    Clamp(value: double, min: double, max: double): double;
    ClampNative(value: double, min: double, max: double): double;
    ConvertToInteger<TInteger extends IBinaryInteger_1<TInteger>>(value: double): TInteger;
    ConvertToIntegerNative<TInteger extends IBinaryInteger_1<TInteger>>(value: double): TInteger;
    CopySign(value: double, sign: double): double;
    Cos(x: double): double;
    Cosh(x: double): double;
    CosPi(x: double): double;
    CreateChecked<TOther extends INumberBase_1<TOther>>(value: TOther): double;
    CreateSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): double;
    CreateTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): double;
    DegreesToRadians(degrees: double): double;
    Exp(x: double): double;
    Exp10(x: double): double;
    Exp10M1(x: double): double;
    Exp2(x: double): double;
    Exp2M1(x: double): double;
    ExpM1(x: double): double;
    Floor(x: double): double;
    FusedMultiplyAdd(left: double, right: double, addend: double): double;
    Hypot(x: double, y: double): double;
    Ieee754Remainder(left: double, right: double): double;
    ILogB(x: double): int;
    IsEvenInteger(value: double): boolean;
    IsFinite(d: double): boolean;
    IsInfinity(d: double): boolean;
    IsInteger(value: double): boolean;
    IsNaN(d: double): boolean;
    IsNegative(d: double): boolean;
    IsNegativeInfinity(d: double): boolean;
    IsNormal(d: double): boolean;
    IsOddInteger(value: double): boolean;
    IsPositive(value: double): boolean;
    IsPositiveInfinity(d: double): boolean;
    IsPow2(value: double): boolean;
    IsRealNumber(value: double): boolean;
    IsSubnormal(d: double): boolean;
    Lerp(value1: double, value2: double, amount: double): double;
    Log(x: double, newBase: double): double;
    Log(x: double): double;
    Log10(x: double): double;
    Log10P1(x: double): double;
    Log2(value: double): double;
    Log2P1(x: double): double;
    LogP1(x: double): double;
    Max(x: double, y: double): double;
    MaxMagnitude(x: double, y: double): double;
    MaxMagnitudeNumber(x: double, y: double): double;
    MaxNative(x: double, y: double): double;
    MaxNumber(x: double, y: double): double;
    Min(x: double, y: double): double;
    MinMagnitude(x: double, y: double): double;
    MinMagnitudeNumber(x: double, y: double): double;
    MinNative(x: double, y: double): double;
    MinNumber(x: double, y: double): double;
    MultiplyAddEstimate(left: double, right: double, addend: double): double;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, style?: NumberStyles, provider?: IFormatProvider | undefined): double;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined): double;
    Parse(s: ReadOnlySpan_1<Char>, style?: NumberStyles, provider?: IFormatProvider | undefined): double;
    Parse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined): double;
    Parse(s: string, style: NumberStyles, provider: IFormatProvider | undefined): double;
    Parse(s: string, style: NumberStyles): double;
    Parse(s: string, provider: IFormatProvider | undefined): double;
    Parse(s: string): double;
    Pow(x: double, y: double): double;
    RadiansToDegrees(radians: double): double;
    ReciprocalEstimate(x: double): double;
    ReciprocalSqrtEstimate(x: double): double;
    RootN(x: double, n: int): double;
    Round(x: double, digits: int, mode: MidpointRounding): double;
    Round(x: double, digits: int): double;
    Round(x: double, mode: MidpointRounding): double;
    Round(x: double): double;
    ScaleB(x: double, n: int): double;
    Sign(value: double): int;
    Sin(x: double): double;
    SinCos(x: double): ValueTuple_2<Double, Double>;
    SinCosPi(x: double): ValueTuple_2<Double, Double>;
    Sinh(x: double): double;
    SinPi(x: double): double;
    Sqrt(x: double): double;
    Tan(x: double): double;
    Tanh(x: double): double;
    TanPi(x: double): double;
    Truncate(x: double): double;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, result: double): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, style: NumberStyles, provider: IFormatProvider | undefined, result: double): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined, result: double): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, result: double): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, style: NumberStyles, provider: IFormatProvider | undefined, result: double): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, result: double): boolean;
    TryParse(s: string | undefined, result: double): boolean;
    TryParse(s: string | undefined, style: NumberStyles, provider: IFormatProvider | undefined, result: double): boolean;
    TryParse(s: string | undefined, provider: IFormatProvider | undefined, result: double): boolean;
};


export interface __Double$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<Double>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<Double>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<Double>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<Double>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<Double>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<Double, Double>;
    As_IFloatingPoint_1(): System_Numerics_Internal.IFloatingPoint_1$instance<Double>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<Double>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<Double>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<Double>;
    As_IRootFunctions_1(): System_Numerics_Internal.IRootFunctions_1$instance<Double>;
    As_ITrigonometricFunctions_1(): System_Numerics_Internal.ITrigonometricFunctions_1$instance<Double>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Double): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    GetExponentByteCount(): int;
    GetExponentShortestBitLength(): int;
    TryWriteExponentBigEndian(destination: Span_1<Byte>, bytesWritten: int): boolean;
    WriteExponentBigEndian(destination: byte[], startIndex: int): int;
    WriteExponentBigEndian(destination: byte[]): int;
    WriteExponentBigEndian(destination: Span_1<Byte>): int;
}

export interface Double$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<Double> {}

export type Double = number & Double$instance & __Double$views;


export interface Environment_ProcessCpuUsage$instance {
    readonly PrivilegedTime: TimeSpan;
    readonly TotalTime: TimeSpan;
    readonly UserTime: TimeSpan;
}


export const Environment_ProcessCpuUsage: {
    new(): Environment_ProcessCpuUsage;
};


export type Environment_ProcessCpuUsage = Environment_ProcessCpuUsage$instance;

export interface GCGenerationInfo$instance {
    readonly FragmentationAfterBytes: long;
    readonly FragmentationBeforeBytes: long;
    readonly SizeAfterBytes: long;
    readonly SizeBeforeBytes: long;
}


export const GCGenerationInfo: {
    new(): GCGenerationInfo;
};


export type GCGenerationInfo = GCGenerationInfo$instance;

export interface GCMemoryInfo$instance {
    readonly Compacted: boolean;
    readonly Concurrent: boolean;
    readonly FinalizationPendingCount: long;
    readonly FragmentedBytes: long;
    readonly Generation: int;
    readonly GenerationInfo: ReadOnlySpan_1<GCGenerationInfo>;
    readonly HeapSizeBytes: long;
    readonly HighMemoryLoadThresholdBytes: long;
    readonly Index: long;
    readonly MemoryLoadBytes: long;
    readonly PauseDurations: ReadOnlySpan_1<TimeSpan>;
    readonly PauseTimePercentage: double;
    readonly PinnedObjectsCount: long;
    readonly PromotedBytes: long;
    readonly TotalAvailableMemoryBytes: long;
    readonly TotalCommittedBytes: long;
}


export const GCMemoryInfo: {
    new(): GCMemoryInfo;
};


export type GCMemoryInfo = GCMemoryInfo$instance;

export interface Guid$instance {
    readonly Variant: int;
    readonly Version: int;
    CompareTo(value: unknown | undefined): int;
    CompareTo(value: Guid): int;
    Equals(o: unknown | undefined): boolean;
    Equals(g: Guid): boolean;
    GetHashCode(): int;
    ToByteArray(): byte[];
    ToByteArray(bigEndian: boolean): byte[];
    ToString(): string;
    ToString(format: string | undefined): string;
    ToString(format: string | undefined, provider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format?: ReadOnlySpan_1<Char>): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format?: ReadOnlySpan_1<Char>): boolean;
    TryWriteBytes(destination: Span_1<Byte>): boolean;
    TryWriteBytes(destination: Span_1<Byte>, bigEndian: boolean, bytesWritten: int): boolean;
}


export const Guid: {
    new(b: byte[]): Guid;
    new(b: ReadOnlySpan_1<Byte>): Guid;
    new(b: ReadOnlySpan_1<Byte>, bigEndian: boolean): Guid;
    new(a: uint, b: ushort, c: ushort, d: byte, e: byte, f: byte, g: byte, h: byte, i: byte, j: byte, k: byte): Guid;
    new(a: int, b: short, c: short, d: byte[]): Guid;
    new(a: int, b: short, c: short, d: byte, e: byte, f: byte, g: byte, h: byte, i: byte, j: byte, k: byte): Guid;
    new(g: string): Guid;
    readonly Empty: Guid;
    readonly AllBitsSet: Guid;
    CreateVersion7(): Guid;
    CreateVersion7(timestamp: DateTimeOffset): Guid;
    NewGuid(): Guid;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined): Guid;
    Parse(utf8Text: ReadOnlySpan_1<Byte>): Guid;
    Parse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined): Guid;
    Parse(input: ReadOnlySpan_1<Char>): Guid;
    Parse(s: string, provider: IFormatProvider | undefined): Guid;
    Parse(input: string): Guid;
    ParseExact(input: ReadOnlySpan_1<Char>, format: ReadOnlySpan_1<Char>): Guid;
    ParseExact(input: string, format: string): Guid;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, result: Guid): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined, result: Guid): boolean;
    TryParse(input: ReadOnlySpan_1<Char>, result: Guid): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, result: Guid): boolean;
    TryParse(input: string | undefined, result: Guid): boolean;
    TryParse(s: string | undefined, provider: IFormatProvider | undefined, result: Guid): boolean;
    TryParseExact(input: ReadOnlySpan_1<Char>, format: ReadOnlySpan_1<Char>, result: Guid): boolean;
    TryParseExact(input: string | undefined, format: string | undefined, result: Guid): boolean;
};


export interface __Guid$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<Guid>;
    As_IEquatable_1(): IEquatable_1$instance<Guid>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<Guid>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<Guid>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<Guid>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Guid): boolean;
    CompareTo(obj: unknown): int;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
}

export interface Guid$instance extends IComparable_1$instance<Guid>, ISpanParsable_1$instance<Guid> {}

export type Guid = Guid$instance & __Guid$views;


export interface Half$instance extends IBitwiseOperators_3<Half, Half, Half>, IComparisonOperators_3<Half, Half, Boolean>, IEqualityOperators_3<Half, Half, Boolean>, IModulusOperators_3<Half, Half, Half>, IAdditionOperators_3<Half, Half, Half>, IDecrementOperators_1<Half>, IDivisionOperators_3<Half, Half, Half>, IIncrementOperators_1<Half>, IMultiplicativeIdentity_2<Half, Half>, IMultiplyOperators_3<Half, Half, Half>, ISubtractionOperators_3<Half, Half, Half>, IUnaryPlusOperators_2<Half, Half>, IUnaryNegationOperators_2<Half, Half> {
    CompareTo(obj: unknown | undefined): int;
    CompareTo(other: half): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(other: half): boolean;
    GetHashCode(): int;
    ToString(): string;
    ToString(format: string | undefined): string;
    ToString(provider: IFormatProvider | undefined): string;
    ToString(format: string | undefined, provider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
}


export const Half: {
    new(): Half;
    readonly Epsilon: half;
    readonly PositiveInfinity: half;
    readonly NegativeInfinity: half;
    readonly NaN: half;
    readonly MinValue: half;
    readonly MaxValue: half;
    readonly E: half;
    readonly Pi: half;
    readonly Tau: half;
    readonly NegativeZero: half;
    readonly MultiplicativeIdentity: half;
    readonly One: half;
    readonly Zero: half;
    readonly NegativeOne: half;
    Abs(value: half): half;
    Acos(x: half): half;
    Acosh(x: half): half;
    AcosPi(x: half): half;
    Asin(x: half): half;
    Asinh(x: half): half;
    AsinPi(x: half): half;
    Atan(x: half): half;
    Atan2(y: half, x: half): half;
    Atan2Pi(y: half, x: half): half;
    Atanh(x: half): half;
    AtanPi(x: half): half;
    BitDecrement(x: half): half;
    BitIncrement(x: half): half;
    Cbrt(x: half): half;
    Ceiling(x: half): half;
    Clamp(value: half, min: half, max: half): half;
    ClampNative(value: half, min: half, max: half): half;
    ConvertToInteger<TInteger extends IBinaryInteger_1<TInteger>>(value: half): TInteger;
    ConvertToIntegerNative<TInteger extends IBinaryInteger_1<TInteger>>(value: half): TInteger;
    CopySign(value: half, sign: half): half;
    Cos(x: half): half;
    Cosh(x: half): half;
    CosPi(x: half): half;
    CreateChecked<TOther extends INumberBase_1<TOther>>(value: TOther): half;
    CreateSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): half;
    CreateTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): half;
    DegreesToRadians(degrees: half): half;
    Exp(x: half): half;
    Exp10(x: half): half;
    Exp10M1(x: half): half;
    Exp2(x: half): half;
    Exp2M1(x: half): half;
    ExpM1(x: half): half;
    Floor(x: half): half;
    FusedMultiplyAdd(left: half, right: half, addend: half): half;
    Hypot(x: half, y: half): half;
    Ieee754Remainder(left: half, right: half): half;
    ILogB(x: half): int;
    IsEvenInteger(value: half): boolean;
    IsFinite(value: half): boolean;
    IsInfinity(value: half): boolean;
    IsInteger(value: half): boolean;
    IsNaN(value: half): boolean;
    IsNegative(value: half): boolean;
    IsNegativeInfinity(value: half): boolean;
    IsNormal(value: half): boolean;
    IsOddInteger(value: half): boolean;
    IsPositive(value: half): boolean;
    IsPositiveInfinity(value: half): boolean;
    IsPow2(value: half): boolean;
    IsRealNumber(value: half): boolean;
    IsSubnormal(value: half): boolean;
    Lerp(value1: half, value2: half, amount: half): half;
    Log(x: half, newBase: half): half;
    Log(x: half): half;
    Log10(x: half): half;
    Log10P1(x: half): half;
    Log2(value: half): half;
    Log2P1(x: half): half;
    LogP1(x: half): half;
    Max(x: half, y: half): half;
    MaxMagnitude(x: half, y: half): half;
    MaxMagnitudeNumber(x: half, y: half): half;
    MaxNative(x: half, y: half): half;
    MaxNumber(x: half, y: half): half;
    Min(x: half, y: half): half;
    MinMagnitude(x: half, y: half): half;
    MinMagnitudeNumber(x: half, y: half): half;
    MinNative(x: half, y: half): half;
    MinNumber(x: half, y: half): half;
    MultiplyAddEstimate(left: half, right: half, addend: half): half;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, style?: NumberStyles, provider?: IFormatProvider | undefined): half;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined): half;
    Parse(s: ReadOnlySpan_1<Char>, style?: NumberStyles, provider?: IFormatProvider | undefined): half;
    Parse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined): half;
    Parse(s: string, style?: NumberStyles, provider?: IFormatProvider | undefined): half;
    Parse(s: string, style: NumberStyles): half;
    Parse(s: string, provider: IFormatProvider | undefined): half;
    Parse(s: string): half;
    Pow(x: half, y: half): half;
    RadiansToDegrees(radians: half): half;
    ReciprocalEstimate(x: half): half;
    ReciprocalSqrtEstimate(x: half): half;
    RootN(x: half, n: int): half;
    Round(x: half, digits: int, mode: MidpointRounding): half;
    Round(x: half, digits: int): half;
    Round(x: half, mode: MidpointRounding): half;
    Round(x: half): half;
    ScaleB(x: half, n: int): half;
    Sign(value: half): int;
    Sin(x: half): half;
    SinCos(x: half): ValueTuple_2<Half, Half>;
    SinCosPi(x: half): ValueTuple_2<Half, Half>;
    Sinh(x: half): half;
    SinPi(x: half): half;
    Sqrt(x: half): half;
    Tan(x: half): half;
    Tanh(x: half): half;
    TanPi(x: half): half;
    Truncate(x: half): half;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, style: NumberStyles, provider: IFormatProvider | undefined, result: half): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, result: half): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined, result: half): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, style: NumberStyles, provider: IFormatProvider | undefined, result: half): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, result: half): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, result: half): boolean;
    TryParse(s: string | undefined, style: NumberStyles, provider: IFormatProvider | undefined, result: half): boolean;
    TryParse(s: string | undefined, result: half): boolean;
    TryParse(s: string | undefined, provider: IFormatProvider | undefined, result: half): boolean;
};


export interface __Half$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<Half>;
    As_IEquatable_1(): IEquatable_1$instance<Half>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<Half>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<Half>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<Half>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<Half, Half>;
    As_IFloatingPoint_1(): System_Numerics_Internal.IFloatingPoint_1$instance<Half>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<Half>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<Half>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<Half>;
    As_IRootFunctions_1(): System_Numerics_Internal.IRootFunctions_1$instance<Half>;
    As_ITrigonometricFunctions_1(): System_Numerics_Internal.ITrigonometricFunctions_1$instance<Half>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Half): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    GetExponentByteCount(): int;
    GetExponentShortestBitLength(): int;
    TryWriteExponentBigEndian(destination: Span_1<Byte>, bytesWritten: int): boolean;
    WriteExponentBigEndian(destination: byte[], startIndex: int): int;
    WriteExponentBigEndian(destination: byte[]): int;
    WriteExponentBigEndian(destination: Span_1<Byte>): int;
}

export interface Half$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<Half> {}

export type Half = number & Half$instance & __Half$views;


export interface HashCode$instance {
    Add<T>(value: T): void;
    Add<T>(value: T, comparer: IEqualityComparer_1<T> | undefined): void;
    AddBytes(value: ReadOnlySpan_1<Byte>): void;
    Equals(obj: unknown | undefined): boolean;
    GetHashCode(): int;
    ToHashCode(): int;
}


export const HashCode: {
    new(): HashCode;
    Combine<T1, T2, T3, T4, T5, T6, T7, T8>(value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7, value8: T8): int;
    Combine<T1, T2, T3, T4, T5, T6, T7>(value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6, value7: T7): int;
    Combine<T1, T2, T3, T4, T5, T6>(value1: T1, value2: T2, value3: T3, value4: T4, value5: T5, value6: T6): int;
    Combine<T1, T2, T3, T4, T5>(value1: T1, value2: T2, value3: T3, value4: T4, value5: T5): int;
    Combine<T1, T2, T3, T4>(value1: T1, value2: T2, value3: T3, value4: T4): int;
    Combine<T1, T2, T3>(value1: T1, value2: T2, value3: T3): int;
    Combine<T1, T2>(value1: T1, value2: T2): int;
    Combine<T1>(value1: T1): int;
};


export type HashCode = HashCode$instance;

export interface Index$instance {
    readonly IsFromEnd: boolean;
    readonly Value: int;
    Equals(value: unknown | undefined): boolean;
    Equals(other: Index): boolean;
    GetHashCode(): int;
    GetOffset(length: int): int;
    ToString(): string;
}


export const Index: {
    new(value: int, fromEnd: boolean): Index;
    readonly Start: Index;
    readonly End: Index;
    FromEnd(value: int): Index;
    FromStart(value: int): Index;
};


export interface __Index$views {
    As_IEquatable_1(): IEquatable_1$instance<Index>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Index): boolean;
}

export type Index = Index$instance & __Index$views;


export interface Int128$instance extends IBitwiseOperators_3<Int128, Int128, Int128>, IComparisonOperators_3<Int128, Int128, Boolean>, IEqualityOperators_3<Int128, Int128, Boolean>, IModulusOperators_3<Int128, Int128, Int128>, IAdditionOperators_3<Int128, Int128, Int128>, IDecrementOperators_1<Int128>, IDivisionOperators_3<Int128, Int128, Int128>, IIncrementOperators_1<Int128>, IMultiplyOperators_3<Int128, Int128, Int128>, ISubtractionOperators_3<Int128, Int128, Int128>, IUnaryPlusOperators_2<Int128, Int128>, IUnaryNegationOperators_2<Int128, Int128>, IShiftOperators_3<Int128, Int32, Int128> {
    CompareTo(value: unknown | undefined): int;
    CompareTo(value: int128): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(other: int128): boolean;
    GetHashCode(): int;
    ToString(): string;
    ToString(provider: IFormatProvider | undefined): string;
    ToString(format: string | undefined): string;
    ToString(format: string | undefined, provider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
}


export const Int128: {
    new(upper: ulong, lower: ulong): Int128;
    readonly MinValue: int128;
    readonly MaxValue: int128;
    readonly One: int128;
    readonly Zero: int128;
    readonly NegativeOne: int128;
    Abs(value: int128): int128;
    BigMul(left: int128, right: int128, lower: int128): int128;
    Clamp(value: int128, min: int128, max: int128): int128;
    CopySign(value: int128, sign: int128): int128;
    CreateChecked<TOther extends INumberBase_1<TOther>>(value: TOther): int128;
    CreateSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): int128;
    CreateTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): int128;
    DivRem(left: int128, right: int128): ValueTuple_2<Int128, Int128>;
    IsEvenInteger(value: int128): boolean;
    IsNegative(value: int128): boolean;
    IsOddInteger(value: int128): boolean;
    IsPositive(value: int128): boolean;
    IsPow2(value: int128): boolean;
    LeadingZeroCount(value: int128): int128;
    Log2(value: int128): int128;
    Max(x: int128, y: int128): int128;
    MaxMagnitude(x: int128, y: int128): int128;
    Min(x: int128, y: int128): int128;
    MinMagnitude(x: int128, y: int128): int128;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, style?: NumberStyles, provider?: IFormatProvider | undefined): int128;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined): int128;
    Parse(s: ReadOnlySpan_1<Char>, style?: NumberStyles, provider?: IFormatProvider | undefined): int128;
    Parse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined): int128;
    Parse(s: string, style: NumberStyles, provider: IFormatProvider | undefined): int128;
    Parse(s: string, style: NumberStyles): int128;
    Parse(s: string, provider: IFormatProvider | undefined): int128;
    Parse(s: string): int128;
    PopCount(value: int128): int128;
    RotateLeft(value: int128, rotateAmount: int): int128;
    RotateRight(value: int128, rotateAmount: int): int128;
    Sign(value: int128): int;
    TrailingZeroCount(value: int128): int128;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, style: NumberStyles, provider: IFormatProvider | undefined, result: int128): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined, result: int128): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, result: int128): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, style: NumberStyles, provider: IFormatProvider | undefined, result: int128): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, result: int128): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, result: int128): boolean;
    TryParse(s: string | undefined, style: NumberStyles, provider: IFormatProvider | undefined, result: int128): boolean;
    TryParse(s: string | undefined, provider: IFormatProvider | undefined, result: int128): boolean;
    TryParse(s: string | undefined, result: int128): boolean;
};


export interface __Int128$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<Int128>;
    As_IEquatable_1(): IEquatable_1$instance<Int128>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<Int128>;
    As_ISpanParsable_1(): ISpanParsable_1$instance<Int128>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<Int128>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<Int128, Int128>;
    As_IBinaryInteger_1(): System_Numerics_Internal.IBinaryInteger_1$instance<Int128>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<Int128>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<Int128>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<Int128>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Int128): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: Span_1<Byte>, bytesWritten: int): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<Byte>): int;
}

export interface Int128$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<Int128> {}

export type Int128 = number & Int128$instance & __Int128$views;


export interface Int16$instance extends IBitwiseOperators_3<Int16, Int16, Int16>, IComparisonOperators_3<Int16, Int16, Boolean>, IEqualityOperators_3<Int16, Int16, Boolean>, IModulusOperators_3<Int16, Int16, Int16>, IAdditionOperators_3<Int16, Int16, Int16>, IDecrementOperators_1<Int16>, IDivisionOperators_3<Int16, Int16, Int16>, IIncrementOperators_1<Int16>, IMultiplyOperators_3<Int16, Int16, Int16>, ISubtractionOperators_3<Int16, Int16, Int16>, IUnaryPlusOperators_2<Int16, Int16>, IUnaryNegationOperators_2<Int16, Int16>, IShiftOperators_3<Int16, Int32, Int16> {
    CompareTo(value: unknown | undefined): int;
    CompareTo(value: short): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(obj: short): boolean;
    GetHashCode(): int;
    GetTypeCode(): TypeCode;
    ToString(): string;
    ToString(provider: IFormatProvider | undefined): string;
    ToString(format: string | undefined): string;
    ToString(format: string | undefined, provider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
}


export const Int16: {
    new(): Int16;
    readonly MaxValue: short;
    readonly MinValue: short;
    Abs(value: short): short;
    Clamp(value: short, min: short, max: short): short;
    CopySign(value: short, sign: short): short;
    CreateChecked<TOther extends INumberBase_1<TOther>>(value: TOther): short;
    CreateSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): short;
    CreateTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): short;
    DivRem(left: short, right: short): ValueTuple_2<Int16, Int16>;
    IsEvenInteger(value: short): boolean;
    IsNegative(value: short): boolean;
    IsOddInteger(value: short): boolean;
    IsPositive(value: short): boolean;
    IsPow2(value: short): boolean;
    LeadingZeroCount(value: short): short;
    Log2(value: short): short;
    Max(x: short, y: short): short;
    MaxMagnitude(x: short, y: short): short;
    Min(x: short, y: short): short;
    MinMagnitude(x: short, y: short): short;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, style?: NumberStyles, provider?: IFormatProvider | undefined): short;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined): short;
    Parse(s: ReadOnlySpan_1<Char>, style?: NumberStyles, provider?: IFormatProvider | undefined): short;
    Parse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined): short;
    Parse(s: string, style: NumberStyles, provider: IFormatProvider | undefined): short;
    Parse(s: string, style: NumberStyles): short;
    Parse(s: string, provider: IFormatProvider | undefined): short;
    Parse(s: string): short;
    PopCount(value: short): short;
    RotateLeft(value: short, rotateAmount: int): short;
    RotateRight(value: short, rotateAmount: int): short;
    Sign(value: short): int;
    TrailingZeroCount(value: short): short;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, style: NumberStyles, provider: IFormatProvider | undefined, result: short): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined, result: short): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, result: short): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, style: NumberStyles, provider: IFormatProvider | undefined, result: short): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, result: short): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, result: short): boolean;
    TryParse(s: string | undefined, style: NumberStyles, provider: IFormatProvider | undefined, result: short): boolean;
    TryParse(s: string | undefined, provider: IFormatProvider | undefined, result: short): boolean;
    TryParse(s: string | undefined, result: short): boolean;
};


export interface __Int16$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<Int16>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<Int16>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<Int16>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<Int16>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<Int16>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<Int16, Int16>;
    As_IBinaryInteger_1(): System_Numerics_Internal.IBinaryInteger_1$instance<Int16>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<Int16>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<Int16>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<Int16>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Int16): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: Span_1<Byte>, bytesWritten: int): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<Byte>): int;
}

export interface Int16$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<Int16> {}

export type Int16 = number & Int16$instance & __Int16$views;


export interface Int32$instance extends IBitwiseOperators_3<Int32, Int32, Int32>, IComparisonOperators_3<Int32, Int32, Boolean>, IEqualityOperators_3<Int32, Int32, Boolean>, IModulusOperators_3<Int32, Int32, Int32>, IAdditionOperators_3<Int32, Int32, Int32>, IDecrementOperators_1<Int32>, IDivisionOperators_3<Int32, Int32, Int32>, IIncrementOperators_1<Int32>, IMultiplyOperators_3<Int32, Int32, Int32>, ISubtractionOperators_3<Int32, Int32, Int32>, IUnaryPlusOperators_2<Int32, Int32>, IUnaryNegationOperators_2<Int32, Int32>, IShiftOperators_3<Int32, Int32, Int32> {
    CompareTo(value: unknown | undefined): int;
    CompareTo(value: int): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(obj: int): boolean;
    GetHashCode(): int;
    GetTypeCode(): TypeCode;
    ToString(): string;
    ToString(format: string | undefined): string;
    ToString(provider: IFormatProvider | undefined): string;
    ToString(format: string | undefined, provider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
}


export const Int32: {
    new(): Int32;
    readonly MaxValue: int;
    readonly MinValue: int;
    Abs(value: int): int;
    BigMul(left: int, right: int): long;
    Clamp(value: int, min: int, max: int): int;
    CopySign(value: int, sign: int): int;
    CreateChecked<TOther extends INumberBase_1<TOther>>(value: TOther): int;
    CreateSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): int;
    CreateTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): int;
    DivRem(left: int, right: int): ValueTuple_2<Int32, Int32>;
    IsEvenInteger(value: int): boolean;
    IsNegative(value: int): boolean;
    IsOddInteger(value: int): boolean;
    IsPositive(value: int): boolean;
    IsPow2(value: int): boolean;
    LeadingZeroCount(value: int): int;
    Log2(value: int): int;
    Max(x: int, y: int): int;
    MaxMagnitude(x: int, y: int): int;
    Min(x: int, y: int): int;
    MinMagnitude(x: int, y: int): int;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, style?: NumberStyles, provider?: IFormatProvider | undefined): int;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined): int;
    Parse(s: ReadOnlySpan_1<Char>, style?: NumberStyles, provider?: IFormatProvider | undefined): int;
    Parse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined): int;
    Parse(s: string, style: NumberStyles, provider: IFormatProvider | undefined): int;
    Parse(s: string, style: NumberStyles): int;
    Parse(s: string, provider: IFormatProvider | undefined): int;
    Parse(s: string): int;
    PopCount(value: int): int;
    RotateLeft(value: int, rotateAmount: int): int;
    RotateRight(value: int, rotateAmount: int): int;
    Sign(value: int): int;
    TrailingZeroCount(value: int): int;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, style: NumberStyles, provider: IFormatProvider | undefined, result: int): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined, result: int): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, result: int): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, style: NumberStyles, provider: IFormatProvider | undefined, result: int): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, result: int): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, result: int): boolean;
    TryParse(s: string | undefined, style: NumberStyles, provider: IFormatProvider | undefined, result: int): boolean;
    TryParse(s: string | undefined, provider: IFormatProvider | undefined, result: int): boolean;
    TryParse(s: string | undefined, result: int): boolean;
};


export interface __Int32$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<Int32>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<Int32>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<Int32>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<Int32>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<Int32>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<Int32, Int32>;
    As_IBinaryInteger_1(): System_Numerics_Internal.IBinaryInteger_1$instance<Int32>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<Int32>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<Int32>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<Int32>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Int32): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: Span_1<Byte>, bytesWritten: int): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<Byte>): int;
}

export interface Int32$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<Int32> {}

export type Int32 = number & Int32$instance & __Int32$views;


export interface Int64$instance extends IBitwiseOperators_3<Int64, Int64, Int64>, IComparisonOperators_3<Int64, Int64, Boolean>, IEqualityOperators_3<Int64, Int64, Boolean>, IModulusOperators_3<Int64, Int64, Int64>, IAdditionOperators_3<Int64, Int64, Int64>, IDecrementOperators_1<Int64>, IDivisionOperators_3<Int64, Int64, Int64>, IIncrementOperators_1<Int64>, IMultiplyOperators_3<Int64, Int64, Int64>, ISubtractionOperators_3<Int64, Int64, Int64>, IUnaryPlusOperators_2<Int64, Int64>, IUnaryNegationOperators_2<Int64, Int64>, IShiftOperators_3<Int64, Int32, Int64> {
    CompareTo(value: unknown | undefined): int;
    CompareTo(value: long): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(obj: long): boolean;
    GetHashCode(): int;
    GetTypeCode(): TypeCode;
    ToString(): string;
    ToString(provider: IFormatProvider | undefined): string;
    ToString(format: string | undefined): string;
    ToString(format: string | undefined, provider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
}


export const Int64: {
    new(): Int64;
    readonly MaxValue: long;
    readonly MinValue: long;
    Abs(value: long): long;
    BigMul(left: long, right: long): int128;
    Clamp(value: long, min: long, max: long): long;
    CopySign(value: long, sign: long): long;
    CreateChecked<TOther extends INumberBase_1<TOther>>(value: TOther): long;
    CreateSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): long;
    CreateTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): long;
    DivRem(left: long, right: long): ValueTuple_2<Int64, Int64>;
    IsEvenInteger(value: long): boolean;
    IsNegative(value: long): boolean;
    IsOddInteger(value: long): boolean;
    IsPositive(value: long): boolean;
    IsPow2(value: long): boolean;
    LeadingZeroCount(value: long): long;
    Log2(value: long): long;
    Max(x: long, y: long): long;
    MaxMagnitude(x: long, y: long): long;
    Min(x: long, y: long): long;
    MinMagnitude(x: long, y: long): long;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, style?: NumberStyles, provider?: IFormatProvider | undefined): long;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined): long;
    Parse(s: ReadOnlySpan_1<Char>, style?: NumberStyles, provider?: IFormatProvider | undefined): long;
    Parse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined): long;
    Parse(s: string, style: NumberStyles, provider: IFormatProvider | undefined): long;
    Parse(s: string, style: NumberStyles): long;
    Parse(s: string, provider: IFormatProvider | undefined): long;
    Parse(s: string): long;
    PopCount(value: long): long;
    RotateLeft(value: long, rotateAmount: int): long;
    RotateRight(value: long, rotateAmount: int): long;
    Sign(value: long): int;
    TrailingZeroCount(value: long): long;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, style: NumberStyles, provider: IFormatProvider | undefined, result: long): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined, result: long): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, result: long): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, style: NumberStyles, provider: IFormatProvider | undefined, result: long): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, result: long): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, result: long): boolean;
    TryParse(s: string | undefined, style: NumberStyles, provider: IFormatProvider | undefined, result: long): boolean;
    TryParse(s: string | undefined, provider: IFormatProvider | undefined, result: long): boolean;
    TryParse(s: string | undefined, result: long): boolean;
};


export interface __Int64$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<Int64>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<Int64>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<Int64>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<Int64>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<Int64>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<Int64, Int64>;
    As_IBinaryInteger_1(): System_Numerics_Internal.IBinaryInteger_1$instance<Int64>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<Int64>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<Int64>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<Int64>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Int64): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: Span_1<Byte>, bytesWritten: int): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<Byte>): int;
}

export interface Int64$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<Int64> {}

export type Int64 = number & Int64$instance & __Int64$views;


export interface IntPtr$instance extends IBitwiseOperators_3<IntPtr, IntPtr, IntPtr>, IComparisonOperators_3<IntPtr, IntPtr, Boolean>, IEqualityOperators_3<IntPtr, IntPtr, Boolean>, IModulusOperators_3<IntPtr, IntPtr, IntPtr>, IAdditionOperators_3<IntPtr, IntPtr, IntPtr>, IDecrementOperators_1<IntPtr>, IDivisionOperators_3<IntPtr, IntPtr, IntPtr>, IIncrementOperators_1<IntPtr>, IMultiplyOperators_3<IntPtr, IntPtr, IntPtr>, ISubtractionOperators_3<IntPtr, IntPtr, IntPtr>, IUnaryPlusOperators_2<IntPtr, IntPtr>, IUnaryNegationOperators_2<IntPtr, IntPtr>, IShiftOperators_3<IntPtr, Int32, IntPtr> {
    CompareTo(value: unknown | undefined): int;
    CompareTo(value: nint): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(other: nint): boolean;
    GetHashCode(): int;
    ToInt32(): int;
    ToInt64(): long;
    ToPointer(): ptr<void>;
    ToString(): string;
    ToString(format: string | undefined): string;
    ToString(provider: IFormatProvider | undefined): string;
    ToString(format: string | undefined, provider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
}


export const IntPtr: {
    new(value: int): IntPtr;
    new(value: long): IntPtr;
    new(value: ptr<void>): IntPtr;
    readonly Zero: nint;
    readonly Size: int;
    readonly MaxValue: nint;
    readonly MinValue: nint;
    Abs(value: nint): nint;
    Add(pointer: nint, offset: int): nint;
    BigMul(left: nint, right: nint, lower: nint): nint;
    Clamp(value: nint, min: nint, max: nint): nint;
    CopySign(value: nint, sign: nint): nint;
    CreateChecked<TOther extends INumberBase_1<TOther>>(value: TOther): nint;
    CreateSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): nint;
    CreateTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): nint;
    DivRem(left: nint, right: nint): ValueTuple_2<IntPtr, IntPtr>;
    IsEvenInteger(value: nint): boolean;
    IsNegative(value: nint): boolean;
    IsOddInteger(value: nint): boolean;
    IsPositive(value: nint): boolean;
    IsPow2(value: nint): boolean;
    LeadingZeroCount(value: nint): nint;
    Log2(value: nint): nint;
    Max(x: nint, y: nint): nint;
    MaxMagnitude(x: nint, y: nint): nint;
    Min(x: nint, y: nint): nint;
    MinMagnitude(x: nint, y: nint): nint;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, style?: NumberStyles, provider?: IFormatProvider | undefined): nint;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined): nint;
    Parse(s: ReadOnlySpan_1<Char>, style?: NumberStyles, provider?: IFormatProvider | undefined): nint;
    Parse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined): nint;
    Parse(s: string, style: NumberStyles, provider: IFormatProvider | undefined): nint;
    Parse(s: string, style: NumberStyles): nint;
    Parse(s: string, provider: IFormatProvider | undefined): nint;
    Parse(s: string): nint;
    PopCount(value: nint): nint;
    RotateLeft(value: nint, rotateAmount: int): nint;
    RotateRight(value: nint, rotateAmount: int): nint;
    Sign(value: nint): int;
    Subtract(pointer: nint, offset: int): nint;
    TrailingZeroCount(value: nint): nint;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, style: NumberStyles, provider: IFormatProvider | undefined, result: nint): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined, result: nint): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, result: nint): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, style: NumberStyles, provider: IFormatProvider | undefined, result: nint): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, result: nint): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, result: nint): boolean;
    TryParse(s: string | undefined, style: NumberStyles, provider: IFormatProvider | undefined, result: nint): boolean;
    TryParse(s: string | undefined, provider: IFormatProvider | undefined, result: nint): boolean;
    TryParse(s: string | undefined, result: nint): boolean;
};


export interface __IntPtr$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<IntPtr>;
    As_IEquatable_1(): IEquatable_1$instance<IntPtr>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<IntPtr>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<IntPtr>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<IntPtr>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<IntPtr, IntPtr>;
    As_IBinaryInteger_1(): System_Numerics_Internal.IBinaryInteger_1$instance<IntPtr>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<IntPtr>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<IntPtr>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<IntPtr>;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: IntPtr): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: Span_1<Byte>, bytesWritten: int): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<Byte>): int;
}

export interface IntPtr$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<IntPtr>, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type IntPtr = number & IntPtr$instance & __IntPtr$views;


export interface Memory_1$instance<T> {
    readonly IsEmpty: boolean;
    readonly Length: int;
    readonly Span: Span_1<T>;
    CopyTo(destination: Memory_1<T>): void;
    Equals(obj: unknown | undefined): boolean;
    Equals(other: Memory_1<T>): boolean;
    GetHashCode(): int;
    Pin(): MemoryHandle;
    Slice(start: int): Memory_1<T>;
    Slice(start: int, length: int): Memory_1<T>;
    ToArray(): T[];
    ToString(): string;
    TryCopyTo(destination: Memory_1<T>): boolean;
}


export const Memory_1: {
    new<T>(array: T[] | undefined): Memory_1<T>;
    new<T>(array: T[] | undefined, start: int, length: int): Memory_1<T>;
    readonly Empty: unknown;
};


export interface __Memory_1$views<T> {
    As_IEquatable_1(): IEquatable_1$instance<Memory_1<T>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Memory_1<T>): boolean;
}

export type Memory_1<T> = Memory_1$instance<T> & __Memory_1$views<T>;


export interface MemoryExtensions_SpanSplitEnumerator_1$instance<T extends (IEquatable_1<T> | number | string | boolean)> {
    readonly Current: Range;
    readonly Source: ReadOnlySpan_1<T>;
    GetEnumerator(): MemoryExtensions_SpanSplitEnumerator_1<T>;
    MoveNext(): boolean;
    Reset(): void;
}


export const MemoryExtensions_SpanSplitEnumerator_1: {
    new<T extends (IEquatable_1<T> | number | string | boolean)>(): MemoryExtensions_SpanSplitEnumerator_1<T>;
};


export interface __MemoryExtensions_SpanSplitEnumerator_1$views<T extends (IEquatable_1<T> | number | string | boolean)> {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<Range>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDisposable(): IDisposable$instance;
}

export type MemoryExtensions_SpanSplitEnumerator_1<T extends (IEquatable_1<T> | number | string | boolean)> = MemoryExtensions_SpanSplitEnumerator_1$instance<T> & __MemoryExtensions_SpanSplitEnumerator_1$views<T>;


export interface MemoryExtensions_TryWriteInterpolatedStringHandler$instance {
    AppendFormatted<T>(value: T): boolean;
    AppendFormatted<T>(value: T, format: string | undefined): boolean;
    AppendFormatted<T>(value: T, alignment: int): boolean;
    AppendFormatted<T>(value: T, alignment: int, format: string | undefined): boolean;
    AppendFormatted(value: ReadOnlySpan_1<Char>): boolean;
    AppendFormatted(value: ReadOnlySpan_1<Char>, alignment?: int, format?: string | undefined): boolean;
    AppendFormatted(value: string | undefined): boolean;
    AppendFormatted(value: string | undefined, alignment?: int, format?: string | undefined): boolean;
    AppendFormatted(value: unknown | undefined, alignment?: int, format?: string | undefined): boolean;
    AppendLiteral(value: string): boolean;
}


export const MemoryExtensions_TryWriteInterpolatedStringHandler: {
    new(literalLength: int, formattedCount: int, destination: Span_1<Char>, shouldAppend: boolean): MemoryExtensions_TryWriteInterpolatedStringHandler;
    new(literalLength: int, formattedCount: int, destination: Span_1<Char>, provider: IFormatProvider | undefined, shouldAppend: boolean): MemoryExtensions_TryWriteInterpolatedStringHandler;
};


export type MemoryExtensions_TryWriteInterpolatedStringHandler = MemoryExtensions_TryWriteInterpolatedStringHandler$instance;

export interface ModuleHandle$instance {
    readonly MDStreamVersion: int;
    Equals(obj: unknown | undefined): boolean;
    Equals(handle: ModuleHandle): boolean;
    GetHashCode(): int;
    GetRuntimeFieldHandleFromMetadataToken(fieldToken: int): RuntimeFieldHandle;
    GetRuntimeMethodHandleFromMetadataToken(methodToken: int): RuntimeMethodHandle;
    GetRuntimeTypeHandleFromMetadataToken(typeToken: int): RuntimeTypeHandle;
    ResolveFieldHandle(fieldToken: int): RuntimeFieldHandle;
    ResolveFieldHandle(fieldToken: int, typeInstantiationContext: RuntimeTypeHandle[] | undefined, methodInstantiationContext: RuntimeTypeHandle[] | undefined): RuntimeFieldHandle;
    ResolveMethodHandle(methodToken: int): RuntimeMethodHandle;
    ResolveMethodHandle(methodToken: int, typeInstantiationContext: RuntimeTypeHandle[] | undefined, methodInstantiationContext: RuntimeTypeHandle[] | undefined): RuntimeMethodHandle;
    ResolveTypeHandle(typeToken: int): RuntimeTypeHandle;
    ResolveTypeHandle(typeToken: int, typeInstantiationContext: RuntimeTypeHandle[] | undefined, methodInstantiationContext: RuntimeTypeHandle[] | undefined): RuntimeTypeHandle;
}


export const ModuleHandle: {
    new(): ModuleHandle;
    readonly EmptyHandle: ModuleHandle;
};


export interface __ModuleHandle$views {
    As_IEquatable_1(): IEquatable_1$instance<ModuleHandle>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ModuleHandle): boolean;
}

export type ModuleHandle = ModuleHandle$instance & __ModuleHandle$views;


export interface Nullable_1$instance<T extends unknown> {
    readonly HasValue: boolean;
    readonly Value: T;
    Equals(other: unknown | undefined): boolean;
    GetHashCode(): int;
    GetValueOrDefault(): T;
    GetValueOrDefault(defaultValue: T): T;
    ToString(): string | undefined;
}


export const Nullable_1: {
    new<T extends unknown>(value: T): Nullable_1<T>;
};


export type Nullable_1<T> = Nullable_1$instance<T>;

export interface Range$instance {
    readonly End: Index;
    readonly Start: Index;
    Equals(value: unknown | undefined): boolean;
    Equals(other: Range): boolean;
    GetHashCode(): int;
    GetOffsetAndLength(length: int): ValueTuple_2<Int32, Int32>;
    ToString(): string;
}


export const Range: {
    new(start: Index, end: Index): Range;
    readonly All: Range;
    EndAt(end: Index): Range;
    StartAt(start: Index): Range;
};


export interface __Range$views {
    As_IEquatable_1(): IEquatable_1$instance<Range>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Range): boolean;
}

export type Range = Range$instance & __Range$views;


export interface ReadOnlyMemory_1$instance<T> {
    readonly IsEmpty: boolean;
    readonly Length: int;
    readonly Span: ReadOnlySpan_1<T>;
    CopyTo(destination: Memory_1<T>): void;
    Equals(obj: unknown | undefined): boolean;
    Equals(other: ReadOnlyMemory_1<T>): boolean;
    GetHashCode(): int;
    Pin(): MemoryHandle;
    Slice(start: int): ReadOnlyMemory_1<T>;
    Slice(start: int, length: int): ReadOnlyMemory_1<T>;
    ToArray(): T[];
    ToString(): string;
    TryCopyTo(destination: Memory_1<T>): boolean;
}


export const ReadOnlyMemory_1: {
    new<T>(array: T[] | undefined): ReadOnlyMemory_1<T>;
    new<T>(array: T[] | undefined, start: int, length: int): ReadOnlyMemory_1<T>;
    readonly Empty: unknown;
};


export interface __ReadOnlyMemory_1$views<T> {
    As_IEquatable_1(): IEquatable_1$instance<ReadOnlyMemory_1<T>>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ReadOnlyMemory_1<T>): boolean;
}

export type ReadOnlyMemory_1<T> = ReadOnlyMemory_1$instance<T> & __ReadOnlyMemory_1$views<T>;


export interface ReadOnlySpan_1$instance<T> {
    readonly IsEmpty: boolean;
    readonly Item: T;
    readonly Length: int;
    CopyTo(destination: Span_1<T>): void;
    Equals(obj: unknown | undefined): boolean;
    GetEnumerator(): ReadOnlySpan_1_Enumerator<T>;
    GetHashCode(): int;
    GetPinnableReference(): T;
    Slice(start: int): ReadOnlySpan_1<T>;
    Slice(start: int, length: int): ReadOnlySpan_1<T>;
    ToArray(): T[];
    ToString(): string;
    TryCopyTo(destination: Span_1<T>): boolean;
}


export const ReadOnlySpan_1: {
    new<T>(array: T[] | undefined): ReadOnlySpan_1<T>;
    new<T>(array: T[] | undefined, start: int, length: int): ReadOnlySpan_1<T>;
    new<T>(pointer: ptr<void>, length: int): ReadOnlySpan_1<T>;
    new<T>(reference: T): ReadOnlySpan_1<T>;
    readonly Empty: unknown;
    CastUp<T, TDerived extends T>(items: ReadOnlySpan_1<TDerived>): ReadOnlySpan_1<T>;
};


export type ReadOnlySpan_1<T> = ReadOnlySpan_1$instance<T>;

export interface ReadOnlySpan_1_Enumerator$instance<T> {
    readonly Current: T;
    MoveNext(): boolean;
    Reset(): void;
}


export const ReadOnlySpan_1_Enumerator: {
    new<T>(): ReadOnlySpan_1_Enumerator<T>;
};


export interface __ReadOnlySpan_1_Enumerator$views<T> {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<T>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDisposable(): IDisposable$instance;
}

export type ReadOnlySpan_1_Enumerator<T> = ReadOnlySpan_1_Enumerator$instance<T> & __ReadOnlySpan_1_Enumerator$views<T>;


export interface RuntimeArgumentHandle$instance {
}


export const RuntimeArgumentHandle: {
    new(): RuntimeArgumentHandle;
};


export type RuntimeArgumentHandle = RuntimeArgumentHandle$instance;

export interface RuntimeFieldHandle$instance {
    readonly Value: nint;
    Equals(obj: unknown | undefined): boolean;
    Equals(handle: RuntimeFieldHandle): boolean;
    GetHashCode(): int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const RuntimeFieldHandle: {
    new(): RuntimeFieldHandle;
    FromIntPtr(value: nint): RuntimeFieldHandle;
    ToIntPtr(value: RuntimeFieldHandle): nint;
};


export interface __RuntimeFieldHandle$views {
    As_IEquatable_1(): IEquatable_1$instance<RuntimeFieldHandle>;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: RuntimeFieldHandle): boolean;
}

export interface RuntimeFieldHandle$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type RuntimeFieldHandle = RuntimeFieldHandle$instance & __RuntimeFieldHandle$views;


export interface RuntimeMethodHandle$instance {
    readonly Value: nint;
    Equals(obj: unknown | undefined): boolean;
    Equals(handle: RuntimeMethodHandle): boolean;
    GetFunctionPointer(): nint;
    GetHashCode(): int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const RuntimeMethodHandle: {
    new(): RuntimeMethodHandle;
    FromIntPtr(value: nint): RuntimeMethodHandle;
    ToIntPtr(value: RuntimeMethodHandle): nint;
};


export interface __RuntimeMethodHandle$views {
    As_IEquatable_1(): IEquatable_1$instance<RuntimeMethodHandle>;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: RuntimeMethodHandle): boolean;
}

export interface RuntimeMethodHandle$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type RuntimeMethodHandle = RuntimeMethodHandle$instance & __RuntimeMethodHandle$views;


export interface RuntimeTypeHandle$instance {
    readonly Value: nint;
    Equals(obj: unknown | undefined): boolean;
    Equals(handle: RuntimeTypeHandle): boolean;
    GetHashCode(): int;
    GetModuleHandle(): ModuleHandle;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const RuntimeTypeHandle: {
    new(): RuntimeTypeHandle;
    FromIntPtr(value: nint): RuntimeTypeHandle;
    ToIntPtr(value: RuntimeTypeHandle): nint;
};


export interface __RuntimeTypeHandle$views {
    As_IEquatable_1(): IEquatable_1$instance<RuntimeTypeHandle>;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: RuntimeTypeHandle): boolean;
}

export interface RuntimeTypeHandle$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type RuntimeTypeHandle = RuntimeTypeHandle$instance & __RuntimeTypeHandle$views;


export interface SByte$instance extends IBitwiseOperators_3<SByte, SByte, SByte>, IComparisonOperators_3<SByte, SByte, Boolean>, IEqualityOperators_3<SByte, SByte, Boolean>, IModulusOperators_3<SByte, SByte, SByte>, IAdditionOperators_3<SByte, SByte, SByte>, IDecrementOperators_1<SByte>, IDivisionOperators_3<SByte, SByte, SByte>, IIncrementOperators_1<SByte>, IMultiplyOperators_3<SByte, SByte, SByte>, ISubtractionOperators_3<SByte, SByte, SByte>, IUnaryPlusOperators_2<SByte, SByte>, IUnaryNegationOperators_2<SByte, SByte>, IShiftOperators_3<SByte, Int32, SByte> {
    CompareTo(obj: unknown | undefined): int;
    CompareTo(value: sbyte): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(obj: sbyte): boolean;
    GetHashCode(): int;
    GetTypeCode(): TypeCode;
    ToString(): string;
    ToString(format: string | undefined): string;
    ToString(provider: IFormatProvider | undefined): string;
    ToString(format: string | undefined, provider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
}


export const SByte: {
    new(): SByte;
    readonly MaxValue: sbyte;
    readonly MinValue: sbyte;
    Abs(value: sbyte): sbyte;
    Clamp(value: sbyte, min: sbyte, max: sbyte): sbyte;
    CopySign(value: sbyte, sign: sbyte): sbyte;
    CreateChecked<TOther extends INumberBase_1<TOther>>(value: TOther): sbyte;
    CreateSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): sbyte;
    CreateTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): sbyte;
    DivRem(left: sbyte, right: sbyte): ValueTuple_2<SByte, SByte>;
    IsEvenInteger(value: sbyte): boolean;
    IsNegative(value: sbyte): boolean;
    IsOddInteger(value: sbyte): boolean;
    IsPositive(value: sbyte): boolean;
    IsPow2(value: sbyte): boolean;
    LeadingZeroCount(value: sbyte): sbyte;
    Log2(value: sbyte): sbyte;
    Max(x: sbyte, y: sbyte): sbyte;
    MaxMagnitude(x: sbyte, y: sbyte): sbyte;
    Min(x: sbyte, y: sbyte): sbyte;
    MinMagnitude(x: sbyte, y: sbyte): sbyte;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, style?: NumberStyles, provider?: IFormatProvider | undefined): sbyte;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined): sbyte;
    Parse(s: ReadOnlySpan_1<Char>, style?: NumberStyles, provider?: IFormatProvider | undefined): sbyte;
    Parse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined): sbyte;
    Parse(s: string, style: NumberStyles, provider: IFormatProvider | undefined): sbyte;
    Parse(s: string, style: NumberStyles): sbyte;
    Parse(s: string, provider: IFormatProvider | undefined): sbyte;
    Parse(s: string): sbyte;
    PopCount(value: sbyte): sbyte;
    RotateLeft(value: sbyte, rotateAmount: int): sbyte;
    RotateRight(value: sbyte, rotateAmount: int): sbyte;
    Sign(value: sbyte): int;
    TrailingZeroCount(value: sbyte): sbyte;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, style: NumberStyles, provider: IFormatProvider | undefined, result: sbyte): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined, result: sbyte): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, result: sbyte): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, style: NumberStyles, provider: IFormatProvider | undefined, result: sbyte): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, result: sbyte): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, result: sbyte): boolean;
    TryParse(s: string | undefined, style: NumberStyles, provider: IFormatProvider | undefined, result: sbyte): boolean;
    TryParse(s: string | undefined, provider: IFormatProvider | undefined, result: sbyte): boolean;
    TryParse(s: string | undefined, result: sbyte): boolean;
};


export interface __SByte$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<SByte>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<SByte>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<SByte>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<SByte>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<SByte>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<SByte, SByte>;
    As_IBinaryInteger_1(): System_Numerics_Internal.IBinaryInteger_1$instance<SByte>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<SByte>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<SByte>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<SByte>;

    // Structural method bridges for numeric interface constraints
    Equals(other: SByte): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: Span_1<Byte>, bytesWritten: int): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<Byte>): int;
}

export interface SByte$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<SByte> {}

export type SByte = number & SByte$instance & __SByte$views;


export interface SequencePosition$instance {
    Equals(other: SequencePosition): boolean;
    Equals(obj: unknown | undefined): boolean;
    GetHashCode(): int;
    GetInteger(): int;
    GetObject(): unknown | undefined;
}


export const SequencePosition: {
    new(object_: unknown | undefined, integer: int): SequencePosition;
};


export interface __SequencePosition$views {
    As_IEquatable_1(): IEquatable_1$instance<SequencePosition>;

    // Structural method bridges for numeric interface constraints
    Equals(other: SequencePosition): boolean;
}

export type SequencePosition = SequencePosition$instance & __SequencePosition$views;


export interface Single$instance extends IBitwiseOperators_3<Single, Single, Single>, IComparisonOperators_3<Single, Single, Boolean>, IEqualityOperators_3<Single, Single, Boolean>, IModulusOperators_3<Single, Single, Single>, IAdditionOperators_3<Single, Single, Single>, IDecrementOperators_1<Single>, IDivisionOperators_3<Single, Single, Single>, IIncrementOperators_1<Single>, IMultiplyOperators_3<Single, Single, Single>, ISubtractionOperators_3<Single, Single, Single>, IUnaryPlusOperators_2<Single, Single>, IUnaryNegationOperators_2<Single, Single> {
    CompareTo(value: unknown | undefined): int;
    CompareTo(value: float): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(obj: float): boolean;
    GetHashCode(): int;
    GetTypeCode(): TypeCode;
    ToString(): string;
    ToString(provider: IFormatProvider | undefined): string;
    ToString(format: string | undefined): string;
    ToString(format: string | undefined, provider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
}


export const Single: {
    new(): Single;
    readonly MinValue: float;
    readonly MaxValue: float;
    readonly Epsilon: float;
    readonly NegativeInfinity: float;
    readonly PositiveInfinity: float;
    readonly NaN: float;
    readonly NegativeZero: float;
    readonly E: float;
    readonly Pi: float;
    readonly Tau: float;
    Abs(value: float): float;
    Acos(x: float): float;
    Acosh(x: float): float;
    AcosPi(x: float): float;
    Asin(x: float): float;
    Asinh(x: float): float;
    AsinPi(x: float): float;
    Atan(x: float): float;
    Atan2(y: float, x: float): float;
    Atan2Pi(y: float, x: float): float;
    Atanh(x: float): float;
    AtanPi(x: float): float;
    BitDecrement(x: float): float;
    BitIncrement(x: float): float;
    Cbrt(x: float): float;
    Ceiling(x: float): float;
    Clamp(value: float, min: float, max: float): float;
    ClampNative(value: float, min: float, max: float): float;
    ConvertToInteger<TInteger extends IBinaryInteger_1<TInteger>>(value: float): TInteger;
    ConvertToIntegerNative<TInteger extends IBinaryInteger_1<TInteger>>(value: float): TInteger;
    CopySign(value: float, sign: float): float;
    Cos(x: float): float;
    Cosh(x: float): float;
    CosPi(x: float): float;
    CreateChecked<TOther extends INumberBase_1<TOther>>(value: TOther): float;
    CreateSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): float;
    CreateTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): float;
    DegreesToRadians(degrees: float): float;
    Exp(x: float): float;
    Exp10(x: float): float;
    Exp10M1(x: float): float;
    Exp2(x: float): float;
    Exp2M1(x: float): float;
    ExpM1(x: float): float;
    Floor(x: float): float;
    FusedMultiplyAdd(left: float, right: float, addend: float): float;
    Hypot(x: float, y: float): float;
    Ieee754Remainder(left: float, right: float): float;
    ILogB(x: float): int;
    IsEvenInteger(value: float): boolean;
    IsFinite(f: float): boolean;
    IsInfinity(f: float): boolean;
    IsInteger(value: float): boolean;
    IsNaN(f: float): boolean;
    IsNegative(f: float): boolean;
    IsNegativeInfinity(f: float): boolean;
    IsNormal(f: float): boolean;
    IsOddInteger(value: float): boolean;
    IsPositive(value: float): boolean;
    IsPositiveInfinity(f: float): boolean;
    IsPow2(value: float): boolean;
    IsRealNumber(value: float): boolean;
    IsSubnormal(f: float): boolean;
    Lerp(value1: float, value2: float, amount: float): float;
    Log(x: float, newBase: float): float;
    Log(x: float): float;
    Log10(x: float): float;
    Log10P1(x: float): float;
    Log2(value: float): float;
    Log2P1(x: float): float;
    LogP1(x: float): float;
    Max(x: float, y: float): float;
    MaxMagnitude(x: float, y: float): float;
    MaxMagnitudeNumber(x: float, y: float): float;
    MaxNative(x: float, y: float): float;
    MaxNumber(x: float, y: float): float;
    Min(x: float, y: float): float;
    MinMagnitude(x: float, y: float): float;
    MinMagnitudeNumber(x: float, y: float): float;
    MinNative(x: float, y: float): float;
    MinNumber(x: float, y: float): float;
    MultiplyAddEstimate(left: float, right: float, addend: float): float;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, style?: NumberStyles, provider?: IFormatProvider | undefined): float;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined): float;
    Parse(s: ReadOnlySpan_1<Char>, style?: NumberStyles, provider?: IFormatProvider | undefined): float;
    Parse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined): float;
    Parse(s: string, style: NumberStyles, provider: IFormatProvider | undefined): float;
    Parse(s: string, style: NumberStyles): float;
    Parse(s: string, provider: IFormatProvider | undefined): float;
    Parse(s: string): float;
    Pow(x: float, y: float): float;
    RadiansToDegrees(radians: float): float;
    ReciprocalEstimate(x: float): float;
    ReciprocalSqrtEstimate(x: float): float;
    RootN(x: float, n: int): float;
    Round(x: float, digits: int, mode: MidpointRounding): float;
    Round(x: float, digits: int): float;
    Round(x: float, mode: MidpointRounding): float;
    Round(x: float): float;
    ScaleB(x: float, n: int): float;
    Sign(value: float): int;
    Sin(x: float): float;
    SinCos(x: float): ValueTuple_2<Single, Single>;
    SinCosPi(x: float): ValueTuple_2<Single, Single>;
    Sinh(x: float): float;
    SinPi(x: float): float;
    Sqrt(x: float): float;
    Tan(x: float): float;
    Tanh(x: float): float;
    TanPi(x: float): float;
    Truncate(x: float): float;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, style: NumberStyles, provider: IFormatProvider | undefined, result: float): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined, result: float): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, result: float): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, style: NumberStyles, provider: IFormatProvider | undefined, result: float): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, result: float): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, result: float): boolean;
    TryParse(s: string | undefined, style: NumberStyles, provider: IFormatProvider | undefined, result: float): boolean;
    TryParse(s: string | undefined, provider: IFormatProvider | undefined, result: float): boolean;
    TryParse(s: string | undefined, result: float): boolean;
};


export interface __Single$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<Single>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<Single>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<Single>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<Single>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<Single>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<Single, Single>;
    As_IFloatingPoint_1(): System_Numerics_Internal.IFloatingPoint_1$instance<Single>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<Single>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<Single>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<Single>;
    As_IRootFunctions_1(): System_Numerics_Internal.IRootFunctions_1$instance<Single>;
    As_ITrigonometricFunctions_1(): System_Numerics_Internal.ITrigonometricFunctions_1$instance<Single>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Single): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    GetExponentByteCount(): int;
    GetExponentShortestBitLength(): int;
    TryWriteExponentBigEndian(destination: Span_1<Byte>, bytesWritten: int): boolean;
    WriteExponentBigEndian(destination: byte[], startIndex: int): int;
    WriteExponentBigEndian(destination: byte[]): int;
    WriteExponentBigEndian(destination: Span_1<Byte>): int;
}

export interface Single$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<Single> {}

export type Single = number & Single$instance & __Single$views;


export interface Span_1$instance<T> {
    readonly IsEmpty: boolean;
    readonly Item: T;
    readonly Length: int;
    Clear(): void;
    CopyTo(destination: Span_1<T>): void;
    Equals(obj: unknown | undefined): boolean;
    Fill(value: T): void;
    GetEnumerator(): Span_1_Enumerator<T>;
    GetHashCode(): int;
    GetPinnableReference(): T;
    Slice(start: int): Span_1<T>;
    Slice(start: int, length: int): Span_1<T>;
    ToArray(): T[];
    ToString(): string;
    TryCopyTo(destination: Span_1<T>): boolean;
}


export const Span_1: {
    new<T>(array: T[] | undefined): Span_1<T>;
    new<T>(array: T[] | undefined, start: int, length: int): Span_1<T>;
    new<T>(pointer: ptr<void>, length: int): Span_1<T>;
    new<T>(reference: T): Span_1<T>;
    readonly Empty: unknown;
};


export type Span_1<T> = Span_1$instance<T>;

export interface Span_1_Enumerator$instance<T> {
    readonly Current: T;
    MoveNext(): boolean;
    Reset(): void;
}


export const Span_1_Enumerator: {
    new<T>(): Span_1_Enumerator<T>;
};


export interface __Span_1_Enumerator$views<T> {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<T>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDisposable(): IDisposable$instance;
}

export type Span_1_Enumerator<T> = Span_1_Enumerator$instance<T> & __Span_1_Enumerator$views<T>;


export interface TimeOnly$instance {
    readonly Hour: int;
    readonly Microsecond: int;
    readonly Millisecond: int;
    readonly Minute: int;
    readonly Nanosecond: int;
    readonly Second: int;
    readonly Ticks: long;
    Add(value: TimeSpan): TimeOnly;
    Add(value: TimeSpan, wrappedDays: int): TimeOnly;
    AddHours(value: double): TimeOnly;
    AddHours(value: double, wrappedDays: int): TimeOnly;
    AddMinutes(value: double): TimeOnly;
    AddMinutes(value: double, wrappedDays: int): TimeOnly;
    CompareTo(value: TimeOnly): int;
    CompareTo(value: unknown | undefined): int;
    Deconstruct(hour: int, minute: int): void;
    Deconstruct(hour: int, minute: int, second: int): void;
    Deconstruct(hour: int, minute: int, second: int, millisecond: int): void;
    Deconstruct(hour: int, minute: int, second: int, millisecond: int, microsecond: int): void;
    Equals(value: TimeOnly): boolean;
    Equals(value: unknown | undefined): boolean;
    GetHashCode(): int;
    IsBetween(start: TimeOnly, end: TimeOnly): boolean;
    ToLongTimeString(): string;
    ToShortTimeString(): string;
    ToString(): string;
    ToString(format: string | undefined): string;
    ToString(provider: IFormatProvider | undefined): string;
    ToString(format: string | undefined, provider: IFormatProvider | undefined): string;
    ToTimeSpan(): TimeSpan;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
}


export const TimeOnly: {
    new(hour: int, minute: int): TimeOnly;
    new(hour: int, minute: int, second: int): TimeOnly;
    new(hour: int, minute: int, second: int, millisecond: int): TimeOnly;
    new(hour: int, minute: int, second: int, millisecond: int, microsecond: int): TimeOnly;
    new(ticks: long): TimeOnly;
    readonly MinValue: TimeOnly;
    readonly MaxValue: TimeOnly;
    FromDateTime(dateTime: DateTime): TimeOnly;
    FromTimeSpan(timeSpan: TimeSpan): TimeOnly;
    Parse(s: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined, style?: DateTimeStyles): TimeOnly;
    Parse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined): TimeOnly;
    Parse(s: string, provider: IFormatProvider | undefined, style?: DateTimeStyles): TimeOnly;
    Parse(s: string, provider: IFormatProvider | undefined): TimeOnly;
    Parse(s: string): TimeOnly;
    ParseExact(s: ReadOnlySpan_1<Char>, format: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined, style?: DateTimeStyles): TimeOnly;
    ParseExact(s: ReadOnlySpan_1<Char>, formats: string[], provider: IFormatProvider | undefined, style?: DateTimeStyles): TimeOnly;
    ParseExact(s: ReadOnlySpan_1<Char>, formats: string[]): TimeOnly;
    ParseExact(s: string, format: string, provider: IFormatProvider | undefined, style?: DateTimeStyles): TimeOnly;
    ParseExact(s: string, format: string): TimeOnly;
    ParseExact(s: string, formats: string[], provider: IFormatProvider | undefined, style?: DateTimeStyles): TimeOnly;
    ParseExact(s: string, formats: string[]): TimeOnly;
    TryParse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, style: DateTimeStyles, result: TimeOnly): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, result: TimeOnly): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, result: TimeOnly): boolean;
    TryParse(s: string | undefined, provider: IFormatProvider | undefined, style: DateTimeStyles, result: TimeOnly): boolean;
    TryParse(s: string | undefined, provider: IFormatProvider | undefined, result: TimeOnly): boolean;
    TryParse(s: string | undefined, result: TimeOnly): boolean;
    TryParseExact(s: ReadOnlySpan_1<Char>, format: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, style: DateTimeStyles, result: TimeOnly): boolean;
    TryParseExact(s: ReadOnlySpan_1<Char>, format: ReadOnlySpan_1<Char>, result: TimeOnly): boolean;
    TryParseExact(s: ReadOnlySpan_1<Char>, formats: (string | undefined)[] | undefined, provider: IFormatProvider | undefined, style: DateTimeStyles, result: TimeOnly): boolean;
    TryParseExact(s: ReadOnlySpan_1<Char>, formats: (string | undefined)[] | undefined, result: TimeOnly): boolean;
    TryParseExact(s: string | undefined, format: string | undefined, provider: IFormatProvider | undefined, style: DateTimeStyles, result: TimeOnly): boolean;
    TryParseExact(s: string | undefined, format: string | undefined, result: TimeOnly): boolean;
    TryParseExact(s: string | undefined, formats: (string | undefined)[] | undefined, provider: IFormatProvider | undefined, style: DateTimeStyles, result: TimeOnly): boolean;
    TryParseExact(s: string | undefined, formats: (string | undefined)[] | undefined, result: TimeOnly): boolean;
};


export interface __TimeOnly$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<TimeOnly>;
    As_IEquatable_1(): IEquatable_1$instance<TimeOnly>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<TimeOnly>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<TimeOnly>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: TimeOnly): boolean;
    CompareTo(obj: unknown): int;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
}

export interface TimeOnly$instance extends IComparable$instance, ISpanParsable_1$instance<TimeOnly> {}

export type TimeOnly = TimeOnly$instance & __TimeOnly$views;


export interface TimeSpan$instance {
    readonly Days: int;
    readonly Hours: int;
    readonly Microseconds: int;
    readonly Milliseconds: int;
    readonly Minutes: int;
    readonly Nanoseconds: int;
    readonly Seconds: int;
    readonly Ticks: long;
    readonly TotalDays: double;
    readonly TotalHours: double;
    readonly TotalMicroseconds: double;
    readonly TotalMilliseconds: double;
    readonly TotalMinutes: double;
    readonly TotalNanoseconds: double;
    readonly TotalSeconds: double;
    Add(ts: TimeSpan): TimeSpan;
    CompareTo(value: unknown | undefined): int;
    CompareTo(value: TimeSpan): int;
    Divide(divisor: double): TimeSpan;
    Divide(ts: TimeSpan): double;
    Duration(): TimeSpan;
    Equals(value: unknown | undefined): boolean;
    Equals(obj: TimeSpan): boolean;
    GetHashCode(): int;
    Multiply(factor: double): TimeSpan;
    Negate(): TimeSpan;
    Subtract(ts: TimeSpan): TimeSpan;
    ToString(): string;
    ToString(format: string | undefined): string;
    ToString(format: string | undefined, formatProvider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format?: ReadOnlySpan_1<Char>, formatProvider?: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format?: ReadOnlySpan_1<Char>, formatProvider?: IFormatProvider | undefined): boolean;
}


export const TimeSpan: {
    new(ticks: long): TimeSpan;
    new(hours: int, minutes: int, seconds: int): TimeSpan;
    new(days: int, hours: int, minutes: int, seconds: int): TimeSpan;
    new(days: int, hours: int, minutes: int, seconds: int, milliseconds: int): TimeSpan;
    new(days: int, hours: int, minutes: int, seconds: int, milliseconds: int, microseconds: int): TimeSpan;
    readonly Zero: TimeSpan;
    readonly MaxValue: TimeSpan;
    readonly MinValue: TimeSpan;
    readonly NanosecondsPerTick: long;
    readonly TicksPerMicrosecond: long;
    readonly TicksPerMillisecond: long;
    readonly TicksPerSecond: long;
    readonly TicksPerMinute: long;
    readonly TicksPerHour: long;
    readonly TicksPerDay: long;
    readonly MicrosecondsPerMillisecond: long;
    readonly MicrosecondsPerSecond: long;
    readonly MicrosecondsPerMinute: long;
    readonly MicrosecondsPerHour: long;
    readonly MicrosecondsPerDay: long;
    readonly MillisecondsPerSecond: long;
    readonly MillisecondsPerMinute: long;
    readonly MillisecondsPerHour: long;
    readonly MillisecondsPerDay: long;
    readonly SecondsPerMinute: long;
    readonly SecondsPerHour: long;
    readonly SecondsPerDay: long;
    readonly MinutesPerHour: long;
    readonly MinutesPerDay: long;
    readonly HoursPerDay: int;
    Compare(t1: TimeSpan, t2: TimeSpan): int;
    Equals(t1: TimeSpan, t2: TimeSpan): boolean;
    FromDays(value: double): TimeSpan;
    FromDays(days: int, hours?: int, minutes?: long, seconds?: long, milliseconds?: long, microseconds?: long): TimeSpan;
    FromDays(days: int): TimeSpan;
    FromHours(value: double): TimeSpan;
    FromHours(hours: int, minutes?: long, seconds?: long, milliseconds?: long, microseconds?: long): TimeSpan;
    FromHours(hours: int): TimeSpan;
    FromMicroseconds(value: double): TimeSpan;
    FromMicroseconds(microseconds: long): TimeSpan;
    FromMilliseconds(value: double): TimeSpan;
    FromMilliseconds(milliseconds: long, microseconds: long): TimeSpan;
    FromMilliseconds(milliseconds: long): TimeSpan;
    FromMinutes(value: double): TimeSpan;
    FromMinutes(minutes: long, seconds?: long, milliseconds?: long, microseconds?: long): TimeSpan;
    FromMinutes(minutes: long): TimeSpan;
    FromSeconds(value: double): TimeSpan;
    FromSeconds(seconds: long, milliseconds?: long, microseconds?: long): TimeSpan;
    FromSeconds(seconds: long): TimeSpan;
    FromTicks(value: long): TimeSpan;
    Parse(input: ReadOnlySpan_1<Char>, formatProvider?: IFormatProvider | undefined): TimeSpan;
    Parse(input: string, formatProvider: IFormatProvider | undefined): TimeSpan;
    Parse(s: string): TimeSpan;
    ParseExact(input: ReadOnlySpan_1<Char>, format: ReadOnlySpan_1<Char>, formatProvider: IFormatProvider | undefined, styles?: TimeSpanStyles): TimeSpan;
    ParseExact(input: ReadOnlySpan_1<Char>, formats: string[], formatProvider: IFormatProvider | undefined, styles?: TimeSpanStyles): TimeSpan;
    ParseExact(input: string, format: string, formatProvider: IFormatProvider | undefined, styles: TimeSpanStyles): TimeSpan;
    ParseExact(input: string, format: string, formatProvider: IFormatProvider | undefined): TimeSpan;
    ParseExact(input: string, formats: string[], formatProvider: IFormatProvider | undefined, styles: TimeSpanStyles): TimeSpan;
    ParseExact(input: string, formats: string[], formatProvider: IFormatProvider | undefined): TimeSpan;
    TryParse(input: ReadOnlySpan_1<Char>, formatProvider: IFormatProvider | undefined, result: TimeSpan): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, result: TimeSpan): boolean;
    TryParse(input: string | undefined, formatProvider: IFormatProvider | undefined, result: TimeSpan): boolean;
    TryParse(s: string | undefined, result: TimeSpan): boolean;
    TryParseExact(input: ReadOnlySpan_1<Char>, format: ReadOnlySpan_1<Char>, formatProvider: IFormatProvider | undefined, styles: TimeSpanStyles, result: TimeSpan): boolean;
    TryParseExact(input: ReadOnlySpan_1<Char>, format: ReadOnlySpan_1<Char>, formatProvider: IFormatProvider | undefined, result: TimeSpan): boolean;
    TryParseExact(input: ReadOnlySpan_1<Char>, formats: (string | undefined)[] | undefined, formatProvider: IFormatProvider | undefined, styles: TimeSpanStyles, result: TimeSpan): boolean;
    TryParseExact(input: ReadOnlySpan_1<Char>, formats: (string | undefined)[] | undefined, formatProvider: IFormatProvider | undefined, result: TimeSpan): boolean;
    TryParseExact(input: string | undefined, format: string | undefined, formatProvider: IFormatProvider | undefined, styles: TimeSpanStyles, result: TimeSpan): boolean;
    TryParseExact(input: string | undefined, format: string | undefined, formatProvider: IFormatProvider | undefined, result: TimeSpan): boolean;
    TryParseExact(input: string | undefined, formats: (string | undefined)[] | undefined, formatProvider: IFormatProvider | undefined, styles: TimeSpanStyles, result: TimeSpan): boolean;
    TryParseExact(input: string | undefined, formats: (string | undefined)[] | undefined, formatProvider: IFormatProvider | undefined, result: TimeSpan): boolean;
};


export interface __TimeSpan$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<TimeSpan>;
    As_IEquatable_1(): IEquatable_1$instance<TimeSpan>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<TimeSpan>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<TimeSpan>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: TimeSpan): boolean;
    CompareTo(obj: unknown): int;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
}

export interface TimeSpan$instance extends IComparable$instance, ISpanParsable_1$instance<TimeSpan> {}

export type TimeSpan = TimeSpan$instance & __TimeSpan$views;


export interface TimeZoneInfo_TransitionTime$instance {
    readonly Day: int;
    readonly DayOfWeek: DayOfWeek;
    readonly IsFixedDateRule: boolean;
    readonly Month: int;
    readonly TimeOfDay: DateTime;
    readonly Week: int;
    Equals(obj: unknown | undefined): boolean;
    Equals(other: TimeZoneInfo_TransitionTime): boolean;
    GetHashCode(): int;
}


export const TimeZoneInfo_TransitionTime: {
    new(): TimeZoneInfo_TransitionTime;
    CreateFixedDateRule(timeOfDay: DateTime, month: int, day: int): TimeZoneInfo_TransitionTime;
    CreateFloatingDateRule(timeOfDay: DateTime, month: int, week: int, dayOfWeek: DayOfWeek): TimeZoneInfo_TransitionTime;
};


export interface __TimeZoneInfo_TransitionTime$views {
    As_IEquatable_1(): IEquatable_1$instance<TimeZoneInfo_TransitionTime>;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: TimeZoneInfo_TransitionTime): boolean;
}

export interface TimeZoneInfo_TransitionTime$instance extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type TimeZoneInfo_TransitionTime = TimeZoneInfo_TransitionTime$instance & __TimeZoneInfo_TransitionTime$views;


export interface TypedReference$instance {
    Equals(o: unknown | undefined): boolean;
    GetHashCode(): int;
}


export const TypedReference: {
    new(): TypedReference;
    GetTargetType(value: TypedReference): Type;
    MakeTypedReference(target: unknown, flds: FieldInfo[]): TypedReference;
    SetTypedReference(target: TypedReference, value: unknown | undefined): void;
    TargetTypeToken(value: TypedReference): RuntimeTypeHandle;
    ToObject(value: TypedReference): unknown | undefined;
};


export type TypedReference = TypedReference$instance;

export interface UInt128$instance extends IBitwiseOperators_3<UInt128, UInt128, UInt128>, IComparisonOperators_3<UInt128, UInt128, Boolean>, IEqualityOperators_3<UInt128, UInt128, Boolean>, IModulusOperators_3<UInt128, UInt128, UInt128>, IAdditionOperators_3<UInt128, UInt128, UInt128>, IDecrementOperators_1<UInt128>, IDivisionOperators_3<UInt128, UInt128, UInt128>, IIncrementOperators_1<UInt128>, IMultiplyOperators_3<UInt128, UInt128, UInt128>, ISubtractionOperators_3<UInt128, UInt128, UInt128>, IUnaryPlusOperators_2<UInt128, UInt128>, IUnaryNegationOperators_2<UInt128, UInt128>, IShiftOperators_3<UInt128, Int32, UInt128> {
    CompareTo(value: unknown | undefined): int;
    CompareTo(value: uint128): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(other: uint128): boolean;
    GetHashCode(): int;
    ToString(): string;
    ToString(provider: IFormatProvider | undefined): string;
    ToString(format: string | undefined): string;
    ToString(format: string | undefined, provider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
}


export const UInt128: {
    new(upper: ulong, lower: ulong): UInt128;
    readonly MinValue: uint128;
    readonly MaxValue: uint128;
    readonly One: uint128;
    readonly Zero: uint128;
    BigMul(left: uint128, right: uint128, lower: uint128): uint128;
    Clamp(value: uint128, min: uint128, max: uint128): uint128;
    CreateChecked<TOther extends INumberBase_1<TOther>>(value: TOther): uint128;
    CreateSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): uint128;
    CreateTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): uint128;
    DivRem(left: uint128, right: uint128): ValueTuple_2<UInt128, UInt128>;
    IsEvenInteger(value: uint128): boolean;
    IsOddInteger(value: uint128): boolean;
    IsPow2(value: uint128): boolean;
    LeadingZeroCount(value: uint128): uint128;
    Log2(value: uint128): uint128;
    Max(x: uint128, y: uint128): uint128;
    Min(x: uint128, y: uint128): uint128;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, style?: NumberStyles, provider?: IFormatProvider | undefined): uint128;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined): uint128;
    Parse(s: ReadOnlySpan_1<Char>, style?: NumberStyles, provider?: IFormatProvider | undefined): uint128;
    Parse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined): uint128;
    Parse(s: string, style: NumberStyles, provider: IFormatProvider | undefined): uint128;
    Parse(s: string, style: NumberStyles): uint128;
    Parse(s: string, provider: IFormatProvider | undefined): uint128;
    Parse(s: string): uint128;
    PopCount(value: uint128): uint128;
    RotateLeft(value: uint128, rotateAmount: int): uint128;
    RotateRight(value: uint128, rotateAmount: int): uint128;
    Sign(value: uint128): int;
    TrailingZeroCount(value: uint128): uint128;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, style: NumberStyles, provider: IFormatProvider | undefined, result: uint128): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined, result: uint128): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, result: uint128): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, style: NumberStyles, provider: IFormatProvider | undefined, result: uint128): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, result: uint128): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, result: uint128): boolean;
    TryParse(s: string | undefined, style: NumberStyles, provider: IFormatProvider | undefined, result: uint128): boolean;
    TryParse(s: string | undefined, provider: IFormatProvider | undefined, result: uint128): boolean;
    TryParse(s: string | undefined, result: uint128): boolean;
};


export interface __UInt128$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<UInt128>;
    As_IEquatable_1(): IEquatable_1$instance<UInt128>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<UInt128>;
    As_ISpanParsable_1(): ISpanParsable_1$instance<UInt128>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<UInt128>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<UInt128, UInt128>;
    As_IBinaryInteger_1(): System_Numerics_Internal.IBinaryInteger_1$instance<UInt128>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<UInt128>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<UInt128>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<UInt128>;

    // Structural method bridges for numeric interface constraints
    Equals(other: UInt128): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: Span_1<Byte>, bytesWritten: int): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<Byte>): int;
}

export interface UInt128$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<UInt128> {}

export type UInt128 = number & UInt128$instance & __UInt128$views;


export interface UInt16$instance extends IBitwiseOperators_3<UInt16, UInt16, UInt16>, IComparisonOperators_3<UInt16, UInt16, Boolean>, IEqualityOperators_3<UInt16, UInt16, Boolean>, IModulusOperators_3<UInt16, UInt16, UInt16>, IAdditionOperators_3<UInt16, UInt16, UInt16>, IDecrementOperators_1<UInt16>, IDivisionOperators_3<UInt16, UInt16, UInt16>, IIncrementOperators_1<UInt16>, IMultiplyOperators_3<UInt16, UInt16, UInt16>, ISubtractionOperators_3<UInt16, UInt16, UInt16>, IUnaryPlusOperators_2<UInt16, UInt16>, IUnaryNegationOperators_2<UInt16, UInt16>, IShiftOperators_3<UInt16, Int32, UInt16> {
    CompareTo(value: unknown | undefined): int;
    CompareTo(value: ushort): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(obj: ushort): boolean;
    GetHashCode(): int;
    GetTypeCode(): TypeCode;
    ToString(): string;
    ToString(provider: IFormatProvider | undefined): string;
    ToString(format: string | undefined): string;
    ToString(format: string | undefined, provider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
}


export const UInt16: {
    new(): UInt16;
    readonly MaxValue: ushort;
    readonly MinValue: ushort;
    Clamp(value: ushort, min: ushort, max: ushort): ushort;
    CreateChecked<TOther extends INumberBase_1<TOther>>(value: TOther): ushort;
    CreateSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): ushort;
    CreateTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): ushort;
    DivRem(left: ushort, right: ushort): ValueTuple_2<UInt16, UInt16>;
    IsEvenInteger(value: ushort): boolean;
    IsOddInteger(value: ushort): boolean;
    IsPow2(value: ushort): boolean;
    LeadingZeroCount(value: ushort): ushort;
    Log2(value: ushort): ushort;
    Max(x: ushort, y: ushort): ushort;
    Min(x: ushort, y: ushort): ushort;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, style?: NumberStyles, provider?: IFormatProvider | undefined): ushort;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined): ushort;
    Parse(s: ReadOnlySpan_1<Char>, style?: NumberStyles, provider?: IFormatProvider | undefined): ushort;
    Parse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined): ushort;
    Parse(s: string, style: NumberStyles, provider: IFormatProvider | undefined): ushort;
    Parse(s: string, style: NumberStyles): ushort;
    Parse(s: string, provider: IFormatProvider | undefined): ushort;
    Parse(s: string): ushort;
    PopCount(value: ushort): ushort;
    RotateLeft(value: ushort, rotateAmount: int): ushort;
    RotateRight(value: ushort, rotateAmount: int): ushort;
    Sign(value: ushort): int;
    TrailingZeroCount(value: ushort): ushort;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, style: NumberStyles, provider: IFormatProvider | undefined, result: ushort): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined, result: ushort): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, result: ushort): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, style: NumberStyles, provider: IFormatProvider | undefined, result: ushort): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, result: ushort): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, result: ushort): boolean;
    TryParse(s: string | undefined, style: NumberStyles, provider: IFormatProvider | undefined, result: ushort): boolean;
    TryParse(s: string | undefined, provider: IFormatProvider | undefined, result: ushort): boolean;
    TryParse(s: string | undefined, result: ushort): boolean;
};


export interface __UInt16$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<UInt16>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<UInt16>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<UInt16>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<UInt16>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<UInt16>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<UInt16, UInt16>;
    As_IBinaryInteger_1(): System_Numerics_Internal.IBinaryInteger_1$instance<UInt16>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<UInt16>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<UInt16>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<UInt16>;

    // Structural method bridges for numeric interface constraints
    Equals(other: UInt16): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: Span_1<Byte>, bytesWritten: int): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<Byte>): int;
}

export interface UInt16$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<UInt16> {}

export type UInt16 = number & UInt16$instance & __UInt16$views;


export interface UInt32$instance extends IBitwiseOperators_3<UInt32, UInt32, UInt32>, IComparisonOperators_3<UInt32, UInt32, Boolean>, IEqualityOperators_3<UInt32, UInt32, Boolean>, IModulusOperators_3<UInt32, UInt32, UInt32>, IAdditionOperators_3<UInt32, UInt32, UInt32>, IDecrementOperators_1<UInt32>, IDivisionOperators_3<UInt32, UInt32, UInt32>, IIncrementOperators_1<UInt32>, IMultiplyOperators_3<UInt32, UInt32, UInt32>, ISubtractionOperators_3<UInt32, UInt32, UInt32>, IUnaryPlusOperators_2<UInt32, UInt32>, IUnaryNegationOperators_2<UInt32, UInt32>, IShiftOperators_3<UInt32, Int32, UInt32> {
    CompareTo(value: unknown | undefined): int;
    CompareTo(value: uint): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(obj: uint): boolean;
    GetHashCode(): int;
    GetTypeCode(): TypeCode;
    ToString(): string;
    ToString(provider: IFormatProvider | undefined): string;
    ToString(format: string | undefined): string;
    ToString(format: string | undefined, provider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
}


export const UInt32: {
    new(): UInt32;
    readonly MaxValue: uint;
    readonly MinValue: uint;
    BigMul(left: uint, right: uint): ulong;
    Clamp(value: uint, min: uint, max: uint): uint;
    CreateChecked<TOther extends INumberBase_1<TOther>>(value: TOther): uint;
    CreateSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): uint;
    CreateTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): uint;
    DivRem(left: uint, right: uint): ValueTuple_2<UInt32, UInt32>;
    IsEvenInteger(value: uint): boolean;
    IsOddInteger(value: uint): boolean;
    IsPow2(value: uint): boolean;
    LeadingZeroCount(value: uint): uint;
    Log2(value: uint): uint;
    Max(x: uint, y: uint): uint;
    Min(x: uint, y: uint): uint;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, style?: NumberStyles, provider?: IFormatProvider | undefined): uint;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined): uint;
    Parse(s: ReadOnlySpan_1<Char>, style?: NumberStyles, provider?: IFormatProvider | undefined): uint;
    Parse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined): uint;
    Parse(s: string, style: NumberStyles, provider: IFormatProvider | undefined): uint;
    Parse(s: string, style: NumberStyles): uint;
    Parse(s: string, provider: IFormatProvider | undefined): uint;
    Parse(s: string): uint;
    PopCount(value: uint): uint;
    RotateLeft(value: uint, rotateAmount: int): uint;
    RotateRight(value: uint, rotateAmount: int): uint;
    Sign(value: uint): int;
    TrailingZeroCount(value: uint): uint;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, style: NumberStyles, provider: IFormatProvider | undefined, result: uint): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined, result: uint): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, result: uint): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, style: NumberStyles, provider: IFormatProvider | undefined, result: uint): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, result: uint): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, result: uint): boolean;
    TryParse(s: string | undefined, style: NumberStyles, provider: IFormatProvider | undefined, result: uint): boolean;
    TryParse(s: string | undefined, provider: IFormatProvider | undefined, result: uint): boolean;
    TryParse(s: string | undefined, result: uint): boolean;
};


export interface __UInt32$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<UInt32>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<UInt32>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<UInt32>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<UInt32>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<UInt32>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<UInt32, UInt32>;
    As_IBinaryInteger_1(): System_Numerics_Internal.IBinaryInteger_1$instance<UInt32>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<UInt32>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<UInt32>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<UInt32>;

    // Structural method bridges for numeric interface constraints
    Equals(other: UInt32): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: Span_1<Byte>, bytesWritten: int): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<Byte>): int;
}

export interface UInt32$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<UInt32> {}

export type UInt32 = number & UInt32$instance & __UInt32$views;


export interface UInt64$instance extends IBitwiseOperators_3<UInt64, UInt64, UInt64>, IComparisonOperators_3<UInt64, UInt64, Boolean>, IEqualityOperators_3<UInt64, UInt64, Boolean>, IModulusOperators_3<UInt64, UInt64, UInt64>, IAdditionOperators_3<UInt64, UInt64, UInt64>, IDecrementOperators_1<UInt64>, IDivisionOperators_3<UInt64, UInt64, UInt64>, IIncrementOperators_1<UInt64>, IMultiplyOperators_3<UInt64, UInt64, UInt64>, ISubtractionOperators_3<UInt64, UInt64, UInt64>, IUnaryPlusOperators_2<UInt64, UInt64>, IUnaryNegationOperators_2<UInt64, UInt64>, IShiftOperators_3<UInt64, Int32, UInt64> {
    CompareTo(value: unknown | undefined): int;
    CompareTo(value: ulong): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(obj: ulong): boolean;
    GetHashCode(): int;
    GetTypeCode(): TypeCode;
    ToString(): string;
    ToString(provider: IFormatProvider | undefined): string;
    ToString(format: string | undefined): string;
    ToString(format: string | undefined, provider: IFormatProvider | undefined): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
}


export const UInt64: {
    new(): UInt64;
    readonly MaxValue: ulong;
    readonly MinValue: ulong;
    BigMul(left: ulong, right: ulong): uint128;
    Clamp(value: ulong, min: ulong, max: ulong): ulong;
    CreateChecked<TOther extends INumberBase_1<TOther>>(value: TOther): ulong;
    CreateSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): ulong;
    CreateTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): ulong;
    DivRem(left: ulong, right: ulong): ValueTuple_2<UInt64, UInt64>;
    IsEvenInteger(value: ulong): boolean;
    IsOddInteger(value: ulong): boolean;
    IsPow2(value: ulong): boolean;
    LeadingZeroCount(value: ulong): ulong;
    Log2(value: ulong): ulong;
    Max(x: ulong, y: ulong): ulong;
    Min(x: ulong, y: ulong): ulong;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, style?: NumberStyles, provider?: IFormatProvider | undefined): ulong;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined): ulong;
    Parse(s: ReadOnlySpan_1<Char>, style?: NumberStyles, provider?: IFormatProvider | undefined): ulong;
    Parse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined): ulong;
    Parse(s: string, style: NumberStyles, provider: IFormatProvider | undefined): ulong;
    Parse(s: string, style: NumberStyles): ulong;
    Parse(s: string, provider: IFormatProvider | undefined): ulong;
    Parse(s: string): ulong;
    PopCount(value: ulong): ulong;
    RotateLeft(value: ulong, rotateAmount: int): ulong;
    RotateRight(value: ulong, rotateAmount: int): ulong;
    Sign(value: ulong): int;
    TrailingZeroCount(value: ulong): ulong;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, style: NumberStyles, provider: IFormatProvider | undefined, result: ulong): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined, result: ulong): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, result: ulong): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, style: NumberStyles, provider: IFormatProvider | undefined, result: ulong): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, result: ulong): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, result: ulong): boolean;
    TryParse(s: string | undefined, style: NumberStyles, provider: IFormatProvider | undefined, result: ulong): boolean;
    TryParse(s: string | undefined, provider: IFormatProvider | undefined, result: ulong): boolean;
    TryParse(s: string | undefined, result: ulong): boolean;
};


export interface __UInt64$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<UInt64>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<UInt64>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<UInt64>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<UInt64>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<UInt64>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<UInt64, UInt64>;
    As_IBinaryInteger_1(): System_Numerics_Internal.IBinaryInteger_1$instance<UInt64>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<UInt64>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<UInt64>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<UInt64>;

    // Structural method bridges for numeric interface constraints
    Equals(other: UInt64): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: Span_1<Byte>, bytesWritten: int): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<Byte>): int;
}

export interface UInt64$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<UInt64> {}

export type UInt64 = number & UInt64$instance & __UInt64$views;


export interface UIntPtr$instance extends IBitwiseOperators_3<UIntPtr, UIntPtr, UIntPtr>, IComparisonOperators_3<UIntPtr, UIntPtr, Boolean>, IEqualityOperators_3<UIntPtr, UIntPtr, Boolean>, IModulusOperators_3<UIntPtr, UIntPtr, UIntPtr>, IAdditionOperators_3<UIntPtr, UIntPtr, UIntPtr>, IDecrementOperators_1<UIntPtr>, IDivisionOperators_3<UIntPtr, UIntPtr, UIntPtr>, IIncrementOperators_1<UIntPtr>, IMultiplyOperators_3<UIntPtr, UIntPtr, UIntPtr>, ISubtractionOperators_3<UIntPtr, UIntPtr, UIntPtr>, IUnaryPlusOperators_2<UIntPtr, UIntPtr>, IUnaryNegationOperators_2<UIntPtr, UIntPtr>, IShiftOperators_3<UIntPtr, Int32, UIntPtr> {
    CompareTo(value: unknown | undefined): int;
    CompareTo(value: nuint): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(other: nuint): boolean;
    GetHashCode(): int;
    ToPointer(): ptr<void>;
    ToString(): string;
    ToString(format: string | undefined): string;
    ToString(provider: IFormatProvider | undefined): string;
    ToString(format: string | undefined, provider: IFormatProvider | undefined): string;
    ToUInt32(): uint;
    ToUInt64(): ulong;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format?: ReadOnlySpan_1<Char>, provider?: IFormatProvider | undefined): boolean;
}


export const UIntPtr: {
    new(value: uint): UIntPtr;
    new(value: ulong): UIntPtr;
    new(value: ptr<void>): UIntPtr;
    readonly Zero: nuint;
    readonly Size: int;
    readonly MaxValue: nuint;
    readonly MinValue: nuint;
    Add(pointer: nuint, offset: int): nuint;
    BigMul(left: nuint, right: nuint, lower: nuint): nuint;
    Clamp(value: nuint, min: nuint, max: nuint): nuint;
    CreateChecked<TOther extends INumberBase_1<TOther>>(value: TOther): nuint;
    CreateSaturating<TOther extends INumberBase_1<TOther>>(value: TOther): nuint;
    CreateTruncating<TOther extends INumberBase_1<TOther>>(value: TOther): nuint;
    DivRem(left: nuint, right: nuint): ValueTuple_2<UIntPtr, UIntPtr>;
    IsEvenInteger(value: nuint): boolean;
    IsOddInteger(value: nuint): boolean;
    IsPow2(value: nuint): boolean;
    LeadingZeroCount(value: nuint): nuint;
    Log2(value: nuint): nuint;
    Max(x: nuint, y: nuint): nuint;
    Min(x: nuint, y: nuint): nuint;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, style?: NumberStyles, provider?: IFormatProvider | undefined): nuint;
    Parse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined): nuint;
    Parse(s: ReadOnlySpan_1<Char>, style?: NumberStyles, provider?: IFormatProvider | undefined): nuint;
    Parse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined): nuint;
    Parse(s: string, style: NumberStyles, provider: IFormatProvider | undefined): nuint;
    Parse(s: string, style: NumberStyles): nuint;
    Parse(s: string, provider: IFormatProvider | undefined): nuint;
    Parse(s: string): nuint;
    PopCount(value: nuint): nuint;
    RotateLeft(value: nuint, rotateAmount: int): nuint;
    RotateRight(value: nuint, rotateAmount: int): nuint;
    Sign(value: nuint): int;
    Subtract(pointer: nuint, offset: int): nuint;
    TrailingZeroCount(value: nuint): nuint;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, style: NumberStyles, provider: IFormatProvider | undefined, result: nuint): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, provider: IFormatProvider | undefined, result: nuint): boolean;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, result: nuint): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, style: NumberStyles, provider: IFormatProvider | undefined, result: nuint): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, provider: IFormatProvider | undefined, result: nuint): boolean;
    TryParse(s: ReadOnlySpan_1<Char>, result: nuint): boolean;
    TryParse(s: string | undefined, style: NumberStyles, provider: IFormatProvider | undefined, result: nuint): boolean;
    TryParse(s: string | undefined, provider: IFormatProvider | undefined, result: nuint): boolean;
    TryParse(s: string | undefined, result: nuint): boolean;
};


export interface __UIntPtr$views {
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<UIntPtr>;
    As_IEquatable_1(): IEquatable_1$instance<UIntPtr>;
    As_IFormattable(): IFormattable$instance;
    As_IParsable_1(): IParsable_1$instance<UIntPtr>;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISpanParsable_1(): ISpanParsable_1$instance<UIntPtr>;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<UIntPtr>;
    As_IAdditiveIdentity_2(): System_Numerics_Internal.IAdditiveIdentity_2$instance<UIntPtr, UIntPtr>;
    As_IBinaryInteger_1(): System_Numerics_Internal.IBinaryInteger_1$instance<UIntPtr>;
    As_IMinMaxValue_1(): System_Numerics_Internal.IMinMaxValue_1$instance<UIntPtr>;
    As_INumber_1(): System_Numerics_Internal.INumber_1$instance<UIntPtr>;
    As_INumberBase_1(): System_Numerics_Internal.INumberBase_1$instance<UIntPtr>;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: UIntPtr): boolean;
    CompareTo(obj: unknown): int;
    ToString(format: string, formatProvider: IFormatProvider): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
    GetByteCount(): int;
    TryWriteBigEndian(destination: Span_1<Byte>, bytesWritten: int): boolean;
    WriteBigEndian(destination: byte[], startIndex: int): int;
    WriteBigEndian(destination: byte[]): int;
    WriteBigEndian(destination: Span_1<Byte>): int;
}

export interface UIntPtr$instance extends System_Numerics_Internal.IMinMaxValue_1$instance<UIntPtr>, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type UIntPtr = number & UIntPtr$instance & __UIntPtr$views;


export interface UriCreationOptions$instance {
    DangerousDisablePathAndQueryCanonicalization: boolean;
}


export const UriCreationOptions: {
    new(): UriCreationOptions;
};


export type UriCreationOptions = UriCreationOptions$instance;

export interface ValueTuple$instance {
    CompareTo(other: ValueTuple): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(other: ValueTuple): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ValueTuple: {
    new(): ValueTuple;
    Create(): ValueTuple;
    Create<T1, T2, T3, T4, T5, T6, T7, T8>(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8): ValueTuple_8<T1, T2, T3, T4, T5, T6, T7, ValueTuple_1<T8>>;
    Create<T1, T2, T3, T4, T5, T6, T7>(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7): ValueTuple_7<T1, T2, T3, T4, T5, T6, T7>;
    Create<T1, T2, T3, T4, T5, T6>(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6): ValueTuple_6<T1, T2, T3, T4, T5, T6>;
    Create<T1, T2, T3, T4, T5>(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5): ValueTuple_5<T1, T2, T3, T4, T5>;
    Create<T1, T2, T3, T4>(item1: T1, item2: T2, item3: T3, item4: T4): ValueTuple_4<T1, T2, T3, T4>;
    Create<T1, T2, T3>(item1: T1, item2: T2, item3: T3): ValueTuple_3<T1, T2, T3>;
    Create<T1, T2>(item1: T1, item2: T2): ValueTuple_2<T1, T2>;
    Create<T1>(item1: T1): ValueTuple_1<T1>;
};


export interface __ValueTuple$views {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<ValueTuple>;
    As_IEquatable_1(): IEquatable_1$instance<ValueTuple>;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: ValueTuple): boolean;
    CompareTo(obj: unknown): int;
}

export interface ValueTuple$instance extends IComparable_1$instance<ValueTuple>, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type ValueTuple = ValueTuple$instance & __ValueTuple$views;


export interface ValueTuple_1$instance<T1> {
    Item1: T1;
    CompareTo(other: ValueTuple_1<T1>): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(other: ValueTuple_1<T1>): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ValueTuple_1: {
    new<T1>(item1: T1): ValueTuple_1<T1>;
};


export interface __ValueTuple_1$views<T1> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<ValueTuple_1<T1>>;
    As_IEquatable_1(): IEquatable_1$instance<ValueTuple_1<T1>>;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: ValueTuple_1<T1>): boolean;
    CompareTo(obj: unknown): int;
}

export interface ValueTuple_1$instance<T1> extends IComparable_1$instance<ValueTuple_1<T1>>, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type ValueTuple_1<T1> = ValueTuple_1$instance<T1> & __ValueTuple_1$views<T1>;


export interface ValueTuple_2$instance<T1, T2> {
    Item1: T1;
    Item2: T2;
    CompareTo(other: ValueTuple_2<T1, T2>): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(other: ValueTuple_2<T1, T2>): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ValueTuple_2: {
    new<T1, T2>(item1: T1, item2: T2): ValueTuple_2<T1, T2>;
};


export interface __ValueTuple_2$views<T1, T2> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<ValueTuple_2<T1, T2>>;
    As_IEquatable_1(): IEquatable_1$instance<ValueTuple_2<T1, T2>>;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: ValueTuple_2<T1, T2>): boolean;
    CompareTo(obj: unknown): int;
}

export interface ValueTuple_2$instance<T1, T2> extends IComparable_1$instance<ValueTuple_2<T1, T2>>, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type ValueTuple_2<T1, T2> = ValueTuple_2$instance<T1, T2> & __ValueTuple_2$views<T1, T2>;


export interface ValueTuple_3$instance<T1, T2, T3> {
    Item1: T1;
    Item2: T2;
    Item3: T3;
    CompareTo(other: ValueTuple_3<T1, T2, T3>): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(other: ValueTuple_3<T1, T2, T3>): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ValueTuple_3: {
    new<T1, T2, T3>(item1: T1, item2: T2, item3: T3): ValueTuple_3<T1, T2, T3>;
};


export interface __ValueTuple_3$views<T1, T2, T3> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<ValueTuple_3<T1, T2, T3>>;
    As_IEquatable_1(): IEquatable_1$instance<ValueTuple_3<T1, T2, T3>>;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: ValueTuple_3<T1, T2, T3>): boolean;
    CompareTo(obj: unknown): int;
}

export interface ValueTuple_3$instance<T1, T2, T3> extends IComparable_1$instance<ValueTuple_3<T1, T2, T3>>, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type ValueTuple_3<T1, T2, T3> = ValueTuple_3$instance<T1, T2, T3> & __ValueTuple_3$views<T1, T2, T3>;


export interface ValueTuple_4$instance<T1, T2, T3, T4> {
    Item1: T1;
    Item2: T2;
    Item3: T3;
    Item4: T4;
    CompareTo(other: ValueTuple_4<T1, T2, T3, T4>): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(other: ValueTuple_4<T1, T2, T3, T4>): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ValueTuple_4: {
    new<T1, T2, T3, T4>(item1: T1, item2: T2, item3: T3, item4: T4): ValueTuple_4<T1, T2, T3, T4>;
};


export interface __ValueTuple_4$views<T1, T2, T3, T4> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<ValueTuple_4<T1, T2, T3, T4>>;
    As_IEquatable_1(): IEquatable_1$instance<ValueTuple_4<T1, T2, T3, T4>>;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: ValueTuple_4<T1, T2, T3, T4>): boolean;
    CompareTo(obj: unknown): int;
}

export interface ValueTuple_4$instance<T1, T2, T3, T4> extends IComparable_1$instance<ValueTuple_4<T1, T2, T3, T4>>, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type ValueTuple_4<T1, T2, T3, T4> = ValueTuple_4$instance<T1, T2, T3, T4> & __ValueTuple_4$views<T1, T2, T3, T4>;


export interface ValueTuple_5$instance<T1, T2, T3, T4, T5> {
    Item1: T1;
    Item2: T2;
    Item3: T3;
    Item4: T4;
    Item5: T5;
    CompareTo(other: ValueTuple_5<T1, T2, T3, T4, T5>): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(other: ValueTuple_5<T1, T2, T3, T4, T5>): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ValueTuple_5: {
    new<T1, T2, T3, T4, T5>(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5): ValueTuple_5<T1, T2, T3, T4, T5>;
};


export interface __ValueTuple_5$views<T1, T2, T3, T4, T5> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<ValueTuple_5<T1, T2, T3, T4, T5>>;
    As_IEquatable_1(): IEquatable_1$instance<ValueTuple_5<T1, T2, T3, T4, T5>>;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: ValueTuple_5<T1, T2, T3, T4, T5>): boolean;
    CompareTo(obj: unknown): int;
}

export interface ValueTuple_5$instance<T1, T2, T3, T4, T5> extends IComparable_1$instance<ValueTuple_5<T1, T2, T3, T4, T5>>, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type ValueTuple_5<T1, T2, T3, T4, T5> = ValueTuple_5$instance<T1, T2, T3, T4, T5> & __ValueTuple_5$views<T1, T2, T3, T4, T5>;


export interface ValueTuple_6$instance<T1, T2, T3, T4, T5, T6> {
    Item1: T1;
    Item2: T2;
    Item3: T3;
    Item4: T4;
    Item5: T5;
    Item6: T6;
    CompareTo(other: ValueTuple_6<T1, T2, T3, T4, T5, T6>): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(other: ValueTuple_6<T1, T2, T3, T4, T5, T6>): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ValueTuple_6: {
    new<T1, T2, T3, T4, T5, T6>(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6): ValueTuple_6<T1, T2, T3, T4, T5, T6>;
};


export interface __ValueTuple_6$views<T1, T2, T3, T4, T5, T6> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<ValueTuple_6<T1, T2, T3, T4, T5, T6>>;
    As_IEquatable_1(): IEquatable_1$instance<ValueTuple_6<T1, T2, T3, T4, T5, T6>>;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: ValueTuple_6<T1, T2, T3, T4, T5, T6>): boolean;
    CompareTo(obj: unknown): int;
}

export interface ValueTuple_6$instance<T1, T2, T3, T4, T5, T6> extends IComparable_1$instance<ValueTuple_6<T1, T2, T3, T4, T5, T6>>, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type ValueTuple_6<T1, T2, T3, T4, T5, T6> = ValueTuple_6$instance<T1, T2, T3, T4, T5, T6> & __ValueTuple_6$views<T1, T2, T3, T4, T5, T6>;


export interface ValueTuple_7$instance<T1, T2, T3, T4, T5, T6, T7> {
    Item1: T1;
    Item2: T2;
    Item3: T3;
    Item4: T4;
    Item5: T5;
    Item6: T6;
    Item7: T7;
    CompareTo(other: ValueTuple_7<T1, T2, T3, T4, T5, T6, T7>): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(other: ValueTuple_7<T1, T2, T3, T4, T5, T6, T7>): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ValueTuple_7: {
    new<T1, T2, T3, T4, T5, T6, T7>(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7): ValueTuple_7<T1, T2, T3, T4, T5, T6, T7>;
};


export interface __ValueTuple_7$views<T1, T2, T3, T4, T5, T6, T7> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<ValueTuple_7<T1, T2, T3, T4, T5, T6, T7>>;
    As_IEquatable_1(): IEquatable_1$instance<ValueTuple_7<T1, T2, T3, T4, T5, T6, T7>>;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: ValueTuple_7<T1, T2, T3, T4, T5, T6, T7>): boolean;
    CompareTo(obj: unknown): int;
}

export interface ValueTuple_7$instance<T1, T2, T3, T4, T5, T6, T7> extends IComparable_1$instance<ValueTuple_7<T1, T2, T3, T4, T5, T6, T7>>, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type ValueTuple_7<T1, T2, T3, T4, T5, T6, T7> = ValueTuple_7$instance<T1, T2, T3, T4, T5, T6, T7> & __ValueTuple_7$views<T1, T2, T3, T4, T5, T6, T7>;


export interface ValueTuple_8$instance<T1, T2, T3, T4, T5, T6, T7, TRest extends unknown> {
    Item1: T1;
    Item2: T2;
    Item3: T3;
    Item4: T4;
    Item5: T5;
    Item6: T6;
    Item7: T7;
    Rest: TRest;
    CompareTo(other: ValueTuple_8<T1, T2, T3, T4, T5, T6, T7, TRest>): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(other: ValueTuple_8<T1, T2, T3, T4, T5, T6, T7, TRest>): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ValueTuple_8: {
    new<T1, T2, T3, T4, T5, T6, T7, TRest extends unknown>(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, rest: TRest): ValueTuple_8<T1, T2, T3, T4, T5, T6, T7, TRest>;
};


export interface __ValueTuple_8$views<T1, T2, T3, T4, T5, T6, T7, TRest extends unknown> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<ValueTuple_8<T1, T2, T3, T4, T5, T6, T7, TRest>>;
    As_IEquatable_1(): IEquatable_1$instance<ValueTuple_8<T1, T2, T3, T4, T5, T6, T7, TRest>>;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: ValueTuple_8<T1, T2, T3, T4, T5, T6, T7, TRest>): boolean;
    CompareTo(obj: unknown): int;
}

export interface ValueTuple_8$instance<T1, T2, T3, T4, T5, T6, T7, TRest extends unknown> extends IComparable_1$instance<ValueTuple_8<T1, T2, T3, T4, T5, T6, T7, TRest>>, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type ValueTuple_8<T1, T2, T3, T4, T5, T6, T7, TRest> = ValueTuple_8$instance<T1, T2, T3, T4, T5, T6, T7, TRest> & __ValueTuple_8$views<T1, T2, T3, T4, T5, T6, T7, TRest>;


export interface Void$instance {
}


export const Void: {
    new(): Void;
};


export type Void = Void$instance;

export interface AccessViolationException$instance extends SystemException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const AccessViolationException: {
    new(): AccessViolationException;
    new(message: string | undefined): AccessViolationException;
    new(message: string | undefined, innerException: Exception | undefined): AccessViolationException;
};


export interface __AccessViolationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AccessViolationException = AccessViolationException$instance & __AccessViolationException$views;


export interface AggregateException$instance extends Exception$instance {
    readonly InnerExceptions: ReadOnlyCollection_1<Exception>;
    readonly Message: string;
    Flatten(): AggregateException;
    GetBaseException(): Exception;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    Handle(predicate: Func_2<Exception, Boolean>): void;
    ToString(): string;
}


export const AggregateException: {
    new(): AggregateException;
    new(message: string | undefined): AggregateException;
    new(message: string | undefined, innerException: Exception): AggregateException;
    new(innerExceptions: IEnumerable_1<Exception>): AggregateException;
    new(innerExceptions: Exception[]): AggregateException;
    new(message: string | undefined, innerExceptions: IEnumerable_1<Exception>): AggregateException;
    new(message: string | undefined, innerExceptions: Exception[]): AggregateException;
};


export interface __AggregateException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AggregateException = AggregateException$instance & __AggregateException$views;


export interface AppDomain$instance extends MarshalByRefObject {
    readonly BaseDirectory: string;
    readonly DynamicDirectory: string | undefined;
    readonly FriendlyName: string;
    readonly Id: int;
    readonly IsFullyTrusted: boolean;
    readonly IsHomogenous: boolean;
    readonly MonitoringSurvivedMemorySize: long;
    readonly MonitoringTotalAllocatedMemorySize: long;
    readonly MonitoringTotalProcessorTime: TimeSpan;
    readonly PermissionSet: PermissionSet;
    readonly RelativeSearchPath: string | undefined;
    readonly SetupInformation: AppDomainSetup;
    readonly ShadowCopyFiles: boolean;
    AppendPrivatePath(path: string | undefined): void;
    ApplyPolicy(assemblyName: string): string;
    ClearPrivatePath(): void;
    ClearShadowCopyPath(): void;
    CreateInstance(assemblyName: string, typeName: string): ObjectHandle | undefined;
    CreateInstance(assemblyName: string, typeName: string, ignoreCase: boolean, bindingAttr: BindingFlags, binder: Binder | undefined, args: (unknown | undefined)[] | undefined, culture: CultureInfo | undefined, activationAttributes: (unknown | undefined)[] | undefined): ObjectHandle | undefined;
    CreateInstance(assemblyName: string, typeName: string, activationAttributes: (unknown | undefined)[] | undefined): ObjectHandle | undefined;
    CreateInstanceAndUnwrap(assemblyName: string, typeName: string): unknown | undefined;
    CreateInstanceAndUnwrap(assemblyName: string, typeName: string, ignoreCase: boolean, bindingAttr: BindingFlags, binder: Binder | undefined, args: (unknown | undefined)[] | undefined, culture: CultureInfo | undefined, activationAttributes: (unknown | undefined)[] | undefined): unknown | undefined;
    CreateInstanceAndUnwrap(assemblyName: string, typeName: string, activationAttributes: (unknown | undefined)[] | undefined): unknown | undefined;
    CreateInstanceFrom(assemblyFile: string, typeName: string): ObjectHandle | undefined;
    CreateInstanceFrom(assemblyFile: string, typeName: string, ignoreCase: boolean, bindingAttr: BindingFlags, binder: Binder | undefined, args: (unknown | undefined)[] | undefined, culture: CultureInfo | undefined, activationAttributes: (unknown | undefined)[] | undefined): ObjectHandle | undefined;
    CreateInstanceFrom(assemblyFile: string, typeName: string, activationAttributes: (unknown | undefined)[] | undefined): ObjectHandle | undefined;
    CreateInstanceFromAndUnwrap(assemblyFile: string, typeName: string): unknown | undefined;
    CreateInstanceFromAndUnwrap(assemblyFile: string, typeName: string, ignoreCase: boolean, bindingAttr: BindingFlags, binder: Binder | undefined, args: (unknown | undefined)[] | undefined, culture: CultureInfo | undefined, activationAttributes: (unknown | undefined)[] | undefined): unknown | undefined;
    CreateInstanceFromAndUnwrap(assemblyFile: string, typeName: string, activationAttributes: (unknown | undefined)[] | undefined): unknown | undefined;
    ExecuteAssembly(assemblyFile: string): int;
    ExecuteAssembly(assemblyFile: string, args: (string | undefined)[] | undefined): int;
    ExecuteAssembly(assemblyFile: string, args: (string | undefined)[] | undefined, hashValue: byte[] | undefined, hashAlgorithm: AssemblyHashAlgorithm): int;
    ExecuteAssemblyByName(assemblyName: AssemblyName, ...args: string[]): int;
    ExecuteAssemblyByName(assemblyName: string): int;
    ExecuteAssemblyByName(assemblyName: string, ...args: string[]): int;
    GetAssemblies(): Assembly[];
    GetData(name: string): unknown | undefined;
    IsCompatibilitySwitchSet(value: string): Nullable_1<Boolean>;
    IsDefaultAppDomain(): boolean;
    IsFinalizingForUnload(): boolean;
    Load(rawAssembly: byte[]): Assembly;
    Load(rawAssembly: byte[], rawSymbolStore: byte[] | undefined): Assembly;
    Load(assemblyRef: AssemblyName): Assembly;
    Load(assemblyString: string): Assembly;
    ReflectionOnlyGetAssemblies(): Assembly[];
    SetCachePath(path: string | undefined): void;
    SetData(name: string, data: unknown | undefined): void;
    SetDynamicBase(path: string | undefined): void;
    SetPrincipalPolicy(policy: PrincipalPolicy): void;
    SetShadowCopyFiles(): void;
    SetShadowCopyPath(path: string | undefined): void;
    SetThreadPrincipal(principal: IPrincipal): void;
    ToString(): string;
}


export const AppDomain: {
    new(): AppDomain;
    readonly CurrentDomain: AppDomain;
    MonitoringIsEnabled: boolean;
    readonly MonitoringSurvivedProcessMemorySize: long;
    CreateDomain(friendlyName: string): AppDomain;
    GetCurrentThreadId(): int;
    Unload(domain: AppDomain): void;
};


export type AppDomain = AppDomain$instance;

export interface AppDomainSetup$instance {
    readonly ApplicationBase: string | undefined;
    readonly TargetFrameworkName: string | undefined;
}


export const AppDomainSetup: {
    new(): AppDomainSetup;
};


export type AppDomainSetup = AppDomainSetup$instance;

export interface AppDomainUnloadedException$instance extends SystemException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const AppDomainUnloadedException: {
    new(): AppDomainUnloadedException;
    new(message: string | undefined): AppDomainUnloadedException;
    new(message: string | undefined, innerException: Exception | undefined): AppDomainUnloadedException;
};


export interface __AppDomainUnloadedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AppDomainUnloadedException = AppDomainUnloadedException$instance & __AppDomainUnloadedException$views;


export interface ApplicationException$instance extends Exception$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const ApplicationException: {
    new(): ApplicationException;
    new(message: string | undefined): ApplicationException;
    new(message: string | undefined, innerException: Exception | undefined): ApplicationException;
};


export interface __ApplicationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ApplicationException = ApplicationException$instance & __ApplicationException$views;


export interface ApplicationId$instance {
    readonly Culture: string;
    readonly Name: string;
    readonly ProcessorArchitecture: string | undefined;
    readonly PublicKeyToken: byte[];
    readonly Version: Version;
    Copy(): ApplicationId;
    Equals(o: unknown | undefined): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const ApplicationId: {
    new(publicKeyToken: byte[], name: string, version: Version, processorArchitecture: string | undefined, culture: string | undefined): ApplicationId;
};


export type ApplicationId = ApplicationId$instance;

export interface ArgumentException$instance extends SystemException$instance {
    readonly Message: string;
    readonly ParamName: string | undefined;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const ArgumentException: {
    new(): ArgumentException;
    new(message: string | undefined): ArgumentException;
    new(message: string | undefined, innerException: Exception | undefined): ArgumentException;
    new(message: string | undefined, paramName: string | undefined, innerException: Exception | undefined): ArgumentException;
    new(message: string | undefined, paramName: string | undefined): ArgumentException;
    ThrowIfNullOrEmpty(argument: string | undefined, paramName?: string | undefined): void;
    ThrowIfNullOrWhiteSpace(argument: string | undefined, paramName?: string | undefined): void;
};


export interface __ArgumentException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ArgumentException = ArgumentException$instance & __ArgumentException$views;


export interface ArgumentNullException$instance extends ArgumentException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const ArgumentNullException: {
    new(): ArgumentNullException;
    new(paramName: string | undefined): ArgumentNullException;
    new(message: string | undefined, innerException: Exception | undefined): ArgumentNullException;
    new(paramName: string | undefined, message: string | undefined): ArgumentNullException;
    ThrowIfNull(argument: unknown | undefined, paramName?: string | undefined): void;
    ThrowIfNull(argument: ptr<void>, paramName?: string | undefined): void;
};


export interface __ArgumentNullException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ArgumentNullException = ArgumentNullException$instance & __ArgumentNullException$views;


export interface ArgumentOutOfRangeException$instance extends ArgumentException$instance {
    readonly ActualValue: unknown | undefined;
    readonly Message: string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const ArgumentOutOfRangeException: {
    new(): ArgumentOutOfRangeException;
    new(paramName: string | undefined): ArgumentOutOfRangeException;
    new(paramName: string | undefined, message: string | undefined): ArgumentOutOfRangeException;
    new(message: string | undefined, innerException: Exception | undefined): ArgumentOutOfRangeException;
    new(paramName: string | undefined, actualValue: unknown | undefined, message: string | undefined): ArgumentOutOfRangeException;
    ThrowIfEqual<T>(value: T, other: T, paramName?: string | undefined): void;
    ThrowIfGreaterThan<T extends IComparable_1<T>>(value: T, other: T, paramName?: string | undefined): void;
    ThrowIfGreaterThanOrEqual<T extends IComparable_1<T>>(value: T, other: T, paramName?: string | undefined): void;
    ThrowIfLessThan<T extends IComparable_1<T>>(value: T, other: T, paramName?: string | undefined): void;
    ThrowIfLessThanOrEqual<T extends IComparable_1<T>>(value: T, other: T, paramName?: string | undefined): void;
    ThrowIfNegative<T extends INumberBase_1<T>>(value: T, paramName?: string | undefined): void;
    ThrowIfNegativeOrZero<T extends INumberBase_1<T>>(value: T, paramName?: string | undefined): void;
    ThrowIfNotEqual<T>(value: T, other: T, paramName?: string | undefined): void;
    ThrowIfZero<T extends INumberBase_1<T>>(value: T, paramName?: string | undefined): void;
};


export interface __ArgumentOutOfRangeException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ArgumentOutOfRangeException = ArgumentOutOfRangeException$instance & __ArgumentOutOfRangeException$views;


export interface ArithmeticException$instance extends SystemException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const ArithmeticException: {
    new(): ArithmeticException;
    new(message: string | undefined): ArithmeticException;
    new(message: string | undefined, innerException: Exception | undefined): ArithmeticException;
};


export interface __ArithmeticException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ArithmeticException = ArithmeticException$instance & __ArithmeticException$views;


export interface Array$instance {
    readonly IsFixedSize: boolean;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    readonly Length: int;
    readonly LongLength: long;
    readonly Rank: int;
    readonly SyncRoot: unknown;
    Clone(): unknown;
    CopyTo(array: Array, index: int): void;
    CopyTo(array: Array, index: long): void;
    GetEnumerator(): IEnumerator;
    GetLength(dimension: int): int;
    GetLongLength(dimension: int): long;
    GetLowerBound(dimension: int): int;
    GetUpperBound(dimension: int): int;
    GetValue(...indices: int[]): unknown | undefined;
    GetValue(index: int): unknown;
    GetValue(index1: int, index2: int): unknown | undefined;
    GetValue(index1: int, index2: int, index3: int): unknown | undefined;
    GetValue(index: long): unknown | undefined;
    GetValue(index1: long, index2: long): unknown | undefined;
    GetValue(index1: long, index2: long, index3: long): unknown | undefined;
    GetValue(...indices: long[]): unknown | undefined;
    Initialize(): void;
    SetValue(value: unknown | undefined, index: int): void;
    SetValue(value: unknown | undefined, index1: int, index2: int): void;
    SetValue(value: unknown | undefined, index1: int, index2: int, index3: int): void;
    SetValue(value: unknown | undefined, ...indices: int[]): void;
    SetValue(value: unknown | undefined, index: long): void;
    SetValue(value: unknown | undefined, index1: long, index2: long): void;
    SetValue(value: unknown | undefined, index1: long, index2: long, index3: long): void;
    SetValue(value: unknown | undefined, ...indices: long[]): void;
}


export const Array: {
    readonly MaxLength: int;
    AsReadOnly<T>(array: T[]): ReadOnlyCollection_1<T>;
    BinarySearch(array: Array, index: int, length: int, value: unknown | undefined, comparer: IComparer | undefined): int;
    BinarySearch(array: Array, index: int, length: int, value: unknown | undefined): int;
    BinarySearch(array: Array, value: unknown | undefined, comparer: IComparer | undefined): int;
    BinarySearch(array: Array, value: unknown | undefined): int;
    BinarySearch<T>(array: T[], index: int, length: int, value: T, comparer: IComparer_1<T> | undefined): int;
    BinarySearch<T>(array: T[], index: int, length: int, value: T): int;
    BinarySearch<T>(array: T[], value: T, comparer: IComparer_1<T> | undefined): int;
    BinarySearch<T>(array: T[], value: T): int;
    Clear(array: Array, index: int, length: int): void;
    Clear(array: Array): void;
    ConstrainedCopy(sourceArray: Array, sourceIndex: int, destinationArray: Array, destinationIndex: int, length: int): void;
    ConvertAll<TInput, TOutput>(array: TInput[], converter: Converter_2<TInput, TOutput>): TOutput[];
    Copy(sourceArray: Array, destinationArray: Array, length: int): void;
    Copy(sourceArray: Array, destinationArray: Array, length: long): void;
    Copy(sourceArray: Array, sourceIndex: int, destinationArray: Array, destinationIndex: int, length: int): void;
    Copy(sourceArray: Array, sourceIndex: long, destinationArray: Array, destinationIndex: long, length: long): void;
    CreateInstance(elementType: Type, length1: int, length2: int, length3: int): Array;
    CreateInstance(elementType: Type, length1: int, length2: int): Array;
    CreateInstance(elementType: Type, length: int): Array;
    CreateInstance(elementType: Type, lengths: int[], lowerBounds: int[]): Array;
    CreateInstance(elementType: Type, ...lengths: int[]): Array;
    CreateInstance(elementType: Type, ...lengths: long[]): Array;
    CreateInstanceFromArrayType(arrayType: Type, length: int): Array;
    CreateInstanceFromArrayType(arrayType: Type, lengths: int[], lowerBounds: int[]): Array;
    CreateInstanceFromArrayType(arrayType: Type, ...lengths: int[]): Array;
    Empty<T>(): T[];
    Exists<T>(array: T[], match: Predicate_1<T>): boolean;
    Fill<T>(array: T[], value: T, startIndex: int, count: int): void;
    Fill<T>(array: T[], value: T): void;
    Find<T>(array: T[], match: Predicate_1<T>): T | undefined;
    FindAll<T>(array: T[], match: Predicate_1<T>): T[];
    FindIndex<T>(array: T[], match: Predicate_1<T>): int;
    FindIndex<T>(array: T[], startIndex: int, match: Predicate_1<T>): int;
    FindIndex<T>(array: T[], startIndex: int, count: int, match: Predicate_1<T>): int;
    FindLast<T>(array: T[], match: Predicate_1<T>): T | undefined;
    FindLastIndex<T>(array: T[], match: Predicate_1<T>): int;
    FindLastIndex<T>(array: T[], startIndex: int, match: Predicate_1<T>): int;
    FindLastIndex<T>(array: T[], startIndex: int, count: int, match: Predicate_1<T>): int;
    ForEach<T>(array: T[], action: Action_1<T>): void;
    IndexOf(array: Array, value: unknown | undefined, startIndex: int, count: int): int;
    IndexOf(array: Array, value: unknown | undefined, startIndex: int): int;
    IndexOf(array: Array, value: unknown | undefined): int;
    IndexOf<T>(array: T[], value: T, startIndex: int, count: int): int;
    IndexOf<T>(array: T[], value: T, startIndex: int): int;
    IndexOf<T>(array: T[], value: T): int;
    LastIndexOf(array: Array, value: unknown | undefined, startIndex: int, count: int): int;
    LastIndexOf(array: Array, value: unknown | undefined, startIndex: int): int;
    LastIndexOf(array: Array, value: unknown | undefined): int;
    LastIndexOf<T>(array: T[], value: T, startIndex: int, count: int): int;
    LastIndexOf<T>(array: T[], value: T, startIndex: int): int;
    LastIndexOf<T>(array: T[], value: T): int;
    Resize<T>(array: T[] | undefined, newSize: int): void;
    Reverse(array: Array, index: int, length: int): void;
    Reverse(array: Array): void;
    Reverse<T>(array: T[], index: int, length: int): void;
    Reverse<T>(array: T[]): void;
    Sort(keys: Array, items: Array | undefined, comparer: IComparer | undefined): void;
    Sort(keys: Array, items: Array | undefined, index: int, length: int, comparer: IComparer | undefined): void;
    Sort(keys: Array, items: Array | undefined, index: int, length: int): void;
    Sort(keys: Array, items: Array | undefined): void;
    Sort(array: Array, comparer: IComparer | undefined): void;
    Sort(array: Array, index: int, length: int, comparer: IComparer | undefined): void;
    Sort(array: Array, index: int, length: int): void;
    Sort(array: Array): void;
    Sort<T>(array: T[], comparison: Comparison_1<T>): void;
    Sort<T>(array: T[], comparer: IComparer_1<T> | undefined): void;
    Sort<T>(array: T[], index: int, length: int, comparer: IComparer_1<T> | undefined): void;
    Sort<T>(array: T[], index: int, length: int): void;
    Sort<T>(array: T[]): void;
    Sort<TKey, TValue>(keys: TKey[], items: TValue[] | undefined, comparer: IComparer_1<TKey> | undefined): void;
    Sort<TKey, TValue>(keys: TKey[], items: TValue[] | undefined, index: int, length: int, comparer: IComparer_1<TKey> | undefined): void;
    Sort<TKey, TValue>(keys: TKey[], items: TValue[] | undefined, index: int, length: int): void;
    Sort<TKey, TValue>(keys: TKey[], items: TValue[] | undefined): void;
    TrueForAll<T>(array: T[], match: Predicate_1<T>): boolean;
};


export interface __Array$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_ICloneable(): ICloneable$instance;
}

export interface Array$instance extends System_Collections_Internal.IStructuralComparable$instance, ICloneable$instance {}

export type Array = Array$instance & __Array$views;


export interface ArrayTypeMismatchException$instance extends SystemException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const ArrayTypeMismatchException: {
    new(): ArrayTypeMismatchException;
    new(message: string | undefined): ArrayTypeMismatchException;
    new(message: string | undefined, innerException: Exception | undefined): ArrayTypeMismatchException;
};


export interface __ArrayTypeMismatchException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ArrayTypeMismatchException = ArrayTypeMismatchException$instance & __ArrayTypeMismatchException$views;


export interface AssemblyLoadEventArgs$instance extends EventArgs {
    readonly LoadedAssembly: Assembly;
}


export const AssemblyLoadEventArgs: {
    new(loadedAssembly: Assembly): AssemblyLoadEventArgs;
};


export type AssemblyLoadEventArgs = AssemblyLoadEventArgs$instance;

export interface Attribute$instance {
    readonly TypeId: unknown;
    Equals(obj: unknown | undefined): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
    Match(obj: unknown | undefined): boolean;
}


export const Attribute: {
    GetCustomAttribute(element: Assembly, attributeType: Type, inherit: boolean): Attribute | undefined;
    GetCustomAttribute(element: Assembly, attributeType: Type): Attribute | undefined;
    GetCustomAttribute(element: MemberInfo, attributeType: Type, inherit: boolean): Attribute | undefined;
    GetCustomAttribute(element: MemberInfo, attributeType: Type): Attribute | undefined;
    GetCustomAttribute(element: Module, attributeType: Type, inherit: boolean): Attribute | undefined;
    GetCustomAttribute(element: Module, attributeType: Type): Attribute | undefined;
    GetCustomAttribute(element: ParameterInfo, attributeType: Type, inherit: boolean): Attribute | undefined;
    GetCustomAttribute(element: ParameterInfo, attributeType: Type): Attribute | undefined;
    GetCustomAttributes(element: Assembly, inherit: boolean): Attribute[];
    GetCustomAttributes(element: Assembly, attributeType: Type, inherit: boolean): Attribute[];
    GetCustomAttributes(element: Assembly, attributeType: Type): Attribute[];
    GetCustomAttributes(element: Assembly): Attribute[];
    GetCustomAttributes(element: MemberInfo, inherit: boolean): Attribute[];
    GetCustomAttributes(element: MemberInfo, attributeType: Type, inherit: boolean): Attribute[];
    GetCustomAttributes(element: MemberInfo, attributeType: Type): Attribute[];
    GetCustomAttributes(element: MemberInfo): Attribute[];
    GetCustomAttributes(element: Module, inherit: boolean): Attribute[];
    GetCustomAttributes(element: Module, attributeType: Type, inherit: boolean): Attribute[];
    GetCustomAttributes(element: Module, attributeType: Type): Attribute[];
    GetCustomAttributes(element: Module): Attribute[];
    GetCustomAttributes(element: ParameterInfo, inherit: boolean): Attribute[];
    GetCustomAttributes(element: ParameterInfo, attributeType: Type, inherit: boolean): Attribute[];
    GetCustomAttributes(element: ParameterInfo, attributeType: Type): Attribute[];
    GetCustomAttributes(element: ParameterInfo): Attribute[];
    IsDefined(element: Assembly, attributeType: Type, inherit: boolean): boolean;
    IsDefined(element: Assembly, attributeType: Type): boolean;
    IsDefined(element: MemberInfo, attributeType: Type, inherit: boolean): boolean;
    IsDefined(element: MemberInfo, attributeType: Type): boolean;
    IsDefined(element: Module, attributeType: Type, inherit: boolean): boolean;
    IsDefined(element: Module, attributeType: Type): boolean;
    IsDefined(element: ParameterInfo, attributeType: Type, inherit: boolean): boolean;
    IsDefined(element: ParameterInfo, attributeType: Type): boolean;
};


export type Attribute = Attribute$instance;

export interface AttributeUsageAttribute$instance extends Attribute {
    AllowMultiple: boolean;
    Inherited: boolean;
    readonly ValidOn: AttributeTargets;
}


export const AttributeUsageAttribute: {
    new(validOn: AttributeTargets): AttributeUsageAttribute;
};


export type AttributeUsageAttribute = AttributeUsageAttribute$instance;

export interface BadImageFormatException$instance extends SystemException$instance {
    readonly FileName: string;
    readonly FusionLog: string | undefined;
    readonly Message: string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    ToString(): string;
}


export const BadImageFormatException: {
    new(): BadImageFormatException;
    new(message: string | undefined): BadImageFormatException;
    new(message: string | undefined, inner: Exception | undefined): BadImageFormatException;
    new(message: string | undefined, fileName: string | undefined): BadImageFormatException;
    new(message: string | undefined, fileName: string | undefined, inner: Exception | undefined): BadImageFormatException;
};


export interface __BadImageFormatException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type BadImageFormatException = BadImageFormatException$instance & __BadImageFormatException$views;


export interface CannotUnloadAppDomainException$instance extends SystemException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const CannotUnloadAppDomainException: {
    new(): CannotUnloadAppDomainException;
    new(message: string | undefined): CannotUnloadAppDomainException;
    new(message: string | undefined, innerException: Exception | undefined): CannotUnloadAppDomainException;
};


export interface __CannotUnloadAppDomainException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type CannotUnloadAppDomainException = CannotUnloadAppDomainException$instance & __CannotUnloadAppDomainException$views;


export interface CharEnumerator$instance extends IDisposable {
    readonly Current: char;
    Clone(): unknown;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export const CharEnumerator: {
    new(): CharEnumerator;
};


export interface __CharEnumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<Char>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_ICloneable(): ICloneable$instance;
}

export interface CharEnumerator$instance extends ICloneable$instance {}

export type CharEnumerator = CharEnumerator$instance & __CharEnumerator$views;


export interface CLSCompliantAttribute$instance extends Attribute {
    readonly IsCompliant: boolean;
}


export const CLSCompliantAttribute: {
    new(isCompliant: boolean): CLSCompliantAttribute;
};


export type CLSCompliantAttribute = CLSCompliantAttribute$instance;

export interface ConsoleCancelEventArgs$instance extends EventArgs {
    Cancel: boolean;
    readonly SpecialKey: ConsoleSpecialKey;
}


export const ConsoleCancelEventArgs: {
    new(): ConsoleCancelEventArgs;
};


export type ConsoleCancelEventArgs = ConsoleCancelEventArgs$instance;

export interface ContextBoundObject$instance extends MarshalByRefObject {
}


export const ContextBoundObject: {
};


export type ContextBoundObject = ContextBoundObject$instance;

export interface ContextMarshalException$instance extends SystemException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const ContextMarshalException: {
    new(): ContextMarshalException;
    new(message: string | undefined): ContextMarshalException;
    new(message: string | undefined, inner: Exception | undefined): ContextMarshalException;
};


export interface __ContextMarshalException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ContextMarshalException = ContextMarshalException$instance & __ContextMarshalException$views;


export interface ContextStaticAttribute$instance extends Attribute {
}


export const ContextStaticAttribute: {
    new(): ContextStaticAttribute;
};


export type ContextStaticAttribute = ContextStaticAttribute$instance;

export interface CultureAwareComparer$instance extends StringComparer$instance {
    Compare(x: string | undefined, y: string | undefined): int;
    Compare(x: unknown | undefined, y: unknown | undefined): int;
    Compare(x: unknown, y: unknown): int;
    Equals(x: string | undefined, y: string | undefined): boolean;
    Equals(x: unknown | undefined, y: unknown | undefined): boolean;
    Equals(x: unknown, y: unknown): boolean;
    GetHashCode(obj: string): int;
    GetHashCode(obj: unknown): int;
    GetHashCode(obj: unknown): int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const CultureAwareComparer: {
    new(): CultureAwareComparer;
};


export interface __CultureAwareComparer$views {
    As_IAlternateEqualityComparer_2(): System_Collections_Generic_Internal.IAlternateEqualityComparer_2$instance<ReadOnlySpan_1<Char>, String>;
    As_IComparer_1(): System_Collections_Generic_Internal.IComparer_1$instance<String>;
    As_IEqualityComparer_1(): System_Collections_Generic_Internal.IEqualityComparer_1$instance<String>;
    As_IComparer(): System_Collections_Internal.IComparer$instance;
    As_IEqualityComparer(): System_Collections_Internal.IEqualityComparer$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface CultureAwareComparer$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type CultureAwareComparer = CultureAwareComparer$instance & __CultureAwareComparer$views;


export interface DataMisalignedException$instance extends SystemException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const DataMisalignedException: {
    new(): DataMisalignedException;
    new(message: string | undefined): DataMisalignedException;
    new(message: string | undefined, innerException: Exception | undefined): DataMisalignedException;
};


export interface __DataMisalignedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DataMisalignedException = DataMisalignedException$instance & __DataMisalignedException$views;


export interface DBNull$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    GetTypeCode(): TypeCode;
    ToString(): string;
    ToString(provider: IFormatProvider | undefined): string;
}


export const DBNull: {
    new(): DBNull;
    readonly Value: DBNull;
};


export interface __DBNull$views {
    As_IConvertible(): IConvertible$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface DBNull$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type DBNull = DBNull$instance & __DBNull$views;


export interface Delegate$instance {
    readonly HasSingleTarget: boolean;
    readonly Method: MethodInfo;
    readonly Target: unknown;
    Clone(): unknown;
    DynamicInvoke(...args: unknown[]): unknown | undefined;
    Equals(obj: unknown | undefined): boolean;
    GetHashCode(): int;
    GetInvocationList(): Function[];
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const Delegate: {
    Combine(a: Function | undefined, b: Function | undefined): Function | undefined;
    Combine(...delegates: Function[]): Function | undefined;
    Combine(delegates: ReadOnlySpan_1<Function>): Function | undefined;
    CreateDelegate(type_: Type, firstArgument: unknown | undefined, method: MethodInfo, throwOnBindFailure: boolean): Function | undefined;
    CreateDelegate(type_: Type, firstArgument: unknown | undefined, method: MethodInfo): Function;
    CreateDelegate(type_: Type, target: unknown, method: string, ignoreCase: boolean, throwOnBindFailure: boolean): Function | undefined;
    CreateDelegate(type_: Type, target: unknown, method: string, ignoreCase: boolean): Function;
    CreateDelegate(type_: Type, target: unknown, method: string): Function;
    CreateDelegate(type_: Type, method: MethodInfo, throwOnBindFailure: boolean): Function | undefined;
    CreateDelegate(type_: Type, method: MethodInfo): Function;
    CreateDelegate(type_: Type, target: Type, method: string, ignoreCase: boolean, throwOnBindFailure: boolean): Function | undefined;
    CreateDelegate(type_: Type, target: Type, method: string, ignoreCase: boolean): Function;
    CreateDelegate(type_: Type, target: Type, method: string): Function;
    EnumerateInvocationList<TDelegate extends Function>(d: TDelegate | undefined): Delegate_InvocationListEnumerator_1<TDelegate>;
    Remove(source: Function | undefined, value: Function | undefined): Function | undefined;
    RemoveAll(source: Function | undefined, value: Function | undefined): Function | undefined;
};


export interface __Delegate$views {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Delegate$instance extends ICloneable$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Delegate = Delegate$instance & __Delegate$views;


export interface DivideByZeroException$instance extends ArithmeticException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const DivideByZeroException: {
    new(): DivideByZeroException;
    new(message: string | undefined): DivideByZeroException;
    new(message: string | undefined, innerException: Exception | undefined): DivideByZeroException;
};


export interface __DivideByZeroException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DivideByZeroException = DivideByZeroException$instance & __DivideByZeroException$views;


export interface DllNotFoundException$instance extends TypeLoadException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const DllNotFoundException: {
    new(): DllNotFoundException;
    new(message: string | undefined): DllNotFoundException;
    new(message: string | undefined, inner: Exception | undefined): DllNotFoundException;
};


export interface __DllNotFoundException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DllNotFoundException = DllNotFoundException$instance & __DllNotFoundException$views;


export interface DuplicateWaitObjectException$instance extends ArgumentException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const DuplicateWaitObjectException: {
    new(): DuplicateWaitObjectException;
    new(parameterName: string | undefined): DuplicateWaitObjectException;
    new(parameterName: string | undefined, message: string | undefined): DuplicateWaitObjectException;
    new(message: string | undefined, innerException: Exception | undefined): DuplicateWaitObjectException;
};


export interface __DuplicateWaitObjectException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type DuplicateWaitObjectException = DuplicateWaitObjectException$instance & __DuplicateWaitObjectException$views;


export interface EntryPointNotFoundException$instance extends TypeLoadException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const EntryPointNotFoundException: {
    new(): EntryPointNotFoundException;
    new(message: string | undefined): EntryPointNotFoundException;
    new(message: string | undefined, inner: Exception | undefined): EntryPointNotFoundException;
};


export interface __EntryPointNotFoundException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type EntryPointNotFoundException = EntryPointNotFoundException$instance & __EntryPointNotFoundException$views;


export interface Enum$instance {
    CompareTo(target: unknown | undefined): int;
    Equals(obj: unknown | undefined): boolean;
    GetHashCode(): int;
    GetTypeCode(): TypeCode;
    HasFlag(flag: number): boolean;
    ToString(): string;
    ToString(format: string | undefined): string;
    ToString(provider: IFormatProvider | undefined): string;
    ToString(format: string | undefined, provider: IFormatProvider | undefined): string;
}


export const Enum: {
    Format(enumType: Type, value: unknown, format: string): string;
    GetName(enumType: Type, value: unknown): string | undefined;
    GetName<TEnum extends number>(value: TEnum): string | undefined;
    GetNames<TEnum extends number>(): string[];
    GetNames(enumType: Type): string[];
    GetUnderlyingType(enumType: Type): Type;
    GetValues<TEnum extends number>(): TEnum[];
    GetValues(enumType: Type): Array;
    GetValuesAsUnderlyingType<TEnum extends number>(): Array;
    GetValuesAsUnderlyingType(enumType: Type): Array;
    IsDefined(enumType: Type, value: unknown): boolean;
    IsDefined<TEnum extends number>(value: TEnum): boolean;
    Parse<TEnum extends unknown>(value: ReadOnlySpan_1<Char>, ignoreCase: boolean): TEnum;
    Parse<TEnum extends unknown>(value: ReadOnlySpan_1<Char>): TEnum;
    Parse<TEnum extends unknown>(value: string, ignoreCase: boolean): TEnum;
    Parse<TEnum extends unknown>(value: string): TEnum;
    Parse(enumType: Type, value: ReadOnlySpan_1<Char>, ignoreCase: boolean): unknown;
    Parse(enumType: Type, value: ReadOnlySpan_1<Char>): unknown;
    Parse(enumType: Type, value: string, ignoreCase: boolean): unknown;
    Parse(enumType: Type, value: string): unknown;
    ToObject(enumType: Type, value: byte): unknown;
    ToObject(enumType: Type, value: short): unknown;
    ToObject(enumType: Type, value: int): unknown;
    ToObject(enumType: Type, value: long): unknown;
    ToObject(enumType: Type, value: unknown): unknown;
    ToObject(enumType: Type, value: sbyte): unknown;
    ToObject(enumType: Type, value: ushort): unknown;
    ToObject(enumType: Type, value: uint): unknown;
    ToObject(enumType: Type, value: ulong): unknown;
    TryFormat<TEnum extends unknown>(value: TEnum, destination: Span_1<Char>, charsWritten: int, format?: ReadOnlySpan_1<Char>): boolean;
    TryParse<TEnum extends unknown>(value: ReadOnlySpan_1<Char>, ignoreCase: boolean, result: TEnum): boolean;
    TryParse<TEnum extends unknown>(value: ReadOnlySpan_1<Char>, result: TEnum): boolean;
    TryParse<TEnum extends unknown>(value: string | undefined, ignoreCase: boolean, result: TEnum): boolean;
    TryParse<TEnum extends unknown>(value: string | undefined, result: TEnum): boolean;
    TryParse(enumType: Type, value: ReadOnlySpan_1<Char>, ignoreCase: boolean, result: unknown | undefined): boolean;
    TryParse(enumType: Type, value: ReadOnlySpan_1<Char>, result: unknown | undefined): boolean;
    TryParse(enumType: Type, value: string | undefined, ignoreCase: boolean, result: unknown | undefined): boolean;
    TryParse(enumType: Type, value: string | undefined, result: unknown | undefined): boolean;
};


export interface __Enum$views {
    As_IComparable(): IComparable$instance;
    As_IConvertible(): IConvertible$instance;
    As_IFormattable(): IFormattable$instance;
    As_ISpanFormattable(): ISpanFormattable$instance;

    // Structural method bridges for numeric interface constraints
    CompareTo(obj: unknown): int;
}

export interface Enum$instance extends IComparable$instance {}

export type Enum = Enum$instance & __Enum$views;


export interface EventArgs$instance {
}


export const EventArgs: {
    new(): EventArgs;
    readonly Empty: EventArgs;
};


export type EventArgs = EventArgs$instance;

export interface Exception$instance {
    readonly Data: IDictionary;
    HelpLink: string | undefined;
    HResult: int;
    readonly InnerException: Exception | undefined;
    readonly Message: string;
    Source: string;
    readonly StackTrace: string | undefined;
    readonly TargetSite: MethodBase | undefined;
    GetBaseException(): Exception;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    GetType(): Type;
    ToString(): string;
}


export const Exception: {
    new(): Exception;
    new(message: string | undefined): Exception;
    new(message: string | undefined, innerException: Exception | undefined): Exception;
};


export interface __Exception$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Exception$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Exception = Exception$instance & __Exception$views;


export interface ExecutionEngineException$instance extends SystemException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const ExecutionEngineException: {
    new(): ExecutionEngineException;
    new(message: string | undefined): ExecutionEngineException;
    new(message: string | undefined, innerException: Exception | undefined): ExecutionEngineException;
};


export interface __ExecutionEngineException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ExecutionEngineException = ExecutionEngineException$instance & __ExecutionEngineException$views;


export interface FieldAccessException$instance extends MemberAccessException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const FieldAccessException: {
    new(): FieldAccessException;
    new(message: string | undefined): FieldAccessException;
    new(message: string | undefined, inner: Exception | undefined): FieldAccessException;
};


export interface __FieldAccessException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type FieldAccessException = FieldAccessException$instance & __FieldAccessException$views;


export interface FileStyleUriParser$instance extends UriParser {
}


export const FileStyleUriParser: {
    new(): FileStyleUriParser;
};


export type FileStyleUriParser = FileStyleUriParser$instance;

export interface FlagsAttribute$instance extends Attribute {
}


export const FlagsAttribute: {
    new(): FlagsAttribute;
};


export type FlagsAttribute = FlagsAttribute$instance;

export interface FormatException$instance extends SystemException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const FormatException: {
    new(): FormatException;
    new(message: string | undefined): FormatException;
    new(message: string | undefined, innerException: Exception | undefined): FormatException;
};


export interface __FormatException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type FormatException = FormatException$instance & __FormatException$views;


export interface FormattableString$instance {
    readonly ArgumentCount: int;
    readonly Format: string;
    GetArgument(index: int): unknown;
    GetArguments(): (unknown | undefined)[];
    ToString(formatProvider: IFormatProvider | undefined): string;
    ToString(): string;
}


export const FormattableString: {
    CurrentCulture(formattable: FormattableString): string;
    Invariant(formattable: FormattableString): string;
};


export interface __FormattableString$views {
    As_IFormattable(): IFormattable$instance;
}

export type FormattableString = FormattableString$instance & __FormattableString$views;


export interface FtpStyleUriParser$instance extends UriParser {
}


export const FtpStyleUriParser: {
    new(): FtpStyleUriParser;
};


export type FtpStyleUriParser = FtpStyleUriParser$instance;

export interface GenericUriParser$instance extends UriParser {
}


export const GenericUriParser: {
    new(options: GenericUriParserOptions): GenericUriParser;
};


export type GenericUriParser = GenericUriParser$instance;

export interface GopherStyleUriParser$instance extends UriParser {
}


export const GopherStyleUriParser: {
    new(): GopherStyleUriParser;
};


export type GopherStyleUriParser = GopherStyleUriParser$instance;

export interface HttpStyleUriParser$instance extends UriParser {
}


export const HttpStyleUriParser: {
    new(): HttpStyleUriParser;
};


export type HttpStyleUriParser = HttpStyleUriParser$instance;

export interface IndexOutOfRangeException$instance extends SystemException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const IndexOutOfRangeException: {
    new(): IndexOutOfRangeException;
    new(message: string | undefined): IndexOutOfRangeException;
    new(message: string | undefined, innerException: Exception | undefined): IndexOutOfRangeException;
};


export interface __IndexOutOfRangeException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type IndexOutOfRangeException = IndexOutOfRangeException$instance & __IndexOutOfRangeException$views;


export interface InsufficientExecutionStackException$instance extends SystemException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const InsufficientExecutionStackException: {
    new(): InsufficientExecutionStackException;
    new(message: string | undefined): InsufficientExecutionStackException;
    new(message: string | undefined, innerException: Exception | undefined): InsufficientExecutionStackException;
};


export interface __InsufficientExecutionStackException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InsufficientExecutionStackException = InsufficientExecutionStackException$instance & __InsufficientExecutionStackException$views;


export interface InsufficientMemoryException$instance extends OutOfMemoryException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const InsufficientMemoryException: {
    new(): InsufficientMemoryException;
    new(message: string | undefined): InsufficientMemoryException;
    new(message: string | undefined, innerException: Exception | undefined): InsufficientMemoryException;
};


export interface __InsufficientMemoryException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InsufficientMemoryException = InsufficientMemoryException$instance & __InsufficientMemoryException$views;


export interface InvalidCastException$instance extends SystemException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const InvalidCastException: {
    new(): InvalidCastException;
    new(message: string | undefined): InvalidCastException;
    new(message: string | undefined, innerException: Exception | undefined): InvalidCastException;
    new(message: string | undefined, errorCode: int): InvalidCastException;
};


export interface __InvalidCastException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidCastException = InvalidCastException$instance & __InvalidCastException$views;


export interface InvalidOperationException$instance extends SystemException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const InvalidOperationException: {
    new(): InvalidOperationException;
    new(message: string | undefined): InvalidOperationException;
    new(message: string | undefined, innerException: Exception | undefined): InvalidOperationException;
};


export interface __InvalidOperationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidOperationException = InvalidOperationException$instance & __InvalidOperationException$views;


export interface InvalidProgramException$instance extends SystemException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const InvalidProgramException: {
    new(): InvalidProgramException;
    new(message: string | undefined): InvalidProgramException;
    new(message: string | undefined, inner: Exception | undefined): InvalidProgramException;
};


export interface __InvalidProgramException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidProgramException = InvalidProgramException$instance & __InvalidProgramException$views;


export interface InvalidTimeZoneException$instance extends Exception$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const InvalidTimeZoneException: {
    new(): InvalidTimeZoneException;
    new(message: string | undefined): InvalidTimeZoneException;
    new(message: string | undefined, innerException: Exception | undefined): InvalidTimeZoneException;
};


export interface __InvalidTimeZoneException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidTimeZoneException = InvalidTimeZoneException$instance & __InvalidTimeZoneException$views;


export interface Lazy_1$instance<T> {
    readonly IsValueCreated: boolean;
    readonly Value: T;
    ToString(): string | undefined;
}


export const Lazy_1: {
    new<T>(): Lazy_1<T>;
    new<T>(value: T): Lazy_1<T>;
    new<T>(valueFactory: Func_1<T>): Lazy_1<T>;
    new<T>(isThreadSafe: boolean): Lazy_1<T>;
    new<T>(mode: LazyThreadSafetyMode): Lazy_1<T>;
    new<T>(valueFactory: Func_1<T>, isThreadSafe: boolean): Lazy_1<T>;
    new<T>(valueFactory: Func_1<T>, mode: LazyThreadSafetyMode): Lazy_1<T>;
};


export type Lazy_1<T> = Lazy_1$instance<T>;

export interface Lazy_2$instance<T, TMetadata> extends Lazy_1<T> {
    readonly Metadata: TMetadata;
}


export const Lazy_2: {
    new<T, TMetadata>(valueFactory: Func_1<T>, metadata: TMetadata): Lazy_2<T, TMetadata>;
    new<T, TMetadata>(metadata: TMetadata): Lazy_2<T, TMetadata>;
    new<T, TMetadata>(metadata: TMetadata, isThreadSafe: boolean): Lazy_2<T, TMetadata>;
    new<T, TMetadata>(valueFactory: Func_1<T>, metadata: TMetadata, isThreadSafe: boolean): Lazy_2<T, TMetadata>;
    new<T, TMetadata>(metadata: TMetadata, mode: LazyThreadSafetyMode): Lazy_2<T, TMetadata>;
    new<T, TMetadata>(valueFactory: Func_1<T>, metadata: TMetadata, mode: LazyThreadSafetyMode): Lazy_2<T, TMetadata>;
};


export type Lazy_2<T, TMetadata> = Lazy_2$instance<T, TMetadata>;

export interface LdapStyleUriParser$instance extends UriParser {
}


export const LdapStyleUriParser: {
    new(): LdapStyleUriParser;
};


export type LdapStyleUriParser = LdapStyleUriParser$instance;

export interface LoaderOptimizationAttribute$instance extends Attribute {
    readonly Value: LoaderOptimization;
}


export const LoaderOptimizationAttribute: {
    new(value: byte): LoaderOptimizationAttribute;
    new(value: LoaderOptimization): LoaderOptimizationAttribute;
};


export type LoaderOptimizationAttribute = LoaderOptimizationAttribute$instance;

export interface LocalDataStoreSlot$instance {
}


export const LocalDataStoreSlot: {
    new(): LocalDataStoreSlot;
};


export type LocalDataStoreSlot = LocalDataStoreSlot$instance;

export interface MarshalByRefObject$instance {
    GetLifetimeService(): unknown;
    InitializeLifetimeService(): unknown;
}


export const MarshalByRefObject: {
};


export type MarshalByRefObject = MarshalByRefObject$instance;

export interface MemberAccessException$instance extends SystemException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const MemberAccessException: {
    new(): MemberAccessException;
    new(message: string | undefined): MemberAccessException;
    new(message: string | undefined, inner: Exception | undefined): MemberAccessException;
};


export interface __MemberAccessException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MemberAccessException = MemberAccessException$instance & __MemberAccessException$views;


export interface MethodAccessException$instance extends MemberAccessException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const MethodAccessException: {
    new(): MethodAccessException;
    new(message: string | undefined): MethodAccessException;
    new(message: string | undefined, inner: Exception | undefined): MethodAccessException;
};


export interface __MethodAccessException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MethodAccessException = MethodAccessException$instance & __MethodAccessException$views;


export interface MissingFieldException$instance extends MissingMemberException$instance {
    readonly Message: string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const MissingFieldException: {
    new(): MissingFieldException;
    new(message: string | undefined): MissingFieldException;
    new(message: string | undefined, inner: Exception | undefined): MissingFieldException;
    new(className: string | undefined, fieldName: string | undefined): MissingFieldException;
};


export interface __MissingFieldException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MissingFieldException = MissingFieldException$instance & __MissingFieldException$views;


export interface MissingMemberException$instance extends MemberAccessException$instance {
    readonly Message: string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const MissingMemberException: {
    new(): MissingMemberException;
    new(message: string | undefined): MissingMemberException;
    new(message: string | undefined, inner: Exception | undefined): MissingMemberException;
    new(className: string | undefined, memberName: string | undefined): MissingMemberException;
};


export interface __MissingMemberException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MissingMemberException = MissingMemberException$instance & __MissingMemberException$views;


export interface MissingMethodException$instance extends MissingMemberException$instance {
    readonly Message: string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const MissingMethodException: {
    new(): MissingMethodException;
    new(message: string | undefined): MissingMethodException;
    new(message: string | undefined, inner: Exception | undefined): MissingMethodException;
    new(className: string | undefined, methodName: string | undefined): MissingMethodException;
};


export interface __MissingMethodException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MissingMethodException = MissingMethodException$instance & __MissingMethodException$views;


export interface MTAThreadAttribute$instance extends Attribute {
}


export const MTAThreadAttribute: {
    new(): MTAThreadAttribute;
};


export type MTAThreadAttribute = MTAThreadAttribute$instance;

export interface MulticastDelegate$instance extends Function {
    Clone(): unknown;
    Equals(obj: unknown | undefined): boolean;
    GetHashCode(): int;
    GetInvocationList(): Function[];
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const MulticastDelegate: {
};


export interface __MulticastDelegate$views {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MulticastDelegate = MulticastDelegate$instance & __MulticastDelegate$views;


export interface MulticastNotSupportedException$instance extends SystemException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const MulticastNotSupportedException: {
    new(): MulticastNotSupportedException;
    new(message: string | undefined): MulticastNotSupportedException;
    new(message: string | undefined, inner: Exception | undefined): MulticastNotSupportedException;
};


export interface __MulticastNotSupportedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type MulticastNotSupportedException = MulticastNotSupportedException$instance & __MulticastNotSupportedException$views;


export interface NetPipeStyleUriParser$instance extends UriParser {
}


export const NetPipeStyleUriParser: {
    new(): NetPipeStyleUriParser;
};


export type NetPipeStyleUriParser = NetPipeStyleUriParser$instance;

export interface NetTcpStyleUriParser$instance extends UriParser {
}


export const NetTcpStyleUriParser: {
    new(): NetTcpStyleUriParser;
};


export type NetTcpStyleUriParser = NetTcpStyleUriParser$instance;

export interface NewsStyleUriParser$instance extends UriParser {
}


export const NewsStyleUriParser: {
    new(): NewsStyleUriParser;
};


export type NewsStyleUriParser = NewsStyleUriParser$instance;

export interface NonSerializedAttribute$instance extends Attribute {
}


export const NonSerializedAttribute: {
    new(): NonSerializedAttribute;
};


export type NonSerializedAttribute = NonSerializedAttribute$instance;

export interface NotFiniteNumberException$instance extends ArithmeticException$instance {
    readonly OffendingNumber: double;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const NotFiniteNumberException: {
    new(): NotFiniteNumberException;
    new(offendingNumber: double): NotFiniteNumberException;
    new(message: string | undefined): NotFiniteNumberException;
    new(message: string | undefined, offendingNumber: double): NotFiniteNumberException;
    new(message: string | undefined, innerException: Exception | undefined): NotFiniteNumberException;
    new(message: string | undefined, offendingNumber: double, innerException: Exception | undefined): NotFiniteNumberException;
};


export interface __NotFiniteNumberException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type NotFiniteNumberException = NotFiniteNumberException$instance & __NotFiniteNumberException$views;


export interface NotImplementedException$instance extends SystemException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const NotImplementedException: {
    new(): NotImplementedException;
    new(message: string | undefined): NotImplementedException;
    new(message: string | undefined, inner: Exception | undefined): NotImplementedException;
};


export interface __NotImplementedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type NotImplementedException = NotImplementedException$instance & __NotImplementedException$views;


export interface NotSupportedException$instance extends SystemException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const NotSupportedException: {
    new(): NotSupportedException;
    new(message: string | undefined): NotSupportedException;
    new(message: string | undefined, innerException: Exception | undefined): NotSupportedException;
};


export interface __NotSupportedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type NotSupportedException = NotSupportedException$instance & __NotSupportedException$views;


export interface NullReferenceException$instance extends SystemException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const NullReferenceException: {
    new(): NullReferenceException;
    new(message: string | undefined): NullReferenceException;
    new(message: string | undefined, innerException: Exception | undefined): NullReferenceException;
};


export interface __NullReferenceException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type NullReferenceException = NullReferenceException$instance & __NullReferenceException$views;


export interface Object$instance {
    Equals(obj: unknown | undefined): boolean;
    GetHashCode(): int;
    GetType(): Type;
    ToString(): string | undefined;
}


export const Object: {
    new(): Object;
    Equals(objA: unknown | undefined, objB: unknown | undefined): boolean;
    ReferenceEquals(objA: unknown | undefined, objB: unknown | undefined): boolean;
};


export type Object = Object$instance;

export interface ObjectDisposedException$instance extends InvalidOperationException$instance {
    readonly Message: string;
    readonly ObjectName: string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const ObjectDisposedException: {
    new(objectName: string | undefined): ObjectDisposedException;
    new(objectName: string | undefined, message: string | undefined): ObjectDisposedException;
    new(message: string | undefined, innerException: Exception | undefined): ObjectDisposedException;
    ThrowIf(condition: boolean, instance: unknown): void;
    ThrowIf(condition: boolean, type_: Type): void;
};


export interface __ObjectDisposedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ObjectDisposedException = ObjectDisposedException$instance & __ObjectDisposedException$views;


export interface ObsoleteAttribute$instance extends Attribute {
    DiagnosticId: string;
    readonly IsError: boolean;
    readonly Message: string;
    UrlFormat: string | undefined;
}


export const ObsoleteAttribute: {
    new(): ObsoleteAttribute;
    new(message: string | undefined): ObsoleteAttribute;
    new(message: string | undefined, error: boolean): ObsoleteAttribute;
};


export type ObsoleteAttribute = ObsoleteAttribute$instance;

export interface OperatingSystem$instance {
    readonly Platform: PlatformID;
    readonly ServicePack: string;
    readonly Version: Version;
    readonly VersionString: string;
    Clone(): unknown;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    ToString(): string;
}


export const OperatingSystem: {
    new(platform: PlatformID, version: Version): OperatingSystem;
    IsAndroid(): boolean;
    IsAndroidVersionAtLeast(major: int, minor?: int, build?: int, revision?: int): boolean;
    IsBrowser(): boolean;
    IsFreeBSD(): boolean;
    IsFreeBSDVersionAtLeast(major: int, minor?: int, build?: int, revision?: int): boolean;
    IsIOS(): boolean;
    IsIOSVersionAtLeast(major: int, minor?: int, build?: int): boolean;
    IsLinux(): boolean;
    IsMacCatalyst(): boolean;
    IsMacCatalystVersionAtLeast(major: int, minor?: int, build?: int): boolean;
    IsMacOS(): boolean;
    IsMacOSVersionAtLeast(major: int, minor?: int, build?: int): boolean;
    IsOSPlatform(platform: string): boolean;
    IsOSPlatformVersionAtLeast(platform: string, major: int, minor?: int, build?: int, revision?: int): boolean;
    IsTvOS(): boolean;
    IsTvOSVersionAtLeast(major: int, minor?: int, build?: int): boolean;
    IsWasi(): boolean;
    IsWatchOS(): boolean;
    IsWatchOSVersionAtLeast(major: int, minor?: int, build?: int): boolean;
    IsWindows(): boolean;
    IsWindowsVersionAtLeast(major: int, minor?: int, build?: int, revision?: int): boolean;
};


export interface __OperatingSystem$views {
    As_ICloneable(): ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface OperatingSystem$instance extends ICloneable$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type OperatingSystem = OperatingSystem$instance & __OperatingSystem$views;


export interface OperationCanceledException$instance extends SystemException$instance {
    readonly CancellationToken: CancellationToken;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const OperationCanceledException: {
    new(): OperationCanceledException;
    new(message: string | undefined): OperationCanceledException;
    new(message: string | undefined, innerException: Exception | undefined): OperationCanceledException;
    new(token: CancellationToken): OperationCanceledException;
    new(message: string | undefined, token: CancellationToken): OperationCanceledException;
    new(message: string | undefined, innerException: Exception | undefined, token: CancellationToken): OperationCanceledException;
};


export interface __OperationCanceledException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type OperationCanceledException = OperationCanceledException$instance & __OperationCanceledException$views;


export interface OrdinalComparer$instance extends StringComparer$instance {
    Compare(x: string | undefined, y: string | undefined): int;
    Compare(x: unknown | undefined, y: unknown | undefined): int;
    Compare(x: unknown, y: unknown): int;
    Equals(x: string | undefined, y: string | undefined): boolean;
    Equals(x: unknown | undefined, y: unknown | undefined): boolean;
    Equals(x: unknown, y: unknown): boolean;
    GetHashCode(obj: string): int;
    GetHashCode(obj: unknown): int;
    GetHashCode(obj: unknown): int;
}


export const OrdinalComparer: {
    new(): OrdinalComparer;
};


export interface __OrdinalComparer$views {
    As_IAlternateEqualityComparer_2(): System_Collections_Generic_Internal.IAlternateEqualityComparer_2$instance<ReadOnlySpan_1<Char>, String>;
    As_IComparer_1(): System_Collections_Generic_Internal.IComparer_1$instance<String>;
    As_IEqualityComparer_1(): System_Collections_Generic_Internal.IEqualityComparer_1$instance<String>;
    As_IComparer(): System_Collections_Internal.IComparer$instance;
    As_IEqualityComparer(): System_Collections_Internal.IEqualityComparer$instance;
}

export type OrdinalComparer = OrdinalComparer$instance & __OrdinalComparer$views;


export interface OutOfMemoryException$instance extends SystemException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const OutOfMemoryException: {
    new(): OutOfMemoryException;
    new(message: string | undefined): OutOfMemoryException;
    new(message: string | undefined, innerException: Exception | undefined): OutOfMemoryException;
};


export interface __OutOfMemoryException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type OutOfMemoryException = OutOfMemoryException$instance & __OutOfMemoryException$views;


export interface OverflowException$instance extends ArithmeticException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const OverflowException: {
    new(): OverflowException;
    new(message: string | undefined): OverflowException;
    new(message: string | undefined, innerException: Exception | undefined): OverflowException;
};


export interface __OverflowException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type OverflowException = OverflowException$instance & __OverflowException$views;


export interface ParamArrayAttribute$instance extends Attribute {
}


export const ParamArrayAttribute: {
    new(): ParamArrayAttribute;
};


export type ParamArrayAttribute = ParamArrayAttribute$instance;

export interface PlatformNotSupportedException$instance extends NotSupportedException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const PlatformNotSupportedException: {
    new(): PlatformNotSupportedException;
    new(message: string | undefined): PlatformNotSupportedException;
    new(message: string | undefined, inner: Exception | undefined): PlatformNotSupportedException;
};


export interface __PlatformNotSupportedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type PlatformNotSupportedException = PlatformNotSupportedException$instance & __PlatformNotSupportedException$views;


export interface Progress_1$instance<T> {
}


export const Progress_1: {
    new<T>(): Progress_1<T>;
    new<T>(handler: Action_1<T>): Progress_1<T>;
};


export interface __Progress_1$views<T> {
    As_IProgress_1(): IProgress_1$instance<T>;
}

export interface Progress_1$instance<T> extends IProgress_1$instance<T> {}

export type Progress_1<T> = Progress_1$instance<T> & __Progress_1$views<T>;


export interface Random$instance {
    GetHexString(stringLength: int, lowercase?: boolean): string;
    GetHexString(destination: Span_1<Char>, lowercase?: boolean): void;
    GetItems<T>(choices: ReadOnlySpan_1<T>, destination: Span_1<T>): void;
    GetItems<T>(choices: T[], length: int): T[];
    GetItems<T>(choices: ReadOnlySpan_1<T>, length: int): T[];
    GetString(choices: ReadOnlySpan_1<Char>, length: int): string;
    Next(): int;
    Next(maxValue: int): int;
    Next(minValue: int, maxValue: int): int;
    NextBytes(buffer: byte[]): void;
    NextBytes(buffer: Span_1<Byte>): void;
    NextDouble(): double;
    NextInt64(): long;
    NextInt64(maxValue: long): long;
    NextInt64(minValue: long, maxValue: long): long;
    NextSingle(): float;
    Shuffle<T>(values: T[]): void;
    Shuffle<T>(values: Span_1<T>): void;
}


export const Random: {
    new(): Random;
    new(Seed: int): Random;
    readonly Shared: Random;
};


export type Random = Random$instance;

export interface RankException$instance extends SystemException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const RankException: {
    new(): RankException;
    new(message: string | undefined): RankException;
    new(message: string | undefined, innerException: Exception | undefined): RankException;
};


export interface __RankException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type RankException = RankException$instance & __RankException$views;


export interface ResolveEventArgs$instance extends EventArgs {
    readonly Name: string;
    readonly RequestingAssembly: Assembly | undefined;
}


export const ResolveEventArgs: {
    new(name: string): ResolveEventArgs;
    new(name: string, requestingAssembly: Assembly | undefined): ResolveEventArgs;
};


export type ResolveEventArgs = ResolveEventArgs$instance;

export interface SerializableAttribute$instance extends Attribute {
}


export const SerializableAttribute: {
    new(): SerializableAttribute;
};


export type SerializableAttribute = SerializableAttribute$instance;

export interface StackOverflowException$instance extends SystemException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const StackOverflowException: {
    new(): StackOverflowException;
    new(message: string | undefined): StackOverflowException;
    new(message: string | undefined, innerException: Exception | undefined): StackOverflowException;
};


export interface __StackOverflowException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type StackOverflowException = StackOverflowException$instance & __StackOverflowException$views;


export interface STAThreadAttribute$instance extends Attribute {
}


export const STAThreadAttribute: {
    new(): STAThreadAttribute;
};


export type STAThreadAttribute = STAThreadAttribute$instance;

export interface String$instance {
    readonly Chars: char;
    readonly Length: int;
    Clone(): unknown;
    CompareTo(value: unknown | undefined): int;
    CompareTo(strB: string | undefined): int;
    Contains(value: string): boolean;
    Contains(value: string, comparisonType: StringComparison): boolean;
    Contains(value: char): boolean;
    Contains(value: char, comparisonType: StringComparison): boolean;
    CopyTo(sourceIndex: int, destination: char[], destinationIndex: int, count: int): void;
    CopyTo(destination: Span_1<Char>): void;
    EndsWith(value: string): boolean;
    EndsWith(value: string, comparisonType: StringComparison): boolean;
    EndsWith(value: string, ignoreCase: boolean, culture: CultureInfo | undefined): boolean;
    EndsWith(value: char): boolean;
    EnumerateRunes(): StringRuneEnumerator;
    Equals(obj: unknown | undefined): boolean;
    Equals(value: string | undefined): boolean;
    Equals(value: string | undefined, comparisonType: StringComparison): boolean;
    GetEnumerator(): CharEnumerator;
    GetHashCode(): int;
    GetHashCode(comparisonType: StringComparison): int;
    GetPinnableReference(): char;
    GetTypeCode(): TypeCode;
    IndexOf(value: char): int;
    IndexOf(value: char, startIndex: int): int;
    IndexOf(value: char, comparisonType: StringComparison): int;
    IndexOf(value: char, startIndex: int, count: int): int;
    IndexOf(value: string): int;
    IndexOf(value: string, startIndex: int): int;
    IndexOf(value: string, startIndex: int, count: int): int;
    IndexOf(value: string, comparisonType: StringComparison): int;
    IndexOf(value: string, startIndex: int, comparisonType: StringComparison): int;
    IndexOf(value: string, startIndex: int, count: int, comparisonType: StringComparison): int;
    IndexOfAny(anyOf: char[]): int;
    IndexOfAny(anyOf: char[], startIndex: int): int;
    IndexOfAny(anyOf: char[], startIndex: int, count: int): int;
    Insert(startIndex: int, value: string): string;
    IsNormalized(): boolean;
    IsNormalized(normalizationForm: NormalizationForm): boolean;
    LastIndexOf(value: char): int;
    LastIndexOf(value: char, startIndex: int): int;
    LastIndexOf(value: char, startIndex: int, count: int): int;
    LastIndexOf(value: string): int;
    LastIndexOf(value: string, startIndex: int): int;
    LastIndexOf(value: string, startIndex: int, count: int): int;
    LastIndexOf(value: string, comparisonType: StringComparison): int;
    LastIndexOf(value: string, startIndex: int, comparisonType: StringComparison): int;
    LastIndexOf(value: string, startIndex: int, count: int, comparisonType: StringComparison): int;
    LastIndexOfAny(anyOf: char[]): int;
    LastIndexOfAny(anyOf: char[], startIndex: int): int;
    LastIndexOfAny(anyOf: char[], startIndex: int, count: int): int;
    Normalize(): string;
    Normalize(normalizationForm: NormalizationForm): string;
    PadLeft(totalWidth: int): string;
    PadLeft(totalWidth: int, paddingChar: char): string;
    PadRight(totalWidth: int): string;
    PadRight(totalWidth: int, paddingChar: char): string;
    Remove(startIndex: int, count: int): string;
    Remove(startIndex: int): string;
    Replace(oldValue: string, newValue: string | undefined, ignoreCase: boolean, culture: CultureInfo | undefined): string;
    Replace(oldValue: string, newValue: string | undefined, comparisonType: StringComparison): string;
    Replace(oldChar: char, newChar: char): string;
    Replace(oldValue: string, newValue: string | undefined): string;
    ReplaceLineEndings(): string;
    ReplaceLineEndings(replacementText: string): string;
    Split(separator: char, options?: StringSplitOptions): string[];
    Split(separator: char, count: int, options?: StringSplitOptions): string[];
    Split(...separator: char[]): string[];
    Split(separator: ReadOnlySpan_1<Char>): string[];
    Split(separator: char[] | undefined, count: int): string[];
    Split(separator: char[] | undefined, options: StringSplitOptions): string[];
    Split(separator: char[] | undefined, count: int, options: StringSplitOptions): string[];
    Split(separator: string | undefined, options?: StringSplitOptions): string[];
    Split(separator: string | undefined, count: int, options?: StringSplitOptions): string[];
    Split(separator: string[] | undefined, options: StringSplitOptions): string[];
    Split(separator: string[] | undefined, count: int, options: StringSplitOptions): string[];
    StartsWith(value: string): boolean;
    StartsWith(value: string, comparisonType: StringComparison): boolean;
    StartsWith(value: string, ignoreCase: boolean, culture: CultureInfo | undefined): boolean;
    StartsWith(value: char): boolean;
    Substring(startIndex: int): string;
    Substring(startIndex: int, length: int): string;
    ToCharArray(): char[];
    ToCharArray(startIndex: int, length: int): char[];
    ToLower(): string;
    ToLower(culture: CultureInfo | undefined): string;
    ToLowerInvariant(): string;
    ToString(): string;
    ToString(provider: IFormatProvider | undefined): string;
    ToUpper(): string;
    ToUpper(culture: CultureInfo | undefined): string;
    ToUpperInvariant(): string;
    Trim(): string;
    Trim(trimChar: char): string;
    Trim(...trimChars: char[]): string;
    Trim(trimChars: ReadOnlySpan_1<Char>): string;
    TrimEnd(): string;
    TrimEnd(trimChar: char): string;
    TrimEnd(...trimChars: char[]): string;
    TrimEnd(trimChars: ReadOnlySpan_1<Char>): string;
    TrimStart(): string;
    TrimStart(trimChar: char): string;
    TrimStart(...trimChars: char[]): string;
    TrimStart(trimChars: ReadOnlySpan_1<Char>): string;
    TryCopyTo(destination: Span_1<Char>): boolean;
}


export const String: {
    new(value: char[] | undefined): String;
    new(value: char[], startIndex: int, length: int): String;
    new(value: ptr<char>): String;
    new(value: ptr<char>, startIndex: int, length: int): String;
    new(value: ptr<sbyte>): String;
    new(value: ptr<sbyte>, startIndex: int, length: int): String;
    new(value: ptr<sbyte>, startIndex: int, length: int, enc: Encoding): String;
    new(c: char, count: int): String;
    new(value: ReadOnlySpan_1<Char>): String;
    readonly Empty: string;
    Compare(strA: string | undefined, indexA: int, strB: string | undefined, indexB: int, length: int, ignoreCase: boolean, culture: CultureInfo | undefined): int;
    Compare(strA: string | undefined, indexA: int, strB: string | undefined, indexB: int, length: int, ignoreCase: boolean): int;
    Compare(strA: string | undefined, indexA: int, strB: string | undefined, indexB: int, length: int, culture: CultureInfo | undefined, options: CompareOptions): int;
    Compare(strA: string | undefined, indexA: int, strB: string | undefined, indexB: int, length: int, comparisonType: StringComparison): int;
    Compare(strA: string | undefined, indexA: int, strB: string | undefined, indexB: int, length: int): int;
    Compare(strA: string | undefined, strB: string | undefined, ignoreCase: boolean, culture: CultureInfo | undefined): int;
    Compare(strA: string | undefined, strB: string | undefined, ignoreCase: boolean): int;
    Compare(strA: string | undefined, strB: string | undefined, culture: CultureInfo | undefined, options: CompareOptions): int;
    Compare(strA: string | undefined, strB: string | undefined, comparisonType: StringComparison): int;
    Compare(strA: string | undefined, strB: string | undefined): int;
    CompareOrdinal(strA: string | undefined, indexA: int, strB: string | undefined, indexB: int, length: int): int;
    CompareOrdinal(strA: string | undefined, strB: string | undefined): int;
    Concat<T>(values: IEnumerable_1<T>): string;
    Concat(values: IEnumerable_1<string | undefined>): string;
    Concat(arg0: unknown | undefined, arg1: unknown | undefined, arg2: unknown | undefined): string;
    Concat(arg0: unknown | undefined, arg1: unknown | undefined): string;
    Concat(arg0: unknown | undefined): string;
    Concat(...args: unknown[]): string;
    Concat(str0: ReadOnlySpan_1<Char>, str1: ReadOnlySpan_1<Char>, str2: ReadOnlySpan_1<Char>, str3: ReadOnlySpan_1<Char>): string;
    Concat(str0: ReadOnlySpan_1<Char>, str1: ReadOnlySpan_1<Char>, str2: ReadOnlySpan_1<Char>): string;
    Concat(str0: ReadOnlySpan_1<Char>, str1: ReadOnlySpan_1<Char>): string;
    Concat(args: ReadOnlySpan_1<unknown>): string;
    Concat(values: ReadOnlySpan_1<String>): string;
    Concat(str0: string | undefined, str1: string | undefined, str2: string | undefined, str3: string | undefined): string;
    Concat(str0: string | undefined, str1: string | undefined, str2: string | undefined): string;
    Concat(str0: string | undefined, str1: string | undefined): string;
    Concat(...values: string[]): string;
    Copy(str: string): string;
    Create(provider: IFormatProvider | undefined, handler: DefaultInterpolatedStringHandler): string;
    Create(provider: IFormatProvider | undefined, initialBuffer: Span_1<Char>, handler: DefaultInterpolatedStringHandler): string;
    Create<TState>(length: int, state: TState, action: SpanAction_2<Char, TState>): string;
    Equals(a: string | undefined, b: string | undefined, comparisonType: StringComparison): boolean;
    Equals(a: string | undefined, b: string | undefined): boolean;
    Format(provider: IFormatProvider | undefined, format: string, arg0: unknown | undefined, arg1: unknown | undefined, arg2: unknown | undefined): string;
    Format(provider: IFormatProvider | undefined, format: string, arg0: unknown | undefined, arg1: unknown | undefined): string;
    Format(provider: IFormatProvider | undefined, format: string, arg0: unknown | undefined): string;
    Format(provider: IFormatProvider | undefined, format: string, ...args: unknown[]): string;
    Format(provider: IFormatProvider | undefined, format: string, args: ReadOnlySpan_1<unknown>): string;
    Format(provider: IFormatProvider | undefined, format: CompositeFormat, ...args: unknown[]): string;
    Format(provider: IFormatProvider | undefined, format: CompositeFormat, args: ReadOnlySpan_1<unknown>): string;
    Format<TArg0, TArg1, TArg2>(provider: IFormatProvider | undefined, format: CompositeFormat, arg0: TArg0, arg1: TArg1, arg2: TArg2): string;
    Format<TArg0, TArg1>(provider: IFormatProvider | undefined, format: CompositeFormat, arg0: TArg0, arg1: TArg1): string;
    Format<TArg0>(provider: IFormatProvider | undefined, format: CompositeFormat, arg0: TArg0): string;
    Format(format: string, arg0: unknown | undefined, arg1: unknown | undefined, arg2: unknown | undefined): string;
    Format(format: string, arg0: unknown | undefined, arg1: unknown | undefined): string;
    Format(format: string, arg0: unknown | undefined): string;
    Format(format: string, ...args: unknown[]): string;
    Format(format: string, args: ReadOnlySpan_1<unknown>): string;
    GetHashCode(value: ReadOnlySpan_1<Char>, comparisonType: StringComparison): int;
    GetHashCode(value: ReadOnlySpan_1<Char>): int;
    Intern(str: string): string;
    IsInterned(str: string): string | undefined;
    IsNullOrEmpty(value: string | undefined): boolean;
    IsNullOrWhiteSpace(value: string | undefined): boolean;
    Join<T>(separator: char, values: IEnumerable_1<T>): string;
    Join(separator: char, ...values: unknown[]): string;
    Join(separator: char, values: ReadOnlySpan_1<unknown>): string;
    Join(separator: char, value: ReadOnlySpan_1<String>): string;
    Join(separator: char, value: (string | undefined)[], startIndex: int, count: int): string;
    Join(separator: char, ...value: string[]): string;
    Join<T>(separator: string | undefined, values: IEnumerable_1<T>): string;
    Join(separator: string | undefined, values: IEnumerable_1<string | undefined>): string;
    Join(separator: string | undefined, ...values: unknown[]): string;
    Join(separator: string | undefined, values: ReadOnlySpan_1<unknown>): string;
    Join(separator: string | undefined, value: ReadOnlySpan_1<String>): string;
    Join(separator: string | undefined, value: (string | undefined)[], startIndex: int, count: int): string;
    Join(separator: string | undefined, ...value: string[]): string;
};


export interface __String$views {
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<Char>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_ICloneable(): ICloneable$instance;
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<String>;
    As_IConvertible(): IConvertible$instance;
    As_IEquatable_1(): IEquatable_1$instance<String>;
    As_IParsable_1(): IParsable_1$instance<String>;
    As_ISpanParsable_1(): ISpanParsable_1$instance<String>;

    // Structural method bridges for numeric interface constraints
    Equals(other: String): boolean;
    CompareTo(obj: unknown): int;
}

export interface String$instance extends ICloneable$instance, IComparable$instance, ISpanParsable_1$instance<String> {}

export type String = string & String$instance & __String$views;


export interface StringComparer$instance {
    Compare(x: unknown | undefined, y: unknown | undefined): int;
    Compare(x: string | undefined, y: string | undefined): int;
    Equals(x: unknown | undefined, y: unknown | undefined): boolean;
    Equals(x: string | undefined, y: string | undefined): boolean;
    GetHashCode(obj: unknown): int;
    GetHashCode(obj: string): int;
}


export const StringComparer: {
    readonly InvariantCulture: StringComparer;
    readonly InvariantCultureIgnoreCase: StringComparer;
    readonly CurrentCulture: StringComparer;
    readonly CurrentCultureIgnoreCase: StringComparer;
    readonly Ordinal: StringComparer;
    readonly OrdinalIgnoreCase: StringComparer;
    Create(culture: CultureInfo, ignoreCase: boolean): StringComparer;
    Create(culture: CultureInfo, options: CompareOptions): StringComparer;
    FromComparison(comparisonType: StringComparison): StringComparer;
    IsWellKnownCultureAwareComparer(comparer: IEqualityComparer_1<string | undefined> | undefined, compareInfo: CompareInfo | undefined, compareOptions: CompareOptions): boolean;
    IsWellKnownOrdinalComparer(comparer: IEqualityComparer_1<string | undefined> | undefined, ignoreCase: boolean): boolean;
};


export interface __StringComparer$views {
    As_IComparer_1(): System_Collections_Generic_Internal.IComparer_1$instance<String>;
    As_IEqualityComparer_1(): System_Collections_Generic_Internal.IEqualityComparer_1$instance<String>;
    As_IComparer(): System_Collections_Internal.IComparer$instance;
    As_IEqualityComparer(): System_Collections_Internal.IEqualityComparer$instance;
}

export interface StringComparer$instance extends System_Collections_Internal.IComparer$instance {}

export type StringComparer = StringComparer$instance & __StringComparer$views;


export interface SystemException$instance extends Exception$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SystemException: {
    new(): SystemException;
    new(message: string | undefined): SystemException;
    new(message: string | undefined, innerException: Exception | undefined): SystemException;
};


export interface __SystemException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SystemException = SystemException$instance & __SystemException$views;


export interface ThreadStaticAttribute$instance extends Attribute {
}


export const ThreadStaticAttribute: {
    new(): ThreadStaticAttribute;
};


export type ThreadStaticAttribute = ThreadStaticAttribute$instance;

export interface TimeoutException$instance extends SystemException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TimeoutException: {
    new(): TimeoutException;
    new(message: string | undefined): TimeoutException;
    new(message: string | undefined, innerException: Exception | undefined): TimeoutException;
};


export interface __TimeoutException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TimeoutException = TimeoutException$instance & __TimeoutException$views;


export interface TimeProvider$instance {
    readonly LocalTimeZone: TimeZoneInfo;
    readonly TimestampFrequency: long;
    CreateTimer(callback: TimerCallback, state: unknown | undefined, dueTime: TimeSpan, period: TimeSpan): ITimer;
    GetElapsedTime(startingTimestamp: long, endingTimestamp: long): TimeSpan;
    GetElapsedTime(startingTimestamp: long): TimeSpan;
    GetLocalNow(): DateTimeOffset;
    GetTimestamp(): long;
    GetUtcNow(): DateTimeOffset;
}


export const TimeProvider: {
    readonly System: TimeProvider;
};


export type TimeProvider = TimeProvider$instance;

export interface TimeZone$instance {
    readonly DaylightName: string;
    readonly StandardName: string;
    GetDaylightChanges(year: int): DaylightTime;
    GetUtcOffset(time: DateTime): TimeSpan;
    IsDaylightSavingTime(time: DateTime): boolean;
    ToLocalTime(time: DateTime): DateTime;
    ToUniversalTime(time: DateTime): DateTime;
}


export const TimeZone: {
    readonly CurrentTimeZone: TimeZone;
    IsDaylightSavingTime(time: DateTime, daylightTimes: DaylightTime): boolean;
};


export type TimeZone = TimeZone$instance;

export interface TimeZoneInfo$instance {
    readonly BaseUtcOffset: TimeSpan;
    readonly DaylightName: string;
    readonly DisplayName: string;
    readonly HasIanaId: boolean;
    readonly Id: string;
    readonly StandardName: string;
    readonly SupportsDaylightSavingTime: boolean;
    Equals(other: TimeZoneInfo | undefined): boolean;
    Equals(obj: unknown | undefined): boolean;
    GetAdjustmentRules(): TimeZoneInfo_AdjustmentRule[];
    GetAmbiguousTimeOffsets(dateTimeOffset: DateTimeOffset): TimeSpan[];
    GetAmbiguousTimeOffsets(dateTime: DateTime): TimeSpan[];
    GetHashCode(): int;
    GetUtcOffset(dateTimeOffset: DateTimeOffset): TimeSpan;
    GetUtcOffset(dateTime: DateTime): TimeSpan;
    HasSameRules(other: TimeZoneInfo): boolean;
    IsAmbiguousTime(dateTimeOffset: DateTimeOffset): boolean;
    IsAmbiguousTime(dateTime: DateTime): boolean;
    IsDaylightSavingTime(dateTimeOffset: DateTimeOffset): boolean;
    IsDaylightSavingTime(dateTime: DateTime): boolean;
    IsInvalidTime(dateTime: DateTime): boolean;
    ToSerializedString(): string;
    ToString(): string;
}


export const TimeZoneInfo: {
    new(): TimeZoneInfo;
    readonly Local: TimeZoneInfo;
    readonly Utc: TimeZoneInfo;
    ClearCachedData(): void;
    ConvertTime(dateTime: DateTime, sourceTimeZone: TimeZoneInfo, destinationTimeZone: TimeZoneInfo): DateTime;
    ConvertTime(dateTime: DateTime, destinationTimeZone: TimeZoneInfo): DateTime;
    ConvertTime(dateTimeOffset: DateTimeOffset, destinationTimeZone: TimeZoneInfo): DateTimeOffset;
    ConvertTimeBySystemTimeZoneId(dateTime: DateTime, sourceTimeZoneId: string, destinationTimeZoneId: string): DateTime;
    ConvertTimeBySystemTimeZoneId(dateTime: DateTime, destinationTimeZoneId: string): DateTime;
    ConvertTimeBySystemTimeZoneId(dateTimeOffset: DateTimeOffset, destinationTimeZoneId: string): DateTimeOffset;
    ConvertTimeFromUtc(dateTime: DateTime, destinationTimeZone: TimeZoneInfo): DateTime;
    ConvertTimeToUtc(dateTime: DateTime, sourceTimeZone: TimeZoneInfo): DateTime;
    ConvertTimeToUtc(dateTime: DateTime): DateTime;
    CreateCustomTimeZone(id: string, baseUtcOffset: TimeSpan, displayName: string | undefined, standardDisplayName: string | undefined, daylightDisplayName: string | undefined, adjustmentRules: TimeZoneInfo_AdjustmentRule[] | undefined, disableDaylightSavingTime: boolean): TimeZoneInfo;
    CreateCustomTimeZone(id: string, baseUtcOffset: TimeSpan, displayName: string | undefined, standardDisplayName: string | undefined, daylightDisplayName: string | undefined, adjustmentRules: TimeZoneInfo_AdjustmentRule[] | undefined): TimeZoneInfo;
    CreateCustomTimeZone(id: string, baseUtcOffset: TimeSpan, displayName: string | undefined, standardDisplayName: string | undefined): TimeZoneInfo;
    FindSystemTimeZoneById(id: string): TimeZoneInfo;
    FromSerializedString(source: string): TimeZoneInfo;
    GetSystemTimeZones(): ReadOnlyCollection_1<TimeZoneInfo>;
    GetSystemTimeZones(skipSorting: boolean): ReadOnlyCollection_1<TimeZoneInfo>;
    TryConvertIanaIdToWindowsId(ianaId: string, windowsId: string | undefined): boolean;
    TryConvertWindowsIdToIanaId(windowsId: string, region: string | undefined, ianaId: string | undefined): boolean;
    TryConvertWindowsIdToIanaId(windowsId: string, ianaId: string | undefined): boolean;
    TryFindSystemTimeZoneById(id: string, timeZoneInfo: TimeZoneInfo | undefined): boolean;
};


export interface __TimeZoneInfo$views {
    As_IEquatable_1(): IEquatable_1$instance<TimeZoneInfo>;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: TimeZoneInfo): boolean;
}

export interface TimeZoneInfo$instance extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type TimeZoneInfo = TimeZoneInfo$instance & __TimeZoneInfo$views;


export interface TimeZoneInfo_AdjustmentRule$instance {
    readonly BaseUtcOffsetDelta: TimeSpan;
    readonly DateEnd: DateTime;
    readonly DateStart: DateTime;
    readonly DaylightDelta: TimeSpan;
    readonly DaylightTransitionEnd: TimeZoneInfo_TransitionTime;
    readonly DaylightTransitionStart: TimeZoneInfo_TransitionTime;
    Equals(other: TimeZoneInfo_AdjustmentRule | undefined): boolean;
    Equals(obj: unknown | undefined): boolean;
    GetHashCode(): int;
}


export const TimeZoneInfo_AdjustmentRule: {
    new(): TimeZoneInfo_AdjustmentRule;
    CreateAdjustmentRule(dateStart: DateTime, dateEnd: DateTime, daylightDelta: TimeSpan, daylightTransitionStart: TimeZoneInfo_TransitionTime, daylightTransitionEnd: TimeZoneInfo_TransitionTime, baseUtcOffsetDelta: TimeSpan): TimeZoneInfo_AdjustmentRule;
    CreateAdjustmentRule(dateStart: DateTime, dateEnd: DateTime, daylightDelta: TimeSpan, daylightTransitionStart: TimeZoneInfo_TransitionTime, daylightTransitionEnd: TimeZoneInfo_TransitionTime): TimeZoneInfo_AdjustmentRule;
};


export interface __TimeZoneInfo_AdjustmentRule$views {
    As_IEquatable_1(): IEquatable_1$instance<TimeZoneInfo_AdjustmentRule>;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: TimeZoneInfo_AdjustmentRule): boolean;
}

export interface TimeZoneInfo_AdjustmentRule$instance extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type TimeZoneInfo_AdjustmentRule = TimeZoneInfo_AdjustmentRule$instance & __TimeZoneInfo_AdjustmentRule$views;


export interface TimeZoneNotFoundException$instance extends Exception$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TimeZoneNotFoundException: {
    new(): TimeZoneNotFoundException;
    new(message: string | undefined): TimeZoneNotFoundException;
    new(message: string | undefined, innerException: Exception | undefined): TimeZoneNotFoundException;
};


export interface __TimeZoneNotFoundException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TimeZoneNotFoundException = TimeZoneNotFoundException$instance & __TimeZoneNotFoundException$views;


export interface Tuple_1$instance<T1> {
    readonly Item1: T1;
    Equals(obj: unknown | undefined): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const Tuple_1: {
    new<T1>(item1: T1): Tuple_1<T1>;
};


export interface __Tuple_1$views<T1> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    CompareTo(obj: unknown): int;
}

export interface Tuple_1$instance<T1> extends System_Collections_Internal.IStructuralComparable$instance, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type Tuple_1<T1> = Tuple_1$instance<T1> & __Tuple_1$views<T1>;


export interface Tuple_2$instance<T1, T2> {
    readonly Item1: T1;
    readonly Item2: T2;
    Equals(obj: unknown | undefined): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const Tuple_2: {
    new<T1, T2>(item1: T1, item2: T2): Tuple_2<T1, T2>;
};


export interface __Tuple_2$views<T1, T2> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    CompareTo(obj: unknown): int;
}

export interface Tuple_2$instance<T1, T2> extends System_Collections_Internal.IStructuralComparable$instance, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type Tuple_2<T1, T2> = Tuple_2$instance<T1, T2> & __Tuple_2$views<T1, T2>;


export interface Tuple_3$instance<T1, T2, T3> {
    readonly Item1: T1;
    readonly Item2: T2;
    readonly Item3: T3;
    Equals(obj: unknown | undefined): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const Tuple_3: {
    new<T1, T2, T3>(item1: T1, item2: T2, item3: T3): Tuple_3<T1, T2, T3>;
};


export interface __Tuple_3$views<T1, T2, T3> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    CompareTo(obj: unknown): int;
}

export interface Tuple_3$instance<T1, T2, T3> extends System_Collections_Internal.IStructuralComparable$instance, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type Tuple_3<T1, T2, T3> = Tuple_3$instance<T1, T2, T3> & __Tuple_3$views<T1, T2, T3>;


export interface Tuple_4$instance<T1, T2, T3, T4> {
    readonly Item1: T1;
    readonly Item2: T2;
    readonly Item3: T3;
    readonly Item4: T4;
    Equals(obj: unknown | undefined): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const Tuple_4: {
    new<T1, T2, T3, T4>(item1: T1, item2: T2, item3: T3, item4: T4): Tuple_4<T1, T2, T3, T4>;
};


export interface __Tuple_4$views<T1, T2, T3, T4> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    CompareTo(obj: unknown): int;
}

export interface Tuple_4$instance<T1, T2, T3, T4> extends System_Collections_Internal.IStructuralComparable$instance, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type Tuple_4<T1, T2, T3, T4> = Tuple_4$instance<T1, T2, T3, T4> & __Tuple_4$views<T1, T2, T3, T4>;


export interface Tuple_5$instance<T1, T2, T3, T4, T5> {
    readonly Item1: T1;
    readonly Item2: T2;
    readonly Item3: T3;
    readonly Item4: T4;
    readonly Item5: T5;
    Equals(obj: unknown | undefined): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const Tuple_5: {
    new<T1, T2, T3, T4, T5>(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5): Tuple_5<T1, T2, T3, T4, T5>;
};


export interface __Tuple_5$views<T1, T2, T3, T4, T5> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    CompareTo(obj: unknown): int;
}

export interface Tuple_5$instance<T1, T2, T3, T4, T5> extends System_Collections_Internal.IStructuralComparable$instance, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type Tuple_5<T1, T2, T3, T4, T5> = Tuple_5$instance<T1, T2, T3, T4, T5> & __Tuple_5$views<T1, T2, T3, T4, T5>;


export interface Tuple_6$instance<T1, T2, T3, T4, T5, T6> {
    readonly Item1: T1;
    readonly Item2: T2;
    readonly Item3: T3;
    readonly Item4: T4;
    readonly Item5: T5;
    readonly Item6: T6;
    Equals(obj: unknown | undefined): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const Tuple_6: {
    new<T1, T2, T3, T4, T5, T6>(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6): Tuple_6<T1, T2, T3, T4, T5, T6>;
};


export interface __Tuple_6$views<T1, T2, T3, T4, T5, T6> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    CompareTo(obj: unknown): int;
}

export interface Tuple_6$instance<T1, T2, T3, T4, T5, T6> extends System_Collections_Internal.IStructuralComparable$instance, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type Tuple_6<T1, T2, T3, T4, T5, T6> = Tuple_6$instance<T1, T2, T3, T4, T5, T6> & __Tuple_6$views<T1, T2, T3, T4, T5, T6>;


export interface Tuple_7$instance<T1, T2, T3, T4, T5, T6, T7> {
    readonly Item1: T1;
    readonly Item2: T2;
    readonly Item3: T3;
    readonly Item4: T4;
    readonly Item5: T5;
    readonly Item6: T6;
    readonly Item7: T7;
    Equals(obj: unknown | undefined): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const Tuple_7: {
    new<T1, T2, T3, T4, T5, T6, T7>(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7): Tuple_7<T1, T2, T3, T4, T5, T6, T7>;
};


export interface __Tuple_7$views<T1, T2, T3, T4, T5, T6, T7> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    CompareTo(obj: unknown): int;
}

export interface Tuple_7$instance<T1, T2, T3, T4, T5, T6, T7> extends System_Collections_Internal.IStructuralComparable$instance, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type Tuple_7<T1, T2, T3, T4, T5, T6, T7> = Tuple_7$instance<T1, T2, T3, T4, T5, T6, T7> & __Tuple_7$views<T1, T2, T3, T4, T5, T6, T7>;


export interface Tuple_8$instance<T1, T2, T3, T4, T5, T6, T7, TRest> {
    readonly Item1: T1;
    readonly Item2: T2;
    readonly Item3: T3;
    readonly Item4: T4;
    readonly Item5: T5;
    readonly Item6: T6;
    readonly Item7: T7;
    readonly Rest: TRest;
    Equals(obj: unknown | undefined): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const Tuple_8: {
    new<T1, T2, T3, T4, T5, T6, T7, TRest>(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, rest: TRest): Tuple_8<T1, T2, T3, T4, T5, T6, T7, TRest>;
};


export interface __Tuple_8$views<T1, T2, T3, T4, T5, T6, T7, TRest> {
    As_IStructuralComparable(): System_Collections_Internal.IStructuralComparable$instance;
    As_IStructuralEquatable(): System_Collections_Internal.IStructuralEquatable$instance;
    As_IComparable(): IComparable$instance;
    As_ITuple(): System_Runtime_CompilerServices_Internal.ITuple$instance;

    // Structural method bridges for numeric interface constraints
    CompareTo(obj: unknown): int;
}

export interface Tuple_8$instance<T1, T2, T3, T4, T5, T6, T7, TRest> extends System_Collections_Internal.IStructuralComparable$instance, System_Runtime_CompilerServices_Internal.ITuple$instance {}

export type Tuple_8<T1, T2, T3, T4, T5, T6, T7, TRest> = Tuple_8$instance<T1, T2, T3, T4, T5, T6, T7, TRest> & __Tuple_8$views<T1, T2, T3, T4, T5, T6, T7, TRest>;


export interface Type$instance extends MemberInfo {
    readonly Assembly: Assembly;
    readonly AssemblyQualifiedName: string;
    readonly Attributes: TypeAttributes;
    readonly BaseType: Type | undefined;
    readonly ContainsGenericParameters: boolean;
    readonly DeclaringMethod: MethodBase | undefined;
    readonly DeclaringType: Type;
    readonly FullName: string;
    readonly GenericParameterAttributes: GenericParameterAttributes;
    readonly GenericParameterPosition: int;
    readonly GenericTypeArguments: Type[];
    readonly GUID: Guid;
    readonly HasElementType: boolean;
    readonly IsAbstract: boolean;
    readonly IsAnsiClass: boolean;
    readonly IsArray: boolean;
    readonly IsAutoClass: boolean;
    readonly IsAutoLayout: boolean;
    readonly IsByRef: boolean;
    readonly IsByRefLike: boolean;
    readonly IsClass: boolean;
    readonly IsCOMObject: boolean;
    readonly IsConstructedGenericType: boolean;
    readonly IsContextful: boolean;
    readonly IsEnum: boolean;
    readonly IsExplicitLayout: boolean;
    readonly IsFunctionPointer: boolean;
    readonly IsGenericMethodParameter: boolean;
    readonly IsGenericParameter: boolean;
    readonly IsGenericType: boolean;
    readonly IsGenericTypeDefinition: boolean;
    readonly IsGenericTypeParameter: boolean;
    readonly IsImport: boolean;
    readonly IsInterface: boolean;
    readonly IsLayoutSequential: boolean;
    readonly IsMarshalByRef: boolean;
    readonly IsNested: boolean;
    readonly IsNestedAssembly: boolean;
    readonly IsNestedFamANDAssem: boolean;
    readonly IsNestedFamily: boolean;
    readonly IsNestedFamORAssem: boolean;
    readonly IsNestedPrivate: boolean;
    readonly IsNestedPublic: boolean;
    readonly IsNotPublic: boolean;
    readonly IsPointer: boolean;
    readonly IsPrimitive: boolean;
    readonly IsPublic: boolean;
    readonly IsSealed: boolean;
    readonly IsSecurityCritical: boolean;
    readonly IsSecuritySafeCritical: boolean;
    readonly IsSecurityTransparent: boolean;
    readonly IsSerializable: boolean;
    readonly IsSignatureType: boolean;
    readonly IsSpecialName: boolean;
    readonly IsSZArray: boolean;
    readonly IsTypeDefinition: boolean;
    readonly IsUnicodeClass: boolean;
    readonly IsUnmanagedFunctionPointer: boolean;
    readonly IsValueType: boolean;
    readonly IsVariableBoundArray: boolean;
    readonly IsVisible: boolean;
    readonly MemberType: MemberTypes;
    readonly Module: Module;
    readonly Namespace: string;
    readonly ReflectedType: Type | undefined;
    readonly StructLayoutAttribute: StructLayoutAttribute | undefined;
    readonly TypeHandle: RuntimeTypeHandle;
    readonly TypeInitializer: ConstructorInfo | undefined;
    readonly UnderlyingSystemType: Type;
    Equals(o: unknown | undefined): boolean;
    Equals(o: Type | undefined): boolean;
    FindInterfaces(filter: TypeFilter, filterCriteria: unknown | undefined): Type[];
    FindMembers(memberType: MemberTypes, bindingAttr: BindingFlags, filter: MemberFilter | undefined, filterCriteria: unknown | undefined): MemberInfo[];
    GetArrayRank(): int;
    GetConstructor(types: Type[]): ConstructorInfo | undefined;
    GetConstructor(bindingAttr: BindingFlags, types: Type[]): ConstructorInfo | undefined;
    GetConstructor(bindingAttr: BindingFlags, binder: Binder | undefined, types: Type[], modifiers: ParameterModifier[] | undefined): ConstructorInfo | undefined;
    GetConstructor(bindingAttr: BindingFlags, binder: Binder | undefined, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[] | undefined): ConstructorInfo | undefined;
    GetConstructors(): ConstructorInfo[];
    GetConstructors(bindingAttr: BindingFlags): ConstructorInfo[];
    GetCustomAttributes(inherit: boolean): unknown[];
    GetCustomAttributes(attributeType: Type, inherit: boolean): unknown[];
    GetDefaultMembers(): MemberInfo[];
    GetElementType(): Type;
    GetEnumName(value: unknown): string | undefined;
    GetEnumNames(): string[];
    GetEnumUnderlyingType(): Type;
    GetEnumValues(): Array;
    GetEnumValuesAsUnderlyingType(): Array;
    GetEvent(name: string): EventInfo | undefined;
    GetEvent(name: string, bindingAttr: BindingFlags): EventInfo | undefined;
    GetEvents(): EventInfo[];
    GetEvents(bindingAttr: BindingFlags): EventInfo[];
    GetField(name: string): FieldInfo | undefined;
    GetField(name: string, bindingAttr: BindingFlags): FieldInfo | undefined;
    GetFields(): FieldInfo[];
    GetFields(bindingAttr: BindingFlags): FieldInfo[];
    GetFunctionPointerCallingConventions(): Type[];
    GetFunctionPointerParameterTypes(): Type[];
    GetFunctionPointerReturnType(): Type;
    GetGenericArguments(): Type[];
    GetGenericParameterConstraints(): Type[];
    GetGenericTypeDefinition(): Type;
    GetHashCode(): int;
    GetInterface(name: string): Type | undefined;
    GetInterface(name: string, ignoreCase: boolean): Type | undefined;
    GetInterfaceMap(interfaceType: Type): InterfaceMapping;
    GetInterfaces(): Type[];
    GetMember(name: string): MemberInfo[];
    GetMember(name: string, bindingAttr: BindingFlags): MemberInfo[];
    GetMember(name: string, type_: MemberTypes, bindingAttr: BindingFlags): MemberInfo[];
    GetMembers(): MemberInfo[];
    GetMembers(bindingAttr: BindingFlags): MemberInfo[];
    GetMemberWithSameMetadataDefinitionAs(member: MemberInfo): MemberInfo;
    GetMethod(name: string): MethodInfo | undefined;
    GetMethod(name: string, bindingAttr: BindingFlags): MethodInfo | undefined;
    GetMethod(name: string, bindingAttr: BindingFlags, types: Type[]): MethodInfo | undefined;
    GetMethod(name: string, types: Type[]): MethodInfo | undefined;
    GetMethod(name: string, types: Type[], modifiers: ParameterModifier[] | undefined): MethodInfo | undefined;
    GetMethod(name: string, bindingAttr: BindingFlags, binder: Binder | undefined, types: Type[], modifiers: ParameterModifier[] | undefined): MethodInfo | undefined;
    GetMethod(name: string, bindingAttr: BindingFlags, binder: Binder | undefined, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[] | undefined): MethodInfo | undefined;
    GetMethod(name: string, genericParameterCount: int, types: Type[]): MethodInfo | undefined;
    GetMethod(name: string, genericParameterCount: int, types: Type[], modifiers: ParameterModifier[] | undefined): MethodInfo | undefined;
    GetMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, types: Type[]): MethodInfo | undefined;
    GetMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, binder: Binder | undefined, types: Type[], modifiers: ParameterModifier[] | undefined): MethodInfo | undefined;
    GetMethod(name: string, genericParameterCount: int, bindingAttr: BindingFlags, binder: Binder | undefined, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[] | undefined): MethodInfo | undefined;
    GetMethods(): MethodInfo[];
    GetMethods(bindingAttr: BindingFlags): MethodInfo[];
    GetNestedType(name: string): Type | undefined;
    GetNestedType(name: string, bindingAttr: BindingFlags): Type | undefined;
    GetNestedTypes(): Type[];
    GetNestedTypes(bindingAttr: BindingFlags): Type[];
    GetOptionalCustomModifiers(): Type[];
    GetProperties(): PropertyInfo[];
    GetProperties(bindingAttr: BindingFlags): PropertyInfo[];
    GetProperty(name: string): PropertyInfo | undefined;
    GetProperty(name: string, bindingAttr: BindingFlags): PropertyInfo | undefined;
    GetProperty(name: string, returnType: Type | undefined): PropertyInfo | undefined;
    GetProperty(name: string, types: Type[]): PropertyInfo | undefined;
    GetProperty(name: string, returnType: Type | undefined, types: Type[]): PropertyInfo | undefined;
    GetProperty(name: string, returnType: Type | undefined, types: Type[], modifiers: ParameterModifier[] | undefined): PropertyInfo | undefined;
    GetProperty(name: string, bindingAttr: BindingFlags, binder: Binder | undefined, returnType: Type | undefined, types: Type[], modifiers: ParameterModifier[] | undefined): PropertyInfo | undefined;
    GetRequiredCustomModifiers(): Type[];
    GetType(): Type;
    InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder | undefined, target: unknown | undefined, args: (unknown | undefined)[] | undefined): unknown | undefined;
    InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder | undefined, target: unknown | undefined, args: (unknown | undefined)[] | undefined, culture: CultureInfo | undefined): unknown | undefined;
    InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder | undefined, target: unknown | undefined, args: (unknown | undefined)[] | undefined, modifiers: ParameterModifier[] | undefined, culture: CultureInfo | undefined, namedParameters: string[] | undefined): unknown | undefined;
    IsAssignableFrom(c: Type | undefined): boolean;
    IsAssignableTo(targetType: Type | undefined): boolean;
    IsDefined(attributeType: Type, inherit: boolean): boolean;
    IsEnumDefined(value: unknown): boolean;
    IsEquivalentTo(other: Type | undefined): boolean;
    IsInstanceOfType(o: unknown | undefined): boolean;
    IsSubclassOf(c: Type): boolean;
    MakeArrayType(): Type;
    MakeArrayType(rank: int): Type;
    MakeByRefType(): Type;
    MakeGenericType(...typeArguments: Type[]): Type;
    MakePointerType(): Type;
    ToString(): string;
}


export const Type: {
    readonly Delimiter: char;
    readonly EmptyTypes: Type[];
    readonly Missing: unknown;
    readonly FilterAttribute: MemberFilter;
    readonly FilterName: MemberFilter;
    readonly FilterNameIgnoreCase: MemberFilter;
    readonly DefaultBinder: Binder;
    GetType(typeName: string, throwOnError: boolean, ignoreCase: boolean): Type | undefined;
    GetType(typeName: string, throwOnError: boolean): Type | undefined;
    GetType(typeName: string, assemblyResolver: Func_2<AssemblyName, Assembly | undefined> | undefined, typeResolver: Func_4<Assembly | undefined, String, Boolean, Type | undefined> | undefined, throwOnError: boolean, ignoreCase: boolean): Type | undefined;
    GetType(typeName: string, assemblyResolver: Func_2<AssemblyName, Assembly | undefined> | undefined, typeResolver: Func_4<Assembly | undefined, String, Boolean, Type | undefined> | undefined, throwOnError: boolean): Type | undefined;
    GetType(typeName: string, assemblyResolver: Func_2<AssemblyName, Assembly | undefined> | undefined, typeResolver: Func_4<Assembly | undefined, String, Boolean, Type | undefined> | undefined): Type | undefined;
    GetType(typeName: string): Type | undefined;
    GetTypeArray(args: unknown[]): Type[];
    GetTypeCode(type_: Type | undefined): TypeCode;
    GetTypeFromCLSID(clsid: Guid, throwOnError: boolean): Type | undefined;
    GetTypeFromCLSID(clsid: Guid, server: string | undefined, throwOnError: boolean): Type | undefined;
    GetTypeFromCLSID(clsid: Guid, server: string | undefined): Type | undefined;
    GetTypeFromCLSID(clsid: Guid): Type | undefined;
    GetTypeFromHandle(handle: RuntimeTypeHandle): Type | undefined;
    GetTypeFromProgID(progID: string, throwOnError: boolean): Type | undefined;
    GetTypeFromProgID(progID: string, server: string | undefined, throwOnError: boolean): Type | undefined;
    GetTypeFromProgID(progID: string, server: string | undefined): Type | undefined;
    GetTypeFromProgID(progID: string): Type | undefined;
    GetTypeHandle(o: unknown): RuntimeTypeHandle;
    MakeGenericMethodParameter(position: int): Type;
    MakeGenericSignatureType(genericTypeDefinition: Type, ...typeArguments: Type[]): Type;
    ReflectionOnlyGetType(typeName: string, throwIfNotFound: boolean, ignoreCase: boolean): Type | undefined;
};


export interface __Type$views {
    As_ICustomAttributeProvider(): System_Reflection_Internal.ICustomAttributeProvider$instance;
    As_IReflect(): System_Reflection_Internal.IReflect$instance;
}

export type Type = Type$instance & __Type$views;


export interface TypeAccessException$instance extends TypeLoadException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TypeAccessException: {
    new(): TypeAccessException;
    new(message: string | undefined): TypeAccessException;
    new(message: string | undefined, inner: Exception | undefined): TypeAccessException;
};


export interface __TypeAccessException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TypeAccessException = TypeAccessException$instance & __TypeAccessException$views;


export interface TypeInitializationException$instance extends SystemException$instance {
    readonly TypeName: string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TypeInitializationException: {
    new(fullTypeName: string | undefined, innerException: Exception | undefined): TypeInitializationException;
};


export interface __TypeInitializationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TypeInitializationException = TypeInitializationException$instance & __TypeInitializationException$views;


export interface TypeLoadException$instance extends SystemException$instance {
    readonly Message: string;
    readonly TypeName: string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TypeLoadException: {
    new(): TypeLoadException;
    new(message: string | undefined): TypeLoadException;
    new(message: string | undefined, inner: Exception | undefined): TypeLoadException;
};


export interface __TypeLoadException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TypeLoadException = TypeLoadException$instance & __TypeLoadException$views;


export interface TypeUnloadedException$instance extends SystemException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TypeUnloadedException: {
    new(): TypeUnloadedException;
    new(message: string | undefined): TypeUnloadedException;
    new(message: string | undefined, innerException: Exception | undefined): TypeUnloadedException;
};


export interface __TypeUnloadedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TypeUnloadedException = TypeUnloadedException$instance & __TypeUnloadedException$views;


export interface UnauthorizedAccessException$instance extends SystemException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const UnauthorizedAccessException: {
    new(): UnauthorizedAccessException;
    new(message: string | undefined): UnauthorizedAccessException;
    new(message: string | undefined, inner: Exception | undefined): UnauthorizedAccessException;
};


export interface __UnauthorizedAccessException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type UnauthorizedAccessException = UnauthorizedAccessException$instance & __UnauthorizedAccessException$views;


export interface UnhandledExceptionEventArgs$instance extends EventArgs {
    readonly ExceptionObject: unknown;
    readonly IsTerminating: boolean;
}


export const UnhandledExceptionEventArgs: {
    new(exception: unknown, isTerminating: boolean): UnhandledExceptionEventArgs;
};


export type UnhandledExceptionEventArgs = UnhandledExceptionEventArgs$instance;

export interface UnitySerializationHolder$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    GetRealObject(context: StreamingContext): unknown;
}


export const UnitySerializationHolder: {
    new(info: SerializationInfo, context: StreamingContext): UnitySerializationHolder;
};


export interface __UnitySerializationHolder$views {
    As_IObjectReference(): System_Runtime_Serialization_Internal.IObjectReference$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface UnitySerializationHolder$instance extends System_Runtime_Serialization_Internal.IObjectReference$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type UnitySerializationHolder = UnitySerializationHolder$instance & __UnitySerializationHolder$views;


export interface Uri$instance {
    readonly AbsolutePath: string;
    readonly AbsoluteUri: string;
    readonly Authority: string;
    readonly DnsSafeHost: string;
    readonly Fragment: string;
    readonly Host: string;
    readonly HostNameType: UriHostNameType;
    readonly IdnHost: string;
    readonly IsAbsoluteUri: boolean;
    readonly IsDefaultPort: boolean;
    readonly IsFile: boolean;
    readonly IsLoopback: boolean;
    readonly IsUnc: boolean;
    readonly LocalPath: string;
    readonly OriginalString: string;
    readonly PathAndQuery: string;
    readonly Port: int;
    readonly Query: string;
    readonly Scheme: string;
    readonly Segments: string[];
    readonly UserEscaped: boolean;
    readonly UserInfo: string;
    Equals(comparand: unknown | undefined): boolean;
    Equals(other: Uri | undefined): boolean;
    GetComponents(components: UriComponents, format: UriFormat): string;
    GetHashCode(): int;
    GetLeftPart(part: UriPartial): string;
    IsBaseOf(uri: Uri): boolean;
    IsWellFormedOriginalString(): boolean;
    MakeRelative(toUri: Uri): string;
    MakeRelativeUri(uri: Uri): Uri;
    ToString(): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int): boolean;
}


export const Uri: {
    new(uriString: string): Uri;
    new(uriString: string, dontEscape: boolean): Uri;
    new(baseUri: Uri, relativeUri: string | undefined, dontEscape: boolean): Uri;
    new(uriString: string, uriKind: UriKind): Uri;
    new(uriString: string, creationOptions: UriCreationOptions): Uri;
    new(baseUri: Uri, relativeUri: string | undefined): Uri;
    new(baseUri: Uri, relativeUri: Uri): Uri;
    readonly UriSchemeFile: string;
    readonly UriSchemeFtp: string;
    readonly UriSchemeSftp: string;
    readonly UriSchemeFtps: string;
    readonly UriSchemeGopher: string;
    readonly UriSchemeHttp: string;
    readonly UriSchemeHttps: string;
    readonly UriSchemeWs: string;
    readonly UriSchemeWss: string;
    readonly UriSchemeMailto: string;
    readonly UriSchemeNews: string;
    readonly UriSchemeNntp: string;
    readonly UriSchemeSsh: string;
    readonly UriSchemeTelnet: string;
    readonly UriSchemeNetTcp: string;
    readonly UriSchemeNetPipe: string;
    readonly SchemeDelimiter: string;
    CheckHostName(name: string | undefined): UriHostNameType;
    CheckSchemeName(schemeName: string | undefined): boolean;
    Compare(uri1: Uri | undefined, uri2: Uri | undefined, partsToCompare: UriComponents, compareFormat: UriFormat, comparisonType: StringComparison): int;
    EscapeDataString(charsToEscape: ReadOnlySpan_1<Char>): string;
    EscapeDataString(stringToEscape: string): string;
    EscapeUriString(stringToEscape: string): string;
    FromHex(digit: char): int;
    HexEscape(character: char): string;
    HexUnescape(pattern: string, index: int): char;
    IsHexDigit(character: char): boolean;
    IsHexEncoding(pattern: string, index: int): boolean;
    IsWellFormedUriString(uriString: string | undefined, uriKind: UriKind): boolean;
    TryCreate(uriString: string | undefined, creationOptions: UriCreationOptions, result: Uri | undefined): boolean;
    TryCreate(uriString: string | undefined, uriKind: UriKind, result: Uri | undefined): boolean;
    TryCreate(baseUri: Uri | undefined, relativeUri: string | undefined, result: Uri | undefined): boolean;
    TryCreate(baseUri: Uri | undefined, relativeUri: Uri | undefined, result: Uri | undefined): boolean;
    TryEscapeDataString(charsToEscape: ReadOnlySpan_1<Char>, destination: Span_1<Char>, charsWritten: int): boolean;
    TryUnescapeDataString(charsToUnescape: ReadOnlySpan_1<Char>, destination: Span_1<Char>, charsWritten: int): boolean;
    UnescapeDataString(charsToUnescape: ReadOnlySpan_1<Char>): string;
    UnescapeDataString(stringToUnescape: string): string;
};


export interface __Uri$views {
    As_IEquatable_1(): IEquatable_1$instance<Uri>;
    As_IFormattable(): IFormattable$instance;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;

    // Structural method bridges for numeric interface constraints
    Equals(other: Uri): boolean;
}

export interface Uri$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Uri = Uri$instance & __Uri$views;


export interface UriBuilder$instance {
    Fragment: string;
    Host: string;
    Password: string;
    Path: string;
    Port: int;
    Query: string;
    Scheme: string;
    readonly Uri: Uri;
    UserName: string;
    Equals(rparam: unknown | undefined): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const UriBuilder: {
    new(): UriBuilder;
    new(uri: string): UriBuilder;
    new(uri: Uri): UriBuilder;
    new(schemeName: string | undefined, hostName: string | undefined): UriBuilder;
    new(scheme: string | undefined, host: string | undefined, portNumber: int): UriBuilder;
    new(scheme: string | undefined, host: string | undefined, port: int, pathValue: string | undefined): UriBuilder;
    new(scheme: string | undefined, host: string | undefined, port: int, path: string | undefined, extraValue: string | undefined): UriBuilder;
};


export type UriBuilder = UriBuilder$instance;

export interface UriFormatException$instance extends FormatException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const UriFormatException: {
    new(): UriFormatException;
    new(textString: string | undefined): UriFormatException;
    new(textString: string | undefined, e: Exception | undefined): UriFormatException;
};


export interface __UriFormatException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type UriFormatException = UriFormatException$instance & __UriFormatException$views;


export interface UriParser$instance {
}


export const UriParser: {
    IsKnownScheme(schemeName: string): boolean;
    Register(uriParser: UriParser, schemeName: string, defaultPort: int): void;
};


export type UriParser = UriParser$instance;

export interface UriTypeConverter$instance extends TypeConverter {
    CanConvertFrom(context: ITypeDescriptorContext | undefined, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext | undefined, destinationType: Type | undefined): boolean;
    CanConvertTo(destinationType: Type | undefined): boolean;
    ConvertFrom(context: ITypeDescriptorContext | undefined, culture: CultureInfo | undefined, value: unknown | undefined): unknown | undefined;
    ConvertFrom(value: unknown): unknown | undefined;
    ConvertTo(context: ITypeDescriptorContext | undefined, culture: CultureInfo | undefined, value: unknown | undefined, destinationType: Type): unknown;
    ConvertTo(value: unknown | undefined, destinationType: Type): unknown | undefined;
    IsValid(context: ITypeDescriptorContext | undefined, value: unknown | undefined): boolean;
    IsValid(value: unknown): boolean;
}


export const UriTypeConverter: {
    new(): UriTypeConverter;
};


export type UriTypeConverter = UriTypeConverter$instance;

export interface ValueType$instance {
    Equals(obj: unknown | undefined): boolean;
    GetHashCode(): int;
    ToString(): string | undefined;
}


export const ValueType: {
};


export type ValueType = ValueType$instance;

export interface Version$instance {
    readonly Build: int;
    readonly Major: int;
    readonly MajorRevision: short;
    readonly Minor: int;
    readonly MinorRevision: short;
    readonly Revision: int;
    Clone(): unknown;
    CompareTo(version: unknown | undefined): int;
    CompareTo(value: Version | undefined): int;
    Equals(obj: unknown | undefined): boolean;
    Equals(obj: Version | undefined): boolean;
    GetHashCode(): int;
    ToString(): string;
    ToString(fieldCount: int): string;
    TryFormat(destination: Span_1<Char>, charsWritten: int): boolean;
    TryFormat(destination: Span_1<Char>, fieldCount: int, charsWritten: int): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int): boolean;
    TryFormat(utf8Destination: Span_1<Byte>, fieldCount: int, bytesWritten: int): boolean;
}


export const Version: {
    new(major: int, minor: int, build: int, revision: int): Version;
    new(major: int, minor: int, build: int): Version;
    new(major: int, minor: int): Version;
    new(version: string): Version;
    new(): Version;
    Parse(utf8Text: ReadOnlySpan_1<Byte>): Version;
    Parse(input: ReadOnlySpan_1<Char>): Version;
    Parse(input: string): Version;
    TryParse(utf8Text: ReadOnlySpan_1<Byte>, result: Version | undefined): boolean;
    TryParse(input: ReadOnlySpan_1<Char>, result: Version | undefined): boolean;
    TryParse(input: string | undefined, result: Version | undefined): boolean;
};


export interface __Version$views {
    As_ICloneable(): ICloneable$instance;
    As_IComparable(): IComparable$instance;
    As_IComparable_1(): IComparable_1$instance<Version>;
    As_IEquatable_1(): IEquatable_1$instance<Version>;
    As_IFormattable(): IFormattable$instance;
    As_ISpanFormattable(): ISpanFormattable$instance;
    As_IUtf8SpanFormattable(): IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): IUtf8SpanParsable_1$instance<Version>;

    // Structural method bridges for numeric interface constraints
    Equals(other: Version): boolean;
    CompareTo(obj: unknown): int;
    TryFormat(utf8Destination: Span_1<Byte>, bytesWritten: int, format: ReadOnlySpan_1<Char>, provider: IFormatProvider): boolean;
}

export interface Version$instance extends ICloneable$instance, IComparable$instance, IUtf8SpanParsable_1$instance<Version> {}

export type Version = Version$instance & __Version$views;


export interface WeakReference$instance {
    readonly IsAlive: boolean;
    Target: unknown;
    readonly TrackResurrection: boolean;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const WeakReference: {
    new(target: unknown | undefined): WeakReference;
    new(target: unknown | undefined, trackResurrection: boolean): WeakReference;
};


export interface __WeakReference$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface WeakReference$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type WeakReference = WeakReference$instance & __WeakReference$views;


export interface WeakReference_1$instance<T> {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    SetTarget(target: T): void;
    TryGetTarget(target: T): boolean;
}


export const WeakReference_1: {
    new<T>(target: T): WeakReference_1<T>;
    new<T>(target: T, trackResurrection: boolean): WeakReference_1<T>;
};


export interface __WeakReference_1$views<T> {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface WeakReference_1$instance<T> extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type WeakReference_1<T> = WeakReference_1$instance<T> & __WeakReference_1$views<T>;


export abstract class Activator$instance {
    static CreateInstance<T>(): T;
    static CreateInstance(assemblyName: string, typeName: string, ignoreCase: boolean, bindingAttr: BindingFlags, binder: Binder | undefined, args: (unknown | undefined)[] | undefined, culture: CultureInfo | undefined, activationAttributes: (unknown | undefined)[] | undefined): ObjectHandle | undefined;
    static CreateInstance(assemblyName: string, typeName: string, activationAttributes: (unknown | undefined)[] | undefined): ObjectHandle | undefined;
    static CreateInstance(assemblyName: string, typeName: string): ObjectHandle | undefined;
    static CreateInstance(type_: Type, nonPublic: boolean): unknown | undefined;
    static CreateInstance(type_: Type, args: (unknown | undefined)[] | undefined, activationAttributes: (unknown | undefined)[] | undefined): unknown | undefined;
    static CreateInstance(type_: Type, ...args: unknown[]): unknown | undefined;
    static CreateInstance(type_: Type, bindingAttr: BindingFlags, binder: Binder | undefined, args: (unknown | undefined)[] | undefined, culture: CultureInfo | undefined, activationAttributes: (unknown | undefined)[] | undefined): unknown | undefined;
    static CreateInstance(type_: Type, bindingAttr: BindingFlags, binder: Binder | undefined, args: (unknown | undefined)[] | undefined, culture: CultureInfo | undefined): unknown | undefined;
    static CreateInstance(type_: Type): unknown | undefined;
    static CreateInstanceFrom(assemblyFile: string, typeName: string, ignoreCase: boolean, bindingAttr: BindingFlags, binder: Binder | undefined, args: (unknown | undefined)[] | undefined, culture: CultureInfo | undefined, activationAttributes: (unknown | undefined)[] | undefined): ObjectHandle | undefined;
    static CreateInstanceFrom(assemblyFile: string, typeName: string, activationAttributes: (unknown | undefined)[] | undefined): ObjectHandle | undefined;
    static CreateInstanceFrom(assemblyFile: string, typeName: string): ObjectHandle | undefined;
}


export type Activator = Activator$instance;

export abstract class AppContext$instance {
    static readonly BaseDirectory: string;
    static readonly TargetFrameworkName: string | undefined;
    static GetData(name: string): unknown | undefined;
    static SetData(name: string, data: unknown | undefined): void;
    static SetSwitch(switchName: string, isEnabled: boolean): void;
    static TryGetSwitch(switchName: string, isEnabled: boolean): boolean;
}


export type AppContext = AppContext$instance;

export abstract class BitConverter$instance {
    static readonly IsLittleEndian: boolean;
    static DoubleToInt64Bits(value: double): long;
    static DoubleToUInt64Bits(value: double): ulong;
    static GetBytes(value: boolean): byte[];
    static GetBytes(value: char): byte[];
    static GetBytes(value: double): byte[];
    static GetBytes(value: half): byte[];
    static GetBytes(value: int128): byte[];
    static GetBytes(value: short): byte[];
    static GetBytes(value: int): byte[];
    static GetBytes(value: long): byte[];
    static GetBytes(value: float): byte[];
    static GetBytes(value: uint128): byte[];
    static GetBytes(value: ushort): byte[];
    static GetBytes(value: uint): byte[];
    static GetBytes(value: ulong): byte[];
    static HalfToInt16Bits(value: half): short;
    static HalfToUInt16Bits(value: half): ushort;
    static Int16BitsToHalf(value: short): half;
    static Int32BitsToSingle(value: int): float;
    static Int64BitsToDouble(value: long): double;
    static SingleToInt32Bits(value: float): int;
    static SingleToUInt32Bits(value: float): uint;
    static ToBoolean(value: byte[], startIndex: int): boolean;
    static ToBoolean(value: ReadOnlySpan_1<Byte>): boolean;
    static ToChar(value: byte[], startIndex: int): char;
    static ToChar(value: ReadOnlySpan_1<Byte>): char;
    static ToDouble(value: byte[], startIndex: int): double;
    static ToDouble(value: ReadOnlySpan_1<Byte>): double;
    static ToHalf(value: byte[], startIndex: int): half;
    static ToHalf(value: ReadOnlySpan_1<Byte>): half;
    static ToInt128(value: byte[], startIndex: int): int128;
    static ToInt128(value: ReadOnlySpan_1<Byte>): int128;
    static ToInt16(value: byte[], startIndex: int): short;
    static ToInt16(value: ReadOnlySpan_1<Byte>): short;
    static ToInt32(value: byte[], startIndex: int): int;
    static ToInt32(value: ReadOnlySpan_1<Byte>): int;
    static ToInt64(value: byte[], startIndex: int): long;
    static ToInt64(value: ReadOnlySpan_1<Byte>): long;
    static ToSingle(value: byte[], startIndex: int): float;
    static ToSingle(value: ReadOnlySpan_1<Byte>): float;
    static ToString(value: byte[], startIndex: int, length: int): string;
    static ToString(value: byte[], startIndex: int): string;
    static ToString(value: byte[]): string;
    static ToUInt128(value: byte[], startIndex: int): uint128;
    static ToUInt128(value: ReadOnlySpan_1<Byte>): uint128;
    static ToUInt16(value: byte[], startIndex: int): ushort;
    static ToUInt16(value: ReadOnlySpan_1<Byte>): ushort;
    static ToUInt32(value: byte[], startIndex: int): uint;
    static ToUInt32(value: ReadOnlySpan_1<Byte>): uint;
    static ToUInt64(value: byte[], startIndex: int): ulong;
    static ToUInt64(value: ReadOnlySpan_1<Byte>): ulong;
    static TryWriteBytes(destination: Span_1<Byte>, value: boolean): boolean;
    static TryWriteBytes(destination: Span_1<Byte>, value: char): boolean;
    static TryWriteBytes(destination: Span_1<Byte>, value: double): boolean;
    static TryWriteBytes(destination: Span_1<Byte>, value: half): boolean;
    static TryWriteBytes(destination: Span_1<Byte>, value: int128): boolean;
    static TryWriteBytes(destination: Span_1<Byte>, value: short): boolean;
    static TryWriteBytes(destination: Span_1<Byte>, value: int): boolean;
    static TryWriteBytes(destination: Span_1<Byte>, value: long): boolean;
    static TryWriteBytes(destination: Span_1<Byte>, value: float): boolean;
    static TryWriteBytes(destination: Span_1<Byte>, value: uint128): boolean;
    static TryWriteBytes(destination: Span_1<Byte>, value: ushort): boolean;
    static TryWriteBytes(destination: Span_1<Byte>, value: uint): boolean;
    static TryWriteBytes(destination: Span_1<Byte>, value: ulong): boolean;
    static UInt16BitsToHalf(value: ushort): half;
    static UInt32BitsToSingle(value: uint): float;
    static UInt64BitsToDouble(value: ulong): double;
}


export type BitConverter = BitConverter$instance;

export abstract class Buffer$instance {
    static BlockCopy(src: Array, srcOffset: int, dst: Array, dstOffset: int, count: int): void;
    static ByteLength(array: Array): int;
    static GetByte(array: Array, index: int): byte;
    static MemoryCopy(source: ptr<void>, destination: ptr<void>, destinationSizeInBytes: long, sourceBytesToCopy: long): void;
    static MemoryCopy(source: ptr<void>, destination: ptr<void>, destinationSizeInBytes: ulong, sourceBytesToCopy: ulong): void;
    static SetByte(array: Array, index: int, value: byte): void;
}


export type Buffer = Buffer$instance;

export abstract class Console$instance {
    static readonly In: TextReader;
    static InputEncoding: Encoding;
    static OutputEncoding: Encoding;
    static readonly KeyAvailable: boolean;
    static readonly Out: TextWriter;
    static readonly Error: TextWriter;
    static readonly IsInputRedirected: boolean;
    static readonly IsOutputRedirected: boolean;
    static readonly IsErrorRedirected: boolean;
    static CursorSize: int;
    static readonly NumberLock: boolean;
    static readonly CapsLock: boolean;
    static BackgroundColor: ConsoleColor;
    static ForegroundColor: ConsoleColor;
    static BufferWidth: int;
    static BufferHeight: int;
    static WindowLeft: int;
    static WindowTop: int;
    static WindowWidth: int;
    static WindowHeight: int;
    static readonly LargestWindowWidth: int;
    static readonly LargestWindowHeight: int;
    static CursorVisible: boolean;
    static CursorLeft: int;
    static CursorTop: int;
    static Title: string;
    static TreatControlCAsInput: boolean;
    static Beep(): void;
    static Beep(frequency: int, duration: int): void;
    static Clear(): void;
    static GetCursorPosition(): ValueTuple_2<Int32, Int32>;
    static MoveBufferArea(sourceLeft: int, sourceTop: int, sourceWidth: int, sourceHeight: int, targetLeft: int, targetTop: int, sourceChar: char, sourceForeColor: ConsoleColor, sourceBackColor: ConsoleColor): void;
    static MoveBufferArea(sourceLeft: int, sourceTop: int, sourceWidth: int, sourceHeight: int, targetLeft: int, targetTop: int): void;
    static OpenStandardError(): Stream;
    static OpenStandardError(bufferSize: int): Stream;
    static OpenStandardInput(): Stream;
    static OpenStandardInput(bufferSize: int): Stream;
    static OpenStandardOutput(): Stream;
    static OpenStandardOutput(bufferSize: int): Stream;
    static Read(): int;
    static ReadKey(): ConsoleKeyInfo;
    static ReadKey(intercept: boolean): ConsoleKeyInfo;
    static ReadLine(): string | undefined;
    static ResetColor(): void;
    static SetBufferSize(width: int, height: int): void;
    static SetCursorPosition(left: int, top: int): void;
    static SetError(newError: TextWriter): void;
    static SetIn(newIn: TextReader): void;
    static SetOut(newOut: TextWriter): void;
    static SetWindowPosition(left: int, top: int): void;
    static SetWindowSize(width: int, height: int): void;
    static Write(value: boolean): void;
    static Write(value: char): void;
    static Write(buffer: char[], index: int, count: int): void;
    static Write(buffer: char[] | undefined): void;
    static Write(value: decimal): void;
    static Write(value: double): void;
    static Write(value: int): void;
    static Write(value: long): void;
    static Write(value: unknown | undefined): void;
    static Write(value: ReadOnlySpan_1<Char>): void;
    static Write(value: float): void;
    static Write(format: string, arg0: unknown | undefined, arg1: unknown | undefined, arg2: unknown | undefined): void;
    static Write(format: string, arg0: unknown | undefined, arg1: unknown | undefined): void;
    static Write(format: string, arg0: unknown | undefined): void;
    static Write(format: string, ...arg: unknown[]): void;
    static Write(format: string, arg: ReadOnlySpan_1<unknown>): void;
    static Write(value: string | undefined): void;
    static Write(value: uint): void;
    static Write(value: ulong): void;
    static WriteLine(): void;
    static WriteLine(value: boolean): void;
    static WriteLine(value: char): void;
    static WriteLine(buffer: char[], index: int, count: int): void;
    static WriteLine(buffer: char[] | undefined): void;
    static WriteLine(value: decimal): void;
    static WriteLine(value: double): void;
    static WriteLine(value: int): void;
    static WriteLine(value: long): void;
    static WriteLine(value: unknown | undefined): void;
    static WriteLine(value: ReadOnlySpan_1<Char>): void;
    static WriteLine(value: float): void;
    static WriteLine(format: string, arg0: unknown | undefined, arg1: unknown | undefined, arg2: unknown | undefined): void;
    static WriteLine(format: string, arg0: unknown | undefined, arg1: unknown | undefined): void;
    static WriteLine(format: string, arg0: unknown | undefined): void;
    static WriteLine(format: string, ...arg: unknown[]): void;
    static WriteLine(format: string, arg: ReadOnlySpan_1<unknown>): void;
    static WriteLine(value: string | undefined): void;
    static WriteLine(value: uint): void;
    static WriteLine(value: ulong): void;
}


export type Console = Console$instance;

export abstract class Convert$instance {
    static readonly DBNull: unknown;
    static ChangeType(value: unknown | undefined, conversionType: Type, provider: IFormatProvider | undefined): unknown | undefined;
    static ChangeType(value: unknown | undefined, conversionType: Type): unknown | undefined;
    static ChangeType(value: unknown | undefined, typeCode: TypeCode, provider: IFormatProvider | undefined): unknown | undefined;
    static ChangeType(value: unknown | undefined, typeCode: TypeCode): unknown | undefined;
    static FromBase64CharArray(inArray: char[], offset: int, length: int): byte[];
    static FromBase64String(s: string): byte[];
    static FromHexString(utf8Source: ReadOnlySpan_1<Byte>, destination: Span_1<Byte>, bytesConsumed: int, bytesWritten: int): OperationStatus;
    static FromHexString(utf8Source: ReadOnlySpan_1<Byte>): byte[];
    static FromHexString(source: ReadOnlySpan_1<Char>, destination: Span_1<Byte>, charsConsumed: int, bytesWritten: int): OperationStatus;
    static FromHexString(chars: ReadOnlySpan_1<Char>): byte[];
    static FromHexString(source: string, destination: Span_1<Byte>, charsConsumed: int, bytesWritten: int): OperationStatus;
    static FromHexString(s: string): byte[];
    static GetTypeCode(value: unknown | undefined): TypeCode;
    static IsDBNull(value: unknown | undefined): boolean;
    static ToBase64CharArray(inArray: byte[], offsetIn: int, length: int, outArray: char[], offsetOut: int, options: Base64FormattingOptions): int;
    static ToBase64CharArray(inArray: byte[], offsetIn: int, length: int, outArray: char[], offsetOut: int): int;
    static ToBase64String(inArray: byte[], options: Base64FormattingOptions): string;
    static ToBase64String(inArray: byte[], offset: int, length: int, options: Base64FormattingOptions): string;
    static ToBase64String(inArray: byte[], offset: int, length: int): string;
    static ToBase64String(inArray: byte[]): string;
    static ToBase64String(bytes: ReadOnlySpan_1<Byte>, options?: Base64FormattingOptions): string;
    static ToBoolean(value: boolean): boolean;
    static ToBoolean(value: byte): boolean;
    static ToBoolean(value: char): boolean;
    static ToBoolean(value: DateTime): boolean;
    static ToBoolean(value: decimal): boolean;
    static ToBoolean(value: double): boolean;
    static ToBoolean(value: short): boolean;
    static ToBoolean(value: int): boolean;
    static ToBoolean(value: long): boolean;
    static ToBoolean(value: unknown | undefined, provider: IFormatProvider | undefined): boolean;
    static ToBoolean(value: unknown | undefined): boolean;
    static ToBoolean(value: sbyte): boolean;
    static ToBoolean(value: float): boolean;
    static ToBoolean(value: string | undefined, provider: IFormatProvider | undefined): boolean;
    static ToBoolean(value: string | undefined): boolean;
    static ToBoolean(value: ushort): boolean;
    static ToBoolean(value: uint): boolean;
    static ToBoolean(value: ulong): boolean;
    static ToByte(value: boolean): byte;
    static ToByte(value: byte): byte;
    static ToByte(value: char): byte;
    static ToByte(value: DateTime): byte;
    static ToByte(value: decimal): byte;
    static ToByte(value: double): byte;
    static ToByte(value: short): byte;
    static ToByte(value: int): byte;
    static ToByte(value: long): byte;
    static ToByte(value: unknown | undefined, provider: IFormatProvider | undefined): byte;
    static ToByte(value: unknown | undefined): byte;
    static ToByte(value: sbyte): byte;
    static ToByte(value: float): byte;
    static ToByte(value: string | undefined, provider: IFormatProvider | undefined): byte;
    static ToByte(value: string | undefined, fromBase: int): byte;
    static ToByte(value: string | undefined): byte;
    static ToByte(value: ushort): byte;
    static ToByte(value: uint): byte;
    static ToByte(value: ulong): byte;
    static ToChar(value: boolean): char;
    static ToChar(value: byte): char;
    static ToChar(value: char): char;
    static ToChar(value: DateTime): char;
    static ToChar(value: decimal): char;
    static ToChar(value: double): char;
    static ToChar(value: short): char;
    static ToChar(value: int): char;
    static ToChar(value: long): char;
    static ToChar(value: unknown | undefined, provider: IFormatProvider | undefined): char;
    static ToChar(value: unknown | undefined): char;
    static ToChar(value: sbyte): char;
    static ToChar(value: float): char;
    static ToChar(value: string, provider: IFormatProvider | undefined): char;
    static ToChar(value: string): char;
    static ToChar(value: ushort): char;
    static ToChar(value: uint): char;
    static ToChar(value: ulong): char;
    static ToDateTime(value: boolean): DateTime;
    static ToDateTime(value: byte): DateTime;
    static ToDateTime(value: char): DateTime;
    static ToDateTime(value: DateTime): DateTime;
    static ToDateTime(value: decimal): DateTime;
    static ToDateTime(value: double): DateTime;
    static ToDateTime(value: short): DateTime;
    static ToDateTime(value: int): DateTime;
    static ToDateTime(value: long): DateTime;
    static ToDateTime(value: unknown | undefined, provider: IFormatProvider | undefined): DateTime;
    static ToDateTime(value: unknown | undefined): DateTime;
    static ToDateTime(value: sbyte): DateTime;
    static ToDateTime(value: float): DateTime;
    static ToDateTime(value: string | undefined, provider: IFormatProvider | undefined): DateTime;
    static ToDateTime(value: string | undefined): DateTime;
    static ToDateTime(value: ushort): DateTime;
    static ToDateTime(value: uint): DateTime;
    static ToDateTime(value: ulong): DateTime;
    static ToDecimal(value: boolean): decimal;
    static ToDecimal(value: byte): decimal;
    static ToDecimal(value: char): decimal;
    static ToDecimal(value: DateTime): decimal;
    static ToDecimal(value: decimal): decimal;
    static ToDecimal(value: double): decimal;
    static ToDecimal(value: short): decimal;
    static ToDecimal(value: int): decimal;
    static ToDecimal(value: long): decimal;
    static ToDecimal(value: unknown | undefined, provider: IFormatProvider | undefined): decimal;
    static ToDecimal(value: unknown | undefined): decimal;
    static ToDecimal(value: sbyte): decimal;
    static ToDecimal(value: float): decimal;
    static ToDecimal(value: string | undefined, provider: IFormatProvider | undefined): decimal;
    static ToDecimal(value: string | undefined): decimal;
    static ToDecimal(value: ushort): decimal;
    static ToDecimal(value: uint): decimal;
    static ToDecimal(value: ulong): decimal;
    static ToDouble(value: boolean): double;
    static ToDouble(value: byte): double;
    static ToDouble(value: char): double;
    static ToDouble(value: DateTime): double;
    static ToDouble(value: decimal): double;
    static ToDouble(value: double): double;
    static ToDouble(value: short): double;
    static ToDouble(value: int): double;
    static ToDouble(value: long): double;
    static ToDouble(value: unknown | undefined, provider: IFormatProvider | undefined): double;
    static ToDouble(value: unknown | undefined): double;
    static ToDouble(value: sbyte): double;
    static ToDouble(value: float): double;
    static ToDouble(value: string | undefined, provider: IFormatProvider | undefined): double;
    static ToDouble(value: string | undefined): double;
    static ToDouble(value: ushort): double;
    static ToDouble(value: uint): double;
    static ToDouble(value: ulong): double;
    static ToHexString(inArray: byte[], offset: int, length: int): string;
    static ToHexString(inArray: byte[]): string;
    static ToHexString(bytes: ReadOnlySpan_1<Byte>): string;
    static ToHexStringLower(inArray: byte[], offset: int, length: int): string;
    static ToHexStringLower(inArray: byte[]): string;
    static ToHexStringLower(bytes: ReadOnlySpan_1<Byte>): string;
    static ToInt16(value: boolean): short;
    static ToInt16(value: byte): short;
    static ToInt16(value: char): short;
    static ToInt16(value: DateTime): short;
    static ToInt16(value: decimal): short;
    static ToInt16(value: double): short;
    static ToInt16(value: short): short;
    static ToInt16(value: int): short;
    static ToInt16(value: long): short;
    static ToInt16(value: unknown | undefined, provider: IFormatProvider | undefined): short;
    static ToInt16(value: unknown | undefined): short;
    static ToInt16(value: sbyte): short;
    static ToInt16(value: float): short;
    static ToInt16(value: string | undefined, provider: IFormatProvider | undefined): short;
    static ToInt16(value: string | undefined, fromBase: int): short;
    static ToInt16(value: string | undefined): short;
    static ToInt16(value: ushort): short;
    static ToInt16(value: uint): short;
    static ToInt16(value: ulong): short;
    static ToInt32(value: boolean): int;
    static ToInt32(value: byte): int;
    static ToInt32(value: char): int;
    static ToInt32(value: DateTime): int;
    static ToInt32(value: decimal): int;
    static ToInt32(value: double): int;
    static ToInt32(value: short): int;
    static ToInt32(value: int): int;
    static ToInt32(value: long): int;
    static ToInt32(value: unknown | undefined, provider: IFormatProvider | undefined): int;
    static ToInt32(value: unknown | undefined): int;
    static ToInt32(value: sbyte): int;
    static ToInt32(value: float): int;
    static ToInt32(value: string | undefined, provider: IFormatProvider | undefined): int;
    static ToInt32(value: string | undefined, fromBase: int): int;
    static ToInt32(value: string | undefined): int;
    static ToInt32(value: ushort): int;
    static ToInt32(value: uint): int;
    static ToInt32(value: ulong): int;
    static ToInt64(value: boolean): long;
    static ToInt64(value: byte): long;
    static ToInt64(value: char): long;
    static ToInt64(value: DateTime): long;
    static ToInt64(value: decimal): long;
    static ToInt64(value: double): long;
    static ToInt64(value: short): long;
    static ToInt64(value: int): long;
    static ToInt64(value: long): long;
    static ToInt64(value: unknown | undefined, provider: IFormatProvider | undefined): long;
    static ToInt64(value: unknown | undefined): long;
    static ToInt64(value: sbyte): long;
    static ToInt64(value: float): long;
    static ToInt64(value: string | undefined, provider: IFormatProvider | undefined): long;
    static ToInt64(value: string | undefined, fromBase: int): long;
    static ToInt64(value: string | undefined): long;
    static ToInt64(value: ushort): long;
    static ToInt64(value: uint): long;
    static ToInt64(value: ulong): long;
    static ToSByte(value: boolean): sbyte;
    static ToSByte(value: byte): sbyte;
    static ToSByte(value: char): sbyte;
    static ToSByte(value: DateTime): sbyte;
    static ToSByte(value: decimal): sbyte;
    static ToSByte(value: double): sbyte;
    static ToSByte(value: short): sbyte;
    static ToSByte(value: int): sbyte;
    static ToSByte(value: long): sbyte;
    static ToSByte(value: unknown | undefined, provider: IFormatProvider | undefined): sbyte;
    static ToSByte(value: unknown | undefined): sbyte;
    static ToSByte(value: sbyte): sbyte;
    static ToSByte(value: float): sbyte;
    static ToSByte(value: string, provider: IFormatProvider | undefined): sbyte;
    static ToSByte(value: string | undefined, fromBase: int): sbyte;
    static ToSByte(value: string | undefined): sbyte;
    static ToSByte(value: ushort): sbyte;
    static ToSByte(value: uint): sbyte;
    static ToSByte(value: ulong): sbyte;
    static ToSingle(value: boolean): float;
    static ToSingle(value: byte): float;
    static ToSingle(value: char): float;
    static ToSingle(value: DateTime): float;
    static ToSingle(value: decimal): float;
    static ToSingle(value: double): float;
    static ToSingle(value: short): float;
    static ToSingle(value: int): float;
    static ToSingle(value: long): float;
    static ToSingle(value: unknown | undefined, provider: IFormatProvider | undefined): float;
    static ToSingle(value: unknown | undefined): float;
    static ToSingle(value: sbyte): float;
    static ToSingle(value: float): float;
    static ToSingle(value: string | undefined, provider: IFormatProvider | undefined): float;
    static ToSingle(value: string | undefined): float;
    static ToSingle(value: ushort): float;
    static ToSingle(value: uint): float;
    static ToSingle(value: ulong): float;
    static ToString(value: boolean, provider: IFormatProvider | undefined): string;
    static ToString(value: boolean): string;
    static ToString(value: byte, provider: IFormatProvider | undefined): string;
    static ToString(value: byte, toBase: int): string;
    static ToString(value: byte): string;
    static ToString(value: char, provider: IFormatProvider | undefined): string;
    static ToString(value: char): string;
    static ToString(value: DateTime, provider: IFormatProvider | undefined): string;
    static ToString(value: DateTime): string;
    static ToString(value: decimal, provider: IFormatProvider | undefined): string;
    static ToString(value: decimal): string;
    static ToString(value: double, provider: IFormatProvider | undefined): string;
    static ToString(value: double): string;
    static ToString(value: short, provider: IFormatProvider | undefined): string;
    static ToString(value: short, toBase: int): string;
    static ToString(value: short): string;
    static ToString(value: int, provider: IFormatProvider | undefined): string;
    static ToString(value: int, toBase: int): string;
    static ToString(value: int): string;
    static ToString(value: long, provider: IFormatProvider | undefined): string;
    static ToString(value: long, toBase: int): string;
    static ToString(value: long): string;
    static ToString(value: unknown | undefined, provider: IFormatProvider | undefined): string | undefined;
    static ToString(value: unknown | undefined): string | undefined;
    static ToString(value: sbyte, provider: IFormatProvider | undefined): string;
    static ToString(value: sbyte): string;
    static ToString(value: float, provider: IFormatProvider | undefined): string;
    static ToString(value: float): string;
    static ToString(value: string | undefined, provider: IFormatProvider | undefined): string | undefined;
    static ToString(value: string | undefined): string | undefined;
    static ToString(value: ushort, provider: IFormatProvider | undefined): string;
    static ToString(value: ushort): string;
    static ToString(value: uint, provider: IFormatProvider | undefined): string;
    static ToString(value: uint): string;
    static ToString(value: ulong, provider: IFormatProvider | undefined): string;
    static ToString(value: ulong): string;
    static ToUInt16(value: boolean): ushort;
    static ToUInt16(value: byte): ushort;
    static ToUInt16(value: char): ushort;
    static ToUInt16(value: DateTime): ushort;
    static ToUInt16(value: decimal): ushort;
    static ToUInt16(value: double): ushort;
    static ToUInt16(value: short): ushort;
    static ToUInt16(value: int): ushort;
    static ToUInt16(value: long): ushort;
    static ToUInt16(value: unknown | undefined, provider: IFormatProvider | undefined): ushort;
    static ToUInt16(value: unknown | undefined): ushort;
    static ToUInt16(value: sbyte): ushort;
    static ToUInt16(value: float): ushort;
    static ToUInt16(value: string | undefined, provider: IFormatProvider | undefined): ushort;
    static ToUInt16(value: string | undefined, fromBase: int): ushort;
    static ToUInt16(value: string | undefined): ushort;
    static ToUInt16(value: ushort): ushort;
    static ToUInt16(value: uint): ushort;
    static ToUInt16(value: ulong): ushort;
    static ToUInt32(value: boolean): uint;
    static ToUInt32(value: byte): uint;
    static ToUInt32(value: char): uint;
    static ToUInt32(value: DateTime): uint;
    static ToUInt32(value: decimal): uint;
    static ToUInt32(value: double): uint;
    static ToUInt32(value: short): uint;
    static ToUInt32(value: int): uint;
    static ToUInt32(value: long): uint;
    static ToUInt32(value: unknown | undefined, provider: IFormatProvider | undefined): uint;
    static ToUInt32(value: unknown | undefined): uint;
    static ToUInt32(value: sbyte): uint;
    static ToUInt32(value: float): uint;
    static ToUInt32(value: string | undefined, provider: IFormatProvider | undefined): uint;
    static ToUInt32(value: string | undefined, fromBase: int): uint;
    static ToUInt32(value: string | undefined): uint;
    static ToUInt32(value: ushort): uint;
    static ToUInt32(value: uint): uint;
    static ToUInt32(value: ulong): uint;
    static ToUInt64(value: boolean): ulong;
    static ToUInt64(value: byte): ulong;
    static ToUInt64(value: char): ulong;
    static ToUInt64(value: DateTime): ulong;
    static ToUInt64(value: decimal): ulong;
    static ToUInt64(value: double): ulong;
    static ToUInt64(value: short): ulong;
    static ToUInt64(value: int): ulong;
    static ToUInt64(value: long): ulong;
    static ToUInt64(value: unknown | undefined, provider: IFormatProvider | undefined): ulong;
    static ToUInt64(value: unknown | undefined): ulong;
    static ToUInt64(value: sbyte): ulong;
    static ToUInt64(value: float): ulong;
    static ToUInt64(value: string | undefined, provider: IFormatProvider | undefined): ulong;
    static ToUInt64(value: string | undefined, fromBase: int): ulong;
    static ToUInt64(value: string | undefined): ulong;
    static ToUInt64(value: ushort): ulong;
    static ToUInt64(value: uint): ulong;
    static ToUInt64(value: ulong): ulong;
    static TryFromBase64Chars(chars: ReadOnlySpan_1<Char>, bytes: Span_1<Byte>, bytesWritten: int): boolean;
    static TryFromBase64String(s: string, bytes: Span_1<Byte>, bytesWritten: int): boolean;
    static TryToBase64Chars(bytes: ReadOnlySpan_1<Byte>, chars: Span_1<Char>, charsWritten: int, options?: Base64FormattingOptions): boolean;
    static TryToHexString(source: ReadOnlySpan_1<Byte>, utf8Destination: Span_1<Byte>, bytesWritten: int): boolean;
    static TryToHexString(source: ReadOnlySpan_1<Byte>, destination: Span_1<Char>, charsWritten: int): boolean;
    static TryToHexStringLower(source: ReadOnlySpan_1<Byte>, utf8Destination: Span_1<Byte>, bytesWritten: int): boolean;
    static TryToHexStringLower(source: ReadOnlySpan_1<Byte>, destination: Span_1<Char>, charsWritten: int): boolean;
}


export type Convert = Convert$instance;

export abstract class Environment$instance {
    static readonly CurrentManagedThreadId: int;
    static ExitCode: int;
    static readonly ProcessorCount: int;
    static readonly IsPrivilegedProcess: boolean;
    static readonly HasShutdownStarted: boolean;
    static readonly CommandLine: string;
    static CurrentDirectory: string;
    static readonly ProcessId: int;
    static readonly ProcessPath: string | undefined;
    static readonly Is64BitProcess: boolean;
    static readonly Is64BitOperatingSystem: boolean;
    static readonly NewLine: string;
    static readonly OSVersion: OperatingSystem;
    static readonly StackTrace: string;
    static readonly SystemPageSize: int;
    static readonly TickCount: int;
    static readonly UserInteractive: boolean;
    static readonly SystemDirectory: string;
    static readonly UserDomainName: string;
    static readonly CpuUsage: Environment_ProcessCpuUsage;
    static readonly TickCount64: long;
    static readonly MachineName: string;
    static readonly UserName: string;
    static readonly WorkingSet: long;
    static readonly Version: Version;
    static Exit(exitCode: int): void;
    static ExpandEnvironmentVariables(name: string): string;
    static FailFast(message: string | undefined, exception: Exception | undefined): void;
    static FailFast(message: string | undefined): void;
    static GetCommandLineArgs(): string[];
    static GetEnvironmentVariable(variable: string, target: EnvironmentVariableTarget): string | undefined;
    static GetEnvironmentVariable(variable: string): string | undefined;
    static GetEnvironmentVariables(): IDictionary;
    static GetEnvironmentVariables(target: EnvironmentVariableTarget): IDictionary;
    static GetFolderPath(folder: Environment_SpecialFolder, option: Environment_SpecialFolderOption): string;
    static GetFolderPath(folder: Environment_SpecialFolder): string;
    static GetLogicalDrives(): string[];
    static SetEnvironmentVariable(variable: string, value: string | undefined, target: EnvironmentVariableTarget): void;
    static SetEnvironmentVariable(variable: string, value: string | undefined): void;
}


export type Environment = Environment$instance;

export abstract class GC$instance {
    static readonly MaxGeneration: int;
    static AddMemoryPressure(bytesAllocated: long): void;
    static AllocateArray<T>(length: int, pinned?: boolean): T[];
    static AllocateUninitializedArray<T>(length: int, pinned?: boolean): T[];
    static CancelFullGCNotification(): void;
    static Collect(): void;
    static Collect(generation: int, mode: GCCollectionMode, blocking: boolean, compacting: boolean): void;
    static Collect(generation: int, mode: GCCollectionMode, blocking: boolean): void;
    static Collect(generation: int, mode: GCCollectionMode): void;
    static Collect(generation: int): void;
    static CollectionCount(generation: int): int;
    static EndNoGCRegion(): void;
    static GetAllocatedBytesForCurrentThread(): long;
    static GetConfigurationVariables(): IReadOnlyDictionary_2<String, unknown>;
    static GetGCMemoryInfo(): GCMemoryInfo;
    static GetGCMemoryInfo(kind: GCKind): GCMemoryInfo;
    static GetGeneration(obj: unknown): int;
    static GetGeneration(wo: WeakReference): int;
    static GetTotalAllocatedBytes(precise?: boolean): long;
    static GetTotalMemory(forceFullCollection: boolean): long;
    static GetTotalPauseDuration(): TimeSpan;
    static KeepAlive(obj: unknown | undefined): void;
    static RefreshMemoryLimit(): void;
    static RegisterForFullGCNotification(maxGenerationThreshold: int, largeObjectHeapThreshold: int): void;
    static RegisterNoGCRegionCallback(totalSize: long, callback: Action): void;
    static RemoveMemoryPressure(bytesAllocated: long): void;
    static ReRegisterForFinalize(obj: unknown): void;
    static SuppressFinalize(obj: unknown): void;
    static TryStartNoGCRegion(totalSize: long, disallowFullBlockingGC: boolean): boolean;
    static TryStartNoGCRegion(totalSize: long, lohSize: long, disallowFullBlockingGC: boolean): boolean;
    static TryStartNoGCRegion(totalSize: long, lohSize: long): boolean;
    static TryStartNoGCRegion(totalSize: long): boolean;
    static WaitForFullGCApproach(): GCNotificationStatus;
    static WaitForFullGCApproach(millisecondsTimeout: int): GCNotificationStatus;
    static WaitForFullGCApproach(timeout: TimeSpan): GCNotificationStatus;
    static WaitForFullGCComplete(): GCNotificationStatus;
    static WaitForFullGCComplete(millisecondsTimeout: int): GCNotificationStatus;
    static WaitForFullGCComplete(timeout: TimeSpan): GCNotificationStatus;
    static WaitForPendingFinalizers(): void;
}


export type GC = GC$instance;

export abstract class Math$instance {
    static readonly E: double;
    static readonly PI: double;
    static readonly Tau: double;
    static Abs(value: decimal): decimal;
    static Abs(value: double): double;
    static Abs(value: short): short;
    static Abs(value: int): int;
    static Abs(value: long): long;
    static Abs(value: nint): nint;
    static Abs(value: sbyte): sbyte;
    static Abs(value: float): float;
    static Acos(d: double): double;
    static Acosh(d: double): double;
    static Asin(d: double): double;
    static Asinh(d: double): double;
    static Atan(d: double): double;
    static Atan2(y: double, x: double): double;
    static Atanh(d: double): double;
    static BigMul(a: int, b: int): long;
    static BigMul(a: long, b: long, low: long): long;
    static BigMul(a: long, b: long): int128;
    static BigMul(a: uint, b: uint): ulong;
    static BigMul(a: ulong, b: ulong, low: ulong): ulong;
    static BigMul(a: ulong, b: ulong): uint128;
    static BitDecrement(x: double): double;
    static BitIncrement(x: double): double;
    static Cbrt(d: double): double;
    static Ceiling(d: decimal): decimal;
    static Ceiling(a: double): double;
    static Clamp(value: byte, min: byte, max: byte): byte;
    static Clamp(value: decimal, min: decimal, max: decimal): decimal;
    static Clamp(value: double, min: double, max: double): double;
    static Clamp(value: short, min: short, max: short): short;
    static Clamp(value: int, min: int, max: int): int;
    static Clamp(value: long, min: long, max: long): long;
    static Clamp(value: nint, min: nint, max: nint): nint;
    static Clamp(value: sbyte, min: sbyte, max: sbyte): sbyte;
    static Clamp(value: float, min: float, max: float): float;
    static Clamp(value: ushort, min: ushort, max: ushort): ushort;
    static Clamp(value: uint, min: uint, max: uint): uint;
    static Clamp(value: ulong, min: ulong, max: ulong): ulong;
    static Clamp(value: nuint, min: nuint, max: nuint): nuint;
    static CopySign(x: double, y: double): double;
    static Cos(d: double): double;
    static Cosh(value: double): double;
    static DivRem(left: byte, right: byte): ValueTuple_2<Byte, Byte>;
    static DivRem(left: short, right: short): ValueTuple_2<Int16, Int16>;
    static DivRem(a: int, b: int, result: int): int;
    static DivRem(left: int, right: int): ValueTuple_2<Int32, Int32>;
    static DivRem(a: long, b: long, result: long): long;
    static DivRem(left: long, right: long): ValueTuple_2<Int64, Int64>;
    static DivRem(left: nint, right: nint): ValueTuple_2<IntPtr, IntPtr>;
    static DivRem(left: sbyte, right: sbyte): ValueTuple_2<SByte, SByte>;
    static DivRem(left: ushort, right: ushort): ValueTuple_2<UInt16, UInt16>;
    static DivRem(left: uint, right: uint): ValueTuple_2<UInt32, UInt32>;
    static DivRem(left: ulong, right: ulong): ValueTuple_2<UInt64, UInt64>;
    static DivRem(left: nuint, right: nuint): ValueTuple_2<UIntPtr, UIntPtr>;
    static Exp(d: double): double;
    static Floor(d: decimal): decimal;
    static Floor(d: double): double;
    static FusedMultiplyAdd(x: double, y: double, z: double): double;
    static IEEERemainder(x: double, y: double): double;
    static ILogB(x: double): int;
    static Log(a: double, newBase: double): double;
    static Log(d: double): double;
    static Log10(d: double): double;
    static Log2(x: double): double;
    static Max(val1: byte, val2: byte): byte;
    static Max(val1: decimal, val2: decimal): decimal;
    static Max(val1: double, val2: double): double;
    static Max(val1: short, val2: short): short;
    static Max(val1: int, val2: int): int;
    static Max(val1: long, val2: long): long;
    static Max(val1: nint, val2: nint): nint;
    static Max(val1: sbyte, val2: sbyte): sbyte;
    static Max(val1: float, val2: float): float;
    static Max(val1: ushort, val2: ushort): ushort;
    static Max(val1: uint, val2: uint): uint;
    static Max(val1: ulong, val2: ulong): ulong;
    static Max(val1: nuint, val2: nuint): nuint;
    static MaxMagnitude(x: double, y: double): double;
    static Min(val1: byte, val2: byte): byte;
    static Min(val1: decimal, val2: decimal): decimal;
    static Min(val1: double, val2: double): double;
    static Min(val1: short, val2: short): short;
    static Min(val1: int, val2: int): int;
    static Min(val1: long, val2: long): long;
    static Min(val1: nint, val2: nint): nint;
    static Min(val1: sbyte, val2: sbyte): sbyte;
    static Min(val1: float, val2: float): float;
    static Min(val1: ushort, val2: ushort): ushort;
    static Min(val1: uint, val2: uint): uint;
    static Min(val1: ulong, val2: ulong): ulong;
    static Min(val1: nuint, val2: nuint): nuint;
    static MinMagnitude(x: double, y: double): double;
    static Pow(x: double, y: double): double;
    static ReciprocalEstimate(d: double): double;
    static ReciprocalSqrtEstimate(d: double): double;
    static Round(d: decimal, decimals: int, mode: MidpointRounding): decimal;
    static Round(d: decimal, decimals: int): decimal;
    static Round(d: decimal, mode: MidpointRounding): decimal;
    static Round(d: decimal): decimal;
    static Round(value: double, digits: int, mode: MidpointRounding): double;
    static Round(value: double, digits: int): double;
    static Round(value: double, mode: MidpointRounding): double;
    static Round(a: double): double;
    static ScaleB(x: double, n: int): double;
    static Sign(value: decimal): int;
    static Sign(value: double): int;
    static Sign(value: short): int;
    static Sign(value: int): int;
    static Sign(value: long): int;
    static Sign(value: nint): int;
    static Sign(value: sbyte): int;
    static Sign(value: float): int;
    static Sin(a: double): double;
    static SinCos(x: double): ValueTuple_2<Double, Double>;
    static Sinh(value: double): double;
    static Sqrt(d: double): double;
    static Tan(a: double): double;
    static Tanh(value: double): double;
    static Truncate(d: decimal): decimal;
    static Truncate(d: double): double;
}


export type Math = Math$instance;

export abstract class MathF$instance {
    static readonly E: float;
    static readonly PI: float;
    static readonly Tau: float;
    static Abs(x: float): float;
    static Acos(x: float): float;
    static Acosh(x: float): float;
    static Asin(x: float): float;
    static Asinh(x: float): float;
    static Atan(x: float): float;
    static Atan2(y: float, x: float): float;
    static Atanh(x: float): float;
    static BitDecrement(x: float): float;
    static BitIncrement(x: float): float;
    static Cbrt(x: float): float;
    static Ceiling(x: float): float;
    static CopySign(x: float, y: float): float;
    static Cos(x: float): float;
    static Cosh(x: float): float;
    static Exp(x: float): float;
    static Floor(x: float): float;
    static FusedMultiplyAdd(x: float, y: float, z: float): float;
    static IEEERemainder(x: float, y: float): float;
    static ILogB(x: float): int;
    static Log(x: float, y: float): float;
    static Log(x: float): float;
    static Log10(x: float): float;
    static Log2(x: float): float;
    static Max(x: float, y: float): float;
    static MaxMagnitude(x: float, y: float): float;
    static Min(x: float, y: float): float;
    static MinMagnitude(x: float, y: float): float;
    static Pow(x: float, y: float): float;
    static ReciprocalEstimate(x: float): float;
    static ReciprocalSqrtEstimate(x: float): float;
    static Round(x: float, digits: int, mode: MidpointRounding): float;
    static Round(x: float, digits: int): float;
    static Round(x: float, mode: MidpointRounding): float;
    static Round(x: float): float;
    static ScaleB(x: float, n: int): float;
    static Sign(x: float): int;
    static Sin(x: float): float;
    static SinCos(x: float): ValueTuple_2<Single, Single>;
    static Sinh(x: float): float;
    static Sqrt(x: float): float;
    static Tan(x: float): float;
    static Tanh(x: float): float;
    static Truncate(x: float): float;
}


export type MathF = MathF$instance;

export abstract class MemoryExtensions$instance {
    static AsMemory<T>(segment: ArraySegment_1<T>, start: int, length: int): Memory_1<T>;
    static AsMemory<T>(segment: ArraySegment_1<T>, start: int): Memory_1<T>;
    static AsMemory<T>(segment: ArraySegment_1<T>): Memory_1<T>;
    static AsMemory(text: string | undefined, startIndex: Index): ReadOnlyMemory_1<Char>;
    static AsMemory(text: string | undefined, start: int, length: int): ReadOnlyMemory_1<Char>;
    static AsMemory(text: string | undefined, start: int): ReadOnlyMemory_1<Char>;
    static AsMemory(text: string | undefined, range: Range): ReadOnlyMemory_1<Char>;
    static AsMemory(text: string | undefined): ReadOnlyMemory_1<Char>;
    static AsMemory<T>(array: T[] | undefined, startIndex: Index): Memory_1<T>;
    static AsMemory<T>(array: T[] | undefined, start: int, length: int): Memory_1<T>;
    static AsMemory<T>(array: T[] | undefined, start: int): Memory_1<T>;
    static AsMemory<T>(array: T[] | undefined, range: Range): Memory_1<T>;
    static AsMemory<T>(array: T[] | undefined): Memory_1<T>;
    static AsSpan<T>(segment: ArraySegment_1<T>, startIndex: Index): Span_1<T>;
    static AsSpan<T>(segment: ArraySegment_1<T>, start: int, length: int): Span_1<T>;
    static AsSpan<T>(segment: ArraySegment_1<T>, start: int): Span_1<T>;
    static AsSpan<T>(segment: ArraySegment_1<T>, range: Range): Span_1<T>;
    static AsSpan<T>(segment: ArraySegment_1<T>): Span_1<T>;
    static AsSpan(text: string | undefined, startIndex: Index): ReadOnlySpan_1<Char>;
    static AsSpan(text: string | undefined, start: int, length: int): ReadOnlySpan_1<Char>;
    static AsSpan(text: string | undefined, start: int): ReadOnlySpan_1<Char>;
    static AsSpan(text: string | undefined, range: Range): ReadOnlySpan_1<Char>;
    static AsSpan(text: string | undefined): ReadOnlySpan_1<Char>;
    static AsSpan<T>(array: T[] | undefined, startIndex: Index): Span_1<T>;
    static AsSpan<T>(array: T[] | undefined, start: int, length: int): Span_1<T>;
    static AsSpan<T>(array: T[] | undefined, start: int): Span_1<T>;
    static AsSpan<T>(array: T[] | undefined, range: Range): Span_1<T>;
    static AsSpan<T>(array: T[] | undefined): Span_1<T>;
    static BinarySearch<T>(span: ReadOnlySpan_1<T>, comparable: IComparable_1<T>): int;
    static BinarySearch<T, TComparer extends IComparer_1<T>>(span: ReadOnlySpan_1<T>, value: T, comparer: TComparer): int;
    static BinarySearch<T, TComparable extends IComparable_1<T>>(span: ReadOnlySpan_1<T>, comparable: TComparable): int;
    static BinarySearch<T>(span: Span_1<T>, comparable: IComparable_1<T>): int;
    static BinarySearch<T, TComparer extends IComparer_1<T>>(span: Span_1<T>, value: T, comparer: TComparer): int;
    static BinarySearch<T, TComparable extends IComparable_1<T>>(span: Span_1<T>, comparable: TComparable): int;
    static CommonPrefixLength<T>(span: ReadOnlySpan_1<T>, other: ReadOnlySpan_1<T>, comparer: IEqualityComparer_1<T> | undefined): int;
    static CommonPrefixLength<T>(span: ReadOnlySpan_1<T>, other: ReadOnlySpan_1<T>): int;
    static CommonPrefixLength<T>(span: Span_1<T>, other: ReadOnlySpan_1<T>, comparer: IEqualityComparer_1<T> | undefined): int;
    static CommonPrefixLength<T>(span: Span_1<T>, other: ReadOnlySpan_1<T>): int;
    static CompareTo(span: ReadOnlySpan_1<Char>, other: ReadOnlySpan_1<Char>, comparisonType: StringComparison): int;
    static Contains<T>(span: ReadOnlySpan_1<T>, value: T, comparer?: IEqualityComparer_1<T> | undefined): boolean;
    static Contains<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: T): boolean;
    static Contains<T extends IEquatable_1<T>>(span: Span_1<T>, value: T): boolean;
    static Contains(span: ReadOnlySpan_1<Char>, value: ReadOnlySpan_1<Char>, comparisonType: StringComparison): boolean;
    static ContainsAny<T>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T> | undefined): boolean;
    static ContainsAny<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>): boolean;
    static ContainsAny<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: SearchValues_1<T>): boolean;
    static ContainsAny<T>(span: ReadOnlySpan_1<T>, value0: T, value1: T, comparer?: IEqualityComparer_1<T> | undefined): boolean;
    static ContainsAny<T>(span: ReadOnlySpan_1<T>, value0: T, value1: T, value2: T, comparer?: IEqualityComparer_1<T> | undefined): boolean;
    static ContainsAny<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value0: T, value1: T, value2: T): boolean;
    static ContainsAny<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value0: T, value1: T): boolean;
    static ContainsAny<T extends IEquatable_1<T>>(span: Span_1<T>, values: ReadOnlySpan_1<T>): boolean;
    static ContainsAny<T extends IEquatable_1<T>>(span: Span_1<T>, values: SearchValues_1<T>): boolean;
    static ContainsAny<T extends IEquatable_1<T>>(span: Span_1<T>, value0: T, value1: T, value2: T): boolean;
    static ContainsAny<T extends IEquatable_1<T>>(span: Span_1<T>, value0: T, value1: T): boolean;
    static ContainsAny(span: ReadOnlySpan_1<Char>, values: SearchValues_1<String>): boolean;
    static ContainsAny(span: Span_1<Char>, values: SearchValues_1<String>): boolean;
    static ContainsAnyExcept<T>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T> | undefined): boolean;
    static ContainsAnyExcept<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>): boolean;
    static ContainsAnyExcept<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: SearchValues_1<T>): boolean;
    static ContainsAnyExcept<T>(span: ReadOnlySpan_1<T>, value: T, comparer?: IEqualityComparer_1<T> | undefined): boolean;
    static ContainsAnyExcept<T>(span: ReadOnlySpan_1<T>, value0: T, value1: T, comparer?: IEqualityComparer_1<T> | undefined): boolean;
    static ContainsAnyExcept<T>(span: ReadOnlySpan_1<T>, value0: T, value1: T, value2: T, comparer?: IEqualityComparer_1<T> | undefined): boolean;
    static ContainsAnyExcept<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value0: T, value1: T, value2: T): boolean;
    static ContainsAnyExcept<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value0: T, value1: T): boolean;
    static ContainsAnyExcept<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: T): boolean;
    static ContainsAnyExcept<T extends IEquatable_1<T>>(span: Span_1<T>, values: ReadOnlySpan_1<T>): boolean;
    static ContainsAnyExcept<T extends IEquatable_1<T>>(span: Span_1<T>, values: SearchValues_1<T>): boolean;
    static ContainsAnyExcept<T extends IEquatable_1<T>>(span: Span_1<T>, value0: T, value1: T, value2: T): boolean;
    static ContainsAnyExcept<T extends IEquatable_1<T>>(span: Span_1<T>, value0: T, value1: T): boolean;
    static ContainsAnyExcept<T extends IEquatable_1<T>>(span: Span_1<T>, value: T): boolean;
    static ContainsAnyExceptInRange<T extends IComparable_1<T>>(span: ReadOnlySpan_1<T>, lowInclusive: T, highInclusive: T): boolean;
    static ContainsAnyExceptInRange<T extends IComparable_1<T>>(span: Span_1<T>, lowInclusive: T, highInclusive: T): boolean;
    static ContainsAnyInRange<T extends IComparable_1<T>>(span: ReadOnlySpan_1<T>, lowInclusive: T, highInclusive: T): boolean;
    static ContainsAnyInRange<T extends IComparable_1<T>>(span: Span_1<T>, lowInclusive: T, highInclusive: T): boolean;
    static CopyTo<T>(source: T[] | undefined, destination: Memory_1<T>): void;
    static CopyTo<T>(source: T[] | undefined, destination: Span_1<T>): void;
    static Count<T>(span: ReadOnlySpan_1<T>, value: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T> | undefined): int;
    static Count<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: ReadOnlySpan_1<T>): int;
    static Count<T>(span: ReadOnlySpan_1<T>, value: T, comparer?: IEqualityComparer_1<T> | undefined): int;
    static Count<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: T): int;
    static Count<T extends IEquatable_1<T>>(span: Span_1<T>, value: ReadOnlySpan_1<T>): int;
    static Count<T extends IEquatable_1<T>>(span: Span_1<T>, value: T): int;
    static CountAny<T>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T> | undefined): int;
    static CountAny<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>): int;
    static CountAny<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: SearchValues_1<T>): int;
    static EndsWith<T>(span: ReadOnlySpan_1<T>, value: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T> | undefined): boolean;
    static EndsWith<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: ReadOnlySpan_1<T>): boolean;
    static EndsWith<T>(span: ReadOnlySpan_1<T>, value: T, comparer?: IEqualityComparer_1<T> | undefined): boolean;
    static EndsWith<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: T): boolean;
    static EndsWith<T extends IEquatable_1<T>>(span: Span_1<T>, value: ReadOnlySpan_1<T>): boolean;
    static EndsWith(span: ReadOnlySpan_1<Char>, value: ReadOnlySpan_1<Char>, comparisonType: StringComparison): boolean;
    static EnumerateLines(span: ReadOnlySpan_1<Char>): SpanLineEnumerator;
    static EnumerateLines(span: Span_1<Char>): SpanLineEnumerator;
    static EnumerateRunes(span: ReadOnlySpan_1<Char>): SpanRuneEnumerator;
    static EnumerateRunes(span: Span_1<Char>): SpanRuneEnumerator;
    static Equals(span: ReadOnlySpan_1<Char>, other: ReadOnlySpan_1<Char>, comparisonType: StringComparison): boolean;
    static IndexOf<T>(span: ReadOnlySpan_1<T>, value: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T> | undefined): int;
    static IndexOf<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: ReadOnlySpan_1<T>): int;
    static IndexOf<T>(span: ReadOnlySpan_1<T>, value: T, comparer?: IEqualityComparer_1<T> | undefined): int;
    static IndexOf<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: T): int;
    static IndexOf<T extends IEquatable_1<T>>(span: Span_1<T>, value: ReadOnlySpan_1<T>): int;
    static IndexOf<T extends IEquatable_1<T>>(span: Span_1<T>, value: T): int;
    static IndexOf(span: ReadOnlySpan_1<Char>, value: ReadOnlySpan_1<Char>, comparisonType: StringComparison): int;
    static IndexOfAny<T>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T> | undefined): int;
    static IndexOfAny<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>): int;
    static IndexOfAny<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: SearchValues_1<T>): int;
    static IndexOfAny<T>(span: ReadOnlySpan_1<T>, value0: T, value1: T, comparer?: IEqualityComparer_1<T> | undefined): int;
    static IndexOfAny<T>(span: ReadOnlySpan_1<T>, value0: T, value1: T, value2: T, comparer?: IEqualityComparer_1<T> | undefined): int;
    static IndexOfAny<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value0: T, value1: T, value2: T): int;
    static IndexOfAny<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value0: T, value1: T): int;
    static IndexOfAny<T extends IEquatable_1<T>>(span: Span_1<T>, values: ReadOnlySpan_1<T>): int;
    static IndexOfAny<T extends IEquatable_1<T>>(span: Span_1<T>, values: SearchValues_1<T>): int;
    static IndexOfAny<T extends IEquatable_1<T>>(span: Span_1<T>, value0: T, value1: T, value2: T): int;
    static IndexOfAny<T extends IEquatable_1<T>>(span: Span_1<T>, value0: T, value1: T): int;
    static IndexOfAny(span: ReadOnlySpan_1<Char>, values: SearchValues_1<String>): int;
    static IndexOfAny(span: Span_1<Char>, values: SearchValues_1<String>): int;
    static IndexOfAnyExcept<T>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T> | undefined): int;
    static IndexOfAnyExcept<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>): int;
    static IndexOfAnyExcept<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: SearchValues_1<T>): int;
    static IndexOfAnyExcept<T>(span: ReadOnlySpan_1<T>, value: T, comparer?: IEqualityComparer_1<T> | undefined): int;
    static IndexOfAnyExcept<T>(span: ReadOnlySpan_1<T>, value0: T, value1: T, comparer?: IEqualityComparer_1<T> | undefined): int;
    static IndexOfAnyExcept<T>(span: ReadOnlySpan_1<T>, value0: T, value1: T, value2: T, comparer?: IEqualityComparer_1<T> | undefined): int;
    static IndexOfAnyExcept<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value0: T, value1: T, value2: T): int;
    static IndexOfAnyExcept<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value0: T, value1: T): int;
    static IndexOfAnyExcept<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: T): int;
    static IndexOfAnyExcept<T extends IEquatable_1<T>>(span: Span_1<T>, values: ReadOnlySpan_1<T>): int;
    static IndexOfAnyExcept<T extends IEquatable_1<T>>(span: Span_1<T>, values: SearchValues_1<T>): int;
    static IndexOfAnyExcept<T extends IEquatable_1<T>>(span: Span_1<T>, value0: T, value1: T, value2: T): int;
    static IndexOfAnyExcept<T extends IEquatable_1<T>>(span: Span_1<T>, value0: T, value1: T): int;
    static IndexOfAnyExcept<T extends IEquatable_1<T>>(span: Span_1<T>, value: T): int;
    static IndexOfAnyExceptInRange<T extends IComparable_1<T>>(span: ReadOnlySpan_1<T>, lowInclusive: T, highInclusive: T): int;
    static IndexOfAnyExceptInRange<T extends IComparable_1<T>>(span: Span_1<T>, lowInclusive: T, highInclusive: T): int;
    static IndexOfAnyInRange<T extends IComparable_1<T>>(span: ReadOnlySpan_1<T>, lowInclusive: T, highInclusive: T): int;
    static IndexOfAnyInRange<T extends IComparable_1<T>>(span: Span_1<T>, lowInclusive: T, highInclusive: T): int;
    static IsWhiteSpace(span: ReadOnlySpan_1<Char>): boolean;
    static LastIndexOf<T>(span: ReadOnlySpan_1<T>, value: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T> | undefined): int;
    static LastIndexOf<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: ReadOnlySpan_1<T>): int;
    static LastIndexOf<T>(span: ReadOnlySpan_1<T>, value: T, comparer?: IEqualityComparer_1<T> | undefined): int;
    static LastIndexOf<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: T): int;
    static LastIndexOf<T extends IEquatable_1<T>>(span: Span_1<T>, value: ReadOnlySpan_1<T>): int;
    static LastIndexOf<T extends IEquatable_1<T>>(span: Span_1<T>, value: T): int;
    static LastIndexOf(span: ReadOnlySpan_1<Char>, value: ReadOnlySpan_1<Char>, comparisonType: StringComparison): int;
    static LastIndexOfAny<T>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T> | undefined): int;
    static LastIndexOfAny<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>): int;
    static LastIndexOfAny<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: SearchValues_1<T>): int;
    static LastIndexOfAny<T>(span: ReadOnlySpan_1<T>, value0: T, value1: T, comparer?: IEqualityComparer_1<T> | undefined): int;
    static LastIndexOfAny<T>(span: ReadOnlySpan_1<T>, value0: T, value1: T, value2: T, comparer?: IEqualityComparer_1<T> | undefined): int;
    static LastIndexOfAny<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value0: T, value1: T, value2: T): int;
    static LastIndexOfAny<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value0: T, value1: T): int;
    static LastIndexOfAny<T extends IEquatable_1<T>>(span: Span_1<T>, values: ReadOnlySpan_1<T>): int;
    static LastIndexOfAny<T extends IEquatable_1<T>>(span: Span_1<T>, values: SearchValues_1<T>): int;
    static LastIndexOfAny<T extends IEquatable_1<T>>(span: Span_1<T>, value0: T, value1: T, value2: T): int;
    static LastIndexOfAny<T extends IEquatable_1<T>>(span: Span_1<T>, value0: T, value1: T): int;
    static LastIndexOfAnyExcept<T>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T> | undefined): int;
    static LastIndexOfAnyExcept<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: ReadOnlySpan_1<T>): int;
    static LastIndexOfAnyExcept<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, values: SearchValues_1<T>): int;
    static LastIndexOfAnyExcept<T>(span: ReadOnlySpan_1<T>, value: T, comparer?: IEqualityComparer_1<T> | undefined): int;
    static LastIndexOfAnyExcept<T>(span: ReadOnlySpan_1<T>, value0: T, value1: T, comparer?: IEqualityComparer_1<T> | undefined): int;
    static LastIndexOfAnyExcept<T>(span: ReadOnlySpan_1<T>, value0: T, value1: T, value2: T, comparer?: IEqualityComparer_1<T> | undefined): int;
    static LastIndexOfAnyExcept<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value0: T, value1: T, value2: T): int;
    static LastIndexOfAnyExcept<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value0: T, value1: T): int;
    static LastIndexOfAnyExcept<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: T): int;
    static LastIndexOfAnyExcept<T extends IEquatable_1<T>>(span: Span_1<T>, values: ReadOnlySpan_1<T>): int;
    static LastIndexOfAnyExcept<T extends IEquatable_1<T>>(span: Span_1<T>, values: SearchValues_1<T>): int;
    static LastIndexOfAnyExcept<T extends IEquatable_1<T>>(span: Span_1<T>, value0: T, value1: T, value2: T): int;
    static LastIndexOfAnyExcept<T extends IEquatable_1<T>>(span: Span_1<T>, value0: T, value1: T): int;
    static LastIndexOfAnyExcept<T extends IEquatable_1<T>>(span: Span_1<T>, value: T): int;
    static LastIndexOfAnyExceptInRange<T extends IComparable_1<T>>(span: ReadOnlySpan_1<T>, lowInclusive: T, highInclusive: T): int;
    static LastIndexOfAnyExceptInRange<T extends IComparable_1<T>>(span: Span_1<T>, lowInclusive: T, highInclusive: T): int;
    static LastIndexOfAnyInRange<T extends IComparable_1<T>>(span: ReadOnlySpan_1<T>, lowInclusive: T, highInclusive: T): int;
    static LastIndexOfAnyInRange<T extends IComparable_1<T>>(span: Span_1<T>, lowInclusive: T, highInclusive: T): int;
    static Overlaps<T>(span: ReadOnlySpan_1<T>, other: ReadOnlySpan_1<T>, elementOffset: int): boolean;
    static Overlaps<T>(span: ReadOnlySpan_1<T>, other: ReadOnlySpan_1<T>): boolean;
    static Overlaps<T>(span: Span_1<T>, other: ReadOnlySpan_1<T>, elementOffset: int): boolean;
    static Overlaps<T>(span: Span_1<T>, other: ReadOnlySpan_1<T>): boolean;
    static Replace<T>(source: ReadOnlySpan_1<T>, destination: Span_1<T>, oldValue: T, newValue: T, comparer?: IEqualityComparer_1<T> | undefined): void;
    static Replace<T extends IEquatable_1<T>>(source: ReadOnlySpan_1<T>, destination: Span_1<T>, oldValue: T, newValue: T): void;
    static Replace<T>(span: Span_1<T>, oldValue: T, newValue: T, comparer?: IEqualityComparer_1<T> | undefined): void;
    static Replace<T extends IEquatable_1<T>>(span: Span_1<T>, oldValue: T, newValue: T): void;
    static ReplaceAny<T extends IEquatable_1<T>>(source: ReadOnlySpan_1<T>, destination: Span_1<T>, values: SearchValues_1<T>, newValue: T): void;
    static ReplaceAny<T extends IEquatable_1<T>>(span: Span_1<T>, values: SearchValues_1<T>, newValue: T): void;
    static ReplaceAnyExcept<T extends IEquatable_1<T>>(source: ReadOnlySpan_1<T>, destination: Span_1<T>, values: SearchValues_1<T>, newValue: T): void;
    static ReplaceAnyExcept<T extends IEquatable_1<T>>(span: Span_1<T>, values: SearchValues_1<T>, newValue: T): void;
    static Reverse<T>(span: Span_1<T>): void;
    static SequenceCompareTo<T>(span: ReadOnlySpan_1<T>, other: ReadOnlySpan_1<T>, comparer?: IComparer_1<T> | undefined): int;
    static SequenceCompareTo<T extends IComparable_1<T>>(span: ReadOnlySpan_1<T>, other: ReadOnlySpan_1<T>): int;
    static SequenceCompareTo<T extends IComparable_1<T>>(span: Span_1<T>, other: ReadOnlySpan_1<T>): int;
    static SequenceEqual<T>(span: ReadOnlySpan_1<T>, other: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T> | undefined): boolean;
    static SequenceEqual<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, other: ReadOnlySpan_1<T>): boolean;
    static SequenceEqual<T>(span: Span_1<T>, other: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T> | undefined): boolean;
    static SequenceEqual<T extends IEquatable_1<T>>(span: Span_1<T>, other: ReadOnlySpan_1<T>): boolean;
    static Sort<T>(span: Span_1<T>, comparison: Comparison_1<T>): void;
    static Sort<TKey, TValue>(keys: Span_1<TKey>, items: Span_1<TValue>, comparison: Comparison_1<TKey>): void;
    static Sort<TKey, TValue, TComparer extends IComparer_1<TKey>>(keys: Span_1<TKey>, items: Span_1<TValue>, comparer: TComparer): void;
    static Sort<TKey, TValue>(keys: Span_1<TKey>, items: Span_1<TValue>): void;
    static Sort<T, TComparer extends IComparer_1<T>>(span: Span_1<T>, comparer: TComparer): void;
    static Sort<T>(span: Span_1<T>): void;
    static Split<T extends IEquatable_1<T>>(source: ReadOnlySpan_1<T>, separator: ReadOnlySpan_1<T>): MemoryExtensions_SpanSplitEnumerator_1<T>;
    static Split<T extends IEquatable_1<T>>(source: ReadOnlySpan_1<T>, separator: T): MemoryExtensions_SpanSplitEnumerator_1<T>;
    static Split(source: ReadOnlySpan_1<Char>, destination: Span_1<Range>, separator: char, options?: StringSplitOptions): int;
    static Split(source: ReadOnlySpan_1<Char>, destination: Span_1<Range>, separator: ReadOnlySpan_1<Char>, options?: StringSplitOptions): int;
    static SplitAny<T extends IEquatable_1<T>>(source: ReadOnlySpan_1<T>, separators: ReadOnlySpan_1<T>): MemoryExtensions_SpanSplitEnumerator_1<T>;
    static SplitAny<T extends IEquatable_1<T>>(source: ReadOnlySpan_1<T>, separators: SearchValues_1<T>): MemoryExtensions_SpanSplitEnumerator_1<T>;
    static SplitAny(source: ReadOnlySpan_1<Char>, destination: Span_1<Range>, separators: ReadOnlySpan_1<Char>, options?: StringSplitOptions): int;
    static SplitAny(source: ReadOnlySpan_1<Char>, destination: Span_1<Range>, separators: ReadOnlySpan_1<String>, options?: StringSplitOptions): int;
    static StartsWith<T>(span: ReadOnlySpan_1<T>, value: ReadOnlySpan_1<T>, comparer?: IEqualityComparer_1<T> | undefined): boolean;
    static StartsWith<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: ReadOnlySpan_1<T>): boolean;
    static StartsWith<T>(span: ReadOnlySpan_1<T>, value: T, comparer?: IEqualityComparer_1<T> | undefined): boolean;
    static StartsWith<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, value: T): boolean;
    static StartsWith<T extends IEquatable_1<T>>(span: Span_1<T>, value: ReadOnlySpan_1<T>): boolean;
    static StartsWith(span: ReadOnlySpan_1<Char>, value: ReadOnlySpan_1<Char>, comparisonType: StringComparison): boolean;
    static ToLower(source: ReadOnlySpan_1<Char>, destination: Span_1<Char>, culture: CultureInfo | undefined): int;
    static ToLowerInvariant(source: ReadOnlySpan_1<Char>, destination: Span_1<Char>): int;
    static ToUpper(source: ReadOnlySpan_1<Char>, destination: Span_1<Char>, culture: CultureInfo | undefined): int;
    static ToUpperInvariant(source: ReadOnlySpan_1<Char>, destination: Span_1<Char>): int;
    static Trim<T extends IEquatable_1<T>>(memory: Memory_1<T>, trimElements: ReadOnlySpan_1<T>): Memory_1<T>;
    static Trim<T extends IEquatable_1<T>>(memory: Memory_1<T>, trimElement: T): Memory_1<T>;
    static Trim<T extends IEquatable_1<T>>(memory: ReadOnlyMemory_1<T>, trimElements: ReadOnlySpan_1<T>): ReadOnlyMemory_1<T>;
    static Trim<T extends IEquatable_1<T>>(memory: ReadOnlyMemory_1<T>, trimElement: T): ReadOnlyMemory_1<T>;
    static Trim<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, trimElements: ReadOnlySpan_1<T>): ReadOnlySpan_1<T>;
    static Trim<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, trimElement: T): ReadOnlySpan_1<T>;
    static Trim<T extends IEquatable_1<T>>(span: Span_1<T>, trimElements: ReadOnlySpan_1<T>): Span_1<T>;
    static Trim<T extends IEquatable_1<T>>(span: Span_1<T>, trimElement: T): Span_1<T>;
    static Trim(memory: Memory_1<Char>): Memory_1<Char>;
    static Trim(memory: ReadOnlyMemory_1<Char>): ReadOnlyMemory_1<Char>;
    static Trim(span: ReadOnlySpan_1<Char>, trimChar: char): ReadOnlySpan_1<Char>;
    static Trim(span: ReadOnlySpan_1<Char>, trimChars: ReadOnlySpan_1<Char>): ReadOnlySpan_1<Char>;
    static Trim(span: ReadOnlySpan_1<Char>): ReadOnlySpan_1<Char>;
    static Trim(span: Span_1<Char>): Span_1<Char>;
    static TrimEnd<T extends IEquatable_1<T>>(memory: Memory_1<T>, trimElements: ReadOnlySpan_1<T>): Memory_1<T>;
    static TrimEnd<T extends IEquatable_1<T>>(memory: Memory_1<T>, trimElement: T): Memory_1<T>;
    static TrimEnd<T extends IEquatable_1<T>>(memory: ReadOnlyMemory_1<T>, trimElements: ReadOnlySpan_1<T>): ReadOnlyMemory_1<T>;
    static TrimEnd<T extends IEquatable_1<T>>(memory: ReadOnlyMemory_1<T>, trimElement: T): ReadOnlyMemory_1<T>;
    static TrimEnd<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, trimElements: ReadOnlySpan_1<T>): ReadOnlySpan_1<T>;
    static TrimEnd<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, trimElement: T): ReadOnlySpan_1<T>;
    static TrimEnd<T extends IEquatable_1<T>>(span: Span_1<T>, trimElements: ReadOnlySpan_1<T>): Span_1<T>;
    static TrimEnd<T extends IEquatable_1<T>>(span: Span_1<T>, trimElement: T): Span_1<T>;
    static TrimEnd(memory: Memory_1<Char>): Memory_1<Char>;
    static TrimEnd(memory: ReadOnlyMemory_1<Char>): ReadOnlyMemory_1<Char>;
    static TrimEnd(span: ReadOnlySpan_1<Char>, trimChar: char): ReadOnlySpan_1<Char>;
    static TrimEnd(span: ReadOnlySpan_1<Char>, trimChars: ReadOnlySpan_1<Char>): ReadOnlySpan_1<Char>;
    static TrimEnd(span: ReadOnlySpan_1<Char>): ReadOnlySpan_1<Char>;
    static TrimEnd(span: Span_1<Char>): Span_1<Char>;
    static TrimStart<T extends IEquatable_1<T>>(memory: Memory_1<T>, trimElements: ReadOnlySpan_1<T>): Memory_1<T>;
    static TrimStart<T extends IEquatable_1<T>>(memory: Memory_1<T>, trimElement: T): Memory_1<T>;
    static TrimStart<T extends IEquatable_1<T>>(memory: ReadOnlyMemory_1<T>, trimElements: ReadOnlySpan_1<T>): ReadOnlyMemory_1<T>;
    static TrimStart<T extends IEquatable_1<T>>(memory: ReadOnlyMemory_1<T>, trimElement: T): ReadOnlyMemory_1<T>;
    static TrimStart<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, trimElements: ReadOnlySpan_1<T>): ReadOnlySpan_1<T>;
    static TrimStart<T extends IEquatable_1<T>>(span: ReadOnlySpan_1<T>, trimElement: T): ReadOnlySpan_1<T>;
    static TrimStart<T extends IEquatable_1<T>>(span: Span_1<T>, trimElements: ReadOnlySpan_1<T>): Span_1<T>;
    static TrimStart<T extends IEquatable_1<T>>(span: Span_1<T>, trimElement: T): Span_1<T>;
    static TrimStart(memory: Memory_1<Char>): Memory_1<Char>;
    static TrimStart(memory: ReadOnlyMemory_1<Char>): ReadOnlyMemory_1<Char>;
    static TrimStart(span: ReadOnlySpan_1<Char>, trimChar: char): ReadOnlySpan_1<Char>;
    static TrimStart(span: ReadOnlySpan_1<Char>, trimChars: ReadOnlySpan_1<Char>): ReadOnlySpan_1<Char>;
    static TrimStart(span: ReadOnlySpan_1<Char>): ReadOnlySpan_1<Char>;
    static TrimStart(span: Span_1<Char>): Span_1<Char>;
    static TryWrite(destination: Span_1<Char>, provider: IFormatProvider | undefined, handler: MemoryExtensions_TryWriteInterpolatedStringHandler, charsWritten: int): boolean;
    static TryWrite(destination: Span_1<Char>, provider: IFormatProvider | undefined, format: CompositeFormat, charsWritten: int, ...args: unknown[]): boolean;
    static TryWrite(destination: Span_1<Char>, provider: IFormatProvider | undefined, format: CompositeFormat, charsWritten: int, args: ReadOnlySpan_1<unknown>): boolean;
    static TryWrite<TArg0, TArg1, TArg2>(destination: Span_1<Char>, provider: IFormatProvider | undefined, format: CompositeFormat, charsWritten: int, arg0: TArg0, arg1: TArg1, arg2: TArg2): boolean;
    static TryWrite<TArg0, TArg1>(destination: Span_1<Char>, provider: IFormatProvider | undefined, format: CompositeFormat, charsWritten: int, arg0: TArg0, arg1: TArg1): boolean;
    static TryWrite<TArg0>(destination: Span_1<Char>, provider: IFormatProvider | undefined, format: CompositeFormat, charsWritten: int, arg0: TArg0): boolean;
    static TryWrite(destination: Span_1<Char>, handler: MemoryExtensions_TryWriteInterpolatedStringHandler, charsWritten: int): boolean;
}


export type MemoryExtensions = MemoryExtensions$instance;

export abstract class Nullable$instance {
    static Compare<T extends unknown>(n1: Nullable_1<T>, n2: Nullable_1<T>): int;
    static Equals<T extends unknown>(n1: Nullable_1<T>, n2: Nullable_1<T>): boolean;
    static GetUnderlyingType(nullableType: Type): Type | undefined;
    static GetValueRefOrDefaultRef<T extends unknown>(nullable: Nullable_1<T>): T;
}


export type Nullable = Nullable$instance;

export abstract class StringNormalizationExtensions$instance {
    static GetNormalizedLength(source: ReadOnlySpan_1<Char>, normalizationForm?: NormalizationForm): int;
    static IsNormalized(source: ReadOnlySpan_1<Char>, normalizationForm?: NormalizationForm): boolean;
    static IsNormalized(strInput: string, normalizationForm: NormalizationForm): boolean;
    static IsNormalized(strInput: string): boolean;
    static Normalize(strInput: string, normalizationForm: NormalizationForm): string;
    static Normalize(strInput: string): string;
    static TryNormalize(source: ReadOnlySpan_1<Char>, destination: Span_1<Char>, charsWritten: int, normalizationForm?: NormalizationForm): boolean;
}


export type StringNormalizationExtensions = StringNormalizationExtensions$instance;

export abstract class Tuple$instance {
    static Create<T1, T2, T3, T4, T5, T6, T7, T8>(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8): Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_1<T8>>;
    static Create<T1, T2, T3, T4, T5, T6, T7>(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7): Tuple_7<T1, T2, T3, T4, T5, T6, T7>;
    static Create<T1, T2, T3, T4, T5, T6>(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6): Tuple_6<T1, T2, T3, T4, T5, T6>;
    static Create<T1, T2, T3, T4, T5>(item1: T1, item2: T2, item3: T3, item4: T4, item5: T5): Tuple_5<T1, T2, T3, T4, T5>;
    static Create<T1, T2, T3, T4>(item1: T1, item2: T2, item3: T3, item4: T4): Tuple_4<T1, T2, T3, T4>;
    static Create<T1, T2, T3>(item1: T1, item2: T2, item3: T3): Tuple_3<T1, T2, T3>;
    static Create<T1, T2>(item1: T1, item2: T2): Tuple_2<T1, T2>;
    static Create<T1>(item1: T1): Tuple_1<T1>;
}


export type Tuple = Tuple$instance;

export abstract class TupleExtensions$instance {
    static Deconstruct<T1>(value: Tuple_1<T1>, item1: T1): void;
    static Deconstruct<T1, T2>(value: Tuple_2<T1, T2>, item1: T1, item2: T2): void;
    static Deconstruct<T1, T2, T3>(value: Tuple_3<T1, T2, T3>, item1: T1, item2: T2, item3: T3): void;
    static Deconstruct<T1, T2, T3, T4>(value: Tuple_4<T1, T2, T3, T4>, item1: T1, item2: T2, item3: T3, item4: T4): void;
    static Deconstruct<T1, T2, T3, T4, T5>(value: Tuple_5<T1, T2, T3, T4, T5>, item1: T1, item2: T2, item3: T3, item4: T4, item5: T5): void;
    static Deconstruct<T1, T2, T3, T4, T5, T6>(value: Tuple_6<T1, T2, T3, T4, T5, T6>, item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6): void;
    static Deconstruct<T1, T2, T3, T4, T5, T6, T7>(value: Tuple_7<T1, T2, T3, T4, T5, T6, T7>, item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7): void;
    static Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_8<T8, T9, T10, T11, T12, T13, T14, Tuple_7<T15, T16, T17, T18, T19, T20, T21>>>, item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9, item10: T10, item11: T11, item12: T12, item13: T13, item14: T14, item15: T15, item16: T16, item17: T17, item18: T18, item19: T19, item20: T20, item21: T21): void;
    static Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_8<T8, T9, T10, T11, T12, T13, T14, Tuple_6<T15, T16, T17, T18, T19, T20>>>, item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9, item10: T10, item11: T11, item12: T12, item13: T13, item14: T14, item15: T15, item16: T16, item17: T17, item18: T18, item19: T19, item20: T20): void;
    static Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_8<T8, T9, T10, T11, T12, T13, T14, Tuple_5<T15, T16, T17, T18, T19>>>, item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9, item10: T10, item11: T11, item12: T12, item13: T13, item14: T14, item15: T15, item16: T16, item17: T17, item18: T18, item19: T19): void;
    static Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_8<T8, T9, T10, T11, T12, T13, T14, Tuple_4<T15, T16, T17, T18>>>, item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9, item10: T10, item11: T11, item12: T12, item13: T13, item14: T14, item15: T15, item16: T16, item17: T17, item18: T18): void;
    static Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_8<T8, T9, T10, T11, T12, T13, T14, Tuple_3<T15, T16, T17>>>, item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9, item10: T10, item11: T11, item12: T12, item13: T13, item14: T14, item15: T15, item16: T16, item17: T17): void;
    static Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_8<T8, T9, T10, T11, T12, T13, T14, Tuple_2<T15, T16>>>, item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9, item10: T10, item11: T11, item12: T12, item13: T13, item14: T14, item15: T15, item16: T16): void;
    static Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_8<T8, T9, T10, T11, T12, T13, T14, Tuple_1<T15>>>, item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9, item10: T10, item11: T11, item12: T12, item13: T13, item14: T14, item15: T15): void;
    static Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_7<T8, T9, T10, T11, T12, T13, T14>>, item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9, item10: T10, item11: T11, item12: T12, item13: T13, item14: T14): void;
    static Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_6<T8, T9, T10, T11, T12, T13>>, item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9, item10: T10, item11: T11, item12: T12, item13: T13): void;
    static Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_5<T8, T9, T10, T11, T12>>, item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9, item10: T10, item11: T11, item12: T12): void;
    static Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_4<T8, T9, T10, T11>>, item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9, item10: T10, item11: T11): void;
    static Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_3<T8, T9, T10>>, item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9, item10: T10): void;
    static Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_2<T8, T9>>, item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9): void;
    static Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_1<T8>>, item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8): void;
    static ToTuple<T1>(value: ValueTuple_1<T1>): Tuple_1<T1>;
    static ToTuple<T1, T2>(value: ValueTuple_2<T1, T2>): Tuple_2<T1, T2>;
    static ToTuple<T1, T2, T3>(value: ValueTuple_3<T1, T2, T3>): Tuple_3<T1, T2, T3>;
    static ToTuple<T1, T2, T3, T4>(value: ValueTuple_4<T1, T2, T3, T4>): Tuple_4<T1, T2, T3, T4>;
    static ToTuple<T1, T2, T3, T4, T5>(value: ValueTuple_5<T1, T2, T3, T4, T5>): Tuple_5<T1, T2, T3, T4, T5>;
    static ToTuple<T1, T2, T3, T4, T5, T6>(value: ValueTuple_6<T1, T2, T3, T4, T5, T6>): Tuple_6<T1, T2, T3, T4, T5, T6>;
    static ToTuple<T1, T2, T3, T4, T5, T6, T7>(value: ValueTuple_7<T1, T2, T3, T4, T5, T6, T7>): Tuple_7<T1, T2, T3, T4, T5, T6, T7>;
    static ToTuple<T1, T2, T3, T4, T5, T6, T7, T8>(value: ValueTuple_8<T1, T2, T3, T4, T5, T6, T7, ValueTuple_1<T8>>): Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_1<T8>>;
    static ToValueTuple<T1>(value: Tuple_1<T1>): ValueTuple_1<T1>;
    static ToValueTuple<T1, T2>(value: Tuple_2<T1, T2>): ValueTuple_2<T1, T2>;
    static ToValueTuple<T1, T2, T3>(value: Tuple_3<T1, T2, T3>): ValueTuple_3<T1, T2, T3>;
    static ToValueTuple<T1, T2, T3, T4>(value: Tuple_4<T1, T2, T3, T4>): ValueTuple_4<T1, T2, T3, T4>;
    static ToValueTuple<T1, T2, T3, T4, T5>(value: Tuple_5<T1, T2, T3, T4, T5>): ValueTuple_5<T1, T2, T3, T4, T5>;
    static ToValueTuple<T1, T2, T3, T4, T5, T6>(value: Tuple_6<T1, T2, T3, T4, T5, T6>): ValueTuple_6<T1, T2, T3, T4, T5, T6>;
    static ToValueTuple<T1, T2, T3, T4, T5, T6, T7>(value: Tuple_7<T1, T2, T3, T4, T5, T6, T7>): ValueTuple_7<T1, T2, T3, T4, T5, T6, T7>;
    static ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8>(value: Tuple_8<T1, T2, T3, T4, T5, T6, T7, Tuple_1<T8>>): ValueTuple_8<T1, T2, T3, T4, T5, T6, T7, ValueTuple_1<T8>>;
}


export type TupleExtensions = TupleExtensions$instance;


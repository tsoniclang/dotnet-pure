// Generated by tsbindgen - Architecture
// Namespace: System.Net
// Assembly: System.Net.HttpListener, System.Net.NameResolution, System.Net.Primitives, System.Net.Requests, System.Net.WebClient, System.Net.WebHeaderCollection, System.Net.WebProxy, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IReadOnlyCollection_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_Specialized_Internal from "../../System.Collections.Specialized/internal/index.js";
import type { NameObjectCollectionBase_KeysCollection, NameValueCollection, StringDictionary } from "../../System.Collections.Specialized/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ArrayList, ICollection, IDictionary, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { AsyncCompletedEventArgs, AsyncCompletedEventHandler, Component, IComponent, IContainer, ISite, ProgressChangedEventArgs, Win32Exception } from "../../System.ComponentModel/internal/index.js";
import type { BinaryWriter, Stream, TextWriter } from "../../System.IO/internal/index.js";
import type { RequestCachePolicy } from "../../System.Net.Cache/internal/index.js";
import type { AuthenticationLevel, EncryptionPolicy, RemoteCertificateValidationCallback } from "../../System.Net.Security/internal/index.js";
import type { AddressFamily } from "../../System.Net.Sockets/internal/index.js";
import type { HttpListenerWebSocketContext } from "../../System.Net.WebSockets/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { ChannelBinding, ChannelBindingKind, ExtendedProtectionPolicy, ServiceNameCollection } from "../../System.Security.Authentication.ExtendedProtection/internal/index.js";
import type { Claim, ClaimsIdentity } from "../../System.Security.Claims/internal/index.js";
import type { X509Certificate, X509Certificate2, X509CertificateCollection } from "../../System.Security.Cryptography.X509Certificates/internal/index.js";
import * as System_Security_Principal_Internal from "../../System.Security.Principal/internal/index.js";
import type { GenericIdentity, IIdentity, IPrincipal, TokenImpersonationLevel } from "../../System.Security.Principal/internal/index.js";
import type { SecureString } from "../../System.Security/internal/index.js";
import type { Encoding } from "../../System.Text/internal/index.js";
import type { Task, Task_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, ArraySegment_1, AsyncCallback, Boolean as ClrBoolean, Byte, Char, DateTime, Delegate, Enum, EventArgs, Exception, FormatException, Guid, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, InvalidOperationException, IParsable_1, ISpanFormattable, ISpanParsable_1, IUtf8SpanFormattable, IUtf8SpanParsable_1, MarshalByRefObject, Memory_1, MulticastDelegate, Object as ClrObject, Predicate_1, ReadOnlySpan_1, Span_1, String as ClrString, TimeSpan, Type, TypeCode, Uri, ValueType, Version, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum AuthenticationSchemes {
    None = 0,
    Digest = 1,
    Negotiate = 2,
    Ntlm = 4,
    Basic = 8,
    Anonymous = 32768,
    IntegratedWindowsAuthentication = 6
}


export enum CookieVariant {
    Unknown = 0,
    Plain = 1,
    Rfc2109 = 2,
    Rfc2965 = 3,
    Default = 2
}


export enum DecompressionMethods {
    None = 0,
    GZip = 1,
    Deflate = 2,
    Brotli = 4,
    All = -1
}


export enum FtpStatusCode {
    Undefined = 0,
    RestartMarker = 110,
    ServiceTemporarilyNotAvailable = 120,
    DataAlreadyOpen = 125,
    OpeningData = 150,
    CommandOK = 200,
    CommandExtraneous = 202,
    DirectoryStatus = 212,
    FileStatus = 213,
    SystemType = 215,
    SendUserCommand = 220,
    ClosingControl = 221,
    ClosingData = 226,
    EnteringPassive = 227,
    LoggedInProceed = 230,
    ServerWantsSecureSession = 234,
    FileActionOK = 250,
    PathnameCreated = 257,
    SendPasswordCommand = 331,
    NeedLoginAccount = 332,
    FileCommandPending = 350,
    ServiceNotAvailable = 421,
    CantOpenData = 425,
    ConnectionClosed = 426,
    ActionNotTakenFileUnavailableOrBusy = 450,
    ActionAbortedLocalProcessingError = 451,
    ActionNotTakenInsufficientSpace = 452,
    CommandSyntaxError = 500,
    ArgumentSyntaxError = 501,
    CommandNotImplemented = 502,
    BadCommandSequence = 503,
    NotLoggedIn = 530,
    AccountNeeded = 532,
    ActionNotTakenFileUnavailable = 550,
    ActionAbortedUnknownPageType = 551,
    FileActionAborted = 552,
    ActionNotTakenFilenameNotAllowed = 553
}


export enum HttpRequestHeader {
    CacheControl = 0,
    Connection = 1,
    Date = 2,
    KeepAlive = 3,
    Pragma = 4,
    Trailer = 5,
    TransferEncoding = 6,
    Upgrade = 7,
    Via = 8,
    Warning = 9,
    Allow = 10,
    ContentLength = 11,
    ContentType = 12,
    ContentEncoding = 13,
    ContentLanguage = 14,
    ContentLocation = 15,
    ContentMd5 = 16,
    ContentRange = 17,
    Expires = 18,
    LastModified = 19,
    Accept = 20,
    AcceptCharset = 21,
    AcceptEncoding = 22,
    AcceptLanguage = 23,
    Authorization = 24,
    Cookie = 25,
    Expect = 26,
    From = 27,
    Host = 28,
    IfMatch = 29,
    IfModifiedSince = 30,
    IfNoneMatch = 31,
    IfRange = 32,
    IfUnmodifiedSince = 33,
    MaxForwards = 34,
    ProxyAuthorization = 35,
    Referer = 36,
    Range = 37,
    Te = 38,
    Translate = 39,
    UserAgent = 40
}


export enum HttpResponseHeader {
    CacheControl = 0,
    Connection = 1,
    Date = 2,
    KeepAlive = 3,
    Pragma = 4,
    Trailer = 5,
    TransferEncoding = 6,
    Upgrade = 7,
    Via = 8,
    Warning = 9,
    Allow = 10,
    ContentLength = 11,
    ContentType = 12,
    ContentEncoding = 13,
    ContentLanguage = 14,
    ContentLocation = 15,
    ContentMd5 = 16,
    ContentRange = 17,
    Expires = 18,
    LastModified = 19,
    AcceptRanges = 20,
    Age = 21,
    ETag = 22,
    Location = 23,
    ProxyAuthenticate = 24,
    RetryAfter = 25,
    Server = 26,
    SetCookie = 27,
    Vary = 28,
    WwwAuthenticate = 29
}


export enum HttpStatusCode {
    Continue = 100,
    SwitchingProtocols = 101,
    Processing = 102,
    EarlyHints = 103,
    OK = 200,
    Created = 201,
    Accepted = 202,
    NonAuthoritativeInformation = 203,
    NoContent = 204,
    ResetContent = 205,
    PartialContent = 206,
    MultiStatus = 207,
    AlreadyReported = 208,
    IMUsed = 226,
    MultipleChoices = 300,
    Ambiguous = 300,
    MovedPermanently = 301,
    Moved = 301,
    Found = 302,
    Redirect = 302,
    SeeOther = 303,
    RedirectMethod = 303,
    NotModified = 304,
    UseProxy = 305,
    Unused = 306,
    TemporaryRedirect = 307,
    RedirectKeepVerb = 307,
    PermanentRedirect = 308,
    BadRequest = 400,
    Unauthorized = 401,
    PaymentRequired = 402,
    Forbidden = 403,
    NotFound = 404,
    MethodNotAllowed = 405,
    NotAcceptable = 406,
    ProxyAuthenticationRequired = 407,
    RequestTimeout = 408,
    Conflict = 409,
    Gone = 410,
    LengthRequired = 411,
    PreconditionFailed = 412,
    RequestEntityTooLarge = 413,
    RequestUriTooLong = 414,
    UnsupportedMediaType = 415,
    RequestedRangeNotSatisfiable = 416,
    ExpectationFailed = 417,
    MisdirectedRequest = 421,
    UnprocessableEntity = 422,
    UnprocessableContent = 422,
    Locked = 423,
    FailedDependency = 424,
    UpgradeRequired = 426,
    PreconditionRequired = 428,
    TooManyRequests = 429,
    RequestHeaderFieldsTooLarge = 431,
    UnavailableForLegalReasons = 451,
    InternalServerError = 500,
    NotImplemented = 501,
    BadGateway = 502,
    ServiceUnavailable = 503,
    GatewayTimeout = 504,
    HttpVersionNotSupported = 505,
    VariantAlsoNegotiates = 506,
    InsufficientStorage = 507,
    LoopDetected = 508,
    NotExtended = 510,
    NetworkAuthenticationRequired = 511
}


export enum SecurityProtocolType {
    SystemDefault = 0,
    Ssl3 = 48,
    Tls = 192,
    Tls11 = 768,
    Tls12 = 3072,
    Tls13 = 12288
}


export enum WebExceptionStatus {
    Success = 0,
    NameResolutionFailure = 1,
    ConnectFailure = 2,
    ReceiveFailure = 3,
    SendFailure = 4,
    PipelineFailure = 5,
    RequestCanceled = 6,
    ProtocolError = 7,
    ConnectionClosed = 8,
    TrustFailure = 9,
    SecureChannelFailure = 10,
    ServerProtocolViolation = 11,
    KeepAliveFailure = 12,
    Pending = 13,
    Timeout = 14,
    ProxyNameResolutionFailure = 15,
    UnknownError = 16,
    MessageLengthLimitExceeded = 17,
    CacheEntryNotFound = 18,
    RequestProhibitedByCachePolicy = 19,
    RequestProhibitedByProxy = 20
}


export type AuthenticationSchemeSelector = (httpRequest: HttpListenerRequest) => AuthenticationSchemes;


export type BindIPEndPoint = (servicePoint: ServicePoint, remoteEndPoint: IPEndPoint, retryCount: int) => IPEndPoint;


export type DownloadDataCompletedEventHandler = (sender: unknown, e: DownloadDataCompletedEventArgs) => void;


export type DownloadProgressChangedEventHandler = (sender: unknown, e: DownloadProgressChangedEventArgs) => void;


export type DownloadStringCompletedEventHandler = (sender: unknown, e: DownloadStringCompletedEventArgs) => void;


export type HttpContinueDelegate = (StatusCode: int, httpHeaders: WebHeaderCollection) => void;


export type HttpListener_ExtendedProtectionSelector = (request: HttpListenerRequest) => ExtendedProtectionPolicy;


export type OpenReadCompletedEventHandler = (sender: unknown, e: OpenReadCompletedEventArgs) => void;


export type OpenWriteCompletedEventHandler = (sender: unknown, e: OpenWriteCompletedEventArgs) => void;


export type UploadDataCompletedEventHandler = (sender: unknown, e: UploadDataCompletedEventArgs) => void;


export type UploadFileCompletedEventHandler = (sender: unknown, e: UploadFileCompletedEventArgs) => void;


export type UploadProgressChangedEventHandler = (sender: unknown, e: UploadProgressChangedEventArgs) => void;


export type UploadStringCompletedEventHandler = (sender: unknown, e: UploadStringCompletedEventArgs) => void;


export type UploadValuesCompletedEventHandler = (sender: unknown, e: UploadValuesCompletedEventArgs) => void;


export type WriteStreamClosedEventHandler = (sender: unknown, e: WriteStreamClosedEventArgs) => void;


export interface IAuthenticationModule$instance {
    readonly CanPreAuthenticate: boolean;
    readonly AuthenticationType: string;
    Authenticate(challenge: string, request: WebRequest, credentials: ICredentials): Authorization;
    PreAuthenticate(request: WebRequest, credentials: ICredentials): Authorization;
}


export type IAuthenticationModule = IAuthenticationModule$instance;

export interface ICredentialPolicy$instance {
    ShouldSendCredential(challengeUri: Uri, request: WebRequest, credential: NetworkCredential, authenticationModule: IAuthenticationModule): boolean;
}


export type ICredentialPolicy = ICredentialPolicy$instance;

export interface ICredentials$instance {
    GetCredential(uri: Uri, authType: string): NetworkCredential;
}


export type ICredentials = ICredentials$instance;

export interface ICredentialsByHost$instance {
    GetCredential(host: string, port: int, authenticationType: string): NetworkCredential;
}


export type ICredentialsByHost = ICredentialsByHost$instance;

export interface IWebProxy$instance {
    Credentials: ICredentials;
    GetProxy(destination: Uri): Uri;
    IsBypassed(host: Uri): boolean;
}


export type IWebProxy = IWebProxy$instance;

export interface IWebProxyScript$instance {
    Close(): void;
    Load(scriptLocation: Uri, script: string, helperType: Type): boolean;
    Run(url: string, host: string): string;
}


export type IWebProxyScript = IWebProxyScript$instance;

export interface IWebRequestCreate$instance {
    Create(uri: Uri): WebRequest;
}


export type IWebRequestCreate = IWebRequestCreate$instance;

export interface IPNetwork$instance {
    readonly BaseAddress: IPAddress;
    readonly PrefixLength: int;
    Contains(address: IPAddress): boolean;
    Equals(other: IPNetwork): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
    TryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    TryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export const IPNetwork: {
    new(baseAddress: IPAddress, prefixLength: int): IPNetwork$instance;
    Parse(utf8Text: ReadOnlySpan_1<CLROf<byte>>): IPNetwork;
    Parse(s: ReadOnlySpan_1<CLROf<char>>): IPNetwork;
    Parse(s: string): IPNetwork;
    TryParse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<IPNetwork> }): boolean;
    TryParse(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<IPNetwork> }): boolean;
    TryParse(s: string, result: { value: ref<IPNetwork> }): boolean;
};


export interface __IPNetwork$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<IPNetwork>;
    As_IFormattable(): System_Internal.IFormattable$instance;
    As_IParsable_1(): System_Internal.IParsable_1$instance<IPNetwork>;
    As_ISpanFormattable(): System_Internal.ISpanFormattable$instance;
    As_ISpanParsable_1(): System_Internal.ISpanParsable_1$instance<IPNetwork>;
    As_IUtf8SpanFormattable(): System_Internal.IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): System_Internal.IUtf8SpanParsable_1$instance<IPNetwork>;

    // Structural method bridges for numeric interface constraints
    equals(other: IPNetwork): boolean;
    tryFormat(utf8Destination: import("../../System/internal/index").Span_1<import("../../System/internal/index").CLROf<byte>>, bytesWritten: { value: ref<int> }, format: import("../../System/internal/index").ReadOnlySpan_1<import("../../System/internal/index").CLROf<char>>, provider: import("../../System/internal/index").IFormatProvider): boolean;
}

export interface IPNetwork$instance extends System_Internal.ISpanParsable_1$instance<IPNetwork> {}

export type IPNetwork = IPNetwork$instance & __IPNetwork$views;


export interface AuthenticationManager$instance {
}


export const AuthenticationManager: {
    new(): AuthenticationManager$instance;
    CredentialPolicy: ICredentialPolicy;
    readonly CustomTargetNameDictionary: StringDictionary;
    readonly RegisteredModules: IEnumerator;
    Authenticate(challenge: string, request: WebRequest, credentials: ICredentials): Authorization;
    PreAuthenticate(request: WebRequest, credentials: ICredentials): Authorization;
    Register(authenticationModule: IAuthenticationModule): void;
    Unregister(authenticationModule: IAuthenticationModule): void;
    Unregister(authenticationScheme: string): void;
};


export type AuthenticationManager = AuthenticationManager$instance;

export interface Authorization$instance {
    readonly Complete: boolean;
    readonly ConnectionGroupId: string;
    readonly Message: string;
    MutuallyAuthenticated: boolean;
    ProtectionRealm: string[];
}


export const Authorization: {
    new(token: string): Authorization$instance;
    new(token: string, finished: boolean): Authorization$instance;
    new(token: string, finished: boolean, connectionGroupId: string): Authorization$instance;
};


export type Authorization = Authorization$instance;

export interface Cookie$instance {
    Comment: string;
    CommentUri: Uri;
    Discard: boolean;
    Domain: string;
    Expired: boolean;
    Expires: DateTime;
    HttpOnly: boolean;
    Name: string;
    Path: string;
    Port: string;
    Secure: boolean;
    readonly TimeStamp: DateTime;
    Value: string;
    Version: int;
    Equals(comparand: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const Cookie: {
    new(): Cookie$instance;
    new(name: string, value: string): Cookie$instance;
    new(name: string, value: string, path: string): Cookie$instance;
    new(name: string, value: string, path: string, domain: string): Cookie$instance;
};


export type Cookie = Cookie$instance;

export interface CookieCollection$instance {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    readonly SyncRoot: unknown;
    Add(cookie: Cookie): void;
    Add(cookies: CookieCollection): void;
    Clear(): void;
    Contains(cookie: Cookie): boolean;
    CopyTo(array: ClrArray, index: int): void;
    CopyTo(array: Cookie[], index: int): void;
    get_Item(index: int): Cookie;
    get_Item(name: string): Cookie;
    GetEnumerator(): IEnumerator;
    Remove(cookie: Cookie): boolean;
}


export const CookieCollection: {
    new(): CookieCollection$instance;
};


export interface __CookieCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<Cookie>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<Cookie>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<Cookie>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type CookieCollection = CookieCollection$instance & __CookieCollection$views;


export interface CookieContainer$instance {
    Capacity: int;
    readonly Count: int;
    MaxCookieSize: int;
    PerDomainCapacity: int;
    Add(cookie: Cookie): void;
    Add(cookies: CookieCollection): void;
    Add(uri: Uri, cookie: Cookie): void;
    Add(uri: Uri, cookies: CookieCollection): void;
    GetAllCookies(): CookieCollection;
    GetCookieHeader(uri: Uri): string;
    GetCookies(uri: Uri): CookieCollection;
    SetCookies(uri: Uri, cookieHeader: string): void;
}


export const CookieContainer: {
    new(): CookieContainer$instance;
    new(capacity: int): CookieContainer$instance;
    new(capacity: int, perDomainCapacity: int, maxCookieSize: int): CookieContainer$instance;
    readonly DefaultCookieLimit: int;
    readonly DefaultPerDomainCookieLimit: int;
    readonly DefaultCookieLengthLimit: int;
};


export type CookieContainer = CookieContainer$instance;

export interface CookieException$instance extends FormatException {
    GetObjectData(serializationInfo: SerializationInfo, streamingContext: StreamingContext): void;
}


export const CookieException: {
    new(): CookieException$instance;
    new(message: string): CookieException$instance;
    new(message: string, innerException: Exception): CookieException$instance;
};


export interface __CookieException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type CookieException = CookieException$instance & __CookieException$views;


export interface CredentialCache$instance {
    Add(uriPrefix: Uri, authType: string, cred: NetworkCredential): void;
    Add(host: string, port: int, authenticationType: string, credential: NetworkCredential): void;
    GetCredential(uriPrefix: Uri, authType: string): NetworkCredential;
    GetCredential(host: string, port: int, authenticationType: string): NetworkCredential;
    GetEnumerator(): IEnumerator;
    Remove(uriPrefix: Uri, authType: string): void;
    Remove(host: string, port: int, authenticationType: string): void;
}


export const CredentialCache: {
    new(): CredentialCache$instance;
    readonly DefaultCredentials: ICredentials;
    readonly DefaultNetworkCredentials: NetworkCredential;
};


export interface __CredentialCache$views {
    As_ICredentials(): ICredentials$instance;
    As_ICredentialsByHost(): ICredentialsByHost$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export interface CredentialCache$instance extends System_Collections_Internal.IEnumerable$instance {}

export type CredentialCache = CredentialCache$instance & __CredentialCache$views;


export interface DnsEndPoint$instance extends EndPoint {
    readonly AddressFamily: AddressFamily;
    readonly Host: string;
    readonly Port: int;
    Equals(comparand: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const DnsEndPoint: {
    new(host: string, port: int): DnsEndPoint$instance;
    new(host: string, port: int, addressFamily: AddressFamily): DnsEndPoint$instance;
};


export type DnsEndPoint = DnsEndPoint$instance;

export interface DownloadDataCompletedEventArgs$instance extends AsyncCompletedEventArgs {
    readonly Result: byte[];
}


export const DownloadDataCompletedEventArgs: {
    new(): DownloadDataCompletedEventArgs$instance;
};


export type DownloadDataCompletedEventArgs = DownloadDataCompletedEventArgs$instance;

export interface DownloadProgressChangedEventArgs$instance extends ProgressChangedEventArgs {
    readonly BytesReceived: long;
    readonly TotalBytesToReceive: long;
}


export const DownloadProgressChangedEventArgs: {
    new(): DownloadProgressChangedEventArgs$instance;
};


export type DownloadProgressChangedEventArgs = DownloadProgressChangedEventArgs$instance;

export interface DownloadStringCompletedEventArgs$instance extends AsyncCompletedEventArgs {
    readonly Result: string;
}


export const DownloadStringCompletedEventArgs: {
    new(): DownloadStringCompletedEventArgs$instance;
};


export type DownloadStringCompletedEventArgs = DownloadStringCompletedEventArgs$instance;

export interface EndPoint$instance {
    readonly AddressFamily: AddressFamily;
    Create(socketAddress: SocketAddress): EndPoint;
    Serialize(): SocketAddress;
}


export const EndPoint: {
};


export type EndPoint = EndPoint$instance;

export interface FileWebRequest$instance extends WebRequest$instance {
    ConnectionGroupName: string;
    ContentLength: long;
    ContentType: string;
    Credentials: ICredentials;
    readonly Headers: WebHeaderCollection;
    Method: string;
    PreAuthenticate: boolean;
    Proxy: IWebProxy;
    readonly RequestUri: Uri;
    Timeout: int;
    UseDefaultCredentials: boolean;
    Abort(): void;
    BeginGetRequestStream(callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginGetResponse(callback: AsyncCallback, state: unknown): IAsyncResult;
    EndGetRequestStream(asyncResult: IAsyncResult): Stream;
    EndGetResponse(asyncResult: IAsyncResult): WebResponse;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    GetRequestStream(): Stream;
    GetRequestStreamAsync(): Task_1<Stream>;
    GetRequestStreamAsync(): Task_1<Stream>;
    GetResponse(): WebResponse;
    GetResponseAsync(): Task_1<WebResponse>;
    GetResponseAsync(): Task_1<WebResponse>;
}


export const FileWebRequest: {
    new(): FileWebRequest$instance;
};


export interface __FileWebRequest$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface FileWebRequest$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type FileWebRequest = FileWebRequest$instance & __FileWebRequest$views;


export interface FileWebResponse$instance extends WebResponse$instance {
    readonly ContentLength: long;
    readonly ContentType: string;
    readonly Headers: WebHeaderCollection;
    readonly ResponseUri: Uri;
    readonly SupportsHeaders: boolean;
    Close(): void;
    Dispose(): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    GetResponseStream(): Stream;
}


export const FileWebResponse: {
    new(): FileWebResponse$instance;
};


export interface __FileWebResponse$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface FileWebResponse$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type FileWebResponse = FileWebResponse$instance & __FileWebResponse$views;


export interface FtpWebRequest$instance extends WebRequest$instance {
    CachePolicy: RequestCachePolicy;
    ClientCertificates: X509CertificateCollection;
    ConnectionGroupName: string;
    ContentLength: long;
    ContentOffset: long;
    ContentType: string;
    Credentials: ICredentials;
    EnableSsl: boolean;
    Headers: WebHeaderCollection;
    KeepAlive: boolean;
    Method: string;
    PreAuthenticate: boolean;
    Proxy: IWebProxy;
    ReadWriteTimeout: int;
    RenameTo: string;
    readonly RequestUri: Uri;
    readonly ServicePoint: ServicePoint;
    Timeout: int;
    UseBinary: boolean;
    UseDefaultCredentials: boolean;
    UsePassive: boolean;
    Abort(): void;
    BeginGetRequestStream(callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginGetResponse(callback: AsyncCallback, state: unknown): IAsyncResult;
    EndGetRequestStream(asyncResult: IAsyncResult): Stream;
    EndGetResponse(asyncResult: IAsyncResult): WebResponse;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    GetRequestStream(): Stream;
    GetResponse(): WebResponse;
}


export const FtpWebRequest: {
    new(): FtpWebRequest$instance;
    DefaultCachePolicy: RequestCachePolicy;
};


export interface __FtpWebRequest$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface FtpWebRequest$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type FtpWebRequest = FtpWebRequest$instance & __FtpWebRequest$views;


export interface FtpWebResponse$instance extends WebResponse$instance {
    readonly BannerMessage: string;
    readonly ContentLength: long;
    readonly ExitMessage: string;
    readonly Headers: WebHeaderCollection;
    readonly LastModified: DateTime;
    readonly ResponseUri: Uri;
    readonly StatusCode: FtpStatusCode;
    readonly StatusDescription: string;
    readonly SupportsHeaders: boolean;
    readonly WelcomeMessage: string;
    Close(): void;
    Dispose(): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    GetResponseStream(): Stream;
}


export const FtpWebResponse: {
    new(): FtpWebResponse$instance;
};


export interface __FtpWebResponse$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface FtpWebResponse$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type FtpWebResponse = FtpWebResponse$instance & __FtpWebResponse$views;


export interface GlobalProxySelection$instance {
}


export const GlobalProxySelection: {
    new(): GlobalProxySelection$instance;
    Select: IWebProxy;
    GetEmptyWebProxy(): IWebProxy;
};


export type GlobalProxySelection = GlobalProxySelection$instance;

export interface HttpListener$instance {
    AuthenticationSchemes: AuthenticationSchemes;
    AuthenticationSchemeSelectorDelegate: AuthenticationSchemeSelector;
    readonly DefaultServiceNames: ServiceNameCollection;
    ExtendedProtectionPolicy: ExtendedProtectionPolicy;
    ExtendedProtectionSelectorDelegate: HttpListener_ExtendedProtectionSelector;
    IgnoreWriteExceptions: boolean;
    readonly IsListening: boolean;
    readonly Prefixes: HttpListenerPrefixCollection;
    Realm: string;
    readonly TimeoutManager: HttpListenerTimeoutManager;
    UnsafeConnectionNtlmAuthentication: boolean;
    Abort(): void;
    BeginGetContext(callback: AsyncCallback, state: unknown): IAsyncResult;
    Close(): void;
    EndGetContext(asyncResult: IAsyncResult): HttpListenerContext;
    GetContext(): HttpListenerContext;
    GetContextAsync(): Task_1<HttpListenerContext>;
    Start(): void;
    Stop(): void;
}


export const HttpListener: {
    new(): HttpListener$instance;
    readonly IsSupported: boolean;
};


export interface __HttpListener$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface HttpListener$instance extends System_Internal.IDisposable$instance {}

export type HttpListener = HttpListener$instance & __HttpListener$views;


export interface HttpListenerBasicIdentity$instance extends GenericIdentity {
    readonly Password: string;
}


export const HttpListenerBasicIdentity: {
    new(username: string, password: string): HttpListenerBasicIdentity$instance;
};


export interface __HttpListenerBasicIdentity$views {
    As_IIdentity(): System_Security_Principal_Internal.IIdentity$instance;
}

export interface HttpListenerBasicIdentity$instance extends System_Security_Principal_Internal.IIdentity$instance {}

export type HttpListenerBasicIdentity = HttpListenerBasicIdentity$instance & __HttpListenerBasicIdentity$views;


export interface HttpListenerContext$instance {
    readonly Request: HttpListenerRequest;
    readonly Response: HttpListenerResponse;
    readonly User: IPrincipal;
    AcceptWebSocketAsync(subProtocol: string): Task_1<HttpListenerWebSocketContext>;
    AcceptWebSocketAsync(subProtocol: string, keepAliveInterval: TimeSpan): Task_1<HttpListenerWebSocketContext>;
    AcceptWebSocketAsync(subProtocol: string, receiveBufferSize: int, keepAliveInterval: TimeSpan): Task_1<HttpListenerWebSocketContext>;
    AcceptWebSocketAsync(subProtocol: string, receiveBufferSize: int, keepAliveInterval: TimeSpan, internalBuffer: ArraySegment_1<CLROf<byte>>): Task_1<HttpListenerWebSocketContext>;
}


export const HttpListenerContext: {
    new(): HttpListenerContext$instance;
};


export type HttpListenerContext = HttpListenerContext$instance;

export interface HttpListenerException$instance extends Win32Exception {
    readonly ErrorCode: int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const HttpListenerException: {
    new(): HttpListenerException$instance;
    new(errorCode: int): HttpListenerException$instance;
    new(errorCode: int, message: string): HttpListenerException$instance;
};


export interface __HttpListenerException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type HttpListenerException = HttpListenerException$instance & __HttpListenerException$views;


export interface HttpListenerPrefixCollection$instance {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    Add(uriPrefix: string): void;
    Clear(): void;
    Contains(uriPrefix: string): boolean;
    CopyTo(array: ClrArray, offset: int): void;
    CopyTo(array: string[], offset: int): void;
    GetEnumerator(): IEnumerator_1<CLROf<string>>;
    Remove(uriPrefix: string): boolean;
}


export const HttpListenerPrefixCollection: {
    new(): HttpListenerPrefixCollection$instance;
};


export interface __HttpListenerPrefixCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<CLROf<string>>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<CLROf<string>>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type HttpListenerPrefixCollection = HttpListenerPrefixCollection$instance & __HttpListenerPrefixCollection$views;


export interface HttpListenerRequest$instance {
    readonly AcceptTypes: string[];
    readonly ClientCertificateError: int;
    readonly ContentEncoding: Encoding;
    readonly ContentLength64: long;
    readonly ContentType: string;
    readonly Cookies: CookieCollection;
    readonly HasEntityBody: boolean;
    readonly Headers: NameValueCollection;
    readonly HttpMethod: string;
    readonly InputStream: Stream;
    readonly IsAuthenticated: boolean;
    readonly IsLocal: boolean;
    readonly IsSecureConnection: boolean;
    readonly IsWebSocketRequest: boolean;
    readonly KeepAlive: boolean;
    readonly LocalEndPoint: IPEndPoint;
    readonly ProtocolVersion: Version;
    readonly QueryString: NameValueCollection;
    readonly RawUrl: string;
    readonly RemoteEndPoint: IPEndPoint;
    readonly RequestTraceIdentifier: Guid;
    readonly ServiceName: string;
    readonly TransportContext: TransportContext;
    readonly Url: Uri;
    readonly UrlReferrer: Uri;
    readonly UserAgent: string;
    readonly UserHostAddress: string;
    readonly UserHostName: string;
    readonly UserLanguages: string[];
    BeginGetClientCertificate(requestCallback: AsyncCallback, state: unknown): IAsyncResult;
    EndGetClientCertificate(asyncResult: IAsyncResult): X509Certificate2;
    GetClientCertificate(): X509Certificate2;
    GetClientCertificateAsync(): Task_1<X509Certificate2>;
}


export const HttpListenerRequest: {
    new(): HttpListenerRequest$instance;
};


export type HttpListenerRequest = HttpListenerRequest$instance;

export interface HttpListenerResponse$instance {
    ContentEncoding: Encoding;
    ContentLength64: long;
    ContentType: string;
    Cookies: CookieCollection;
    Headers: WebHeaderCollection;
    KeepAlive: boolean;
    readonly OutputStream: Stream;
    ProtocolVersion: Version;
    RedirectLocation: string;
    SendChunked: boolean;
    StatusCode: int;
    StatusDescription: string;
    Abort(): void;
    AddHeader(name: string, value: string): void;
    AppendCookie(cookie: Cookie): void;
    AppendHeader(name: string, value: string): void;
    Close(): void;
    Close(responseEntity: byte[], willBlock: boolean): void;
    CopyFrom(templateResponse: HttpListenerResponse): void;
    Redirect(url: string): void;
    SetCookie(cookie: Cookie): void;
}


export const HttpListenerResponse: {
    new(): HttpListenerResponse$instance;
};


export interface __HttpListenerResponse$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface HttpListenerResponse$instance extends System_Internal.IDisposable$instance {}

export type HttpListenerResponse = HttpListenerResponse$instance & __HttpListenerResponse$views;


export interface HttpListenerTimeoutManager$instance {
    DrainEntityBody: TimeSpan;
    EntityBody: TimeSpan;
    HeaderWait: TimeSpan;
    IdleConnection: TimeSpan;
    MinSendBytesPerSecond: long;
    RequestQueue: TimeSpan;
}


export const HttpListenerTimeoutManager: {
    new(): HttpListenerTimeoutManager$instance;
};


export type HttpListenerTimeoutManager = HttpListenerTimeoutManager$instance;

export interface HttpWebRequest$instance extends WebRequest$instance {
    Accept: string;
    readonly Address: Uri;
    AllowAutoRedirect: boolean;
    AllowReadStreamBuffering: boolean;
    AllowWriteStreamBuffering: boolean;
    AutomaticDecompression: DecompressionMethods;
    ClientCertificates: X509CertificateCollection;
    Connection: string;
    ConnectionGroupName: string;
    ContentLength: long;
    ContentType: string;
    ContinueDelegate: HttpContinueDelegate;
    ContinueTimeout: int;
    CookieContainer: CookieContainer;
    Credentials: ICredentials;
    Date: DateTime;
    Expect: string;
    readonly HaveResponse: boolean;
    Headers: WebHeaderCollection;
    Host: string;
    IfModifiedSince: DateTime;
    KeepAlive: boolean;
    MaximumAutomaticRedirections: int;
    MaximumResponseHeadersLength: int;
    MediaType: string;
    Method: string;
    Pipelined: boolean;
    PreAuthenticate: boolean;
    ProtocolVersion: Version;
    Proxy: IWebProxy;
    ReadWriteTimeout: int;
    Referer: string;
    readonly RequestUri: Uri;
    SendChunked: boolean;
    ServerCertificateValidationCallback: RemoteCertificateValidationCallback;
    readonly ServicePoint: ServicePoint;
    readonly SupportsCookieContainer: boolean;
    Timeout: int;
    TransferEncoding: string;
    UnsafeAuthenticatedConnectionSharing: boolean;
    UseDefaultCredentials: boolean;
    UserAgent: string;
    Abort(): void;
    AddRange(from_: int, to: int): void;
    AddRange(from_: long, to: long): void;
    AddRange(range: int): void;
    AddRange(range: long): void;
    AddRange(rangeSpecifier: string, from_: int, to: int): void;
    AddRange(rangeSpecifier: string, from_: long, to: long): void;
    AddRange(rangeSpecifier: string, range: int): void;
    AddRange(rangeSpecifier: string, range: long): void;
    BeginGetRequestStream(callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginGetResponse(callback: AsyncCallback, state: unknown): IAsyncResult;
    EndGetRequestStream(asyncResult: IAsyncResult): Stream;
    EndGetResponse(asyncResult: IAsyncResult): WebResponse;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    GetRequestStream(): Stream;
    GetResponse(): WebResponse;
}


export const HttpWebRequest: {
    new(): HttpWebRequest$instance;
    DefaultMaximumResponseHeadersLength: int;
    DefaultMaximumErrorResponseLength: int;
    DefaultCachePolicy: RequestCachePolicy;
};


export interface __HttpWebRequest$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface HttpWebRequest$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type HttpWebRequest = HttpWebRequest$instance & __HttpWebRequest$views;


export interface HttpWebResponse$instance extends WebResponse$instance {
    readonly CharacterSet: string;
    readonly ContentEncoding: string;
    readonly ContentLength: long;
    readonly ContentType: string;
    Cookies: CookieCollection;
    readonly Headers: WebHeaderCollection;
    readonly IsMutuallyAuthenticated: boolean;
    readonly LastModified: DateTime;
    readonly Method: string;
    readonly ProtocolVersion: Version;
    readonly ResponseUri: Uri;
    readonly Server: string;
    readonly StatusCode: HttpStatusCode;
    readonly StatusDescription: string;
    readonly SupportsHeaders: boolean;
    Close(): void;
    Dispose(): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    GetResponseHeader(headerName: string): string;
    GetResponseStream(): Stream;
}


export const HttpWebResponse: {
    new(): HttpWebResponse$instance;
};


export interface __HttpWebResponse$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface HttpWebResponse$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type HttpWebResponse = HttpWebResponse$instance & __HttpWebResponse$views;


export interface IPAddress$instance {
    Address: long;
    readonly AddressFamily: AddressFamily;
    readonly IsIPv4MappedToIPv6: boolean;
    readonly IsIPv6LinkLocal: boolean;
    readonly IsIPv6Multicast: boolean;
    readonly IsIPv6SiteLocal: boolean;
    readonly IsIPv6Teredo: boolean;
    readonly IsIPv6UniqueLocal: boolean;
    ScopeId: long;
    Equals(comparand: unknown): boolean;
    GetAddressBytes(): byte[];
    GetHashCode(): int;
    MapToIPv4(): IPAddress;
    MapToIPv6(): IPAddress;
    ToString(): string;
    TryFormat(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    TryFormat(utf8Destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryWriteBytes(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export const IPAddress: {
    new(newAddress: long): IPAddress$instance;
    new(address: byte[], scopeid: long): IPAddress$instance;
    new(address: ReadOnlySpan_1<CLROf<byte>>, scopeid: long): IPAddress$instance;
    new(address: byte[]): IPAddress$instance;
    new(address: ReadOnlySpan_1<CLROf<byte>>): IPAddress$instance;
    readonly Any: IPAddress;
    readonly Loopback: IPAddress;
    readonly Broadcast: IPAddress;
    readonly None: IPAddress;
    readonly IPv6Any: IPAddress;
    readonly IPv6Loopback: IPAddress;
    readonly IPv6None: IPAddress;
    HostToNetworkOrder(host: short): short;
    HostToNetworkOrder(host: int): int;
    HostToNetworkOrder(host: long): long;
    IsLoopback(address: IPAddress): boolean;
    IsValid(ipSpan: ReadOnlySpan_1<CLROf<char>>): boolean;
    IsValidUtf8(utf8Text: ReadOnlySpan_1<CLROf<byte>>): boolean;
    NetworkToHostOrder(network: short): short;
    NetworkToHostOrder(network: int): int;
    NetworkToHostOrder(network: long): long;
    Parse(utf8Text: ReadOnlySpan_1<CLROf<byte>>): IPAddress;
    Parse(ipSpan: ReadOnlySpan_1<CLROf<char>>): IPAddress;
    Parse(ipString: string): IPAddress;
    TryParse(utf8Text: ReadOnlySpan_1<CLROf<byte>>, result: { value: ref<IPAddress> }): boolean;
    TryParse(ipSpan: ReadOnlySpan_1<CLROf<char>>, address: { value: ref<IPAddress> }): boolean;
    TryParse(ipString: string, address: { value: ref<IPAddress> }): boolean;
};


export interface __IPAddress$views {
    As_IFormattable(): System_Internal.IFormattable$instance;
    As_IParsable_1(): System_Internal.IParsable_1$instance<IPAddress>;
    As_ISpanFormattable(): System_Internal.ISpanFormattable$instance;
    As_ISpanParsable_1(): System_Internal.ISpanParsable_1$instance<IPAddress>;
    As_IUtf8SpanFormattable(): System_Internal.IUtf8SpanFormattable$instance;
    As_IUtf8SpanParsable_1(): System_Internal.IUtf8SpanParsable_1$instance<IPAddress>;

    // Structural method bridges for numeric interface constraints
    tryFormat(utf8Destination: import("../../System/internal/index").Span_1<import("../../System/internal/index").CLROf<byte>>, bytesWritten: { value: ref<int> }, format: import("../../System/internal/index").ReadOnlySpan_1<import("../../System/internal/index").CLROf<char>>, provider: import("../../System/internal/index").IFormatProvider): boolean;
}

export interface IPAddress$instance extends System_Internal.ISpanParsable_1$instance<IPAddress> {}

export type IPAddress = IPAddress$instance & __IPAddress$views;


export interface IPEndPoint$instance extends EndPoint {
    Address: IPAddress;
    readonly AddressFamily: AddressFamily;
    Port: int;
    Create(socketAddress: SocketAddress): EndPoint;
    Equals(comparand: unknown): boolean;
    GetHashCode(): int;
    Serialize(): SocketAddress;
    ToString(): string;
}


export const IPEndPoint: {
    new(address: long, port: int): IPEndPoint$instance;
    new(address: IPAddress, port: int): IPEndPoint$instance;
    readonly MinPort: int;
    readonly MaxPort: int;
    Parse(s: ReadOnlySpan_1<CLROf<char>>): IPEndPoint;
    Parse(s: string): IPEndPoint;
    TryParse(s: ReadOnlySpan_1<CLROf<char>>, result: { value: ref<IPEndPoint> }): boolean;
    TryParse(s: string, result: { value: ref<IPEndPoint> }): boolean;
};


export type IPEndPoint = IPEndPoint$instance;

export interface IPHostEntry$instance {
    AddressList: IPAddress[];
    Aliases: string[];
    HostName: string;
}


export const IPHostEntry: {
    new(): IPHostEntry$instance;
};


export type IPHostEntry = IPHostEntry$instance;

export interface NetworkCredential$instance {
    Domain: string;
    Password: string;
    SecurePassword: SecureString;
    UserName: string;
    GetCredential(uri: Uri, authenticationType: string): NetworkCredential;
    GetCredential(host: string, port: int, authenticationType: string): NetworkCredential;
}


export const NetworkCredential: {
    new(): NetworkCredential$instance;
    new(userName: string, password: string): NetworkCredential$instance;
    new(userName: string, password: string, domain: string): NetworkCredential$instance;
    new(userName: string, password: SecureString): NetworkCredential$instance;
    new(userName: string, password: SecureString, domain: string): NetworkCredential$instance;
};


export interface __NetworkCredential$views {
    As_ICredentials(): ICredentials$instance;
    As_ICredentialsByHost(): ICredentialsByHost$instance;
}

export type NetworkCredential = NetworkCredential$instance & __NetworkCredential$views;


export interface OpenReadCompletedEventArgs$instance extends AsyncCompletedEventArgs {
    readonly Result: Stream;
}


export const OpenReadCompletedEventArgs: {
    new(): OpenReadCompletedEventArgs$instance;
};


export type OpenReadCompletedEventArgs = OpenReadCompletedEventArgs$instance;

export interface OpenWriteCompletedEventArgs$instance extends AsyncCompletedEventArgs {
    readonly Result: Stream;
}


export const OpenWriteCompletedEventArgs: {
    new(): OpenWriteCompletedEventArgs$instance;
};


export type OpenWriteCompletedEventArgs = OpenWriteCompletedEventArgs$instance;

export interface PathList$instance {
}


export const PathList: {
    new(): PathList$instance;
};


export type PathList = PathList$instance;

export interface ProtocolViolationException$instance extends InvalidOperationException {
    GetObjectData(serializationInfo: SerializationInfo, streamingContext: StreamingContext): void;
}


export const ProtocolViolationException: {
    new(): ProtocolViolationException$instance;
    new(message: string): ProtocolViolationException$instance;
};


export interface __ProtocolViolationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ProtocolViolationException = ProtocolViolationException$instance & __ProtocolViolationException$views;


export interface ServicePoint$instance {
    readonly Address: Uri;
    BindIPEndPointDelegate: BindIPEndPoint;
    readonly Certificate: X509Certificate;
    readonly ClientCertificate: X509Certificate;
    ConnectionLeaseTimeout: int;
    ConnectionLimit: int;
    readonly ConnectionName: string;
    readonly CurrentConnections: int;
    Expect100Continue: boolean;
    readonly IdleSince: DateTime;
    MaxIdleTime: int;
    readonly ProtocolVersion: Version;
    ReceiveBufferSize: int;
    readonly SupportsPipelining: boolean;
    UseNagleAlgorithm: boolean;
    CloseConnectionGroup(connectionGroupName: string): boolean;
    SetTcpKeepAlive(enabled: boolean, keepAliveTime: int, keepAliveInterval: int): void;
}


export const ServicePoint: {
    new(): ServicePoint$instance;
};


export type ServicePoint = ServicePoint$instance;

export interface ServicePointManager$instance {
}


export const ServicePointManager: {
    new(): ServicePointManager$instance;
    readonly DefaultNonPersistentConnectionLimit: int;
    readonly DefaultPersistentConnectionLimit: int;
    SecurityProtocol: SecurityProtocolType;
    MaxServicePoints: int;
    DefaultConnectionLimit: int;
    MaxServicePointIdleTime: int;
    UseNagleAlgorithm: boolean;
    Expect100Continue: boolean;
    EnableDnsRoundRobin: boolean;
    DnsRefreshTimeout: int;
    ServerCertificateValidationCallback: RemoteCertificateValidationCallback;
    ReusePort: boolean;
    CheckCertificateRevocationList: boolean;
    readonly EncryptionPolicy: EncryptionPolicy;
    FindServicePoint(uriString: string, proxy: IWebProxy): ServicePoint;
    FindServicePoint(address: Uri, proxy: IWebProxy): ServicePoint;
    FindServicePoint(address: Uri): ServicePoint;
    SetTcpKeepAlive(enabled: boolean, keepAliveTime: int, keepAliveInterval: int): void;
};


export type ServicePointManager = ServicePointManager$instance;

export interface SocketAddress$instance {
    readonly Buffer: Memory_1<CLROf<byte>>;
    readonly Family: AddressFamily;
    Item: byte;
    Size: int;
    Equals(comparand: unknown): boolean;
    Equals(comparand: SocketAddress): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const SocketAddress: {
    new(family: AddressFamily): SocketAddress$instance;
    new(family: AddressFamily, size: int): SocketAddress$instance;
    GetMaximumAddressSize(addressFamily: AddressFamily): int;
};


export interface __SocketAddress$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SocketAddress>;

    // Structural method bridges for numeric interface constraints
    equals(other: SocketAddress): boolean;
}

export type SocketAddress = SocketAddress$instance & __SocketAddress$views;


export interface TransportContext$instance {
    GetChannelBinding(kind: ChannelBindingKind): ChannelBinding;
}


export const TransportContext: {
};


export type TransportContext = TransportContext$instance;

export interface UploadDataCompletedEventArgs$instance extends AsyncCompletedEventArgs {
    readonly Result: byte[];
}


export const UploadDataCompletedEventArgs: {
    new(): UploadDataCompletedEventArgs$instance;
};


export type UploadDataCompletedEventArgs = UploadDataCompletedEventArgs$instance;

export interface UploadFileCompletedEventArgs$instance extends AsyncCompletedEventArgs {
    readonly Result: byte[];
}


export const UploadFileCompletedEventArgs: {
    new(): UploadFileCompletedEventArgs$instance;
};


export type UploadFileCompletedEventArgs = UploadFileCompletedEventArgs$instance;

export interface UploadProgressChangedEventArgs$instance extends ProgressChangedEventArgs {
    readonly BytesReceived: long;
    readonly BytesSent: long;
    readonly TotalBytesToReceive: long;
    readonly TotalBytesToSend: long;
}


export const UploadProgressChangedEventArgs: {
    new(): UploadProgressChangedEventArgs$instance;
};


export type UploadProgressChangedEventArgs = UploadProgressChangedEventArgs$instance;

export interface UploadStringCompletedEventArgs$instance extends AsyncCompletedEventArgs {
    readonly Result: string;
}


export const UploadStringCompletedEventArgs: {
    new(): UploadStringCompletedEventArgs$instance;
};


export type UploadStringCompletedEventArgs = UploadStringCompletedEventArgs$instance;

export interface UploadValuesCompletedEventArgs$instance extends AsyncCompletedEventArgs {
    readonly Result: byte[];
}


export const UploadValuesCompletedEventArgs: {
    new(): UploadValuesCompletedEventArgs$instance;
};


export type UploadValuesCompletedEventArgs = UploadValuesCompletedEventArgs$instance;

export interface WebClient$instance extends Component {
    AllowReadStreamBuffering: boolean;
    AllowWriteStreamBuffering: boolean;
    BaseAddress: string;
    CachePolicy: RequestCachePolicy;
    Credentials: ICredentials;
    Encoding: Encoding;
    Headers: WebHeaderCollection;
    readonly IsBusy: boolean;
    Proxy: IWebProxy;
    QueryString: NameValueCollection;
    readonly ResponseHeaders: WebHeaderCollection;
    UseDefaultCredentials: boolean;
    CancelAsync(): void;
    Dispose(): void;
    DownloadData(address: string): byte[];
    DownloadData(address: Uri): byte[];
    DownloadDataAsync(address: Uri): void;
    DownloadDataAsync(address: Uri, userToken: unknown): void;
    DownloadDataTaskAsync(address: string): Task_1<byte[]>;
    DownloadDataTaskAsync(address: Uri): Task_1<byte[]>;
    DownloadFile(address: string, fileName: string): void;
    DownloadFile(address: Uri, fileName: string): void;
    DownloadFileAsync(address: Uri, fileName: string): void;
    DownloadFileAsync(address: Uri, fileName: string, userToken: unknown): void;
    DownloadFileTaskAsync(address: string, fileName: string): Task;
    DownloadFileTaskAsync(address: Uri, fileName: string): Task;
    DownloadString(address: string): string;
    DownloadString(address: Uri): string;
    DownloadStringAsync(address: Uri): void;
    DownloadStringAsync(address: Uri, userToken: unknown): void;
    DownloadStringTaskAsync(address: string): Task_1<CLROf<string>>;
    DownloadStringTaskAsync(address: Uri): Task_1<CLROf<string>>;
    OpenRead(address: string): Stream;
    OpenRead(address: Uri): Stream;
    OpenReadAsync(address: Uri): void;
    OpenReadAsync(address: Uri, userToken: unknown): void;
    OpenReadTaskAsync(address: string): Task_1<Stream>;
    OpenReadTaskAsync(address: Uri): Task_1<Stream>;
    OpenWrite(address: string): Stream;
    OpenWrite(address: Uri): Stream;
    OpenWrite(address: string, method: string): Stream;
    OpenWrite(address: Uri, method: string): Stream;
    OpenWriteAsync(address: Uri): void;
    OpenWriteAsync(address: Uri, method: string): void;
    OpenWriteAsync(address: Uri, method: string, userToken: unknown): void;
    OpenWriteTaskAsync(address: string): Task_1<Stream>;
    OpenWriteTaskAsync(address: Uri): Task_1<Stream>;
    OpenWriteTaskAsync(address: string, method: string): Task_1<Stream>;
    OpenWriteTaskAsync(address: Uri, method: string): Task_1<Stream>;
    UploadData(address: string, data: byte[]): byte[];
    UploadData(address: Uri, data: byte[]): byte[];
    UploadData(address: string, method: string, data: byte[]): byte[];
    UploadData(address: Uri, method: string, data: byte[]): byte[];
    UploadDataAsync(address: Uri, data: byte[]): void;
    UploadDataAsync(address: Uri, method: string, data: byte[]): void;
    UploadDataAsync(address: Uri, method: string, data: byte[], userToken: unknown): void;
    UploadDataTaskAsync(address: string, data: byte[]): Task_1<byte[]>;
    UploadDataTaskAsync(address: Uri, data: byte[]): Task_1<byte[]>;
    UploadDataTaskAsync(address: string, method: string, data: byte[]): Task_1<byte[]>;
    UploadDataTaskAsync(address: Uri, method: string, data: byte[]): Task_1<byte[]>;
    UploadFile(address: string, fileName: string): byte[];
    UploadFile(address: Uri, fileName: string): byte[];
    UploadFile(address: string, method: string, fileName: string): byte[];
    UploadFile(address: Uri, method: string, fileName: string): byte[];
    UploadFileAsync(address: Uri, fileName: string): void;
    UploadFileAsync(address: Uri, method: string, fileName: string): void;
    UploadFileAsync(address: Uri, method: string, fileName: string, userToken: unknown): void;
    UploadFileTaskAsync(address: string, fileName: string): Task_1<byte[]>;
    UploadFileTaskAsync(address: Uri, fileName: string): Task_1<byte[]>;
    UploadFileTaskAsync(address: string, method: string, fileName: string): Task_1<byte[]>;
    UploadFileTaskAsync(address: Uri, method: string, fileName: string): Task_1<byte[]>;
    UploadString(address: string, data: string): string;
    UploadString(address: Uri, data: string): string;
    UploadString(address: string, method: string, data: string): string;
    UploadString(address: Uri, method: string, data: string): string;
    UploadStringAsync(address: Uri, data: string): void;
    UploadStringAsync(address: Uri, method: string, data: string): void;
    UploadStringAsync(address: Uri, method: string, data: string, userToken: unknown): void;
    UploadStringTaskAsync(address: string, data: string): Task_1<CLROf<string>>;
    UploadStringTaskAsync(address: Uri, data: string): Task_1<CLROf<string>>;
    UploadStringTaskAsync(address: string, method: string, data: string): Task_1<CLROf<string>>;
    UploadStringTaskAsync(address: Uri, method: string, data: string): Task_1<CLROf<string>>;
    UploadValues(address: string, data: NameValueCollection): byte[];
    UploadValues(address: Uri, data: NameValueCollection): byte[];
    UploadValues(address: string, method: string, data: NameValueCollection): byte[];
    UploadValues(address: Uri, method: string, data: NameValueCollection): byte[];
    UploadValuesAsync(address: Uri, data: NameValueCollection): void;
    UploadValuesAsync(address: Uri, method: string, data: NameValueCollection): void;
    UploadValuesAsync(address: Uri, method: string, data: NameValueCollection, userToken: unknown): void;
    UploadValuesTaskAsync(address: string, data: NameValueCollection): Task_1<byte[]>;
    UploadValuesTaskAsync(address: string, method: string, data: NameValueCollection): Task_1<byte[]>;
    UploadValuesTaskAsync(address: Uri, data: NameValueCollection): Task_1<byte[]>;
    UploadValuesTaskAsync(address: Uri, method: string, data: NameValueCollection): Task_1<byte[]>;
}


export const WebClient: {
    new(): WebClient$instance;
};


export interface __WebClient$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface WebClient$instance extends System_ComponentModel_Internal.IComponent$instance {}

export type WebClient = WebClient$instance & __WebClient$views;


export interface WebException$instance extends InvalidOperationException {
    readonly Response: WebResponse;
    readonly Status: WebExceptionStatus;
    GetObjectData(serializationInfo: SerializationInfo, streamingContext: StreamingContext): void;
}


export const WebException: {
    new(): WebException$instance;
    new(message: string): WebException$instance;
    new(message: string, innerException: Exception): WebException$instance;
    new(message: string, status: WebExceptionStatus): WebException$instance;
    new(message: string, innerException: Exception, status: WebExceptionStatus, response: WebResponse): WebException$instance;
};


export interface __WebException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type WebException = WebException$instance & __WebException$views;


export interface WebHeaderCollection$instance extends NameValueCollection {
    readonly AllKeys: string[];
    readonly Count: int;
    readonly Keys: NameObjectCollectionBase_KeysCollection;
    Add(header: HttpResponseHeader, value: string): void;
    Add(name: string, value: string): void;
    Add(c: NameValueCollection): void;
    Clear(): void;
    CopyTo(dest: ClrArray, index: int): void;
    Get(index: int): string;
    Get(name: string): string;
    GetEnumerator(): IEnumerator;
    GetKey(index: int): string;
    GetObjectData(serializationInfo: SerializationInfo, streamingContext: StreamingContext): void;
    GetValues(index: int): string[];
    GetValues(header: string): string[];
    OnDeserialization(sender: unknown): void;
    Remove(header: HttpResponseHeader): void;
    Remove(name: string): void;
    Set(name: string, value: string): void;
    Set(header: HttpResponseHeader, value: string): void;
    ToByteArray(): byte[];
    ToString(): string;
}


export const WebHeaderCollection: {
    new(): WebHeaderCollection$instance;
    IsRestricted(headerName: string, response: boolean): boolean;
    IsRestricted(headerName: string): boolean;
};


export interface __WebHeaderCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type WebHeaderCollection = WebHeaderCollection$instance & __WebHeaderCollection$views;


export interface WebProxy$instance {
    Address: Uri;
    readonly BypassArrayList: ArrayList;
    BypassList: string[];
    BypassProxyOnLocal: boolean;
    Credentials: ICredentials;
    UseDefaultCredentials: boolean;
    GetProxy(destination: Uri): Uri;
    IsBypassed(host: Uri): boolean;
}


export const WebProxy: {
    new(): WebProxy$instance;
    new(Address: Uri): WebProxy$instance;
    new(Address: Uri, BypassOnLocal: boolean): WebProxy$instance;
    new(Address: Uri, BypassOnLocal: boolean, BypassList: string[]): WebProxy$instance;
    new(Address: Uri, BypassOnLocal: boolean, BypassList: string[], Credentials: ICredentials): WebProxy$instance;
    new(Host: string, Port: int): WebProxy$instance;
    new(Address: string): WebProxy$instance;
    new(Address: string, BypassOnLocal: boolean): WebProxy$instance;
    new(Address: string, BypassOnLocal: boolean, BypassList: string[]): WebProxy$instance;
    new(Address: string, BypassOnLocal: boolean, BypassList: string[], Credentials: ICredentials): WebProxy$instance;
    GetDefaultProxy(): WebProxy;
};


export interface __WebProxy$views {
    As_IWebProxy(): IWebProxy$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface WebProxy$instance extends IWebProxy$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type WebProxy = WebProxy$instance & __WebProxy$views;


export interface WebRequest$instance extends MarshalByRefObject {
    AuthenticationLevel: AuthenticationLevel;
    CachePolicy: RequestCachePolicy;
    ConnectionGroupName: string;
    ContentLength: long;
    ContentType: string;
    Credentials: ICredentials;
    Headers: WebHeaderCollection;
    ImpersonationLevel: TokenImpersonationLevel;
    Method: string;
    PreAuthenticate: boolean;
    Proxy: IWebProxy;
    readonly RequestUri: Uri;
    Timeout: int;
    UseDefaultCredentials: boolean;
    Abort(): void;
    BeginGetRequestStream(callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginGetResponse(callback: AsyncCallback, state: unknown): IAsyncResult;
    EndGetRequestStream(asyncResult: IAsyncResult): Stream;
    EndGetResponse(asyncResult: IAsyncResult): WebResponse;
    GetRequestStream(): Stream;
    GetRequestStreamAsync(): Task_1<Stream>;
    GetResponse(): WebResponse;
    GetResponseAsync(): Task_1<WebResponse>;
}


export const WebRequest: {
    DefaultCachePolicy: RequestCachePolicy;
    DefaultWebProxy: IWebProxy;
    Create(requestUriString: string): WebRequest;
    Create(requestUri: Uri): WebRequest;
    CreateDefault(requestUri: Uri): WebRequest;
    CreateHttp(requestUriString: string): HttpWebRequest;
    CreateHttp(requestUri: Uri): HttpWebRequest;
    GetSystemWebProxy(): IWebProxy;
    RegisterPrefix(prefix: string, creator: IWebRequestCreate): boolean;
};


export interface __WebRequest$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface WebRequest$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type WebRequest = WebRequest$instance & __WebRequest$views;


export interface WebResponse$instance extends MarshalByRefObject {
    ContentLength: long;
    ContentType: string;
    readonly Headers: WebHeaderCollection;
    readonly IsFromCache: boolean;
    readonly IsMutuallyAuthenticated: boolean;
    readonly ResponseUri: Uri;
    readonly SupportsHeaders: boolean;
    Close(): void;
    Dispose(): void;
    GetResponseStream(): Stream;
}


export const WebResponse: {
};


export interface __WebResponse$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface WebResponse$instance extends System_Internal.IDisposable$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type WebResponse = WebResponse$instance & __WebResponse$views;


export interface WriteStreamClosedEventArgs$instance extends EventArgs {
    readonly Error: Exception;
}


export const WriteStreamClosedEventArgs: {
    new(): WriteStreamClosedEventArgs$instance;
};


export type WriteStreamClosedEventArgs = WriteStreamClosedEventArgs$instance;

export abstract class Dns$instance {
    static BeginGetHostAddresses(hostNameOrAddress: string, requestCallback: AsyncCallback, state: unknown): IAsyncResult;
    static BeginGetHostByName(hostName: string, requestCallback: AsyncCallback, stateObject: unknown): IAsyncResult;
    static BeginGetHostEntry(address: IPAddress, requestCallback: AsyncCallback, stateObject: unknown): IAsyncResult;
    static BeginGetHostEntry(hostNameOrAddress: string, requestCallback: AsyncCallback, stateObject: unknown): IAsyncResult;
    static BeginResolve(hostName: string, requestCallback: AsyncCallback, stateObject: unknown): IAsyncResult;
    static EndGetHostAddresses(asyncResult: IAsyncResult): IPAddress[];
    static EndGetHostByName(asyncResult: IAsyncResult): IPHostEntry;
    static EndGetHostEntry(asyncResult: IAsyncResult): IPHostEntry;
    static EndResolve(asyncResult: IAsyncResult): IPHostEntry;
    static GetHostAddresses(hostNameOrAddress: string, family: AddressFamily): IPAddress[];
    static GetHostAddresses(hostNameOrAddress: string): IPAddress[];
    static GetHostAddressesAsync(hostNameOrAddress: string, family: AddressFamily, cancellationToken?: CancellationToken): Task_1<IPAddress[]>;
    static GetHostAddressesAsync(hostNameOrAddress: string, cancellationToken: CancellationToken): Task_1<IPAddress[]>;
    static GetHostAddressesAsync(hostNameOrAddress: string): Task_1<IPAddress[]>;
    static GetHostByAddress(address: IPAddress): IPHostEntry;
    static GetHostByAddress(address: string): IPHostEntry;
    static GetHostByName(hostName: string): IPHostEntry;
    static GetHostEntry(address: IPAddress): IPHostEntry;
    static GetHostEntry(hostNameOrAddress: string, family: AddressFamily): IPHostEntry;
    static GetHostEntry(hostNameOrAddress: string): IPHostEntry;
    static GetHostEntryAsync(address: IPAddress): Task_1<IPHostEntry>;
    static GetHostEntryAsync(hostNameOrAddress: string, family: AddressFamily, cancellationToken?: CancellationToken): Task_1<IPHostEntry>;
    static GetHostEntryAsync(hostNameOrAddress: string, cancellationToken: CancellationToken): Task_1<IPHostEntry>;
    static GetHostEntryAsync(hostNameOrAddress: string): Task_1<IPHostEntry>;
    static GetHostName(): string;
    static Resolve(hostName: string): IPHostEntry;
}


export type Dns = Dns$instance;

export abstract class HttpVersion$instance {
    static readonly Unknown: Version;
    static readonly Version10: Version;
    static readonly Version11: Version;
    static readonly Version20: Version;
    static readonly Version30: Version;
}


export type HttpVersion = HttpVersion$instance;

export abstract class WebRequestMethods$instance {
}


export type WebRequestMethods = WebRequestMethods$instance;

export abstract class WebRequestMethods_File$instance {
    static readonly DownloadFile: string;
    static readonly UploadFile: string;
}


export type WebRequestMethods_File = WebRequestMethods_File$instance;

export abstract class WebRequestMethods_Ftp$instance {
    static readonly DownloadFile: string;
    static readonly ListDirectory: string;
    static readonly UploadFile: string;
    static readonly DeleteFile: string;
    static readonly AppendFile: string;
    static readonly GetFileSize: string;
    static readonly UploadFileWithUniqueName: string;
    static readonly MakeDirectory: string;
    static readonly RemoveDirectory: string;
    static readonly ListDirectoryDetails: string;
    static readonly GetDateTimestamp: string;
    static readonly PrintWorkingDirectory: string;
    static readonly Rename: string;
}


export type WebRequestMethods_Ftp = WebRequestMethods_Ftp$instance;

export abstract class WebRequestMethods_Http$instance {
    static readonly Get: string;
    static readonly Connect: string;
    static readonly Head: string;
    static readonly Put: string;
    static readonly Post: string;
    static readonly MkCol: string;
}


export type WebRequestMethods_Http = WebRequestMethods_Http$instance;

export abstract class WebUtility$instance {
    static HtmlDecode(value: string, output: TextWriter): void;
    static HtmlDecode(value: string): string;
    static HtmlEncode(value: string, output: TextWriter): void;
    static HtmlEncode(value: string): string;
    static UrlDecode(encodedValue: string): string;
    static UrlDecodeToBytes(encodedValue: byte[], offset: int, count: int): byte[];
    static UrlEncode(value: string): string;
    static UrlEncodeToBytes(value: byte[], offset: int, count: int): byte[];
}


export type WebUtility = WebUtility$instance;


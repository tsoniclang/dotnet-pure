// Generated by tsbindgen - Architecture
// Namespace: System.IO.Pipelines
// Assembly: System.IO.Pipelines

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import * as System_Buffers_Internal from "../../System.Buffers/internal/index.js";
import type { IBufferWriter_1, MemoryPool_1, ReadOnlySequence_1 } from "../../System.Buffers/internal/index.js";
import type { Stream } from "../../System.IO/internal/index.js";
import type { Task, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Action_2, Boolean as ClrBoolean, Byte, Exception, Int32, Int64, Memory_1, Object as ClrObject, ReadOnlyMemory_1, SequencePosition, Span_1, String as ClrString, Type, ValueType, Void } from "../../System/internal/index.js";

export interface IDuplexPipe$instance {
    readonly Input: PipeReader;
    readonly Output: PipeWriter;
}


export type IDuplexPipe = IDuplexPipe$instance;

export interface FlushResult$instance {
    readonly IsCanceled: boolean;
    readonly IsCompleted: boolean;
}


export const FlushResult: {
    new(isCanceled: boolean, isCompleted: boolean): FlushResult;
};


export type FlushResult = FlushResult$instance;

export interface ReadResult$instance {
    readonly Buffer: ReadOnlySequence_1<System_Internal.Byte>;
    readonly IsCanceled: boolean;
    readonly IsCompleted: boolean;
}


export const ReadResult: {
    new(buffer: ReadOnlySequence_1<System_Internal.Byte>, isCanceled: boolean, isCompleted: boolean): ReadResult;
};


export type ReadResult = ReadResult$instance;

export interface Pipe$instance {
    readonly Reader: PipeReader;
    readonly Writer: PipeWriter;
    Reset(): void;
}


export const Pipe: {
    new(): Pipe;
    new(options: PipeOptions): Pipe;
};


export type Pipe = Pipe$instance;

export interface PipeOptions$instance {
    readonly MinimumSegmentSize: int;
    readonly PauseWriterThreshold: long;
    readonly Pool: MemoryPool_1<System_Internal.Byte>;
    readonly ReaderScheduler: PipeScheduler;
    readonly ResumeWriterThreshold: long;
    readonly UseSynchronizationContext: boolean;
    readonly WriterScheduler: PipeScheduler;
}


export const PipeOptions: {
    new(pool: MemoryPool_1<System_Internal.Byte>, readerScheduler: PipeScheduler, writerScheduler: PipeScheduler, pauseWriterThreshold: long, resumeWriterThreshold: long, minimumSegmentSize: int, useSynchronizationContext: boolean): PipeOptions;
    readonly Default: PipeOptions;
};


export type PipeOptions = PipeOptions$instance;

export interface PipeReader$instance {
    AdvanceTo(consumed: SequencePosition): void;
    AdvanceTo(consumed: SequencePosition, examined: SequencePosition): void;
    AsStream(leaveOpen?: boolean): Stream;
    CancelPendingRead(): void;
    Complete(exception?: Exception): void;
    CompleteAsync(exception?: Exception): ValueTask;
    CopyToAsync(destination: PipeWriter, cancellationToken?: CancellationToken): Task;
    CopyToAsync(destination: Stream, cancellationToken?: CancellationToken): Task;
    OnWriterCompleted(callback: Action_2<Exception | undefined, unknown | undefined>, state: unknown): void;
    ReadAsync(cancellationToken?: CancellationToken): ValueTask_1<ReadResult>;
    ReadAtLeastAsync(minimumSize: int, cancellationToken?: CancellationToken): ValueTask_1<ReadResult>;
    TryRead(result: ReadResult): boolean;
}


export const PipeReader: {
    Create(sequence: ReadOnlySequence_1<System_Internal.Byte>): PipeReader;
    Create(stream: Stream, readerOptions?: StreamPipeReaderOptions | undefined): PipeReader;
};


export type PipeReader = PipeReader$instance;

export interface PipeScheduler$instance {
    Schedule(action: Action_1<unknown | undefined>, state: unknown): void;
}


export const PipeScheduler: {
    readonly ThreadPool: PipeScheduler;
    readonly Inline: PipeScheduler;
};


export type PipeScheduler = PipeScheduler$instance;

export interface PipeWriter$instance {
    readonly CanGetUnflushedBytes: boolean;
    readonly UnflushedBytes: long;
    Advance(bytes: int): void;
    AsStream(leaveOpen?: boolean): Stream;
    CancelPendingFlush(): void;
    Complete(exception?: Exception): void;
    CompleteAsync(exception?: Exception): ValueTask;
    FlushAsync(cancellationToken?: CancellationToken): ValueTask_1<FlushResult>;
    GetMemory(sizeHint?: int): Memory_1<System_Internal.Byte>;
    GetSpan(sizeHint?: int): Span_1<System_Internal.Byte>;
    OnReaderCompleted(callback: Action_2<Exception | undefined, unknown | undefined>, state: unknown): void;
    WriteAsync(source: ReadOnlyMemory_1<System_Internal.Byte>, cancellationToken?: CancellationToken): ValueTask_1<FlushResult>;
}


export const PipeWriter: {
    Create(stream: Stream, writerOptions?: StreamPipeWriterOptions | undefined): PipeWriter;
};


export interface __PipeWriter$views {
    As_IBufferWriter_1(): System_Buffers_Internal.IBufferWriter_1$instance<System_Internal.Byte>;
}

export interface PipeWriter$instance extends System_Buffers_Internal.IBufferWriter_1$instance<System_Internal.Byte> {}

export type PipeWriter = PipeWriter$instance & __PipeWriter$views;


export interface StreamPipeReaderOptions$instance {
    readonly BufferSize: int;
    readonly LeaveOpen: boolean;
    readonly MinimumReadSize: int;
    readonly Pool: MemoryPool_1<System_Internal.Byte>;
    readonly UseZeroByteReads: boolean;
}


export const StreamPipeReaderOptions: {
    new(pool: MemoryPool_1<System_Internal.Byte>, bufferSize: int, minimumReadSize: int, leaveOpen: boolean): StreamPipeReaderOptions;
    new(pool: MemoryPool_1<System_Internal.Byte>, bufferSize: int, minimumReadSize: int, leaveOpen: boolean, useZeroByteReads: boolean): StreamPipeReaderOptions;
};


export type StreamPipeReaderOptions = StreamPipeReaderOptions$instance;

export interface StreamPipeWriterOptions$instance {
    readonly LeaveOpen: boolean;
    readonly MinimumBufferSize: int;
    readonly Pool: MemoryPool_1<System_Internal.Byte>;
}


export const StreamPipeWriterOptions: {
    new(pool: MemoryPool_1<System_Internal.Byte>, minimumBufferSize: int, leaveOpen: boolean): StreamPipeWriterOptions;
};


export type StreamPipeWriterOptions = StreamPipeWriterOptions$instance;

export abstract class StreamPipeExtensions$instance {
    static CopyToAsync(source: Stream, destination: PipeWriter, cancellationToken?: CancellationToken): Task;
}


export type StreamPipeExtensions = StreamPipeExtensions$instance;


// Generated by tsbindgen - Architecture
// Namespace: System.IO.Pipelines
// Assembly: System.IO.Pipelines

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Buffers_Internal from "../../System.Buffers/internal/index.js";
import type { IBufferWriter_1, MemoryPool_1, ReadOnlySequence_1 } from "../../System.Buffers/internal/index.js";
import type { Stream } from "../../System.IO/internal/index.js";
import type { Task, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Action_2, Boolean as ClrBoolean, Byte, Exception, Int32, Int64, Memory_1, Object as ClrObject, ReadOnlyMemory_1, SequencePosition, Span_1, String as ClrString, Type, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export interface IDuplexPipe$instance {
    readonly Input: PipeReader;
    readonly Output: PipeWriter;
}


export type IDuplexPipe = IDuplexPipe$instance;

export interface FlushResult$instance {
    readonly IsCanceled: boolean;
    readonly IsCompleted: boolean;
}


export const FlushResult: {
    new(isCanceled: boolean, isCompleted: boolean): FlushResult$instance;
};


export type FlushResult = FlushResult$instance;

export interface ReadResult$instance {
    readonly Buffer: ReadOnlySequence_1<CLROf<byte>>;
    readonly IsCanceled: boolean;
    readonly IsCompleted: boolean;
}


export const ReadResult: {
    new(buffer: ReadOnlySequence_1<CLROf<byte>>, isCanceled: boolean, isCompleted: boolean): ReadResult$instance;
};


export type ReadResult = ReadResult$instance;

export interface Pipe$instance {
    readonly Reader: PipeReader;
    readonly Writer: PipeWriter;
    Reset(): void;
}


export const Pipe: {
    new(): Pipe$instance;
    new(options: PipeOptions): Pipe$instance;
};


export type Pipe = Pipe$instance;

export interface PipeOptions$instance {
    readonly MinimumSegmentSize: int;
    readonly PauseWriterThreshold: long;
    readonly Pool: MemoryPool_1<CLROf<byte>>;
    readonly ReaderScheduler: PipeScheduler;
    readonly ResumeWriterThreshold: long;
    readonly UseSynchronizationContext: boolean;
    readonly WriterScheduler: PipeScheduler;
}


export const PipeOptions: {
    new(pool: MemoryPool_1<CLROf<byte>>, readerScheduler: PipeScheduler, writerScheduler: PipeScheduler, pauseWriterThreshold: long, resumeWriterThreshold: long, minimumSegmentSize: int, useSynchronizationContext: boolean): PipeOptions$instance;
    readonly Default: PipeOptions;
};


export type PipeOptions = PipeOptions$instance;

export interface PipeReader$instance {
    AdvanceTo(consumed: SequencePosition): void;
    AdvanceTo(consumed: SequencePosition, examined: SequencePosition): void;
    AsStream(leaveOpen?: boolean): Stream;
    CancelPendingRead(): void;
    Complete(exception?: Exception): void;
    CompleteAsync(exception?: Exception): ValueTask;
    CopyToAsync(destination: PipeWriter, cancellationToken?: CancellationToken): Task;
    CopyToAsync(destination: Stream, cancellationToken?: CancellationToken): Task;
    OnWriterCompleted(callback: Action_2<Exception, unknown>, state: unknown): void;
    ReadAsync(cancellationToken?: CancellationToken): ValueTask_1<ReadResult>;
    ReadAtLeastAsync(minimumSize: int, cancellationToken?: CancellationToken): ValueTask_1<ReadResult>;
    TryRead(result: { value: ref<ReadResult> }): boolean;
}


export const PipeReader: {
    Create(sequence: ReadOnlySequence_1<CLROf<byte>>): PipeReader;
    Create(stream: Stream, readerOptions?: StreamPipeReaderOptions): PipeReader;
};


export type PipeReader = PipeReader$instance;

export interface PipeScheduler$instance {
    Schedule(action: Action_1<unknown>, state: unknown): void;
}


export const PipeScheduler: {
    readonly ThreadPool: PipeScheduler;
    readonly Inline: PipeScheduler;
};


export type PipeScheduler = PipeScheduler$instance;

export interface PipeWriter$instance {
    readonly CanGetUnflushedBytes: boolean;
    readonly UnflushedBytes: long;
    Advance(bytes: int): void;
    AsStream(leaveOpen?: boolean): Stream;
    CancelPendingFlush(): void;
    Complete(exception?: Exception): void;
    CompleteAsync(exception?: Exception): ValueTask;
    FlushAsync(cancellationToken?: CancellationToken): ValueTask_1<FlushResult>;
    GetMemory(sizeHint?: int): Memory_1<CLROf<byte>>;
    GetSpan(sizeHint?: int): Span_1<CLROf<byte>>;
    OnReaderCompleted(callback: Action_2<Exception, unknown>, state: unknown): void;
    WriteAsync(source: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<FlushResult>;
}


export const PipeWriter: {
    Create(stream: Stream, writerOptions?: StreamPipeWriterOptions): PipeWriter;
};


export interface __PipeWriter$views {
    As_IBufferWriter_1(): System_Buffers_Internal.IBufferWriter_1$instance<CLROf<byte>>;
}

export interface PipeWriter$instance extends System_Buffers_Internal.IBufferWriter_1$instance<CLROf<byte>> {}

export type PipeWriter = PipeWriter$instance & __PipeWriter$views;


export interface StreamPipeReaderOptions$instance {
    readonly BufferSize: int;
    readonly LeaveOpen: boolean;
    readonly MinimumReadSize: int;
    readonly Pool: MemoryPool_1<CLROf<byte>>;
    readonly UseZeroByteReads: boolean;
}


export const StreamPipeReaderOptions: {
    new(pool: MemoryPool_1<CLROf<byte>>, bufferSize: int, minimumReadSize: int, leaveOpen: boolean): StreamPipeReaderOptions$instance;
    new(pool: MemoryPool_1<CLROf<byte>>, bufferSize: int, minimumReadSize: int, leaveOpen: boolean, useZeroByteReads: boolean): StreamPipeReaderOptions$instance;
};


export type StreamPipeReaderOptions = StreamPipeReaderOptions$instance;

export interface StreamPipeWriterOptions$instance {
    readonly LeaveOpen: boolean;
    readonly MinimumBufferSize: int;
    readonly Pool: MemoryPool_1<CLROf<byte>>;
}


export const StreamPipeWriterOptions: {
    new(pool: MemoryPool_1<CLROf<byte>>, minimumBufferSize: int, leaveOpen: boolean): StreamPipeWriterOptions$instance;
};


export type StreamPipeWriterOptions = StreamPipeWriterOptions$instance;

export abstract class StreamPipeExtensions$instance {
    static CopyToAsync(source: Stream, destination: PipeWriter, cancellationToken?: CancellationToken): Task;
}


export type StreamPipeExtensions = StreamPipeExtensions$instance;


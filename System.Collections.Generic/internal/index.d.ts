// Generated by tsbindgen - Architecture
// Namespace: System.Collections.Generic
// Assembly: System.Collections, System.Private.CoreLib

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { ReadOnlyCollection_1, ReadOnlyDictionary_2, ReadOnlySet_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { DictionaryEntry, ICollection, IComparer, IDictionary, IDictionaryEnumerator, IEnumerable, IEnumerator, IEqualityComparer, IList } from "../../System.Collections/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Array as ClrArray, Boolean as ClrBoolean, Byte, Comparison_1, Converter_2, Enum, Exception, Func_2, Func_3, IAsyncDisposable, IComparable_1, IDisposable, IEquatable_1, Int32, Nullable_1, Object as ClrObject, Predicate_1, ReadOnlySpan_1, Span_1, String as ClrString, SystemException, Type, ValueTuple_2, ValueType, Void } from "../../System/internal/index.js";

export interface IAlternateEqualityComparer_2$instance<TAlternate, T> {
    Create(alternate: TAlternate): T;
    Equals(alternate: TAlternate, other: T): boolean;
    GetHashCode(alternate: TAlternate): int;
}


export type IAlternateEqualityComparer_2<TAlternate, T> = IAlternateEqualityComparer_2$instance<TAlternate, T>;

export interface IAsyncEnumerable_1$instance<T> {
    GetAsyncEnumerator(cancellationToken?: CancellationToken): IAsyncEnumerator_1<T>;
}


export type IAsyncEnumerable_1<T> = IAsyncEnumerable_1$instance<T>;

export interface IAsyncEnumerator_1$instance<T> extends IAsyncDisposable {
    readonly Current: T;
    DisposeAsync(): ValueTask;
    MoveNextAsync(): ValueTask_1<System_Internal.Boolean>;
}


export interface IAsyncEnumerator_1$instance<T> extends System_Internal.IAsyncDisposable$instance {}

export type IAsyncEnumerator_1<T> = IAsyncEnumerator_1$instance<T>;

export interface ICollection_1$instance<T> extends IEnumerable_1<T>, IEnumerable {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    Add(item: T): void;
    Clear(): void;
    Contains(item: T): boolean;
    CopyTo(array: T[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
    GetEnumerator2(): IEnumerator;
}


export type ICollection_1<T> = ICollection_1$instance<T>;

export interface IComparer_1$instance<T> {
    Compare(x: T | undefined, y: T | undefined): int;
}


export type IComparer_1<T> = IComparer_1$instance<T>;

export interface IDictionary_2$instance<TKey, TValue> extends ICollection_1<KeyValuePair_2<TKey, TValue>>, IEnumerable_1<KeyValuePair_2<TKey, TValue>>, IEnumerable {
    Item: TValue;
    readonly Keys: ICollection_1<TKey>;
    readonly Values: ICollection_1<TValue>;
    readonly Count: int;
    readonly IsReadOnly: boolean;
    Add(item: KeyValuePair_2<TKey, TValue>): void;
    Add(key: TKey, value: TValue): void;
    Clear(): void;
    Contains(item: KeyValuePair_2<TKey, TValue>): boolean;
    ContainsKey(key: TKey): boolean;
    CopyTo(array: KeyValuePair_2<TKey, TValue>[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator_1<KeyValuePair_2<TKey, TValue>>;
    GetEnumerator(): IEnumerator;
    TryGetValue(key: TKey, value: TValue): boolean;
    GetEnumerator2(): IEnumerator;
}


export type IDictionary_2<TKey, TValue> = IDictionary_2$instance<TKey, TValue>;

export interface IEnumerable_1$instance<T> extends IEnumerable {
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
}


export type IEnumerable_1<T> = IEnumerable_1$instance<T>;

export interface IEnumerator_1$instance<T> extends IDisposable, IEnumerator {
    readonly Current: T;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export interface IEnumerator_1$instance<T> extends System_Internal.IDisposable$instance {}

export type IEnumerator_1<T> = IEnumerator_1$instance<T>;

export interface IEqualityComparer_1$instance<T> {
    Equals(x: T | undefined, y: T | undefined): boolean;
    GetHashCode(obj: T): int;
}


export type IEqualityComparer_1<T> = IEqualityComparer_1$instance<T>;

export interface IList_1$instance<T> extends ICollection_1<T>, IEnumerable_1<T>, IEnumerable {
    Item: T;
    readonly Count: int;
    readonly IsReadOnly: boolean;
    Add(item: T): void;
    Clear(): void;
    Contains(item: T): boolean;
    CopyTo(array: T[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
    IndexOf(item: T): int;
    Insert(index: int, item: T): void;
    RemoveAt(index: int): void;
    GetEnumerator2(): IEnumerator;
}


export type IList_1<T> = IList_1$instance<T>;

export interface IReadOnlyCollection_1$instance<T> extends IEnumerable_1<T>, IEnumerable {
    readonly Count: int;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
    GetEnumerator2(): IEnumerator;
}


export type IReadOnlyCollection_1<T> = IReadOnlyCollection_1$instance<T>;

export interface IReadOnlyDictionary_2$instance<TKey, TValue> extends IReadOnlyCollection_1<KeyValuePair_2<TKey, TValue>>, IEnumerable_1<KeyValuePair_2<TKey, TValue>>, IEnumerable {
    readonly Item: TValue;
    readonly Keys: IEnumerable_1<TKey>;
    readonly Values: IEnumerable_1<TValue>;
    readonly Count: int;
    ContainsKey(key: TKey): boolean;
    GetEnumerator(): IEnumerator_1<KeyValuePair_2<TKey, TValue>>;
    GetEnumerator(): IEnumerator;
    TryGetValue(key: TKey, value: TValue): boolean;
    GetEnumerator2(): IEnumerator;
}


export type IReadOnlyDictionary_2<TKey, TValue> = IReadOnlyDictionary_2$instance<TKey, TValue>;

export interface IReadOnlyList_1$instance<T> extends IReadOnlyCollection_1<T>, IEnumerable_1<T>, IEnumerable {
    readonly Item: T;
    readonly Count: int;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
    GetEnumerator2(): IEnumerator;
}


export type IReadOnlyList_1<T> = IReadOnlyList_1$instance<T>;

export interface IReadOnlySet_1$instance<T> extends IReadOnlyCollection_1<T>, IEnumerable_1<T>, IEnumerable {
    readonly Count: int;
    Contains(item: T): boolean;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
    IsProperSubsetOf(other: IEnumerable_1<T>): boolean;
    GetEnumerator2(): IEnumerator;
}


export type IReadOnlySet_1<T> = IReadOnlySet_1$instance<T>;

export interface ISet_1$instance<T> extends ICollection_1<T>, IEnumerable_1<T>, IEnumerable {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    Add(item: T): void;
    Add(item: T): boolean;
    Clear(): void;
    Contains(item: T): boolean;
    CopyTo(array: T[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
    IsSubsetOf(other: IEnumerable_1<T>): boolean;
    UnionWith(other: IEnumerable_1<T>): void;
    GetEnumerator2(): IEnumerator;
}


export type ISet_1<T> = ISet_1$instance<T>;

export interface Dictionary_2_AlternateLookup_1$instance<TKey, TValue, TAlternateKey> {
    readonly Dictionary: Dictionary_2<TKey, TValue>;
    Item: TValue;
    ContainsKey(key: TAlternateKey): boolean;
    Remove(key: TAlternateKey): boolean;
    Remove(key: TAlternateKey, actualKey: TKey, value: TValue): boolean;
    TryAdd(key: TAlternateKey, value: TValue): boolean;
    TryGetValue(key: TAlternateKey, value: TValue): boolean;
    TryGetValue(key: TAlternateKey, actualKey: TKey, value: TValue): boolean;
}


export const Dictionary_2_AlternateLookup_1: {
    new<TKey, TValue, TAlternateKey>(): Dictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>;
};


export type Dictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey> = Dictionary_2_AlternateLookup_1$instance<TKey, TValue, TAlternateKey>;

export interface Dictionary_2_Enumerator$instance<TKey, TValue> extends IDisposable {
    readonly Current: KeyValuePair_2<TKey, TValue>;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export const Dictionary_2_Enumerator: {
    new<TKey, TValue>(): Dictionary_2_Enumerator<TKey, TValue>;
};


export interface __Dictionary_2_Enumerator$views<TKey, TValue> {
    As_IEnumerator_1(): IEnumerator_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionaryEnumerator(): System_Collections_Internal.IDictionaryEnumerator$instance;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type Dictionary_2_Enumerator<TKey, TValue> = Dictionary_2_Enumerator$instance<TKey, TValue> & __Dictionary_2_Enumerator$views<TKey, TValue>;


export interface Dictionary_2_KeyCollection_Enumerator$instance<TKey, TValue> extends IDisposable {
    readonly Current: TKey;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export const Dictionary_2_KeyCollection_Enumerator: {
    new<TKey, TValue>(): Dictionary_2_KeyCollection_Enumerator<TKey, TValue>;
};


export interface __Dictionary_2_KeyCollection_Enumerator$views<TKey, TValue> {
    As_IEnumerator_1(): IEnumerator_1$instance<TKey>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type Dictionary_2_KeyCollection_Enumerator<TKey, TValue> = Dictionary_2_KeyCollection_Enumerator$instance<TKey, TValue> & __Dictionary_2_KeyCollection_Enumerator$views<TKey, TValue>;


export interface Dictionary_2_ValueCollection_Enumerator$instance<TKey, TValue> extends IDisposable {
    readonly Current: TValue;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export const Dictionary_2_ValueCollection_Enumerator: {
    new<TKey, TValue>(): Dictionary_2_ValueCollection_Enumerator<TKey, TValue>;
};


export interface __Dictionary_2_ValueCollection_Enumerator$views<TKey, TValue> {
    As_IEnumerator_1(): IEnumerator_1$instance<TValue>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type Dictionary_2_ValueCollection_Enumerator<TKey, TValue> = Dictionary_2_ValueCollection_Enumerator$instance<TKey, TValue> & __Dictionary_2_ValueCollection_Enumerator$views<TKey, TValue>;


export interface HashSet_1_AlternateLookup_1$instance<T, TAlternate> {
    readonly Set: HashSet_1<T>;
    Add(item: TAlternate): boolean;
    Contains(item: TAlternate): boolean;
    Remove(item: TAlternate): boolean;
    TryGetValue(equalValue: TAlternate, actualValue: T): boolean;
}


export const HashSet_1_AlternateLookup_1: {
    new<T, TAlternate>(): HashSet_1_AlternateLookup_1<T, TAlternate>;
};


export type HashSet_1_AlternateLookup_1<T, TAlternate> = HashSet_1_AlternateLookup_1$instance<T, TAlternate>;

export interface HashSet_1_Enumerator$instance<T> extends IDisposable {
    readonly Current: T;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export const HashSet_1_Enumerator: {
    new<T>(): HashSet_1_Enumerator<T>;
};


export interface __HashSet_1_Enumerator$views<T> {
    As_IEnumerator_1(): IEnumerator_1$instance<T>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type HashSet_1_Enumerator<T> = HashSet_1_Enumerator$instance<T> & __HashSet_1_Enumerator$views<T>;


export interface KeyValuePair_2$instance<TKey, TValue> {
    readonly Key: TKey;
    readonly Value: TValue;
    Deconstruct(key: TKey, value: TValue): void;
    ToString(): string;
}


export const KeyValuePair_2: {
    new<TKey, TValue>(key: TKey, value: TValue): KeyValuePair_2<TKey, TValue>;
};


export type KeyValuePair_2<TKey, TValue> = KeyValuePair_2$instance<TKey, TValue>;

export interface LinkedList_1_Enumerator$instance<T> extends IDisposable {
    readonly Current: T;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export const LinkedList_1_Enumerator: {
    new<T>(): LinkedList_1_Enumerator<T>;
};


export interface __LinkedList_1_Enumerator$views<T> {
    As_IEnumerator_1(): IEnumerator_1$instance<T>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface LinkedList_1_Enumerator$instance<T> extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type LinkedList_1_Enumerator<T> = LinkedList_1_Enumerator$instance<T> & __LinkedList_1_Enumerator$views<T>;


export interface List_1_Enumerator$instance<T> extends IDisposable {
    readonly Current: T;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export const List_1_Enumerator: {
    new<T>(): List_1_Enumerator<T>;
};


export interface __List_1_Enumerator$views<T> {
    As_IEnumerator_1(): IEnumerator_1$instance<T>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type List_1_Enumerator<T> = List_1_Enumerator$instance<T> & __List_1_Enumerator$views<T>;


export interface OrderedDictionary_2_Enumerator$instance<TKey, TValue> {
    readonly Current: KeyValuePair_2<TKey, TValue>;
    MoveNext(): boolean;
    Reset(): void;
}


export const OrderedDictionary_2_Enumerator: {
    new<TKey, TValue>(): OrderedDictionary_2_Enumerator<TKey, TValue>;
};


export interface __OrderedDictionary_2_Enumerator$views<TKey, TValue> {
    As_IEnumerator_1(): IEnumerator_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionaryEnumerator(): System_Collections_Internal.IDictionaryEnumerator$instance;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type OrderedDictionary_2_Enumerator<TKey, TValue> = OrderedDictionary_2_Enumerator$instance<TKey, TValue> & __OrderedDictionary_2_Enumerator$views<TKey, TValue>;


export interface OrderedDictionary_2_KeyCollection_Enumerator$instance<TKey, TValue> {
    readonly Current: TKey;
    MoveNext(): boolean;
    Reset(): void;
}


export const OrderedDictionary_2_KeyCollection_Enumerator: {
    new<TKey, TValue>(): OrderedDictionary_2_KeyCollection_Enumerator<TKey, TValue>;
};


export interface __OrderedDictionary_2_KeyCollection_Enumerator$views<TKey, TValue> {
    As_IEnumerator_1(): IEnumerator_1$instance<TKey>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type OrderedDictionary_2_KeyCollection_Enumerator<TKey, TValue> = OrderedDictionary_2_KeyCollection_Enumerator$instance<TKey, TValue> & __OrderedDictionary_2_KeyCollection_Enumerator$views<TKey, TValue>;


export interface OrderedDictionary_2_ValueCollection_Enumerator$instance<TKey, TValue> {
    readonly Current: TValue;
    MoveNext(): boolean;
    Reset(): void;
}


export const OrderedDictionary_2_ValueCollection_Enumerator: {
    new<TKey, TValue>(): OrderedDictionary_2_ValueCollection_Enumerator<TKey, TValue>;
};


export interface __OrderedDictionary_2_ValueCollection_Enumerator$views<TKey, TValue> {
    As_IEnumerator_1(): IEnumerator_1$instance<TValue>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type OrderedDictionary_2_ValueCollection_Enumerator<TKey, TValue> = OrderedDictionary_2_ValueCollection_Enumerator$instance<TKey, TValue> & __OrderedDictionary_2_ValueCollection_Enumerator$views<TKey, TValue>;


export interface PriorityQueue_2_UnorderedItemsCollection_Enumerator$instance<TElement, TPriority> extends IDisposable {
    readonly Current: ValueTuple_2<TElement, TPriority>;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export const PriorityQueue_2_UnorderedItemsCollection_Enumerator: {
    new<TElement, TPriority>(): PriorityQueue_2_UnorderedItemsCollection_Enumerator<TElement, TPriority>;
};


export interface __PriorityQueue_2_UnorderedItemsCollection_Enumerator$views<TElement, TPriority> {
    As_IEnumerator_1(): IEnumerator_1$instance<ValueTuple_2<TElement, TPriority>>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type PriorityQueue_2_UnorderedItemsCollection_Enumerator<TElement, TPriority> = PriorityQueue_2_UnorderedItemsCollection_Enumerator$instance<TElement, TPriority> & __PriorityQueue_2_UnorderedItemsCollection_Enumerator$views<TElement, TPriority>;


export interface Queue_1_Enumerator$instance<T> extends IDisposable {
    readonly Current: T;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export const Queue_1_Enumerator: {
    new<T>(): Queue_1_Enumerator<T>;
};


export interface __Queue_1_Enumerator$views<T> {
    As_IEnumerator_1(): IEnumerator_1$instance<T>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type Queue_1_Enumerator<T> = Queue_1_Enumerator$instance<T> & __Queue_1_Enumerator$views<T>;


export interface SortedDictionary_2_Enumerator$instance<TKey, TValue> extends IDisposable {
    readonly Current: KeyValuePair_2<TKey, TValue>;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export const SortedDictionary_2_Enumerator: {
    new<TKey, TValue>(): SortedDictionary_2_Enumerator<TKey, TValue>;
};


export interface __SortedDictionary_2_Enumerator$views<TKey, TValue> {
    As_IEnumerator_1(): IEnumerator_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionaryEnumerator(): System_Collections_Internal.IDictionaryEnumerator$instance;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type SortedDictionary_2_Enumerator<TKey, TValue> = SortedDictionary_2_Enumerator$instance<TKey, TValue> & __SortedDictionary_2_Enumerator$views<TKey, TValue>;


export interface SortedDictionary_2_KeyCollection_Enumerator$instance<TKey, TValue> extends IDisposable {
    readonly Current: TKey;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export const SortedDictionary_2_KeyCollection_Enumerator: {
    new<TKey, TValue>(): SortedDictionary_2_KeyCollection_Enumerator<TKey, TValue>;
};


export interface __SortedDictionary_2_KeyCollection_Enumerator$views<TKey, TValue> {
    As_IEnumerator_1(): IEnumerator_1$instance<TKey>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type SortedDictionary_2_KeyCollection_Enumerator<TKey, TValue> = SortedDictionary_2_KeyCollection_Enumerator$instance<TKey, TValue> & __SortedDictionary_2_KeyCollection_Enumerator$views<TKey, TValue>;


export interface SortedDictionary_2_ValueCollection_Enumerator$instance<TKey, TValue> extends IDisposable {
    readonly Current: TValue;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export const SortedDictionary_2_ValueCollection_Enumerator: {
    new<TKey, TValue>(): SortedDictionary_2_ValueCollection_Enumerator<TKey, TValue>;
};


export interface __SortedDictionary_2_ValueCollection_Enumerator$views<TKey, TValue> {
    As_IEnumerator_1(): IEnumerator_1$instance<TValue>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type SortedDictionary_2_ValueCollection_Enumerator<TKey, TValue> = SortedDictionary_2_ValueCollection_Enumerator$instance<TKey, TValue> & __SortedDictionary_2_ValueCollection_Enumerator$views<TKey, TValue>;


export interface SortedSet_1_Enumerator$instance<T> extends IDisposable {
    readonly Current: T;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export const SortedSet_1_Enumerator: {
    new<T>(): SortedSet_1_Enumerator<T>;
};


export interface __SortedSet_1_Enumerator$views<T> {
    As_IEnumerator_1(): IEnumerator_1$instance<T>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface SortedSet_1_Enumerator$instance<T> extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type SortedSet_1_Enumerator<T> = SortedSet_1_Enumerator$instance<T> & __SortedSet_1_Enumerator$views<T>;


export interface Stack_1_Enumerator$instance<T> extends IDisposable {
    readonly Current: T;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export const Stack_1_Enumerator: {
    new<T>(): Stack_1_Enumerator<T>;
};


export interface __Stack_1_Enumerator$views<T> {
    As_IEnumerator_1(): IEnumerator_1$instance<T>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type Stack_1_Enumerator<T> = Stack_1_Enumerator$instance<T> & __Stack_1_Enumerator$views<T>;


export interface ByteEqualityComparer$instance extends EqualityComparer_1$instance<System_Internal.Byte> {
    Equals(x: unknown | undefined, y: unknown | undefined): boolean;
    GetHashCode(obj: unknown): int;
}


export const ByteEqualityComparer: {
    new(): ByteEqualityComparer;
};


export interface __ByteEqualityComparer$views {
    As_IEqualityComparer_1(): IEqualityComparer_1$instance<System_Internal.Byte>;
    As_IEqualityComparer(): System_Collections_Internal.IEqualityComparer$instance;
}

export type ByteEqualityComparer = ByteEqualityComparer$instance & __ByteEqualityComparer$views;


export interface Comparer_1$instance<T> {
    Compare(x: T | undefined, y: T | undefined): int;
}


export const Comparer_1: {
    readonly Default: unknown;
    Create<T>(comparison: Comparison_1<T>): Comparer_1<T>;
};


export interface __Comparer_1$views<T> {
    As_IComparer_1(): IComparer_1$instance<T>;
    As_IComparer(): System_Collections_Internal.IComparer$instance;
}

export type Comparer_1<T> = Comparer_1$instance<T> & __Comparer_1$views<T>;


export interface Dictionary_2$instance<TKey, TValue> {
    readonly Capacity: int;
    readonly Comparer: IEqualityComparer_1<TKey>;
    readonly Count: int;
    Item: TValue;
    readonly Keys: Dictionary_2_KeyCollection<TKey, TValue>;
    readonly Values: Dictionary_2_ValueCollection<TKey, TValue>;
    Add(key: TKey, value: TValue): void;
    Clear(): void;
    ContainsKey(key: TKey): boolean;
    ContainsValue(value: TValue): boolean;
    EnsureCapacity(capacity: int): int;
    GetAlternateLookup<TAlternateKey>(): Dictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>;
    GetEnumerator(): Dictionary_2_Enumerator<TKey, TValue>;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    OnDeserialization(sender: unknown | undefined): void;
    Remove(key: TKey): boolean;
    Remove(key: TKey, value: TValue): boolean;
    TrimExcess(): void;
    TrimExcess(capacity: int): void;
    TryAdd(key: TKey, value: TValue): boolean;
    TryGetAlternateLookup<TAlternateKey>(lookup: Dictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>): boolean;
    TryGetValue(key: TKey, value: TValue): boolean;
}


export const Dictionary_2: {
    new<TKey, TValue>(): Dictionary_2<TKey, TValue>;
    new<TKey, TValue>(capacity: int): Dictionary_2<TKey, TValue>;
    new<TKey, TValue>(comparer: IEqualityComparer_1<TKey> | undefined): Dictionary_2<TKey, TValue>;
    new<TKey, TValue>(capacity: int, comparer: IEqualityComparer_1<TKey> | undefined): Dictionary_2<TKey, TValue>;
    new<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>): Dictionary_2<TKey, TValue>;
    new<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>, comparer: IEqualityComparer_1<TKey> | undefined): Dictionary_2<TKey, TValue>;
    new<TKey, TValue>(collection: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): Dictionary_2<TKey, TValue>;
    new<TKey, TValue>(collection: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, comparer: IEqualityComparer_1<TKey> | undefined): Dictionary_2<TKey, TValue>;
};


export interface __Dictionary_2$views<TKey, TValue> {
    As_ICollection_1(): ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionary_2(): IDictionary_2$instance<TKey, TValue>;
    As_IEnumerable_1(): IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyDictionary_2(): IReadOnlyDictionary_2$instance<TKey, TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Dictionary_2$instance<TKey, TValue> extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Dictionary_2<TKey, TValue> = Dictionary_2$instance<TKey, TValue> & __Dictionary_2$views<TKey, TValue>;


export interface Dictionary_2_KeyCollection$instance<TKey, TValue> {
    readonly Count: int;
    Contains(item: TKey): boolean;
    CopyTo(array: TKey[], index: int): void;
    GetEnumerator(): Dictionary_2_KeyCollection_Enumerator<TKey, TValue>;
}


export const Dictionary_2_KeyCollection: {
    new<TKey, TValue>(dictionary: Dictionary_2<TKey, TValue>): Dictionary_2_KeyCollection<TKey, TValue>;
};


export interface __Dictionary_2_KeyCollection$views<TKey, TValue> {
    As_ICollection_1(): ICollection_1$instance<TKey>;
    As_IEnumerable_1(): IEnumerable_1$instance<TKey>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<TKey>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type Dictionary_2_KeyCollection<TKey, TValue> = Dictionary_2_KeyCollection$instance<TKey, TValue> & __Dictionary_2_KeyCollection$views<TKey, TValue>;


export interface Dictionary_2_ValueCollection$instance<TKey, TValue> {
    readonly Count: int;
    CopyTo(array: TValue[], index: int): void;
    GetEnumerator(): Dictionary_2_ValueCollection_Enumerator<TKey, TValue>;
}


export const Dictionary_2_ValueCollection: {
    new<TKey, TValue>(dictionary: Dictionary_2<TKey, TValue>): Dictionary_2_ValueCollection<TKey, TValue>;
};


export interface __Dictionary_2_ValueCollection$views<TKey, TValue> {
    As_ICollection_1(): ICollection_1$instance<TValue>;
    As_IEnumerable_1(): IEnumerable_1$instance<TValue>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type Dictionary_2_ValueCollection<TKey, TValue> = Dictionary_2_ValueCollection$instance<TKey, TValue> & __Dictionary_2_ValueCollection$views<TKey, TValue>;


export interface EnumEqualityComparer_1$instance<T extends number> extends EqualityComparer_1$instance<T> {
    Equals(x: T, y: T): boolean;
    Equals(x: unknown | undefined, y: unknown | undefined): boolean;
    GetHashCode(obj: T): int;
    GetHashCode(obj: unknown): int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const EnumEqualityComparer_1: {
    new<T extends number>(): EnumEqualityComparer_1<T>;
};


export interface __EnumEqualityComparer_1$views<T extends number & unknown> {
    As_IEqualityComparer_1(): IEqualityComparer_1$instance<T>;
    As_IEqualityComparer(): System_Collections_Internal.IEqualityComparer$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface EnumEqualityComparer_1$instance<T extends number & unknown> extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type EnumEqualityComparer_1<T extends number> = EnumEqualityComparer_1$instance<T> & __EnumEqualityComparer_1$views<T>;


export interface EqualityComparer_1$instance<T> {
    Equals(x: T | undefined, y: T | undefined): boolean;
    GetHashCode(obj: T): int;
}


export const EqualityComparer_1: {
    readonly Default: unknown;
    Create<T>(equals: Func_3<T | undefined, T | undefined, System_Internal.Boolean>, getHashCode?: Func_2<T, System_Internal.Int32> | undefined): EqualityComparer_1<T>;
};


export interface __EqualityComparer_1$views<T> {
    As_IEqualityComparer_1(): IEqualityComparer_1$instance<T>;
    As_IEqualityComparer(): System_Collections_Internal.IEqualityComparer$instance;
}

export type EqualityComparer_1<T> = EqualityComparer_1$instance<T> & __EqualityComparer_1$views<T>;


export interface GenericComparer_1$instance<T extends (IComparable_1<T> | number | string | boolean)> extends Comparer_1$instance<T> {
    Compare(x: T | undefined, y: T | undefined): int;
    Compare(x: unknown | undefined, y: unknown | undefined): int;
    Equals(obj: unknown | undefined): boolean;
    GetHashCode(): int;
}


export const GenericComparer_1: {
    new<T extends (IComparable_1<T> | number | string | boolean)>(): GenericComparer_1<T>;
};


export interface __GenericComparer_1$views<T extends (IComparable_1<T> | number | string | boolean)> {
    As_IComparer_1(): IComparer_1$instance<T>;
    As_IComparer(): System_Collections_Internal.IComparer$instance;
}

export type GenericComparer_1<T extends (IComparable_1<T> | number | string | boolean)> = GenericComparer_1$instance<T> & __GenericComparer_1$views<T>;


export interface GenericEqualityComparer_1$instance<T extends (IEquatable_1<T> | number | string | boolean)> extends EqualityComparer_1$instance<T> {
    Equals(x: T | undefined, y: T | undefined): boolean;
    Equals(x: unknown | undefined, y: unknown | undefined): boolean;
    GetHashCode(obj: T): int;
    GetHashCode(obj: unknown): int;
}


export const GenericEqualityComparer_1: {
    new<T extends (IEquatable_1<T> | number | string | boolean)>(): GenericEqualityComparer_1<T>;
};


export interface __GenericEqualityComparer_1$views<T extends (IEquatable_1<T> | number | string | boolean)> {
    As_IEqualityComparer_1(): IEqualityComparer_1$instance<T>;
    As_IEqualityComparer(): System_Collections_Internal.IEqualityComparer$instance;
}

export type GenericEqualityComparer_1<T extends (IEquatable_1<T> | number | string | boolean)> = GenericEqualityComparer_1$instance<T> & __GenericEqualityComparer_1$views<T>;


export interface HashSet_1$instance<T> {
    readonly Capacity: int;
    readonly Comparer: IEqualityComparer_1<T>;
    readonly Count: int;
    Add(item: T): boolean;
    Clear(): void;
    Contains(item: T): boolean;
    CopyTo(array: T[]): void;
    CopyTo(array: T[], arrayIndex: int): void;
    CopyTo(array: T[], arrayIndex: int, count: int): void;
    EnsureCapacity(capacity: int): int;
    ExceptWith(other: IEnumerable_1<T>): void;
    GetAlternateLookup<TAlternate>(): HashSet_1_AlternateLookup_1<T, TAlternate>;
    GetEnumerator(): HashSet_1_Enumerator<T>;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    IntersectWith(other: IEnumerable_1<T>): void;
    IsProperSubsetOf(other: IEnumerable_1<T>): boolean;
    IsProperSupersetOf(other: IEnumerable_1<T>): boolean;
    IsSubsetOf(other: IEnumerable_1<T>): boolean;
    IsSupersetOf(other: IEnumerable_1<T>): boolean;
    OnDeserialization(sender: unknown | undefined): void;
    Overlaps(other: IEnumerable_1<T>): boolean;
    Remove(item: T): boolean;
    RemoveWhere(match: Predicate_1<T>): int;
    SetEquals(other: IEnumerable_1<T>): boolean;
    SymmetricExceptWith(other: IEnumerable_1<T>): void;
    TrimExcess(): void;
    TrimExcess(capacity: int): void;
    TryGetAlternateLookup<TAlternate>(lookup: HashSet_1_AlternateLookup_1<T, TAlternate>): boolean;
    TryGetValue(equalValue: T, actualValue: T): boolean;
    UnionWith(other: IEnumerable_1<T>): void;
}


export const HashSet_1: {
    new<T>(): HashSet_1<T>;
    new<T>(comparer: IEqualityComparer_1<T> | undefined): HashSet_1<T>;
    new<T>(capacity: int): HashSet_1<T>;
    new<T>(collection: IEnumerable_1<T>): HashSet_1<T>;
    new<T>(collection: IEnumerable_1<T>, comparer: IEqualityComparer_1<T> | undefined): HashSet_1<T>;
    new<T>(capacity: int, comparer: IEqualityComparer_1<T> | undefined): HashSet_1<T>;
    CreateSetComparer<T>(): IEqualityComparer_1<HashSet_1<T>>;
};


export interface __HashSet_1$views<T> {
    As_ICollection_1(): ICollection_1$instance<T>;
    As_IEnumerable_1(): IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<T>;
    As_IReadOnlySet_1(): IReadOnlySet_1$instance<T>;
    As_ISet_1(): ISet_1$instance<T>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface HashSet_1$instance<T> extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type HashSet_1<T> = HashSet_1$instance<T> & __HashSet_1$views<T>;


export interface KeyNotFoundException$instance extends SystemException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const KeyNotFoundException: {
    new(): KeyNotFoundException;
    new(message: string | undefined): KeyNotFoundException;
    new(message: string | undefined, innerException: Exception | undefined): KeyNotFoundException;
};


export interface __KeyNotFoundException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type KeyNotFoundException = KeyNotFoundException$instance & __KeyNotFoundException$views;


export interface LinkedList_1$instance<T> {
    readonly Count: int;
    readonly First: LinkedListNode_1<T> | undefined;
    readonly Last: LinkedListNode_1<T> | undefined;
    AddAfter(node: LinkedListNode_1<T>, value: T): LinkedListNode_1<T>;
    AddAfter(node: LinkedListNode_1<T>, newNode: LinkedListNode_1<T>): void;
    AddBefore(node: LinkedListNode_1<T>, value: T): LinkedListNode_1<T>;
    AddBefore(node: LinkedListNode_1<T>, newNode: LinkedListNode_1<T>): void;
    AddFirst(value: T): LinkedListNode_1<T>;
    AddFirst(node: LinkedListNode_1<T>): void;
    AddLast(value: T): LinkedListNode_1<T>;
    AddLast(node: LinkedListNode_1<T>): void;
    Clear(): void;
    Contains(value: T): boolean;
    CopyTo(array: T[], index: int): void;
    Find(value: T): LinkedListNode_1<T> | undefined;
    FindLast(value: T): LinkedListNode_1<T> | undefined;
    GetEnumerator(): LinkedList_1_Enumerator<T>;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    OnDeserialization(sender: unknown | undefined): void;
    Remove(value: T): boolean;
    Remove(node: LinkedListNode_1<T>): void;
    RemoveFirst(): void;
    RemoveLast(): void;
}


export const LinkedList_1: {
    new<T>(): LinkedList_1<T>;
    new<T>(collection: IEnumerable_1<T>): LinkedList_1<T>;
};


export interface __LinkedList_1$views<T> {
    As_ICollection_1(): ICollection_1$instance<T>;
    As_IEnumerable_1(): IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface LinkedList_1$instance<T> extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type LinkedList_1<T> = LinkedList_1$instance<T> & __LinkedList_1$views<T>;


export interface LinkedListNode_1$instance<T> {
    readonly List: LinkedList_1<T> | undefined;
    readonly Next: LinkedListNode_1<T> | undefined;
    readonly Previous: LinkedListNode_1<T> | undefined;
    Value: T;
    readonly ValueRef: T;
}


export const LinkedListNode_1: {
    new<T>(value: T): LinkedListNode_1<T>;
};


export type LinkedListNode_1<T> = LinkedListNode_1$instance<T>;

export interface List_1$instance<T> {
    Capacity: int;
    readonly Count: int;
    Item: T;
    Add(item: T): void;
    AddRange(collection: IEnumerable_1<T>): void;
    AsReadOnly(): ReadOnlyCollection_1<T>;
    BinarySearch(index: int, count: int, item: T, comparer: IComparer_1<T> | undefined): int;
    BinarySearch(item: T): int;
    BinarySearch(item: T, comparer: IComparer_1<T> | undefined): int;
    Clear(): void;
    Contains(item: T): boolean;
    ConvertAll<TOutput>(converter: Converter_2<T, TOutput>): List_1<TOutput>;
    CopyTo(array: T[]): void;
    CopyTo(index: int, array: T[], arrayIndex: int, count: int): void;
    CopyTo(array: T[], arrayIndex: int): void;
    EnsureCapacity(capacity: int): int;
    Exists(match: Predicate_1<T>): boolean;
    Find(match: Predicate_1<T>): T | undefined;
    FindAll(match: Predicate_1<T>): List_1<T>;
    FindIndex(match: Predicate_1<T>): int;
    FindIndex(startIndex: int, match: Predicate_1<T>): int;
    FindIndex(startIndex: int, count: int, match: Predicate_1<T>): int;
    FindLast(match: Predicate_1<T>): T | undefined;
    FindLastIndex(match: Predicate_1<T>): int;
    FindLastIndex(startIndex: int, match: Predicate_1<T>): int;
    FindLastIndex(startIndex: int, count: int, match: Predicate_1<T>): int;
    ForEach(action: Action_1<T>): void;
    GetEnumerator(): List_1_Enumerator<T>;
    GetRange(index: int, count: int): List_1<T>;
    IndexOf(item: T): int;
    IndexOf(item: T, index: int): int;
    IndexOf(item: T, index: int, count: int): int;
    Insert(index: int, item: T): void;
    InsertRange(index: int, collection: IEnumerable_1<T>): void;
    LastIndexOf(item: T): int;
    LastIndexOf(item: T, index: int): int;
    LastIndexOf(item: T, index: int, count: int): int;
    Remove(item: T): boolean;
    RemoveAll(match: Predicate_1<T>): int;
    RemoveAt(index: int): void;
    RemoveRange(index: int, count: int): void;
    Reverse(): void;
    Reverse(index: int, count: int): void;
    Slice(start: int, length: int): List_1<T>;
    Sort(): void;
    Sort(comparer: IComparer_1<T> | undefined): void;
    Sort(index: int, count: int, comparer: IComparer_1<T> | undefined): void;
    Sort(comparison: Comparison_1<T>): void;
    ToArray(): T[];
    TrimExcess(): void;
    TrueForAll(match: Predicate_1<T>): boolean;
}


export const List_1: {
    new<T>(): List_1<T>;
    new<T>(capacity: int): List_1<T>;
    new<T>(collection: IEnumerable_1<T>): List_1<T>;
};


export interface __List_1$views<T> {
    As_ICollection_1(): ICollection_1$instance<T>;
    As_IEnumerable_1(): IEnumerable_1$instance<T>;
    As_IList_1(): IList_1$instance<T>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type List_1<T> = List_1$instance<T> & __List_1$views<T>;


export interface NonRandomizedStringEqualityComparer$instance {
    Equals(x: string | undefined, y: string | undefined): boolean;
    GetHashCode(obj: string | undefined): int;
    GetUnderlyingEqualityComparer(): IEqualityComparer_1<string | undefined>;
}


export const NonRandomizedStringEqualityComparer: {
    new(): NonRandomizedStringEqualityComparer;
    GetStringComparer(comparer: unknown): IEqualityComparer_1<System_Internal.String> | undefined;
};


export interface __NonRandomizedStringEqualityComparer$views {
    As_IEqualityComparer_1(): IEqualityComparer_1$instance<System_Internal.String>;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface NonRandomizedStringEqualityComparer$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type NonRandomizedStringEqualityComparer = NonRandomizedStringEqualityComparer$instance & __NonRandomizedStringEqualityComparer$views;


export interface NullableComparer_1$instance<T extends unknown> extends Comparer_1$instance<Nullable_1<T>> {
    Compare(x: unknown | undefined, y: unknown | undefined): int;
    Equals(obj: unknown | undefined): boolean;
    GetHashCode(): int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const NullableComparer_1: {
    new<T extends unknown>(): NullableComparer_1<T>;
};


export interface __NullableComparer_1$views<T extends unknown> {
    As_IComparer_1(): IComparer_1$instance<Nullable_1<T>>;
    As_IComparer(): System_Collections_Internal.IComparer$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface NullableComparer_1$instance<T extends unknown> extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type NullableComparer_1<T> = NullableComparer_1$instance<T> & __NullableComparer_1$views<T>;


export interface NullableEqualityComparer_1$instance<T extends unknown> extends EqualityComparer_1$instance<Nullable_1<T>> {
    Equals(x: unknown | undefined, y: unknown | undefined): boolean;
    GetHashCode(obj: unknown): int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const NullableEqualityComparer_1: {
    new<T extends unknown>(): NullableEqualityComparer_1<T>;
};


export interface __NullableEqualityComparer_1$views<T extends unknown> {
    As_IEqualityComparer_1(): IEqualityComparer_1$instance<Nullable_1<T>>;
    As_IEqualityComparer(): System_Collections_Internal.IEqualityComparer$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface NullableEqualityComparer_1$instance<T extends unknown> extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type NullableEqualityComparer_1<T> = NullableEqualityComparer_1$instance<T> & __NullableEqualityComparer_1$views<T>;


export interface ObjectComparer_1$instance<T> extends Comparer_1$instance<T> {
    Compare(x: T | undefined, y: T | undefined): int;
    Compare(x: unknown | undefined, y: unknown | undefined): int;
    Equals(obj: unknown | undefined): boolean;
    GetHashCode(): int;
}


export const ObjectComparer_1: {
    new<T>(): ObjectComparer_1<T>;
};


export interface __ObjectComparer_1$views<T> {
    As_IComparer_1(): IComparer_1$instance<T>;
    As_IComparer(): System_Collections_Internal.IComparer$instance;
}

export type ObjectComparer_1<T> = ObjectComparer_1$instance<T> & __ObjectComparer_1$views<T>;


export interface ObjectEqualityComparer_1$instance<T> extends EqualityComparer_1$instance<T> {
    Equals(x: T | undefined, y: T | undefined): boolean;
    Equals(x: unknown | undefined, y: unknown | undefined): boolean;
    GetHashCode(obj: T): int;
    GetHashCode(obj: unknown): int;
}


export const ObjectEqualityComparer_1: {
    new<T>(): ObjectEqualityComparer_1<T>;
};


export interface __ObjectEqualityComparer_1$views<T> {
    As_IEqualityComparer_1(): IEqualityComparer_1$instance<T>;
    As_IEqualityComparer(): System_Collections_Internal.IEqualityComparer$instance;
}

export type ObjectEqualityComparer_1<T> = ObjectEqualityComparer_1$instance<T> & __ObjectEqualityComparer_1$views<T>;


export interface OrderedDictionary_2$instance<TKey, TValue> {
    readonly Capacity: int;
    readonly Comparer: IEqualityComparer_1<TKey>;
    readonly Count: int;
    Item: TValue;
    readonly Keys: OrderedDictionary_2_KeyCollection<TKey, TValue>;
    readonly Values: OrderedDictionary_2_ValueCollection<TKey, TValue>;
    Add(key: TKey, value: TValue): void;
    Clear(): void;
    ContainsKey(key: TKey): boolean;
    ContainsValue(value: TValue): boolean;
    EnsureCapacity(capacity: int): int;
    GetAt(index: int): KeyValuePair_2<TKey, TValue>;
    GetEnumerator(): OrderedDictionary_2_Enumerator<TKey, TValue>;
    IndexOf(key: TKey): int;
    Insert(index: int, key: TKey, value: TValue): void;
    Remove(key: TKey): boolean;
    Remove(key: TKey, value: TValue): boolean;
    RemoveAt(index: int): void;
    SetAt(index: int, value: TValue): void;
    SetAt(index: int, key: TKey, value: TValue): void;
    TrimExcess(): void;
    TrimExcess(capacity: int): void;
    TryAdd(key: TKey, value: TValue): boolean;
    TryAdd(key: TKey, value: TValue, index: int): boolean;
    TryGetValue(key: TKey, value: TValue): boolean;
    TryGetValue(key: TKey, value: TValue, index: int): boolean;
}


export const OrderedDictionary_2: {
    new<TKey, TValue>(): OrderedDictionary_2<TKey, TValue>;
    new<TKey, TValue>(capacity: int): OrderedDictionary_2<TKey, TValue>;
    new<TKey, TValue>(comparer: IEqualityComparer_1<TKey> | undefined): OrderedDictionary_2<TKey, TValue>;
    new<TKey, TValue>(capacity: int, comparer: IEqualityComparer_1<TKey> | undefined): OrderedDictionary_2<TKey, TValue>;
    new<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>): OrderedDictionary_2<TKey, TValue>;
    new<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>, comparer: IEqualityComparer_1<TKey> | undefined): OrderedDictionary_2<TKey, TValue>;
    new<TKey, TValue>(collection: IEnumerable_1<KeyValuePair_2<TKey, TValue>>): OrderedDictionary_2<TKey, TValue>;
    new<TKey, TValue>(collection: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, comparer: IEqualityComparer_1<TKey> | undefined): OrderedDictionary_2<TKey, TValue>;
};


export interface __OrderedDictionary_2$views<TKey, TValue> {
    As_ICollection_1(): ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionary_2(): IDictionary_2$instance<TKey, TValue>;
    As_IEnumerable_1(): IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IList_1(): IList_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyDictionary_2(): IReadOnlyDictionary_2$instance<TKey, TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type OrderedDictionary_2<TKey, TValue> = OrderedDictionary_2$instance<TKey, TValue> & __OrderedDictionary_2$views<TKey, TValue>;


export interface OrderedDictionary_2_KeyCollection$instance<TKey, TValue> {
    readonly Count: int;
    Contains(key: TKey): boolean;
    CopyTo(array: TKey[], arrayIndex: int): void;
    GetEnumerator(): OrderedDictionary_2_KeyCollection_Enumerator<TKey, TValue>;
}


export const OrderedDictionary_2_KeyCollection: {
    new<TKey, TValue>(): OrderedDictionary_2_KeyCollection<TKey, TValue>;
};


export interface __OrderedDictionary_2_KeyCollection$views<TKey, TValue> {
    As_ICollection_1(): ICollection_1$instance<TKey>;
    As_IEnumerable_1(): IEnumerable_1$instance<TKey>;
    As_IList_1(): IList_1$instance<TKey>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<TKey>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type OrderedDictionary_2_KeyCollection<TKey, TValue> = OrderedDictionary_2_KeyCollection$instance<TKey, TValue> & __OrderedDictionary_2_KeyCollection$views<TKey, TValue>;


export interface OrderedDictionary_2_ValueCollection$instance<TKey, TValue> {
    readonly Count: int;
    CopyTo(array: TValue[], arrayIndex: int): void;
    GetEnumerator(): OrderedDictionary_2_ValueCollection_Enumerator<TKey, TValue>;
}


export const OrderedDictionary_2_ValueCollection: {
    new<TKey, TValue>(): OrderedDictionary_2_ValueCollection<TKey, TValue>;
};


export interface __OrderedDictionary_2_ValueCollection$views<TKey, TValue> {
    As_ICollection_1(): ICollection_1$instance<TValue>;
    As_IEnumerable_1(): IEnumerable_1$instance<TValue>;
    As_IList_1(): IList_1$instance<TValue>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type OrderedDictionary_2_ValueCollection<TKey, TValue> = OrderedDictionary_2_ValueCollection$instance<TKey, TValue> & __OrderedDictionary_2_ValueCollection$views<TKey, TValue>;


export interface PriorityQueue_2$instance<TElement, TPriority> {
    readonly Capacity: int;
    readonly Comparer: IComparer_1<TPriority>;
    readonly Count: int;
    readonly UnorderedItems: PriorityQueue_2_UnorderedItemsCollection<TElement, TPriority>;
    Clear(): void;
    Dequeue(): TElement;
    DequeueEnqueue(element: TElement, priority: TPriority): TElement;
    Enqueue(element: TElement, priority: TPriority): void;
    EnqueueDequeue(element: TElement, priority: TPriority): TElement;
    EnqueueRange(items: IEnumerable_1<ValueTuple_2<TElement, TPriority>>): void;
    EnqueueRange(elements: IEnumerable_1<TElement>, priority: TPriority): void;
    EnsureCapacity(capacity: int): int;
    Peek(): TElement;
    Remove(element: TElement, removedElement: TElement, priority: TPriority, equalityComparer?: IEqualityComparer_1<TElement> | undefined): boolean;
    TrimExcess(): void;
    TryDequeue(element: TElement, priority: TPriority): boolean;
    TryPeek(element: TElement, priority: TPriority): boolean;
}


export const PriorityQueue_2: {
    new<TElement, TPriority>(): PriorityQueue_2<TElement, TPriority>;
    new<TElement, TPriority>(initialCapacity: int): PriorityQueue_2<TElement, TPriority>;
    new<TElement, TPriority>(comparer: IComparer_1<TPriority> | undefined): PriorityQueue_2<TElement, TPriority>;
    new<TElement, TPriority>(initialCapacity: int, comparer: IComparer_1<TPriority> | undefined): PriorityQueue_2<TElement, TPriority>;
    new<TElement, TPriority>(items: IEnumerable_1<ValueTuple_2<TElement, TPriority>>): PriorityQueue_2<TElement, TPriority>;
    new<TElement, TPriority>(items: IEnumerable_1<ValueTuple_2<TElement, TPriority>>, comparer: IComparer_1<TPriority> | undefined): PriorityQueue_2<TElement, TPriority>;
};


export type PriorityQueue_2<TElement, TPriority> = PriorityQueue_2$instance<TElement, TPriority>;

export interface PriorityQueue_2_UnorderedItemsCollection$instance<TElement, TPriority> {
    readonly Count: int;
    GetEnumerator(): PriorityQueue_2_UnorderedItemsCollection_Enumerator<TElement, TPriority>;
}


export const PriorityQueue_2_UnorderedItemsCollection: {
    new<TElement, TPriority>(): PriorityQueue_2_UnorderedItemsCollection<TElement, TPriority>;
};


export interface __PriorityQueue_2_UnorderedItemsCollection$views<TElement, TPriority> {
    As_IEnumerable_1(): IEnumerable_1$instance<ValueTuple_2<TElement, TPriority>>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<ValueTuple_2<TElement, TPriority>>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type PriorityQueue_2_UnorderedItemsCollection<TElement, TPriority> = PriorityQueue_2_UnorderedItemsCollection$instance<TElement, TPriority> & __PriorityQueue_2_UnorderedItemsCollection$views<TElement, TPriority>;


export interface Queue_1$instance<T> {
    readonly Capacity: int;
    readonly Count: int;
    Clear(): void;
    Contains(item: T): boolean;
    CopyTo(array: T[], arrayIndex: int): void;
    Dequeue(): T;
    Enqueue(item: T): void;
    EnsureCapacity(capacity: int): int;
    GetEnumerator(): Queue_1_Enumerator<T>;
    Peek(): T;
    ToArray(): T[];
    TrimExcess(): void;
    TrimExcess(capacity: int): void;
    TryDequeue(result: T): boolean;
    TryPeek(result: T): boolean;
}


export const Queue_1: {
    new<T>(): Queue_1<T>;
    new<T>(capacity: int): Queue_1<T>;
    new<T>(collection: IEnumerable_1<T>): Queue_1<T>;
};


export interface __Queue_1$views<T> {
    As_IEnumerable_1(): IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type Queue_1<T> = Queue_1$instance<T> & __Queue_1$views<T>;


export interface ReferenceEqualityComparer$instance {
    Equals(x: unknown | undefined, y: unknown | undefined): boolean;
    GetHashCode(obj: unknown | undefined): int;
}


export const ReferenceEqualityComparer: {
    new(): ReferenceEqualityComparer;
    readonly Instance: ReferenceEqualityComparer;
};


export interface __ReferenceEqualityComparer$views {
    As_IEqualityComparer_1(): IEqualityComparer_1$instance<unknown>;
    As_IEqualityComparer(): System_Collections_Internal.IEqualityComparer$instance;
}

export type ReferenceEqualityComparer = ReferenceEqualityComparer$instance & __ReferenceEqualityComparer$views;


export interface SortedDictionary_2$instance<TKey, TValue> {
    readonly Comparer: IComparer_1<TKey>;
    readonly Count: int;
    Item: TValue;
    readonly Keys: SortedDictionary_2_KeyCollection<TKey, TValue>;
    readonly Values: SortedDictionary_2_ValueCollection<TKey, TValue>;
    Add(key: TKey, value: TValue): void;
    Clear(): void;
    ContainsKey(key: TKey): boolean;
    ContainsValue(value: TValue): boolean;
    CopyTo(array: KeyValuePair_2<TKey, TValue>[], index: int): void;
    GetEnumerator(): SortedDictionary_2_Enumerator<TKey, TValue>;
    Remove(key: TKey): boolean;
    TryGetValue(key: TKey, value: TValue): boolean;
}


export const SortedDictionary_2: {
    new<TKey, TValue>(): SortedDictionary_2<TKey, TValue>;
    new<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>): SortedDictionary_2<TKey, TValue>;
    new<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>, comparer: IComparer_1<TKey> | undefined): SortedDictionary_2<TKey, TValue>;
    new<TKey, TValue>(comparer: IComparer_1<TKey> | undefined): SortedDictionary_2<TKey, TValue>;
};


export interface __SortedDictionary_2$views<TKey, TValue> {
    As_ICollection_1(): ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionary_2(): IDictionary_2$instance<TKey, TValue>;
    As_IEnumerable_1(): IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyDictionary_2(): IReadOnlyDictionary_2$instance<TKey, TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type SortedDictionary_2<TKey, TValue> = SortedDictionary_2$instance<TKey, TValue> & __SortedDictionary_2$views<TKey, TValue>;


export interface SortedDictionary_2_KeyCollection$instance<TKey, TValue> {
    readonly Count: int;
    Contains(item: TKey): boolean;
    CopyTo(array: TKey[], index: int): void;
    GetEnumerator(): SortedDictionary_2_KeyCollection_Enumerator<TKey, TValue>;
}


export const SortedDictionary_2_KeyCollection: {
    new<TKey, TValue>(dictionary: SortedDictionary_2<TKey, TValue>): SortedDictionary_2_KeyCollection<TKey, TValue>;
};


export interface __SortedDictionary_2_KeyCollection$views<TKey, TValue> {
    As_ICollection_1(): ICollection_1$instance<TKey>;
    As_IEnumerable_1(): IEnumerable_1$instance<TKey>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<TKey>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type SortedDictionary_2_KeyCollection<TKey, TValue> = SortedDictionary_2_KeyCollection$instance<TKey, TValue> & __SortedDictionary_2_KeyCollection$views<TKey, TValue>;


export interface SortedDictionary_2_KeyValuePairComparer$instance<TKey, TValue> extends Comparer_1$instance<KeyValuePair_2<TKey, TValue>> {
    Compare(x: unknown | undefined, y: unknown | undefined): int;
    Equals(obj: unknown | undefined): boolean;
    GetHashCode(): int;
}


export const SortedDictionary_2_KeyValuePairComparer: {
    new<TKey, TValue>(keyComparer: IComparer_1<TKey> | undefined): SortedDictionary_2_KeyValuePairComparer<TKey, TValue>;
};


export interface __SortedDictionary_2_KeyValuePairComparer$views<TKey, TValue> {
    As_IComparer_1(): IComparer_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IComparer(): System_Collections_Internal.IComparer$instance;
}

export type SortedDictionary_2_KeyValuePairComparer<TKey, TValue> = SortedDictionary_2_KeyValuePairComparer$instance<TKey, TValue> & __SortedDictionary_2_KeyValuePairComparer$views<TKey, TValue>;


export interface SortedDictionary_2_ValueCollection$instance<TKey, TValue> {
    readonly Count: int;
    CopyTo(array: TValue[], index: int): void;
    GetEnumerator(): SortedDictionary_2_ValueCollection_Enumerator<TKey, TValue>;
}


export const SortedDictionary_2_ValueCollection: {
    new<TKey, TValue>(dictionary: SortedDictionary_2<TKey, TValue>): SortedDictionary_2_ValueCollection<TKey, TValue>;
};


export interface __SortedDictionary_2_ValueCollection$views<TKey, TValue> {
    As_ICollection_1(): ICollection_1$instance<TValue>;
    As_IEnumerable_1(): IEnumerable_1$instance<TValue>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type SortedDictionary_2_ValueCollection<TKey, TValue> = SortedDictionary_2_ValueCollection$instance<TKey, TValue> & __SortedDictionary_2_ValueCollection$views<TKey, TValue>;


export interface SortedList_2$instance<TKey, TValue> {
    Capacity: int;
    readonly Comparer: IComparer_1<TKey>;
    readonly Count: int;
    Item: TValue;
    readonly Keys: IList_1<TKey>;
    readonly Values: IList_1<TValue>;
    Add(key: TKey, value: TValue): void;
    Clear(): void;
    ContainsKey(key: TKey): boolean;
    ContainsValue(value: TValue): boolean;
    GetEnumerator(): IEnumerator_1<KeyValuePair_2<TKey, TValue>>;
    GetKeyAtIndex(index: int): TKey;
    GetValueAtIndex(index: int): TValue;
    IndexOfKey(key: TKey): int;
    IndexOfValue(value: TValue): int;
    Remove(key: TKey): boolean;
    RemoveAt(index: int): void;
    SetValueAtIndex(index: int, value: TValue): void;
    TrimExcess(): void;
    TryGetValue(key: TKey, value: TValue): boolean;
}


export const SortedList_2: {
    new<TKey, TValue>(): SortedList_2<TKey, TValue>;
    new<TKey, TValue>(capacity: int): SortedList_2<TKey, TValue>;
    new<TKey, TValue>(comparer: IComparer_1<TKey> | undefined): SortedList_2<TKey, TValue>;
    new<TKey, TValue>(capacity: int, comparer: IComparer_1<TKey> | undefined): SortedList_2<TKey, TValue>;
    new<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>): SortedList_2<TKey, TValue>;
    new<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>, comparer: IComparer_1<TKey> | undefined): SortedList_2<TKey, TValue>;
};


export interface __SortedList_2$views<TKey, TValue> {
    As_ICollection_1(): ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionary_2(): IDictionary_2$instance<TKey, TValue>;
    As_IEnumerable_1(): IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyDictionary_2(): IReadOnlyDictionary_2$instance<TKey, TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type SortedList_2<TKey, TValue> = SortedList_2$instance<TKey, TValue> & __SortedList_2$views<TKey, TValue>;


export interface SortedList_2_KeyList$instance<TKey, TValue> {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    Item: TKey;
    Add(key: TKey): void;
    Clear(): void;
    Contains(key: TKey): boolean;
    CopyTo(array: TKey[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator_1<TKey>;
    IndexOf(key: TKey): int;
    Insert(index: int, value: TKey): void;
    Remove(key: TKey): boolean;
    RemoveAt(index: int): void;
}


export const SortedList_2_KeyList: {
    new<TKey, TValue>(): SortedList_2_KeyList<TKey, TValue>;
};


export interface __SortedList_2_KeyList$views<TKey, TValue> {
    As_ICollection_1(): ICollection_1$instance<TKey>;
    As_IEnumerable_1(): IEnumerable_1$instance<TKey>;
    As_IList_1(): IList_1$instance<TKey>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type SortedList_2_KeyList<TKey, TValue> = SortedList_2_KeyList$instance<TKey, TValue> & __SortedList_2_KeyList$views<TKey, TValue>;


export interface SortedList_2_ValueList$instance<TKey, TValue> {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    Item: TValue;
    Add(key: TValue): void;
    Clear(): void;
    Contains(value: TValue): boolean;
    CopyTo(array: TValue[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator_1<TValue>;
    IndexOf(value: TValue): int;
    Insert(index: int, value: TValue): void;
    Remove(value: TValue): boolean;
    RemoveAt(index: int): void;
}


export const SortedList_2_ValueList: {
    new<TKey, TValue>(): SortedList_2_ValueList<TKey, TValue>;
};


export interface __SortedList_2_ValueList$views<TKey, TValue> {
    As_ICollection_1(): ICollection_1$instance<TValue>;
    As_IEnumerable_1(): IEnumerable_1$instance<TValue>;
    As_IList_1(): IList_1$instance<TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type SortedList_2_ValueList<TKey, TValue> = SortedList_2_ValueList$instance<TKey, TValue> & __SortedList_2_ValueList$views<TKey, TValue>;


export interface SortedSet_1$instance<T> {
    readonly Comparer: IComparer_1<T>;
    readonly Count: int;
    readonly Max: T | undefined;
    readonly Min: T | undefined;
    Add(item: T): boolean;
    Clear(): void;
    Contains(item: T): boolean;
    CopyTo(array: T[]): void;
    CopyTo(array: T[], index: int): void;
    CopyTo(array: T[], index: int, count: int): void;
    ExceptWith(other: IEnumerable_1<T>): void;
    GetEnumerator(): SortedSet_1_Enumerator<T>;
    GetViewBetween(lowerValue: T | undefined, upperValue: T | undefined): SortedSet_1<T>;
    IntersectWith(other: IEnumerable_1<T>): void;
    IsProperSubsetOf(other: IEnumerable_1<T>): boolean;
    IsProperSupersetOf(other: IEnumerable_1<T>): boolean;
    IsSubsetOf(other: IEnumerable_1<T>): boolean;
    IsSupersetOf(other: IEnumerable_1<T>): boolean;
    Overlaps(other: IEnumerable_1<T>): boolean;
    Remove(item: T): boolean;
    RemoveWhere(match: Predicate_1<T>): int;
    Reverse(): IEnumerable_1<T>;
    SetEquals(other: IEnumerable_1<T>): boolean;
    SymmetricExceptWith(other: IEnumerable_1<T>): void;
    TryGetValue(equalValue: T, actualValue: T): boolean;
    UnionWith(other: IEnumerable_1<T>): void;
}


export const SortedSet_1: {
    new<T>(): SortedSet_1<T>;
    new<T>(comparer: IComparer_1<T> | undefined): SortedSet_1<T>;
    new<T>(collection: IEnumerable_1<T>): SortedSet_1<T>;
    new<T>(collection: IEnumerable_1<T>, comparer: IComparer_1<T> | undefined): SortedSet_1<T>;
    CreateSetComparer<T>(): IEqualityComparer_1<SortedSet_1<T>>;
    CreateSetComparer<T>(memberEqualityComparer: IEqualityComparer_1<T> | undefined): IEqualityComparer_1<SortedSet_1<T>>;
};


export interface __SortedSet_1$views<T> {
    As_ICollection_1(): ICollection_1$instance<T>;
    As_IEnumerable_1(): IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<T>;
    As_IReadOnlySet_1(): IReadOnlySet_1$instance<T>;
    As_ISet_1(): ISet_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface SortedSet_1$instance<T> extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type SortedSet_1<T> = SortedSet_1$instance<T> & __SortedSet_1$views<T>;


export interface Stack_1$instance<T> {
    readonly Capacity: int;
    readonly Count: int;
    Clear(): void;
    Contains(item: T): boolean;
    CopyTo(array: T[], arrayIndex: int): void;
    EnsureCapacity(capacity: int): int;
    GetEnumerator(): Stack_1_Enumerator<T>;
    Peek(): T;
    Pop(): T;
    Push(item: T): void;
    ToArray(): T[];
    TrimExcess(): void;
    TrimExcess(capacity: int): void;
    TryPeek(result: T): boolean;
    TryPop(result: T): boolean;
}


export const Stack_1: {
    new<T>(): Stack_1<T>;
    new<T>(capacity: int): Stack_1<T>;
    new<T>(collection: IEnumerable_1<T>): Stack_1<T>;
};


export interface __Stack_1$views<T> {
    As_IEnumerable_1(): IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type Stack_1<T> = Stack_1$instance<T> & __Stack_1$views<T>;


export interface TreeSet_1$instance<T> extends SortedSet_1$instance<T> {
    Add(item: T): boolean;
    Add(item: T): void;
    Clear(): void;
    Contains(item: T): boolean;
    CopyTo(array: T[]): void;
    CopyTo(array: T[], index: int): void;
    CopyTo(array: T[], index: int, count: int): void;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): SortedSet_1_Enumerator<T>;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    IsProperSubsetOf(other: IEnumerable_1<T>): boolean;
    IsSubsetOf(other: IEnumerable_1<T>): boolean;
    OnDeserialization(sender: unknown | undefined): void;
    UnionWith(other: IEnumerable_1<T>): void;
}


export const TreeSet_1: {
    new<T>(): TreeSet_1<T>;
    new<T>(comparer: IComparer_1<T> | undefined): TreeSet_1<T>;
};


export interface __TreeSet_1$views<T> {
    As_ICollection_1(): ICollection_1$instance<T>;
    As_IEnumerable_1(): IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): IReadOnlyCollection_1$instance<T>;
    As_IReadOnlySet_1(): IReadOnlySet_1$instance<T>;
    As_ISet_1(): ISet_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface TreeSet_1$instance<T> extends System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type TreeSet_1<T> = TreeSet_1$instance<T> & __TreeSet_1$views<T>;


export abstract class CollectionExtensions$instance {
    static AddRange<T>(list: List_1<T>, source: ReadOnlySpan_1<T>): void;
    static AsReadOnly<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>): ReadOnlyDictionary_2<TKey, TValue>;
    static AsReadOnly<T>(list: IList_1<T>): ReadOnlyCollection_1<T>;
    static AsReadOnly<T>(set_: ISet_1<T>): ReadOnlySet_1<T>;
    static CopyTo<T>(list: List_1<T>, destination: Span_1<T>): void;
    static GetValueOrDefault<TKey, TValue>(dictionary: IReadOnlyDictionary_2<TKey, TValue>, key: TKey, defaultValue: TValue): TValue;
    static GetValueOrDefault<TKey, TValue>(dictionary: IReadOnlyDictionary_2<TKey, TValue>, key: TKey): TValue | undefined;
    static InsertRange<T>(list: List_1<T>, index: int, source: ReadOnlySpan_1<T>): void;
    static Remove<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>, key: TKey, value: TValue): boolean;
    static TryAdd<TKey, TValue>(dictionary: IDictionary_2<TKey, TValue>, key: TKey, value: TValue): boolean;
}


export type CollectionExtensions = CollectionExtensions$instance;

export abstract class KeyValuePair$instance {
    static Create<TKey, TValue>(key: TKey, value: TValue): KeyValuePair_2<TKey, TValue>;
}


export type KeyValuePair = KeyValuePair$instance;


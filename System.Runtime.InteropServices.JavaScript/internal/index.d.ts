// Generated by tsbindgen - Architecture
// Namespace: System.Runtime.InteropServices.JavaScript
// Assembly: System.Runtime.InteropServices.JavaScript

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { IDictionary } from "../../System.Collections/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { Task, Task_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action, Action_1, Action_2, Action_3, ArraySegment_1, AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Char, DateTime, DateTimeOffset, Delegate, Double, Exception, Func_1, Func_2, Func_3, Func_4, IAsyncResult, ICloneable, IDisposable, Int16, Int32, Int64, IntPtr, MulticastDelegate, Nullable_1, Object as ClrObject, ReadOnlySpan_1, Single, Span_1, String as ClrString, Type, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export type JSMarshalerArgument_ArgumentToJSCallback_1<T> = (arg: ref<JSMarshalerArgument>, value: T) => void;


export type JSMarshalerArgument_ArgumentToManagedCallback_1<T> = (arg: ref<JSMarshalerArgument>, value: ref<T>) => void;


export interface JSMarshalerArgument$instance {
    Initialize(): void;
    ToJS(value: boolean): void;
    ToJS(value: Nullable_1<CLROf<boolean>>): void;
    ToJS(value: byte): void;
    ToJS(value: Nullable_1<CLROf<byte>>): void;
    ToJS(value: byte[]): void;
    ToJS(value: char): void;
    ToJS(value: Nullable_1<CLROf<char>>): void;
    ToJS(value: short): void;
    ToJS(value: Nullable_1<CLROf<short>>): void;
    ToJS(value: int): void;
    ToJS(value: Nullable_1<CLROf<int>>): void;
    ToJS(value: int[]): void;
    ToJS(value: long): void;
    ToJS(value: Nullable_1<CLROf<long>>): void;
    ToJS(value: float): void;
    ToJS(value: Nullable_1<CLROf<float>>): void;
    ToJS(value: double): void;
    ToJS(value: Nullable_1<CLROf<double>>): void;
    ToJS(value: double[]): void;
    ToJS(value: nint): void;
    ToJS(value: Nullable_1<CLROf<nint>>): void;
    ToJS(value: DateTimeOffset): void;
    ToJS(value: Nullable_1<DateTimeOffset>): void;
    ToJS(value: DateTime): void;
    ToJS(value: Nullable_1<DateTime>): void;
    ToJS(value: string): void;
    ToJS(value: string[]): void;
    ToJS(value: Exception): void;
    ToJS(value: unknown): void;
    ToJS(value: unknown[]): void;
    ToJS(value: JSObject): void;
    ToJS(value: JSObject[]): void;
    ToJS(value: Task): void;
    ToJS<T>(value: Task_1<T>, marshaler: JSMarshalerArgument_ArgumentToJSCallback_1<T>): void;
    ToJS(value: Action): void;
    ToJS<T>(value: Action_1<T>, arg1Marshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<T>): void;
    ToJS<T1, T2>(value: Action_2<T1, T2>, arg1Marshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<T1>, arg2Marshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<T2>): void;
    ToJS<T1, T2, T3>(value: Action_3<T1, T2, T3>, arg1Marshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<T1>, arg2Marshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<T2>, arg3Marshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<T3>): void;
    ToJS<TResult>(value: Func_1<TResult>, resMarshaler: JSMarshalerArgument_ArgumentToJSCallback_1<TResult>): void;
    ToJS<T, TResult>(value: Func_2<T, TResult>, arg1Marshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<T>, resMarshaler: JSMarshalerArgument_ArgumentToJSCallback_1<TResult>): void;
    ToJS<T1, T2, TResult>(value: Func_3<T1, T2, TResult>, arg1Marshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<T1>, arg2Marshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<T2>, resMarshaler: JSMarshalerArgument_ArgumentToJSCallback_1<TResult>): void;
    ToJS<T1, T2, T3, TResult>(value: Func_4<T1, T2, T3, TResult>, arg1Marshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<T1>, arg2Marshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<T2>, arg3Marshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<T3>, resMarshaler: JSMarshalerArgument_ArgumentToJSCallback_1<TResult>): void;
    ToJS(value: ptr<void>): void;
    ToJS(value: Span_1<CLROf<byte>>): void;
    ToJS(value: ArraySegment_1<CLROf<byte>>): void;
    ToJS(value: Span_1<CLROf<int>>): void;
    ToJS(value: Span_1<CLROf<double>>): void;
    ToJS(value: ArraySegment_1<CLROf<int>>): void;
    ToJS(value: ArraySegment_1<CLROf<double>>): void;
    ToJSBig(value: long): void;
    ToJSBig(value: Nullable_1<CLROf<long>>): void;
    ToManaged(value: { value: ref<boolean> }): void;
    ToManaged(value: { value: ref<Nullable_1<CLROf<boolean>>> }): void;
    ToManaged(value: { value: ref<byte> }): void;
    ToManaged(value: { value: ref<Nullable_1<CLROf<byte>>> }): void;
    ToManaged(value: { value: ref<byte[]> }): void;
    ToManaged(value: { value: ref<char> }): void;
    ToManaged(value: { value: ref<Nullable_1<CLROf<char>>> }): void;
    ToManaged(value: { value: ref<short> }): void;
    ToManaged(value: { value: ref<Nullable_1<CLROf<short>>> }): void;
    ToManaged(value: { value: ref<int> }): void;
    ToManaged(value: { value: ref<Nullable_1<CLROf<int>>> }): void;
    ToManaged(value: { value: ref<int[]> }): void;
    ToManaged(value: { value: ref<long> }): void;
    ToManaged(value: { value: ref<Nullable_1<CLROf<long>>> }): void;
    ToManaged(value: { value: ref<float> }): void;
    ToManaged(value: { value: ref<Nullable_1<CLROf<float>>> }): void;
    ToManaged(value: { value: ref<double> }): void;
    ToManaged(value: { value: ref<Nullable_1<CLROf<double>>> }): void;
    ToManaged(value: { value: ref<double[]> }): void;
    ToManaged(value: { value: ref<nint> }): void;
    ToManaged(value: { value: ref<Nullable_1<CLROf<nint>>> }): void;
    ToManaged(value: { value: ref<DateTimeOffset> }): void;
    ToManaged(value: { value: ref<Nullable_1<DateTimeOffset>> }): void;
    ToManaged(value: { value: ref<DateTime> }): void;
    ToManaged(value: { value: ref<Nullable_1<DateTime>> }): void;
    ToManaged(value: { value: ref<string> }): void;
    ToManaged(value: { value: ref<string[]> }): void;
    ToManaged(value: { value: ref<Exception> }): void;
    ToManaged(value: { value: ref<unknown> }): void;
    ToManaged(value: { value: ref<unknown[]> }): void;
    ToManaged(value: { value: ref<JSObject> }): void;
    ToManaged(value: { value: ref<JSObject[]> }): void;
    ToManaged(value: { value: ref<Task> }): void;
    ToManaged<T>(value: { value: ref<Task_1<T>> }, marshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<T>): void;
    ToManaged(value: { value: ref<Action> }): void;
    ToManaged<T>(value: { value: ref<Action_1<T>> }, arg1Marshaler: JSMarshalerArgument_ArgumentToJSCallback_1<T>): void;
    ToManaged<T1, T2>(value: { value: ref<Action_2<T1, T2>> }, arg1Marshaler: JSMarshalerArgument_ArgumentToJSCallback_1<T1>, arg2Marshaler: JSMarshalerArgument_ArgumentToJSCallback_1<T2>): void;
    ToManaged<T1, T2, T3>(value: { value: ref<Action_3<T1, T2, T3>> }, arg1Marshaler: JSMarshalerArgument_ArgumentToJSCallback_1<T1>, arg2Marshaler: JSMarshalerArgument_ArgumentToJSCallback_1<T2>, arg3Marshaler: JSMarshalerArgument_ArgumentToJSCallback_1<T3>): void;
    ToManaged<TResult>(value: { value: ref<Func_1<TResult>> }, resMarshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<TResult>): void;
    ToManaged<T, TResult>(value: { value: ref<Func_2<T, TResult>> }, arg1Marshaler: JSMarshalerArgument_ArgumentToJSCallback_1<T>, resMarshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<TResult>): void;
    ToManaged<T1, T2, TResult>(value: { value: ref<Func_3<T1, T2, TResult>> }, arg1Marshaler: JSMarshalerArgument_ArgumentToJSCallback_1<T1>, arg2Marshaler: JSMarshalerArgument_ArgumentToJSCallback_1<T2>, resMarshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<TResult>): void;
    ToManaged<T1, T2, T3, TResult>(value: { value: ref<Func_4<T1, T2, T3, TResult>> }, arg1Marshaler: JSMarshalerArgument_ArgumentToJSCallback_1<T1>, arg2Marshaler: JSMarshalerArgument_ArgumentToJSCallback_1<T2>, arg3Marshaler: JSMarshalerArgument_ArgumentToJSCallback_1<T3>, resMarshaler: JSMarshalerArgument_ArgumentToManagedCallback_1<TResult>): void;
    ToManaged(value: { value: ref<ptr<void>> }): void;
    ToManaged(value: { value: ref<Span_1<CLROf<byte>>> }): void;
    ToManaged(value: { value: ref<ArraySegment_1<CLROf<byte>>> }): void;
    ToManaged(value: { value: ref<Span_1<CLROf<int>>> }): void;
    ToManaged(value: { value: ref<Span_1<CLROf<double>>> }): void;
    ToManaged(value: { value: ref<ArraySegment_1<CLROf<int>>> }): void;
    ToManaged(value: { value: ref<ArraySegment_1<CLROf<double>>> }): void;
    ToManagedBig(value: { value: ref<long> }): void;
    ToManagedBig(value: { value: ref<Nullable_1<CLROf<long>>> }): void;
}


export const JSMarshalerArgument: {
    new(): JSMarshalerArgument$instance;
};


export type JSMarshalerArgument = JSMarshalerArgument$instance;

export interface JSException$instance extends Exception {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const JSException: {
    new(msg: string): JSException$instance;
};


export interface __JSException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type JSException = JSException$instance & __JSException$views;


export interface JSExportAttribute$instance extends Attribute {
}


export const JSExportAttribute: {
    new(): JSExportAttribute$instance;
};


export type JSExportAttribute = JSExportAttribute$instance;

export interface JSFunctionBinding$instance {
}


export const JSFunctionBinding: {
    new(): JSFunctionBinding$instance;
    BindJSFunction(functionName: string, moduleName: string, signatures: ReadOnlySpan_1<JSMarshalerType>): JSFunctionBinding;
    BindManagedFunction(fullyQualifiedName: string, signatureHash: int, signatures: ReadOnlySpan_1<JSMarshalerType>): JSFunctionBinding;
    InvokeJS(signature: JSFunctionBinding, arguments: Span_1<JSMarshalerArgument>): void;
};


export type JSFunctionBinding = JSFunctionBinding$instance;

export interface JSImportAttribute$instance extends Attribute {
    readonly FunctionName: string;
    readonly ModuleName: string;
}


export const JSImportAttribute: {
    new(functionName: string): JSImportAttribute$instance;
    new(functionName: string, moduleName: string): JSImportAttribute$instance;
};


export type JSImportAttribute = JSImportAttribute$instance;

export interface JSMarshalAsAttribute_1$instance<T extends JSType> extends Attribute {
}


export const JSMarshalAsAttribute_1: {
    new<T extends JSType>(): JSMarshalAsAttribute_1$instance<T>;
};


export type JSMarshalAsAttribute_1<T extends JSType> = JSMarshalAsAttribute_1$instance<T>;

export interface JSMarshalerType$instance {
}


export const JSMarshalerType: {
    new(): JSMarshalerType$instance;
    readonly Void: JSMarshalerType;
    readonly Discard: JSMarshalerType;
    readonly Boolean: JSMarshalerType;
    readonly Byte: JSMarshalerType;
    readonly Char: JSMarshalerType;
    readonly Int16: JSMarshalerType;
    readonly Int32: JSMarshalerType;
    readonly Int52: JSMarshalerType;
    readonly BigInt64: JSMarshalerType;
    readonly Double: JSMarshalerType;
    readonly Single: JSMarshalerType;
    readonly IntPtr: JSMarshalerType;
    readonly JSObject: JSMarshalerType;
    readonly Object: JSMarshalerType;
    readonly String: JSMarshalerType;
    readonly Exception: JSMarshalerType;
    readonly DateTime: JSMarshalerType;
    readonly DateTimeOffset: JSMarshalerType;
    Action(): JSMarshalerType;
    Action(arg1: JSMarshalerType, arg2: JSMarshalerType, arg3: JSMarshalerType): JSMarshalerType;
    Action(arg1: JSMarshalerType, arg2: JSMarshalerType): JSMarshalerType;
    Action(arg1: JSMarshalerType): JSMarshalerType;
    Array(element: JSMarshalerType): JSMarshalerType;
    ArraySegment(element: JSMarshalerType): JSMarshalerType;
    Function(arg1: JSMarshalerType, arg2: JSMarshalerType, arg3: JSMarshalerType, result: JSMarshalerType): JSMarshalerType;
    Function(arg1: JSMarshalerType, arg2: JSMarshalerType, result: JSMarshalerType): JSMarshalerType;
    Function(arg1: JSMarshalerType, result: JSMarshalerType): JSMarshalerType;
    Function(result: JSMarshalerType): JSMarshalerType;
    Nullable(primitive: JSMarshalerType): JSMarshalerType;
    Span(element: JSMarshalerType): JSMarshalerType;
    Task(): JSMarshalerType;
    Task(result: JSMarshalerType): JSMarshalerType;
};


export type JSMarshalerType = JSMarshalerType$instance;

export interface JSObject$instance {
    readonly IsDisposed: boolean;
    Dispose(): void;
    GetPropertyAsBoolean(propertyName: string): boolean;
    GetPropertyAsByteArray(propertyName: string): byte[];
    GetPropertyAsDouble(propertyName: string): double;
    GetPropertyAsInt32(propertyName: string): int;
    GetPropertyAsJSObject(propertyName: string): JSObject;
    GetPropertyAsString(propertyName: string): string;
    GetTypeOfProperty(propertyName: string): string;
    HasProperty(propertyName: string): boolean;
    SetProperty(propertyName: string, value: boolean): void;
    SetProperty(propertyName: string, value: int): void;
    SetProperty(propertyName: string, value: double): void;
    SetProperty(propertyName: string, value: string): void;
    SetProperty(propertyName: string, value: JSObject): void;
    SetProperty(propertyName: string, value: byte[]): void;
}


export const JSObject: {
    new(): JSObject$instance;
};


export interface __JSObject$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface JSObject$instance extends System_Internal.IDisposable$instance {}

export type JSObject = JSObject$instance & __JSObject$views;


export interface JSType$instance {
}


export const JSType: {
};


export type JSType = JSType$instance;

export interface JSType_Any$instance extends JSType {
}


export const JSType_Any: {
    new(): JSType_Any$instance;
};


export type JSType_Any = JSType_Any$instance;

export interface JSType_Array_1$instance<T extends JSType> extends JSType {
}


export const JSType_Array_1: {
    new<T extends JSType>(): JSType_Array_1$instance<T>;
};


export type JSType_Array_1<T extends JSType> = JSType_Array_1$instance<T>;

export interface JSType_BigInt$instance extends JSType {
}


export const JSType_BigInt: {
    new(): JSType_BigInt$instance;
};


export type JSType_BigInt = JSType_BigInt$instance;

export interface JSType_Boolean$instance extends JSType {
}


export const JSType_Boolean: {
    new(): JSType_Boolean$instance;
};


export type JSType_Boolean = JSType_Boolean$instance;

export interface JSType_Date$instance extends JSType {
}


export const JSType_Date: {
    new(): JSType_Date$instance;
};


export type JSType_Date = JSType_Date$instance;

export interface JSType_Discard$instance extends JSType {
}


export const JSType_Discard: {
    new(): JSType_Discard$instance;
};


export type JSType_Discard = JSType_Discard$instance;

export interface JSType_Error$instance extends JSType {
}


export const JSType_Error: {
    new(): JSType_Error$instance;
};


export type JSType_Error = JSType_Error$instance;

export interface JSType_Function$instance extends JSType {
}


export const JSType_Function: {
    new(): JSType_Function$instance;
};


export type JSType_Function = JSType_Function$instance;

export interface JSType_Function_1$instance<T extends JSType> extends JSType {
}


export const JSType_Function_1: {
    new<T extends JSType>(): JSType_Function_1$instance<T>;
};


export type JSType_Function_1<T extends JSType> = JSType_Function_1$instance<T>;

export interface JSType_Function_2$instance<T1 extends JSType, T2 extends JSType> extends JSType {
}


export const JSType_Function_2: {
    new<T1 extends JSType, T2 extends JSType>(): JSType_Function_2$instance<T1, T2>;
};


export type JSType_Function_2<T1 extends JSType, T2 extends JSType> = JSType_Function_2$instance<T1, T2>;

export interface JSType_Function_3$instance<T1 extends JSType, T2 extends JSType, T3 extends JSType> extends JSType {
}


export const JSType_Function_3: {
    new<T1 extends JSType, T2 extends JSType, T3 extends JSType>(): JSType_Function_3$instance<T1, T2, T3>;
};


export type JSType_Function_3<T1 extends JSType, T2 extends JSType, T3 extends JSType> = JSType_Function_3$instance<T1, T2, T3>;

export interface JSType_Function_4$instance<T1 extends JSType, T2 extends JSType, T3 extends JSType, T4 extends JSType> extends JSType {
}


export const JSType_Function_4: {
    new<T1 extends JSType, T2 extends JSType, T3 extends JSType, T4 extends JSType>(): JSType_Function_4$instance<T1, T2, T3, T4>;
};


export type JSType_Function_4<T1 extends JSType, T2 extends JSType, T3 extends JSType, T4 extends JSType> = JSType_Function_4$instance<T1, T2, T3, T4>;

export interface JSType_MemoryView$instance extends JSType {
}


export const JSType_MemoryView: {
    new(): JSType_MemoryView$instance;
};


export type JSType_MemoryView = JSType_MemoryView$instance;

export interface JSType_Number$instance extends JSType {
}


export const JSType_Number: {
    new(): JSType_Number$instance;
};


export type JSType_Number = JSType_Number$instance;

export interface JSType_Object$instance extends JSType {
}


export const JSType_Object: {
    new(): JSType_Object$instance;
};


export type JSType_Object = JSType_Object$instance;

export interface JSType_Promise_1$instance<T extends JSType> extends JSType {
}


export const JSType_Promise_1: {
    new<T extends JSType>(): JSType_Promise_1$instance<T>;
};


export type JSType_Promise_1<T extends JSType> = JSType_Promise_1$instance<T>;

export interface JSType_String$instance extends JSType {
}


export const JSType_String: {
    new(): JSType_String$instance;
};


export type JSType_String = JSType_String$instance;

export interface JSType_Void$instance extends JSType {
}


export const JSType_Void: {
    new(): JSType_Void$instance;
};


export type JSType_Void = JSType_Void$instance;

export abstract class JSHost$instance {
    static readonly GlobalThis: JSObject;
    static readonly DotnetInstance: JSObject;
    static ImportAsync(moduleName: string, moduleUrl: string, cancellationToken?: CancellationToken): Task_1<JSObject>;
}


export type JSHost = JSHost$instance;


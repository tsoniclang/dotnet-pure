// Generated by tsbindgen - Architecture
// Namespace: System.Threading
// Assembly: System.Private.CoreLib, System.Threading, System.Threading.AccessControl

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { SafeWaitHandle } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import type { IList_1 } from "../../System.Collections.Generic/internal/index.js";
import type { IDictionary } from "../../System.Collections/internal/index.js";
import type { CultureInfo } from "../../System.Globalization/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_ConstrainedExecution_Internal from "../../System.Runtime.ConstrainedExecution/internal/index.js";
import type { CriticalFinalizerObject } from "../../System.Runtime.ConstrainedExecution/internal/index.js";
import type { SafeHandle } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { EventWaitHandleRights, EventWaitHandleSecurity, MutexRights, MutexSecurity, SemaphoreRights, SemaphoreSecurity } from "../../System.Security.AccessControl/internal/index.js";
import type { IPrincipal } from "../../System.Security.Principal/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action, Action_1, Action_2, AppDomain, ApplicationException, AsyncCallback, Boolean as ClrBoolean, Byte, Delegate, Double, Enum, EventArgs, Exception, Func_1, IAsyncDisposable, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, LocalDataStoreSlot, MarshalByRefObject, MulticastDelegate, Object as ClrObject, ReadOnlySpan_1, SByte, Single, String as ClrString, SystemException, TimeProvider, TimeSpan, Type, TypeCode, UInt16, UInt32, UInt64, UIntPtr, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum ApartmentState {
    STA = 0,
    MTA = 1,
    Unknown = 2
}


export enum EventResetMode {
    AutoReset = 0,
    ManualReset = 1
}


export enum LazyThreadSafetyMode {
    None = 0,
    PublicationOnly = 1,
    ExecutionAndPublication = 2
}


export enum LockRecursionPolicy {
    NoRecursion = 0,
    SupportsRecursion = 1
}


export enum ThreadPriority {
    Lowest = 0,
    BelowNormal = 1,
    Normal = 2,
    AboveNormal = 3,
    Highest = 4
}


export enum ThreadState {
    Running = 0,
    StopRequested = 1,
    SuspendRequested = 2,
    Background = 4,
    Unstarted = 8,
    Stopped = 16,
    WaitSleepJoin = 32,
    Suspended = 64,
    AbortRequested = 128,
    Aborted = 256
}


export type ContextCallback = (state: unknown) => void;


export type IOCompletionCallback = (errorCode: uint, numBytes: uint, pOVERLAP: ptr<NativeOverlapped>) => void;


export type ParameterizedThreadStart = (obj: unknown) => void;


export type SendOrPostCallback = (state: unknown) => void;


export type ThreadExceptionEventHandler = (sender: unknown, e: ThreadExceptionEventArgs) => void;


export type ThreadStart = () => void;


export type TimerCallback = (state: unknown) => void;


export type WaitCallback = (state: unknown) => void;


export type WaitOrTimerCallback = (state: unknown, timedOut: boolean) => void;


export interface IThreadPoolWorkItem$instance {
    Execute(): void;
}


export type IThreadPoolWorkItem = IThreadPoolWorkItem$instance;

export interface ITimer$instance extends IDisposable, IAsyncDisposable {
    Change(dueTime: TimeSpan, period: TimeSpan): boolean;
    Dispose(): void;
    DisposeAsync(): ValueTask;
}


export interface ITimer$instance extends System_Internal.IAsyncDisposable$instance, System_Internal.IDisposable$instance {}

export type ITimer = ITimer$instance;

export interface AsyncFlowControl$instance {
    Dispose(): void;
    Equals(obj: unknown): boolean;
    Equals(obj: AsyncFlowControl): boolean;
    GetHashCode(): int;
    Undo(): void;
}


export const AsyncFlowControl: {
    new(): AsyncFlowControl$instance;
};


export interface __AsyncFlowControl$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<AsyncFlowControl>;

    // Structural method bridges for numeric interface constraints
    Equals(other: AsyncFlowControl): boolean;
}

export interface AsyncFlowControl$instance extends System_Internal.IDisposable$instance {}

export type AsyncFlowControl = AsyncFlowControl$instance & __AsyncFlowControl$views;


export interface AsyncLocalValueChangedArgs_1$instance<T> {
    readonly CurrentValue: T;
    readonly PreviousValue: T;
    readonly ThreadContextChanged: boolean;
}


export const AsyncLocalValueChangedArgs_1: {
    new<T>(): AsyncLocalValueChangedArgs_1$instance<T>;
};


export type AsyncLocalValueChangedArgs_1<T> = AsyncLocalValueChangedArgs_1$instance<T>;

export interface CancellationToken$instance {
    readonly CanBeCanceled: boolean;
    readonly IsCancellationRequested: boolean;
    readonly WaitHandle: WaitHandle;
    Equals(other: CancellationToken): boolean;
    Equals(other: unknown): boolean;
    GetHashCode(): int;
    Register(callback: Action): CancellationTokenRegistration;
    Register(callback: Action, useSynchronizationContext: boolean): CancellationTokenRegistration;
    Register(callback: Action_1<unknown>, state: unknown): CancellationTokenRegistration;
    Register(callback: Action_2<unknown, CancellationToken>, state: unknown): CancellationTokenRegistration;
    Register(callback: Action_1<unknown>, state: unknown, useSynchronizationContext: boolean): CancellationTokenRegistration;
    ThrowIfCancellationRequested(): void;
    UnsafeRegister(callback: Action_1<unknown>, state: unknown): CancellationTokenRegistration;
    UnsafeRegister(callback: Action_2<unknown, CancellationToken>, state: unknown): CancellationTokenRegistration;
}


export const CancellationToken: {
    new(canceled: boolean): CancellationToken$instance;
    readonly None: CancellationToken;
};


export interface __CancellationToken$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CancellationToken>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CancellationToken): boolean;
}

export type CancellationToken = CancellationToken$instance & __CancellationToken$views;


export interface CancellationTokenRegistration$instance {
    readonly Token: CancellationToken;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    Equals(obj: unknown): boolean;
    Equals(other: CancellationTokenRegistration): boolean;
    GetHashCode(): int;
    Unregister(): boolean;
}


export const CancellationTokenRegistration: {
    new(): CancellationTokenRegistration$instance;
};


export interface __CancellationTokenRegistration$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CancellationTokenRegistration>;

    // Structural method bridges for numeric interface constraints
    Equals(other: CancellationTokenRegistration): boolean;
}

export interface CancellationTokenRegistration$instance extends System_Internal.IAsyncDisposable$instance, System_Internal.IDisposable$instance {}

export type CancellationTokenRegistration = CancellationTokenRegistration$instance & __CancellationTokenRegistration$views;


export interface Lock_Scope$instance {
    Dispose(): void;
}


export const Lock_Scope: {
    new(): Lock_Scope$instance;
};


export type Lock_Scope = Lock_Scope$instance;

export interface LockCookie$instance {
    Equals(obj: unknown): boolean;
    Equals(obj: LockCookie): boolean;
    GetHashCode(): int;
}


export const LockCookie: {
    new(): LockCookie$instance;
};


export interface __LockCookie$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<LockCookie>;

    // Structural method bridges for numeric interface constraints
    Equals(other: LockCookie): boolean;
}

export type LockCookie = LockCookie$instance & __LockCookie$views;


export interface NamedWaitHandleOptions$instance {
    CurrentSessionOnly: boolean;
    CurrentUserOnly: boolean;
}


export const NamedWaitHandleOptions: {
    new(): NamedWaitHandleOptions$instance;
};


export type NamedWaitHandleOptions = NamedWaitHandleOptions$instance;

export interface NativeOverlapped$instance {
    InternalLow: nint;
    InternalHigh: nint;
    OffsetLow: int;
    OffsetHigh: int;
    EventHandle: nint;
}


export const NativeOverlapped: {
    new(): NativeOverlapped$instance;
};


export type NativeOverlapped = NativeOverlapped$instance;

export interface SpinLock$instance {
    readonly IsHeld: boolean;
    readonly IsHeldByCurrentThread: boolean;
    readonly IsThreadOwnerTrackingEnabled: boolean;
    Enter(lockTaken: { value: ref<boolean> }): void;
    Exit(): void;
    Exit(useMemoryBarrier: boolean): void;
    TryEnter(lockTaken: { value: ref<boolean> }): void;
    TryEnter(timeout: TimeSpan, lockTaken: { value: ref<boolean> }): void;
    TryEnter(millisecondsTimeout: int, lockTaken: { value: ref<boolean> }): void;
}


export const SpinLock: {
    new(enableThreadOwnerTracking: boolean): SpinLock$instance;
};


export type SpinLock = SpinLock$instance;

export interface SpinWait$instance {
    readonly Count: int;
    readonly NextSpinWillYield: boolean;
    Reset(): void;
    SpinOnce(): void;
    SpinOnce(sleep1Threshold: int): void;
}


export const SpinWait: {
    new(): SpinWait$instance;
    SpinUntil(condition: Func_1<CLROf<boolean>>, millisecondsTimeout: int): boolean;
    SpinUntil(condition: Func_1<CLROf<boolean>>, timeout: TimeSpan): boolean;
    SpinUntil(condition: Func_1<CLROf<boolean>>): void;
};


export type SpinWait = SpinWait$instance;

export interface AbandonedMutexException$instance extends SystemException {
    readonly Mutex: Mutex;
    readonly MutexIndex: int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const AbandonedMutexException: {
    new(): AbandonedMutexException$instance;
    new(message: string): AbandonedMutexException$instance;
    new(message: string, inner: Exception): AbandonedMutexException$instance;
    new(location: int, handle: WaitHandle): AbandonedMutexException$instance;
    new(message: string, location: int, handle: WaitHandle): AbandonedMutexException$instance;
    new(message: string, inner: Exception, location: int, handle: WaitHandle): AbandonedMutexException$instance;
};


export interface __AbandonedMutexException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AbandonedMutexException = AbandonedMutexException$instance & __AbandonedMutexException$views;


export interface AsyncLocal_1$instance<T> {
    Value: T;
}


export const AsyncLocal_1: {
    new<T>(): AsyncLocal_1$instance<T>;
    new<T>(valueChangedHandler: Action_1<AsyncLocalValueChangedArgs_1<T>>): AsyncLocal_1$instance<T>;
};


export type AsyncLocal_1<T> = AsyncLocal_1$instance<T>;

export interface AutoResetEvent$instance extends EventWaitHandle$instance {
    Dispose(): void;
}


export const AutoResetEvent: {
    new(initialState: boolean): AutoResetEvent$instance;
};


export interface __AutoResetEvent$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type AutoResetEvent = AutoResetEvent$instance & __AutoResetEvent$views;


export interface Barrier$instance {
    readonly CurrentPhaseNumber: long;
    readonly ParticipantCount: int;
    readonly ParticipantsRemaining: int;
    AddParticipant(): long;
    AddParticipants(participantCount: int): long;
    Dispose(): void;
    RemoveParticipant(): void;
    RemoveParticipants(participantCount: int): void;
    SignalAndWait(): void;
    SignalAndWait(cancellationToken: CancellationToken): void;
    SignalAndWait(timeout: TimeSpan): boolean;
    SignalAndWait(timeout: TimeSpan, cancellationToken: CancellationToken): boolean;
    SignalAndWait(millisecondsTimeout: int): boolean;
    SignalAndWait(millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
}


export const Barrier: {
    new(participantCount: int): Barrier$instance;
    new(participantCount: int, postPhaseAction: Action_1<Barrier>): Barrier$instance;
};


export interface __Barrier$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Barrier$instance extends System_Internal.IDisposable$instance {}

export type Barrier = Barrier$instance & __Barrier$views;


export interface BarrierPostPhaseException$instance extends Exception {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const BarrierPostPhaseException: {
    new(): BarrierPostPhaseException$instance;
    new(innerException: Exception): BarrierPostPhaseException$instance;
    new(message: string): BarrierPostPhaseException$instance;
    new(message: string, innerException: Exception): BarrierPostPhaseException$instance;
};


export interface __BarrierPostPhaseException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type BarrierPostPhaseException = BarrierPostPhaseException$instance & __BarrierPostPhaseException$views;


export interface CancellationTokenSource$instance {
    readonly IsCancellationRequested: boolean;
    readonly Token: CancellationToken;
    Cancel(): void;
    Cancel(throwOnFirstException: boolean): void;
    CancelAfter(delay: TimeSpan): void;
    CancelAfter(millisecondsDelay: int): void;
    CancelAsync(): Task;
    Dispose(): void;
    TryReset(): boolean;
}


export const CancellationTokenSource: {
    new(): CancellationTokenSource$instance;
    new(delay: TimeSpan): CancellationTokenSource$instance;
    new(delay: TimeSpan, timeProvider: TimeProvider): CancellationTokenSource$instance;
    new(millisecondsDelay: int): CancellationTokenSource$instance;
    CreateLinkedTokenSource(tokens: ReadOnlySpan_1<CancellationToken>): CancellationTokenSource;
    CreateLinkedTokenSource(token1: CancellationToken, token2: CancellationToken): CancellationTokenSource;
    CreateLinkedTokenSource(token: CancellationToken): CancellationTokenSource;
    CreateLinkedTokenSource(tokens: CancellationToken[]): CancellationTokenSource;
};


export interface __CancellationTokenSource$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface CancellationTokenSource$instance extends System_Internal.IDisposable$instance {}

export type CancellationTokenSource = CancellationTokenSource$instance & __CancellationTokenSource$views;


export interface CompressedStack$instance {
    CreateCopy(): CompressedStack;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const CompressedStack: {
    new(): CompressedStack$instance;
    Capture(): CompressedStack;
    GetCompressedStack(): CompressedStack;
    Run(compressedStack: CompressedStack, callback: ContextCallback, state: unknown): void;
};


export interface __CompressedStack$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface CompressedStack$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type CompressedStack = CompressedStack$instance & __CompressedStack$views;


export interface CountdownEvent$instance {
    readonly CurrentCount: int;
    readonly InitialCount: int;
    readonly IsSet: boolean;
    readonly WaitHandle: WaitHandle;
    AddCount(): void;
    AddCount(signalCount: int): void;
    Dispose(): void;
    Reset(): void;
    Reset(count: int): void;
    Signal(): boolean;
    Signal(signalCount: int): boolean;
    TryAddCount(): boolean;
    TryAddCount(signalCount: int): boolean;
    Wait(): void;
    Wait(cancellationToken: CancellationToken): void;
    Wait(timeout: TimeSpan): boolean;
    Wait(timeout: TimeSpan, cancellationToken: CancellationToken): boolean;
    Wait(millisecondsTimeout: int): boolean;
    Wait(millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
}


export const CountdownEvent: {
    new(initialCount: int): CountdownEvent$instance;
};


export interface __CountdownEvent$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface CountdownEvent$instance extends System_Internal.IDisposable$instance {}

export type CountdownEvent = CountdownEvent$instance & __CountdownEvent$views;


export interface EventWaitHandle$instance extends WaitHandle$instance {
    Dispose(): void;
    Reset(): boolean;
    Set(): boolean;
}


export const EventWaitHandle: {
    new(initialState: boolean, mode: EventResetMode): EventWaitHandle$instance;
    new(initialState: boolean, mode: EventResetMode, name: string, options: NamedWaitHandleOptions): EventWaitHandle$instance;
    new(initialState: boolean, mode: EventResetMode, name: string): EventWaitHandle$instance;
    new(initialState: boolean, mode: EventResetMode, name: string, options: NamedWaitHandleOptions, createdNew: ref<boolean>): EventWaitHandle$instance;
    new(initialState: boolean, mode: EventResetMode, name: string, createdNew: ref<boolean>): EventWaitHandle$instance;
    OpenExisting(name: string, options: NamedWaitHandleOptions): EventWaitHandle;
    OpenExisting(name: string): EventWaitHandle;
    TryOpenExisting(name: string, result: { value: ref<EventWaitHandle> }): boolean;
    TryOpenExisting(name: string, options: NamedWaitHandleOptions, result: { value: ref<EventWaitHandle> }): boolean;
};


export interface __EventWaitHandle$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type EventWaitHandle = EventWaitHandle$instance & __EventWaitHandle$views;


export interface ExecutionContext$instance {
    CreateCopy(): ExecutionContext;
    Dispose(): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const ExecutionContext: {
    new(): ExecutionContext$instance;
    Capture(): ExecutionContext;
    IsFlowSuppressed(): boolean;
    Restore(executionContext: ExecutionContext): void;
    RestoreFlow(): void;
    Run(executionContext: ExecutionContext, callback: ContextCallback, state: unknown): void;
    SuppressFlow(): AsyncFlowControl;
};


export interface __ExecutionContext$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface ExecutionContext$instance extends System_Internal.IDisposable$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type ExecutionContext = ExecutionContext$instance & __ExecutionContext$views;


export interface HostExecutionContext$instance {
    CreateCopy(): HostExecutionContext;
    Dispose(): void;
    Dispose(disposing: boolean): void;
}


export const HostExecutionContext: {
    new(): HostExecutionContext$instance;
    new(state: unknown): HostExecutionContext$instance;
};


export interface __HostExecutionContext$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type HostExecutionContext = HostExecutionContext$instance & __HostExecutionContext$views;


export interface HostExecutionContextManager$instance {
    Capture(): HostExecutionContext;
    Revert(previousState: unknown): void;
    SetHostExecutionContext(hostExecutionContext: HostExecutionContext): unknown;
}


export const HostExecutionContextManager: {
    new(): HostExecutionContextManager$instance;
};


export type HostExecutionContextManager = HostExecutionContextManager$instance;

export interface Lock$instance {
    readonly IsHeldByCurrentThread: boolean;
    Enter(): void;
    EnterScope(): Lock_Scope;
    Exit(): void;
    TryEnter(): boolean;
    TryEnter(millisecondsTimeout: int): boolean;
    TryEnter(timeout: TimeSpan): boolean;
}


export const Lock: {
    new(): Lock$instance;
};


export type Lock = Lock$instance;

export interface LockRecursionException$instance extends Exception {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const LockRecursionException: {
    new(): LockRecursionException$instance;
    new(message: string): LockRecursionException$instance;
    new(message: string, innerException: Exception): LockRecursionException$instance;
};


export interface __LockRecursionException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type LockRecursionException = LockRecursionException$instance & __LockRecursionException$views;


export interface ManualResetEvent$instance extends EventWaitHandle$instance {
    Dispose(): void;
}


export const ManualResetEvent: {
    new(initialState: boolean): ManualResetEvent$instance;
};


export interface __ManualResetEvent$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ManualResetEvent = ManualResetEvent$instance & __ManualResetEvent$views;


export interface ManualResetEventSlim$instance {
    readonly IsSet: boolean;
    readonly SpinCount: int;
    readonly WaitHandle: WaitHandle;
    Dispose(): void;
    Reset(): void;
    Set(): void;
    Wait(): void;
    Wait(cancellationToken: CancellationToken): void;
    Wait(timeout: TimeSpan): boolean;
    Wait(timeout: TimeSpan, cancellationToken: CancellationToken): boolean;
    Wait(millisecondsTimeout: int): boolean;
    Wait(millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
}


export const ManualResetEventSlim: {
    new(): ManualResetEventSlim$instance;
    new(initialState: boolean): ManualResetEventSlim$instance;
    new(initialState: boolean, spinCount: int): ManualResetEventSlim$instance;
};


export interface __ManualResetEventSlim$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ManualResetEventSlim$instance extends System_Internal.IDisposable$instance {}

export type ManualResetEventSlim = ManualResetEventSlim$instance & __ManualResetEventSlim$views;


export interface Mutex$instance extends WaitHandle$instance {
    Dispose(): void;
    ReleaseMutex(): void;
}


export const Mutex: {
    new(initiallyOwned: boolean, name: string, options: NamedWaitHandleOptions, createdNew: ref<boolean>): Mutex$instance;
    new(initiallyOwned: boolean, name: string, createdNew: ref<boolean>): Mutex$instance;
    new(initiallyOwned: boolean, name: string, options: NamedWaitHandleOptions): Mutex$instance;
    new(initiallyOwned: boolean, name: string): Mutex$instance;
    new(name: string, options: NamedWaitHandleOptions): Mutex$instance;
    new(initiallyOwned: boolean): Mutex$instance;
    new(): Mutex$instance;
    OpenExisting(name: string, options: NamedWaitHandleOptions): Mutex;
    OpenExisting(name: string): Mutex;
    TryOpenExisting(name: string, result: { value: ref<Mutex> }): boolean;
    TryOpenExisting(name: string, options: NamedWaitHandleOptions, result: { value: ref<Mutex> }): boolean;
};


export interface __Mutex$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type Mutex = Mutex$instance & __Mutex$views;


export interface Overlapped$instance {
    AsyncResult: IAsyncResult;
    EventHandle: int;
    EventHandleIntPtr: nint;
    OffsetHigh: int;
    OffsetLow: int;
    Pack(iocb: IOCompletionCallback): ptr<NativeOverlapped>;
    Pack(iocb: IOCompletionCallback, userData: unknown): ptr<NativeOverlapped>;
    UnsafePack(iocb: IOCompletionCallback): ptr<NativeOverlapped>;
    UnsafePack(iocb: IOCompletionCallback, userData: unknown): ptr<NativeOverlapped>;
}


export const Overlapped: {
    new(): Overlapped$instance;
    new(offsetLo: int, offsetHi: int, hEvent: nint, ar: IAsyncResult): Overlapped$instance;
    new(offsetLo: int, offsetHi: int, hEvent: int, ar: IAsyncResult): Overlapped$instance;
    Free(nativeOverlappedPtr: ptr<NativeOverlapped>): void;
    Unpack(nativeOverlappedPtr: ptr<NativeOverlapped>): Overlapped;
};


export type Overlapped = Overlapped$instance;

export interface PeriodicTimer$instance {
    Period: TimeSpan;
    Dispose(): void;
    WaitForNextTickAsync(cancellationToken?: CancellationToken): ValueTask_1<CLROf<boolean>>;
}


export const PeriodicTimer: {
    new(period: TimeSpan): PeriodicTimer$instance;
    new(period: TimeSpan, timeProvider: TimeProvider): PeriodicTimer$instance;
};


export interface __PeriodicTimer$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface PeriodicTimer$instance extends System_Internal.IDisposable$instance {}

export type PeriodicTimer = PeriodicTimer$instance & __PeriodicTimer$views;


export interface PreAllocatedOverlapped$instance {
    Dispose(): void;
}


export const PreAllocatedOverlapped: {
    new(callback: IOCompletionCallback, state: unknown, pinData: unknown): PreAllocatedOverlapped$instance;
    UnsafeCreate(callback: IOCompletionCallback, state: unknown, pinData: unknown): PreAllocatedOverlapped;
};


export interface __PreAllocatedOverlapped$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface PreAllocatedOverlapped$instance extends System_Internal.IDisposable$instance {}

export type PreAllocatedOverlapped = PreAllocatedOverlapped$instance & __PreAllocatedOverlapped$views;


export interface ReaderWriterLock$instance extends CriticalFinalizerObject {
    readonly IsReaderLockHeld: boolean;
    readonly IsWriterLockHeld: boolean;
    readonly WriterSeqNum: int;
    AcquireReaderLock(millisecondsTimeout: int): void;
    AcquireReaderLock(timeout: TimeSpan): void;
    AcquireWriterLock(millisecondsTimeout: int): void;
    AcquireWriterLock(timeout: TimeSpan): void;
    AnyWritersSince(seqNum: int): boolean;
    DowngradeFromWriterLock(lockCookie: { value: ref<LockCookie> }): void;
    ReleaseLock(): LockCookie;
    ReleaseReaderLock(): void;
    ReleaseWriterLock(): void;
    RestoreLock(lockCookie: { value: ref<LockCookie> }): void;
    UpgradeToWriterLock(millisecondsTimeout: int): LockCookie;
    UpgradeToWriterLock(timeout: TimeSpan): LockCookie;
}


export const ReaderWriterLock: {
    new(): ReaderWriterLock$instance;
};


export type ReaderWriterLock = ReaderWriterLock$instance;

export interface ReaderWriterLockSlim$instance {
    readonly CurrentReadCount: int;
    readonly IsReadLockHeld: boolean;
    readonly IsUpgradeableReadLockHeld: boolean;
    readonly IsWriteLockHeld: boolean;
    readonly RecursionPolicy: LockRecursionPolicy;
    readonly RecursiveReadCount: int;
    readonly RecursiveUpgradeCount: int;
    readonly RecursiveWriteCount: int;
    readonly WaitingReadCount: int;
    readonly WaitingUpgradeCount: int;
    readonly WaitingWriteCount: int;
    Dispose(): void;
    EnterReadLock(): void;
    EnterUpgradeableReadLock(): void;
    EnterWriteLock(): void;
    ExitReadLock(): void;
    ExitUpgradeableReadLock(): void;
    ExitWriteLock(): void;
    TryEnterReadLock(timeout: TimeSpan): boolean;
    TryEnterReadLock(millisecondsTimeout: int): boolean;
    TryEnterUpgradeableReadLock(timeout: TimeSpan): boolean;
    TryEnterUpgradeableReadLock(millisecondsTimeout: int): boolean;
    TryEnterWriteLock(timeout: TimeSpan): boolean;
    TryEnterWriteLock(millisecondsTimeout: int): boolean;
}


export const ReaderWriterLockSlim: {
    new(): ReaderWriterLockSlim$instance;
    new(recursionPolicy: LockRecursionPolicy): ReaderWriterLockSlim$instance;
};


export interface __ReaderWriterLockSlim$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ReaderWriterLockSlim$instance extends System_Internal.IDisposable$instance {}

export type ReaderWriterLockSlim = ReaderWriterLockSlim$instance & __ReaderWriterLockSlim$views;


export interface RegisteredWaitHandle$instance extends MarshalByRefObject {
    Unregister(waitObject: WaitHandle): boolean;
}


export const RegisteredWaitHandle: {
    new(): RegisteredWaitHandle$instance;
};


export type RegisteredWaitHandle = RegisteredWaitHandle$instance;

export interface Semaphore$instance extends WaitHandle$instance {
    Dispose(): void;
    Release(): int;
    Release(releaseCount: int): int;
}


export const Semaphore: {
    new(initialCount: int, maximumCount: int): Semaphore$instance;
    new(initialCount: int, maximumCount: int, name: string, options: NamedWaitHandleOptions): Semaphore$instance;
    new(initialCount: int, maximumCount: int, name: string): Semaphore$instance;
    new(initialCount: int, maximumCount: int, name: string, options: NamedWaitHandleOptions, createdNew: ref<boolean>): Semaphore$instance;
    new(initialCount: int, maximumCount: int, name: string, createdNew: ref<boolean>): Semaphore$instance;
    OpenExisting(name: string, options: NamedWaitHandleOptions): Semaphore;
    OpenExisting(name: string): Semaphore;
    TryOpenExisting(name: string, options: NamedWaitHandleOptions, result: { value: ref<Semaphore> }): boolean;
    TryOpenExisting(name: string, result: { value: ref<Semaphore> }): boolean;
};


export interface __Semaphore$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type Semaphore = Semaphore$instance & __Semaphore$views;


export interface SemaphoreFullException$instance extends SystemException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SemaphoreFullException: {
    new(): SemaphoreFullException$instance;
    new(message: string): SemaphoreFullException$instance;
    new(message: string, innerException: Exception): SemaphoreFullException$instance;
};


export interface __SemaphoreFullException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SemaphoreFullException = SemaphoreFullException$instance & __SemaphoreFullException$views;


export interface SemaphoreSlim$instance {
    readonly AvailableWaitHandle: WaitHandle;
    readonly CurrentCount: int;
    Dispose(): void;
    Release(): int;
    Release(releaseCount: int): int;
    Wait(): void;
    Wait(cancellationToken: CancellationToken): void;
    Wait(timeout: TimeSpan): boolean;
    Wait(timeout: TimeSpan, cancellationToken: CancellationToken): boolean;
    Wait(millisecondsTimeout: int): boolean;
    Wait(millisecondsTimeout: int, cancellationToken: CancellationToken): boolean;
    WaitAsync(): Task;
    WaitAsync(cancellationToken: CancellationToken): Task;
    WaitAsync(millisecondsTimeout: int): Task_1<CLROf<boolean>>;
    WaitAsync(timeout: TimeSpan): Task_1<CLROf<boolean>>;
    WaitAsync(timeout: TimeSpan, cancellationToken: CancellationToken): Task_1<CLROf<boolean>>;
    WaitAsync(millisecondsTimeout: int, cancellationToken: CancellationToken): Task_1<CLROf<boolean>>;
}


export const SemaphoreSlim: {
    new(initialCount: int): SemaphoreSlim$instance;
    new(initialCount: int, maxCount: int): SemaphoreSlim$instance;
};


export interface __SemaphoreSlim$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface SemaphoreSlim$instance extends System_Internal.IDisposable$instance {}

export type SemaphoreSlim = SemaphoreSlim$instance & __SemaphoreSlim$views;


export interface SynchronizationContext$instance {
    CreateCopy(): SynchronizationContext;
    IsWaitNotificationRequired(): boolean;
    OperationCompleted(): void;
    OperationStarted(): void;
    Post(d: SendOrPostCallback, state: unknown): void;
    Send(d: SendOrPostCallback, state: unknown): void;
    Wait(waitHandles: nint[], waitAll: boolean, millisecondsTimeout: int): int;
}


export const SynchronizationContext: {
    new(): SynchronizationContext$instance;
    readonly Current: SynchronizationContext;
    SetSynchronizationContext(syncContext: SynchronizationContext): void;
};


export type SynchronizationContext = SynchronizationContext$instance;

export interface SynchronizationLockException$instance extends SystemException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SynchronizationLockException: {
    new(): SynchronizationLockException$instance;
    new(message: string): SynchronizationLockException$instance;
    new(message: string, innerException: Exception): SynchronizationLockException$instance;
};


export interface __SynchronizationLockException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type SynchronizationLockException = SynchronizationLockException$instance & __SynchronizationLockException$views;


export interface Thread$instance extends CriticalFinalizerObject {
    ApartmentState: ApartmentState;
    CurrentCulture: CultureInfo;
    CurrentUICulture: CultureInfo;
    readonly ExecutionContext: ExecutionContext;
    readonly IsAlive: boolean;
    IsBackground: boolean;
    readonly IsThreadPoolThread: boolean;
    readonly ManagedThreadId: int;
    Name: string;
    Priority: ThreadPriority;
    readonly ThreadState: ThreadState;
    Abort(): void;
    Abort(stateInfo: unknown): void;
    DisableComObjectEagerCleanup(): void;
    GetApartmentState(): ApartmentState;
    GetCompressedStack(): CompressedStack;
    GetHashCode(): int;
    Interrupt(): void;
    Join(millisecondsTimeout: int): boolean;
    Join(): void;
    Join(timeout: TimeSpan): boolean;
    Resume(): void;
    SetApartmentState(state: ApartmentState): void;
    SetCompressedStack(stack: CompressedStack): void;
    Start(parameter: unknown): void;
    Start(): void;
    Suspend(): void;
    TrySetApartmentState(state: ApartmentState): boolean;
    UnsafeStart(parameter: unknown): void;
    UnsafeStart(): void;
}


export const Thread: {
    new(start: ThreadStart): Thread$instance;
    new(start: ThreadStart, maxStackSize: int): Thread$instance;
    new(start: ParameterizedThreadStart): Thread$instance;
    new(start: ParameterizedThreadStart, maxStackSize: int): Thread$instance;
    CurrentPrincipal: IPrincipal;
    readonly CurrentThread: Thread;
    AllocateDataSlot(): LocalDataStoreSlot;
    AllocateNamedDataSlot(name: string): LocalDataStoreSlot;
    BeginCriticalRegion(): void;
    BeginThreadAffinity(): void;
    EndCriticalRegion(): void;
    EndThreadAffinity(): void;
    FreeNamedDataSlot(name: string): void;
    GetCurrentProcessorId(): int;
    GetData(slot: LocalDataStoreSlot): unknown;
    GetDomain(): AppDomain;
    GetDomainID(): int;
    GetNamedDataSlot(name: string): LocalDataStoreSlot;
    MemoryBarrier(): void;
    ResetAbort(): void;
    SetData(slot: LocalDataStoreSlot, data: unknown): void;
    Sleep(millisecondsTimeout: int): void;
    Sleep(timeout: TimeSpan): void;
    SpinWait(iterations: int): void;
    VolatileRead(address: { value: ref<byte> }): byte;
    VolatileRead(address: { value: ref<double> }): double;
    VolatileRead(address: { value: ref<short> }): short;
    VolatileRead(address: { value: ref<int> }): int;
    VolatileRead(address: { value: ref<long> }): long;
    VolatileRead(address: { value: ref<nint> }): nint;
    VolatileRead(address: { value: ref<unknown> }): unknown;
    VolatileRead(address: { value: ref<sbyte> }): sbyte;
    VolatileRead(address: { value: ref<float> }): float;
    VolatileRead(address: { value: ref<ushort> }): ushort;
    VolatileRead(address: { value: ref<uint> }): uint;
    VolatileRead(address: { value: ref<ulong> }): ulong;
    VolatileRead(address: { value: ref<nuint> }): nuint;
    VolatileWrite(address: { value: ref<byte> }, value: byte): void;
    VolatileWrite(address: { value: ref<double> }, value: double): void;
    VolatileWrite(address: { value: ref<short> }, value: short): void;
    VolatileWrite(address: { value: ref<int> }, value: int): void;
    VolatileWrite(address: { value: ref<long> }, value: long): void;
    VolatileWrite(address: { value: ref<nint> }, value: nint): void;
    VolatileWrite(address: { value: ref<unknown> }, value: unknown): void;
    VolatileWrite(address: { value: ref<sbyte> }, value: sbyte): void;
    VolatileWrite(address: { value: ref<float> }, value: float): void;
    VolatileWrite(address: { value: ref<ushort> }, value: ushort): void;
    VolatileWrite(address: { value: ref<uint> }, value: uint): void;
    VolatileWrite(address: { value: ref<ulong> }, value: ulong): void;
    VolatileWrite(address: { value: ref<nuint> }, value: nuint): void;
    Yield(): boolean;
};


export type Thread = Thread$instance;

export interface ThreadAbortException$instance extends SystemException {
    readonly ExceptionState: unknown;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const ThreadAbortException: {
    new(): ThreadAbortException$instance;
};


export interface __ThreadAbortException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ThreadAbortException = ThreadAbortException$instance & __ThreadAbortException$views;


export interface ThreadExceptionEventArgs$instance extends EventArgs {
    readonly Exception: Exception;
}


export const ThreadExceptionEventArgs: {
    new(t: Exception): ThreadExceptionEventArgs$instance;
};


export type ThreadExceptionEventArgs = ThreadExceptionEventArgs$instance;

export interface ThreadInterruptedException$instance extends SystemException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const ThreadInterruptedException: {
    new(): ThreadInterruptedException$instance;
    new(message: string): ThreadInterruptedException$instance;
    new(message: string, innerException: Exception): ThreadInterruptedException$instance;
};


export interface __ThreadInterruptedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ThreadInterruptedException = ThreadInterruptedException$instance & __ThreadInterruptedException$views;


export interface ThreadLocal_1$instance<T> {
    readonly IsValueCreated: boolean;
    Value: T;
    readonly Values: IList_1<T>;
    Dispose(): void;
    ToString(): string;
}


export const ThreadLocal_1: {
    new<T>(): ThreadLocal_1$instance<T>;
    new<T>(trackAllValues: boolean): ThreadLocal_1$instance<T>;
    new<T>(valueFactory: Func_1<T>): ThreadLocal_1$instance<T>;
    new<T>(valueFactory: Func_1<T>, trackAllValues: boolean): ThreadLocal_1$instance<T>;
};


export interface __ThreadLocal_1$views<T> {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ThreadLocal_1$instance<T> extends System_Internal.IDisposable$instance {}

export type ThreadLocal_1<T> = ThreadLocal_1$instance<T> & __ThreadLocal_1$views<T>;


export interface ThreadPoolBoundHandle$instance {
    readonly Handle: SafeHandle;
    AllocateNativeOverlapped(callback: IOCompletionCallback, state: unknown, pinData: unknown): ptr<NativeOverlapped>;
    AllocateNativeOverlapped(preAllocated: PreAllocatedOverlapped): ptr<NativeOverlapped>;
    Dispose(): void;
    FreeNativeOverlapped(overlapped: ptr<NativeOverlapped>): void;
    UnsafeAllocateNativeOverlapped(callback: IOCompletionCallback, state: unknown, pinData: unknown): ptr<NativeOverlapped>;
}


export const ThreadPoolBoundHandle: {
    new(): ThreadPoolBoundHandle$instance;
    BindHandle(handle: SafeHandle): ThreadPoolBoundHandle;
    GetNativeOverlappedState(overlapped: ptr<NativeOverlapped>): unknown;
};


export interface __ThreadPoolBoundHandle$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ThreadPoolBoundHandle$instance extends System_Internal.IDisposable$instance {}

export type ThreadPoolBoundHandle = ThreadPoolBoundHandle$instance & __ThreadPoolBoundHandle$views;


export interface ThreadStartException$instance extends SystemException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const ThreadStartException: {
    new(): ThreadStartException$instance;
};


export interface __ThreadStartException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ThreadStartException = ThreadStartException$instance & __ThreadStartException$views;


export interface ThreadStateException$instance extends SystemException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const ThreadStateException: {
    new(): ThreadStateException$instance;
    new(message: string): ThreadStateException$instance;
    new(message: string, innerException: Exception): ThreadStateException$instance;
};


export interface __ThreadStateException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type ThreadStateException = ThreadStateException$instance & __ThreadStateException$views;


export interface Timer$instance extends MarshalByRefObject {
    Change(dueTime: int, period: int): boolean;
    Change(dueTime: TimeSpan, period: TimeSpan): boolean;
    Change(dueTime: uint, period: uint): boolean;
    Change(dueTime: long, period: long): boolean;
    Dispose(notifyObject: WaitHandle): boolean;
    Dispose(): void;
    DisposeAsync(): ValueTask;
}


export const Timer: {
    new(callback: TimerCallback, state: unknown, dueTime: int, period: int): Timer$instance;
    new(callback: TimerCallback, state: unknown, dueTime: TimeSpan, period: TimeSpan): Timer$instance;
    new(callback: TimerCallback, state: unknown, dueTime: uint, period: uint): Timer$instance;
    new(callback: TimerCallback, state: unknown, dueTime: long, period: long): Timer$instance;
    new(callback: TimerCallback): Timer$instance;
    readonly ActiveCount: long;
};


export interface __Timer$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ITimer(): ITimer$instance;
}

export type Timer = Timer$instance & __Timer$views;


export interface WaitHandle$instance extends MarshalByRefObject {
    Handle: nint;
    SafeWaitHandle: SafeWaitHandle;
    Close(): void;
    Dispose(): void;
    WaitOne(millisecondsTimeout: int): boolean;
    WaitOne(timeout: TimeSpan): boolean;
    WaitOne(): boolean;
    WaitOne(millisecondsTimeout: int, exitContext: boolean): boolean;
    WaitOne(timeout: TimeSpan, exitContext: boolean): boolean;
}


export const WaitHandle: {
    readonly WaitTimeout: int;
    SignalAndWait(toSignal: WaitHandle, toWaitOn: WaitHandle, millisecondsTimeout: int, exitContext: boolean): boolean;
    SignalAndWait(toSignal: WaitHandle, toWaitOn: WaitHandle, timeout: TimeSpan, exitContext: boolean): boolean;
    SignalAndWait(toSignal: WaitHandle, toWaitOn: WaitHandle): boolean;
    WaitAll(waitHandles: WaitHandle[], millisecondsTimeout: int, exitContext: boolean): boolean;
    WaitAll(waitHandles: WaitHandle[], millisecondsTimeout: int): boolean;
    WaitAll(waitHandles: WaitHandle[], timeout: TimeSpan, exitContext: boolean): boolean;
    WaitAll(waitHandles: WaitHandle[], timeout: TimeSpan): boolean;
    WaitAll(waitHandles: WaitHandle[]): boolean;
    WaitAny(waitHandles: WaitHandle[], millisecondsTimeout: int, exitContext: boolean): int;
    WaitAny(waitHandles: WaitHandle[], millisecondsTimeout: int): int;
    WaitAny(waitHandles: WaitHandle[], timeout: TimeSpan, exitContext: boolean): int;
    WaitAny(waitHandles: WaitHandle[], timeout: TimeSpan): int;
    WaitAny(waitHandles: WaitHandle[]): int;
};


export interface __WaitHandle$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface WaitHandle$instance extends System_Internal.IDisposable$instance {}

export type WaitHandle = WaitHandle$instance & __WaitHandle$views;


export interface WaitHandleCannotBeOpenedException$instance extends ApplicationException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const WaitHandleCannotBeOpenedException: {
    new(): WaitHandleCannotBeOpenedException$instance;
    new(message: string): WaitHandleCannotBeOpenedException$instance;
    new(message: string, innerException: Exception): WaitHandleCannotBeOpenedException$instance;
};


export interface __WaitHandleCannotBeOpenedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type WaitHandleCannotBeOpenedException = WaitHandleCannotBeOpenedException$instance & __WaitHandleCannotBeOpenedException$views;


export abstract class EventWaitHandleAcl$instance {
    static Create(initialState: boolean, mode: EventResetMode, name: string, createdNew: { value: ref<boolean> }, eventSecurity: EventWaitHandleSecurity): EventWaitHandle;
    static OpenExisting(name: string, rights: EventWaitHandleRights): EventWaitHandle;
    static TryOpenExisting(name: string, rights: EventWaitHandleRights, result: { value: ref<EventWaitHandle> }): boolean;
}


export type EventWaitHandleAcl = EventWaitHandleAcl$instance;

export abstract class Interlocked$instance {
    static Add(location1: { value: ref<int> }, value: int): int;
    static Add(location1: { value: ref<long> }, value: long): long;
    static Add(location1: { value: ref<uint> }, value: uint): uint;
    static Add(location1: { value: ref<ulong> }, value: ulong): ulong;
    static And(location1: { value: ref<int> }, value: int): int;
    static And(location1: { value: ref<long> }, value: long): long;
    static And(location1: { value: ref<uint> }, value: uint): uint;
    static And(location1: { value: ref<ulong> }, value: ulong): ulong;
    static CompareExchange(location1: { value: ref<byte> }, value: byte, comparand: byte): byte;
    static CompareExchange(location1: { value: ref<double> }, value: double, comparand: double): double;
    static CompareExchange(location1: { value: ref<short> }, value: short, comparand: short): short;
    static CompareExchange(location1: { value: ref<int> }, value: int, comparand: int): int;
    static CompareExchange(location1: { value: ref<long> }, value: long, comparand: long): long;
    static CompareExchange(location1: { value: ref<nint> }, value: nint, comparand: nint): nint;
    static CompareExchange(location1: { value: ref<unknown> }, value: unknown, comparand: unknown): unknown;
    static CompareExchange(location1: { value: ref<sbyte> }, value: sbyte, comparand: sbyte): sbyte;
    static CompareExchange(location1: { value: ref<float> }, value: float, comparand: float): float;
    static CompareExchange(location1: { value: ref<ushort> }, value: ushort, comparand: ushort): ushort;
    static CompareExchange(location1: { value: ref<uint> }, value: uint, comparand: uint): uint;
    static CompareExchange(location1: { value: ref<ulong> }, value: ulong, comparand: ulong): ulong;
    static CompareExchange(location1: { value: ref<nuint> }, value: nuint, comparand: nuint): nuint;
    static CompareExchange<T>(location1: { value: ref<T> }, value: T, comparand: T): T;
    static Decrement(location: { value: ref<int> }): int;
    static Decrement(location: { value: ref<long> }): long;
    static Decrement(location: { value: ref<uint> }): uint;
    static Decrement(location: { value: ref<ulong> }): ulong;
    static Exchange(location1: { value: ref<byte> }, value: byte): byte;
    static Exchange(location1: { value: ref<double> }, value: double): double;
    static Exchange(location1: { value: ref<short> }, value: short): short;
    static Exchange(location1: { value: ref<int> }, value: int): int;
    static Exchange(location1: { value: ref<long> }, value: long): long;
    static Exchange(location1: { value: ref<nint> }, value: nint): nint;
    static Exchange(location1: { value: ref<unknown> }, value: unknown): unknown;
    static Exchange(location1: { value: ref<sbyte> }, value: sbyte): sbyte;
    static Exchange(location1: { value: ref<float> }, value: float): float;
    static Exchange(location1: { value: ref<ushort> }, value: ushort): ushort;
    static Exchange(location1: { value: ref<uint> }, value: uint): uint;
    static Exchange(location1: { value: ref<ulong> }, value: ulong): ulong;
    static Exchange(location1: { value: ref<nuint> }, value: nuint): nuint;
    static Exchange<T>(location1: { value: ref<T> }, value: T): T;
    static Increment(location: { value: ref<int> }): int;
    static Increment(location: { value: ref<long> }): long;
    static Increment(location: { value: ref<uint> }): uint;
    static Increment(location: { value: ref<ulong> }): ulong;
    static MemoryBarrier(): void;
    static MemoryBarrierProcessWide(): void;
    static Or(location1: { value: ref<int> }, value: int): int;
    static Or(location1: { value: ref<long> }, value: long): long;
    static Or(location1: { value: ref<uint> }, value: uint): uint;
    static Or(location1: { value: ref<ulong> }, value: ulong): ulong;
    static Read(location: { value: ref<long> }): long;
    static Read(location: { value: ref<ulong> }): ulong;
}


export type Interlocked = Interlocked$instance;

export abstract class LazyInitializer$instance {
    static EnsureInitialized<T>(target: { value: ref<T> }, valueFactory: Func_1<T>): T;
    static EnsureInitialized<T>(target: { value: ref<T> }, initialized: { value: ref<boolean> }, syncLock: { value: ref<unknown> }, valueFactory: Func_1<T>): T;
    static EnsureInitialized<T>(target: { value: ref<T> }, initialized: { value: ref<boolean> }, syncLock: { value: ref<unknown> }): T;
    static EnsureInitialized<T>(target: { value: ref<T> }, syncLock: { value: ref<unknown> }, valueFactory: Func_1<T>): T;
    static EnsureInitialized<T>(target: { value: ref<T> }): T;
}


export type LazyInitializer = LazyInitializer$instance;

export abstract class Monitor$instance {
    static readonly LockContentionCount: long;
    static Enter(obj: unknown, lockTaken: { value: ref<boolean> }): void;
    static Enter(obj: unknown): void;
    static Exit(obj: unknown): void;
    static IsEntered(obj: unknown): boolean;
    static Pulse(obj: unknown): void;
    static PulseAll(obj: unknown): void;
    static TryEnter(obj: unknown, lockTaken: { value: ref<boolean> }): void;
    static TryEnter(obj: unknown, millisecondsTimeout: int, lockTaken: { value: ref<boolean> }): void;
    static TryEnter(obj: unknown, millisecondsTimeout: int): boolean;
    static TryEnter(obj: unknown, timeout: TimeSpan, lockTaken: { value: ref<boolean> }): void;
    static TryEnter(obj: unknown, timeout: TimeSpan): boolean;
    static TryEnter(obj: unknown): boolean;
    static Wait(obj: unknown, millisecondsTimeout: int, exitContext: boolean): boolean;
    static Wait(obj: unknown, millisecondsTimeout: int): boolean;
    static Wait(obj: unknown, timeout: TimeSpan, exitContext: boolean): boolean;
    static Wait(obj: unknown, timeout: TimeSpan): boolean;
    static Wait(obj: unknown): boolean;
}


export type Monitor = Monitor$instance;

export abstract class MutexAcl$instance {
    static Create(initiallyOwned: boolean, name: string, createdNew: { value: ref<boolean> }, mutexSecurity: MutexSecurity): Mutex;
    static OpenExisting(name: string, rights: MutexRights): Mutex;
    static TryOpenExisting(name: string, rights: MutexRights, result: { value: ref<Mutex> }): boolean;
}


export type MutexAcl = MutexAcl$instance;

export abstract class SemaphoreAcl$instance {
    static Create(initialCount: int, maximumCount: int, name: string, createdNew: { value: ref<boolean> }, semaphoreSecurity: SemaphoreSecurity): Semaphore;
    static OpenExisting(name: string, rights: SemaphoreRights): Semaphore;
    static TryOpenExisting(name: string, rights: SemaphoreRights, result: { value: ref<Semaphore> }): boolean;
}


export type SemaphoreAcl = SemaphoreAcl$instance;

export abstract class ThreadingAclExtensions$instance {
    static GetAccessControl(handle: EventWaitHandle): EventWaitHandleSecurity;
    static GetAccessControl(mutex: Mutex): MutexSecurity;
    static GetAccessControl(semaphore: Semaphore): SemaphoreSecurity;
    static SetAccessControl(handle: EventWaitHandle, eventSecurity: EventWaitHandleSecurity): void;
    static SetAccessControl(mutex: Mutex, mutexSecurity: MutexSecurity): void;
    static SetAccessControl(semaphore: Semaphore, semaphoreSecurity: SemaphoreSecurity): void;
}


export type ThreadingAclExtensions = ThreadingAclExtensions$instance;

export abstract class ThreadPool$instance {
    static readonly PendingWorkItemCount: long;
    static readonly ThreadCount: int;
    static readonly CompletedWorkItemCount: long;
    static BindHandle(osHandle: nint): boolean;
    static BindHandle(osHandle: SafeHandle): boolean;
    static GetAvailableThreads(workerThreads: { value: ref<int> }, completionPortThreads: { value: ref<int> }): void;
    static GetMaxThreads(workerThreads: { value: ref<int> }, completionPortThreads: { value: ref<int> }): void;
    static GetMinThreads(workerThreads: { value: ref<int> }, completionPortThreads: { value: ref<int> }): void;
    static QueueUserWorkItem<TState>(callBack: Action_1<TState>, state: TState, preferLocal: boolean): boolean;
    static QueueUserWorkItem(callBack: WaitCallback, state: unknown): boolean;
    static QueueUserWorkItem(callBack: WaitCallback): boolean;
    static RegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: unknown, millisecondsTimeOutInterval: int, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static RegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: unknown, millisecondsTimeOutInterval: long, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static RegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: unknown, timeout: TimeSpan, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static RegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: unknown, millisecondsTimeOutInterval: uint, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static SetMaxThreads(workerThreads: int, completionPortThreads: int): boolean;
    static SetMinThreads(workerThreads: int, completionPortThreads: int): boolean;
    static UnsafeQueueNativeOverlapped(overlapped: ptr<NativeOverlapped>): boolean;
    static UnsafeQueueUserWorkItem<TState>(callBack: Action_1<TState>, state: TState, preferLocal: boolean): boolean;
    static UnsafeQueueUserWorkItem(callBack: IThreadPoolWorkItem, preferLocal: boolean): boolean;
    static UnsafeQueueUserWorkItem(callBack: WaitCallback, state: unknown): boolean;
    static UnsafeRegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: unknown, millisecondsTimeOutInterval: int, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static UnsafeRegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: unknown, millisecondsTimeOutInterval: long, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static UnsafeRegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: unknown, timeout: TimeSpan, executeOnlyOnce: boolean): RegisteredWaitHandle;
    static UnsafeRegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: unknown, millisecondsTimeOutInterval: uint, executeOnlyOnce: boolean): RegisteredWaitHandle;
}


export type ThreadPool = ThreadPool$instance;

export abstract class Timeout$instance {
    static readonly InfiniteTimeSpan: TimeSpan;
    static readonly Infinite: int;
}


export type Timeout = Timeout$instance;

export abstract class Volatile$instance {
    static Read(location: { value: ref<boolean> }): boolean;
    static Read(location: { value: ref<byte> }): byte;
    static Read(location: { value: ref<double> }): double;
    static Read(location: { value: ref<short> }): short;
    static Read(location: { value: ref<int> }): int;
    static Read(location: { value: ref<long> }): long;
    static Read(location: { value: ref<nint> }): nint;
    static Read(location: { value: ref<sbyte> }): sbyte;
    static Read(location: { value: ref<float> }): float;
    static Read(location: { value: ref<ushort> }): ushort;
    static Read(location: { value: ref<uint> }): uint;
    static Read(location: { value: ref<ulong> }): ulong;
    static Read(location: { value: ref<nuint> }): nuint;
    static Read<T>(location: { value: ref<T> }): T;
    static ReadBarrier(): void;
    static Write(location: { value: ref<boolean> }, value: boolean): void;
    static Write(location: { value: ref<byte> }, value: byte): void;
    static Write(location: { value: ref<double> }, value: double): void;
    static Write(location: { value: ref<short> }, value: short): void;
    static Write(location: { value: ref<int> }, value: int): void;
    static Write(location: { value: ref<long> }, value: long): void;
    static Write(location: { value: ref<nint> }, value: nint): void;
    static Write(location: { value: ref<sbyte> }, value: sbyte): void;
    static Write(location: { value: ref<float> }, value: float): void;
    static Write(location: { value: ref<ushort> }, value: ushort): void;
    static Write(location: { value: ref<uint> }, value: uint): void;
    static Write(location: { value: ref<ulong> }, value: ulong): void;
    static Write(location: { value: ref<nuint> }, value: nuint): void;
    static Write<T>(location: { value: ref<T> }, value: T): void;
    static WriteBarrier(): void;
}


export type Volatile = Volatile$instance;

export abstract class WaitHandleExtensions$instance {
    static GetSafeWaitHandle(waitHandle: WaitHandle): SafeWaitHandle;
    static SetSafeWaitHandle(waitHandle: WaitHandle, value: SafeWaitHandle): void;
}


export type WaitHandleExtensions = WaitHandleExtensions$instance;


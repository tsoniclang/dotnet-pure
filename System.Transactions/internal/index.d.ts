// Generated by tsbindgen - Architecture
// Namespace: System.Transactions
// Assembly: System.Transactions.Local

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import type { IDictionary } from "../../System.Collections/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { WaitHandle } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { AsyncCallback, Boolean as ClrBoolean, Byte, DateTime, Delegate, Enum, EventArgs, Exception, Guid, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, MulticastDelegate, Object as ClrObject, String as ClrString, SystemException, TimeSpan, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

export enum DependentCloneOption {
    BlockCommitUntilComplete = 0,
    RollbackIfNotComplete = 1
}


export enum EnlistmentOptions {
    None = 0,
    EnlistDuringPrepareRequired = 1
}


export enum EnterpriseServicesInteropOption {
    None = 0,
    Automatic = 1,
    Full = 2
}


export enum IsolationLevel {
    Serializable = 0,
    RepeatableRead = 1,
    ReadCommitted = 2,
    ReadUncommitted = 3,
    Snapshot = 4,
    Chaos = 5,
    Unspecified = 6
}


export enum TransactionScopeAsyncFlowOption {
    Suppress = 0,
    Enabled = 1
}


export enum TransactionScopeOption {
    Required = 0,
    RequiresNew = 1,
    Suppress = 2
}


export enum TransactionStatus {
    Active = 0,
    Committed = 1,
    Aborted = 2,
    InDoubt = 3
}


export type HostCurrentTransactionCallback = () => Transaction;


export type TransactionCompletedEventHandler = (sender: unknown, e: TransactionEventArgs) => void;


export type TransactionStartedEventHandler = (sender: unknown, e: TransactionEventArgs) => void;


export interface IDtcTransaction$instance {
    Abort(reason: nint, retaining: int, async_: int): void;
    Commit(retaining: int, commitType: int, reserved: int): void;
    GetTransactionInfo(transactionInformation: nint): void;
}


export type IDtcTransaction = IDtcTransaction$instance;

export interface IEnlistmentNotification$instance {
    Commit(enlistment: Enlistment): void;
    Prepare(preparingEnlistment: PreparingEnlistment): void;
}


export type IEnlistmentNotification = IEnlistmentNotification$instance;

export interface IPromotableSinglePhaseNotification$instance extends ITransactionPromoter {
    Initialize(): void;
    Promote(): byte[] | undefined;
    SinglePhaseCommit(singlePhaseEnlistment: SinglePhaseEnlistment): void;
}


export interface IPromotableSinglePhaseNotification$instance extends ITransactionPromoter$instance {}

export type IPromotableSinglePhaseNotification = IPromotableSinglePhaseNotification$instance;

export interface ISimpleTransactionSuperior$instance extends ITransactionPromoter {
    Promote(): byte[] | undefined;
    Rollback(): void;
}


export interface ISimpleTransactionSuperior$instance extends ITransactionPromoter$instance {}

export type ISimpleTransactionSuperior = ISimpleTransactionSuperior$instance;

export interface ISinglePhaseNotification$instance extends IEnlistmentNotification {
    Commit(enlistment: Enlistment): void;
    Prepare(preparingEnlistment: PreparingEnlistment): void;
    SinglePhaseCommit(singlePhaseEnlistment: SinglePhaseEnlistment): void;
}


export interface ISinglePhaseNotification$instance extends IEnlistmentNotification$instance {}

export type ISinglePhaseNotification = ISinglePhaseNotification$instance;

export interface ITransactionPromoter$instance {
    Promote(): byte[] | undefined;
}


export type ITransactionPromoter = ITransactionPromoter$instance;

export interface TransactionOptions$instance {
    IsolationLevel: IsolationLevel;
    Timeout: TimeSpan;
    Equals(obj: unknown): boolean;
    Equals(other: TransactionOptions): boolean;
    GetHashCode(): int;
}


export const TransactionOptions: {
    new(): TransactionOptions;
};


export interface __TransactionOptions$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<TransactionOptions>;

    // Structural method bridges for numeric interface constraints
    Equals(other: TransactionOptions): boolean;
}

export type TransactionOptions = TransactionOptions$instance & __TransactionOptions$views;


export interface CommittableTransaction$instance extends Transaction$instance {
    BeginCommit(asyncCallback: AsyncCallback, asyncState: unknown): IAsyncResult;
    Commit(): void;
    Dispose(): void;
    EndCommit(asyncResult: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const CommittableTransaction: {
    new(): CommittableTransaction;
    new(timeout: TimeSpan): CommittableTransaction;
    new(options: TransactionOptions): CommittableTransaction;
};


export interface __CommittableTransaction$views {
    As_IAsyncResult(): System_Internal.IAsyncResult$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface CommittableTransaction$instance extends System_Internal.IAsyncResult$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type CommittableTransaction = CommittableTransaction$instance & __CommittableTransaction$views;


export interface DependentTransaction$instance extends Transaction$instance {
    Complete(): void;
    Dispose(): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const DependentTransaction: {
    new(): DependentTransaction;
};


export interface __DependentTransaction$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface DependentTransaction$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type DependentTransaction = DependentTransaction$instance & __DependentTransaction$views;


export interface Enlistment$instance {
    Done(): void;
}


export const Enlistment: {
    new(): Enlistment;
};


export type Enlistment = Enlistment$instance;

export interface PreparingEnlistment$instance extends Enlistment {
    ForceRollback(): void;
    ForceRollback(e: Exception): void;
    Prepared(): void;
    RecoveryInformation(): byte[];
}


export const PreparingEnlistment: {
    new(): PreparingEnlistment;
};


export type PreparingEnlistment = PreparingEnlistment$instance;

export interface SinglePhaseEnlistment$instance extends Enlistment {
    Aborted(): void;
    Aborted(e: Exception): void;
    Committed(): void;
    InDoubt(): void;
    InDoubt(e: Exception): void;
}


export const SinglePhaseEnlistment: {
    new(): SinglePhaseEnlistment;
};


export type SinglePhaseEnlistment = SinglePhaseEnlistment$instance;

export interface SubordinateTransaction$instance extends Transaction$instance {
    Dispose(): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SubordinateTransaction: {
    new(isoLevel: IsolationLevel, superior: ISimpleTransactionSuperior): SubordinateTransaction;
};


export interface __SubordinateTransaction$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface SubordinateTransaction$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type SubordinateTransaction = SubordinateTransaction$instance & __SubordinateTransaction$views;


export interface Transaction$instance {
    readonly IsolationLevel: IsolationLevel;
    readonly PromoterType: Guid;
    readonly TransactionInformation: TransactionInformation;
    Clone(): Transaction;
    DependentClone(cloneOption: DependentCloneOption): DependentTransaction;
    Dispose(): void;
    EnlistDurable(resourceManagerIdentifier: Guid, enlistmentNotification: IEnlistmentNotification, enlistmentOptions: EnlistmentOptions): Enlistment;
    EnlistDurable(resourceManagerIdentifier: Guid, singlePhaseNotification: ISinglePhaseNotification, enlistmentOptions: EnlistmentOptions): Enlistment;
    EnlistPromotableSinglePhase(promotableSinglePhaseNotification: IPromotableSinglePhaseNotification): boolean;
    EnlistPromotableSinglePhase(promotableSinglePhaseNotification: IPromotableSinglePhaseNotification, promoterType: Guid): boolean;
    EnlistVolatile(enlistmentNotification: IEnlistmentNotification, enlistmentOptions: EnlistmentOptions): Enlistment;
    EnlistVolatile(singlePhaseNotification: ISinglePhaseNotification, enlistmentOptions: EnlistmentOptions): Enlistment;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    GetPromotedToken(): byte[];
    PromoteAndEnlistDurable(resourceManagerIdentifier: Guid, promotableNotification: IPromotableSinglePhaseNotification, enlistmentNotification: ISinglePhaseNotification, enlistmentOptions: EnlistmentOptions): Enlistment;
    Rollback(): void;
    Rollback(e: Exception): void;
    SetDistributedTransactionIdentifier(promotableNotification: IPromotableSinglePhaseNotification, distributedTransactionIdentifier: Guid): void;
}


export const Transaction: {
    new(): Transaction;
    get Current(): Transaction | undefined;
    set Current(value: Transaction);
};


export interface __Transaction$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Transaction$instance extends System_Internal.IDisposable$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Transaction = Transaction$instance & __Transaction$views;


export interface TransactionAbortedException$instance extends TransactionException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TransactionAbortedException: {
    new(): TransactionAbortedException;
    new(message: string): TransactionAbortedException;
    new(message: string, innerException: Exception): TransactionAbortedException;
};


export interface __TransactionAbortedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionAbortedException = TransactionAbortedException$instance & __TransactionAbortedException$views;


export interface TransactionEventArgs$instance extends EventArgs {
    readonly Transaction: Transaction | undefined;
}


export const TransactionEventArgs: {
    new(): TransactionEventArgs;
};


export type TransactionEventArgs = TransactionEventArgs$instance;

export interface TransactionException$instance extends SystemException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TransactionException: {
    new(): TransactionException;
    new(message: string): TransactionException;
    new(message: string, innerException: Exception): TransactionException;
};


export interface __TransactionException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionException = TransactionException$instance & __TransactionException$views;


export interface TransactionInDoubtException$instance extends TransactionException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TransactionInDoubtException: {
    new(): TransactionInDoubtException;
    new(message: string): TransactionInDoubtException;
    new(message: string, innerException: Exception): TransactionInDoubtException;
};


export interface __TransactionInDoubtException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionInDoubtException = TransactionInDoubtException$instance & __TransactionInDoubtException$views;


export interface TransactionInformation$instance {
    readonly CreationTime: DateTime;
    readonly DistributedIdentifier: Guid;
    readonly LocalIdentifier: string;
    readonly Status: TransactionStatus;
}


export const TransactionInformation: {
    new(): TransactionInformation;
};


export type TransactionInformation = TransactionInformation$instance;

export interface TransactionManagerCommunicationException$instance extends TransactionException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TransactionManagerCommunicationException: {
    new(): TransactionManagerCommunicationException;
    new(message: string): TransactionManagerCommunicationException;
    new(message: string, innerException: Exception): TransactionManagerCommunicationException;
};


export interface __TransactionManagerCommunicationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionManagerCommunicationException = TransactionManagerCommunicationException$instance & __TransactionManagerCommunicationException$views;


export interface TransactionPromotionException$instance extends TransactionException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TransactionPromotionException: {
    new(): TransactionPromotionException;
    new(message: string): TransactionPromotionException;
    new(message: string, innerException: Exception): TransactionPromotionException;
};


export interface __TransactionPromotionException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionPromotionException = TransactionPromotionException$instance & __TransactionPromotionException$views;


export interface TransactionScope$instance {
    Complete(): void;
    Dispose(): void;
}


export const TransactionScope: {
    new(): TransactionScope;
    new(scopeOption: TransactionScopeOption): TransactionScope;
    new(asyncFlowOption: TransactionScopeAsyncFlowOption): TransactionScope;
    new(scopeOption: TransactionScopeOption, asyncFlowOption: TransactionScopeAsyncFlowOption): TransactionScope;
    new(scopeOption: TransactionScopeOption, scopeTimeout: TimeSpan): TransactionScope;
    new(scopeOption: TransactionScopeOption, scopeTimeout: TimeSpan, asyncFlowOption: TransactionScopeAsyncFlowOption): TransactionScope;
    new(scopeOption: TransactionScopeOption, transactionOptions: TransactionOptions): TransactionScope;
    new(scopeOption: TransactionScopeOption, transactionOptions: TransactionOptions, asyncFlowOption: TransactionScopeAsyncFlowOption): TransactionScope;
    new(scopeOption: TransactionScopeOption, transactionOptions: TransactionOptions, interopOption: EnterpriseServicesInteropOption): TransactionScope;
    new(transactionToUse: Transaction): TransactionScope;
    new(transactionToUse: Transaction, asyncFlowOption: TransactionScopeAsyncFlowOption): TransactionScope;
    new(transactionToUse: Transaction, scopeTimeout: TimeSpan): TransactionScope;
    new(transactionToUse: Transaction, scopeTimeout: TimeSpan, asyncFlowOption: TransactionScopeAsyncFlowOption): TransactionScope;
    new(transactionToUse: Transaction, scopeTimeout: TimeSpan, interopOption: EnterpriseServicesInteropOption): TransactionScope;
};


export interface __TransactionScope$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface TransactionScope$instance extends System_Internal.IDisposable$instance {}

export type TransactionScope = TransactionScope$instance & __TransactionScope$views;


export abstract class TransactionInterop$instance {
    static readonly PromoterTypeDtc: Guid;
    static GetDtcTransaction(transaction: Transaction): IDtcTransaction;
    static GetExportCookie(transaction: Transaction, whereabouts: byte[]): byte[];
    static GetTransactionFromDtcTransaction(transactionNative: IDtcTransaction): Transaction;
    static GetTransactionFromExportCookie(cookie: byte[]): Transaction;
    static GetTransactionFromTransmitterPropagationToken(propagationToken: byte[]): Transaction;
    static GetTransmitterPropagationToken(transaction: Transaction): byte[];
    static GetWhereabouts(): byte[];
}


export type TransactionInterop = TransactionInterop$instance;

export abstract class TransactionManager$instance {
    static get HostCurrentCallback(): HostCurrentTransactionCallback | undefined;
    static set HostCurrentCallback(value: HostCurrentTransactionCallback);
    static DefaultTimeout: TimeSpan;
    static MaximumTimeout: TimeSpan;
    static ImplicitDistributedTransactions: boolean;
    static RecoveryComplete(resourceManagerIdentifier: Guid): void;
    static Reenlist(resourceManagerIdentifier: Guid, recoveryInformation: byte[], enlistmentNotification: IEnlistmentNotification): Enlistment;
}


export type TransactionManager = TransactionManager$instance;


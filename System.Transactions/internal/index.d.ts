// Generated by tsbindgen - Architecture
// Namespace: System.Transactions
// Assembly: System.Transactions.Local

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { IDictionary } from "../../System.Collections/internal/index.js";
import type { MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { WaitHandle } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { AsyncCallback, Boolean as ClrBoolean, Byte, DateTime, Delegate, Enum, EventArgs, Exception, Guid, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int32, IntPtr, ISpanFormattable, MulticastDelegate, Object as ClrObject, String as ClrString, SystemException, TimeSpan, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum DependentCloneOption {
    BlockCommitUntilComplete = 0,
    RollbackIfNotComplete = 1
}


export enum EnlistmentOptions {
    None = 0,
    EnlistDuringPrepareRequired = 1
}


export enum EnterpriseServicesInteropOption {
    None = 0,
    Automatic = 1,
    Full = 2
}


export enum IsolationLevel {
    Serializable = 0,
    RepeatableRead = 1,
    ReadCommitted = 2,
    ReadUncommitted = 3,
    Snapshot = 4,
    Chaos = 5,
    Unspecified = 6
}


export enum TransactionScopeAsyncFlowOption {
    Suppress = 0,
    Enabled = 1
}


export enum TransactionScopeOption {
    Required = 0,
    RequiresNew = 1,
    Suppress = 2
}


export enum TransactionStatus {
    Active = 0,
    Committed = 1,
    Aborted = 2,
    InDoubt = 3
}


export type HostCurrentTransactionCallback = () => Transaction;


export type TransactionCompletedEventHandler = (sender: unknown, e: TransactionEventArgs) => void;


export type TransactionStartedEventHandler = (sender: unknown, e: TransactionEventArgs) => void;


export interface IDtcTransaction$instance {
    Abort(reason: nint, retaining: int, async_: int): void;
    Commit(retaining: int, commitType: int, reserved: int): void;
    GetTransactionInfo(transactionInformation: nint): void;
}


export type IDtcTransaction = IDtcTransaction$instance;

export interface IEnlistmentNotification$instance {
    Commit(enlistment: Enlistment): void;
    Prepare(preparingEnlistment: PreparingEnlistment): void;
}


export type IEnlistmentNotification = IEnlistmentNotification$instance;

export interface IPromotableSinglePhaseNotification$instance extends ITransactionPromoter {
    Initialize(): void;
    Promote(): byte[];
    SinglePhaseCommit(singlePhaseEnlistment: SinglePhaseEnlistment): void;
}


export interface IPromotableSinglePhaseNotification$instance extends ITransactionPromoter$instance {}

export type IPromotableSinglePhaseNotification = IPromotableSinglePhaseNotification$instance;

export interface ISimpleTransactionSuperior$instance extends ITransactionPromoter {
    Promote(): byte[];
    Rollback(): void;
}


export interface ISimpleTransactionSuperior$instance extends ITransactionPromoter$instance {}

export type ISimpleTransactionSuperior = ISimpleTransactionSuperior$instance;

export interface ISinglePhaseNotification$instance extends IEnlistmentNotification {
    Commit(enlistment: Enlistment): void;
    Prepare(preparingEnlistment: PreparingEnlistment): void;
    SinglePhaseCommit(singlePhaseEnlistment: SinglePhaseEnlistment): void;
}


export interface ISinglePhaseNotification$instance extends IEnlistmentNotification$instance {}

export type ISinglePhaseNotification = ISinglePhaseNotification$instance;

export interface ITransactionPromoter$instance {
    Promote(): byte[];
}


export type ITransactionPromoter = ITransactionPromoter$instance;

export interface TransactionOptions$instance {
    IsolationLevel: IsolationLevel;
    Timeout: TimeSpan;
    Equals(obj: unknown): boolean;
    Equals(other: TransactionOptions): boolean;
    GetHashCode(): int;
}


export const TransactionOptions: {
    new(): TransactionOptions$instance;
};


export interface __TransactionOptions$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<TransactionOptions>;

    // Structural method bridges for numeric interface constraints
    equals(other: TransactionOptions): boolean;
}

export type TransactionOptions = TransactionOptions$instance & __TransactionOptions$views;


export interface CommittableTransaction$instance extends Transaction$instance {
    BeginCommit(asyncCallback: AsyncCallback, asyncState: unknown): IAsyncResult;
    Commit(): void;
    Dispose(): void;
    EndCommit(asyncResult: IAsyncResult): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const CommittableTransaction: {
    new(): CommittableTransaction$instance;
    new(timeout: TimeSpan): CommittableTransaction$instance;
    new(options: TransactionOptions): CommittableTransaction$instance;
};


export interface __CommittableTransaction$views {
    As_IAsyncResult(): System_Internal.IAsyncResult$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface CommittableTransaction$instance extends System_Internal.IAsyncResult$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type CommittableTransaction = CommittableTransaction$instance & __CommittableTransaction$views;


export interface DependentTransaction$instance extends Transaction$instance {
    Complete(): void;
    Dispose(): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const DependentTransaction: {
    new(): DependentTransaction$instance;
};


export interface __DependentTransaction$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface DependentTransaction$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type DependentTransaction = DependentTransaction$instance & __DependentTransaction$views;


export interface Enlistment$instance {
    Done(): void;
}


export const Enlistment: {
    new(): Enlistment$instance;
};


export type Enlistment = Enlistment$instance;

export interface PreparingEnlistment$instance extends Enlistment {
    ForceRollback(): void;
    ForceRollback(e: Exception): void;
    Prepared(): void;
    RecoveryInformation(): byte[];
}


export const PreparingEnlistment: {
    new(): PreparingEnlistment$instance;
};


export type PreparingEnlistment = PreparingEnlistment$instance;

export interface SinglePhaseEnlistment$instance extends Enlistment {
    Aborted(): void;
    Aborted(e: Exception): void;
    Committed(): void;
    InDoubt(): void;
    InDoubt(e: Exception): void;
}


export const SinglePhaseEnlistment: {
    new(): SinglePhaseEnlistment$instance;
};


export type SinglePhaseEnlistment = SinglePhaseEnlistment$instance;

export interface SubordinateTransaction$instance extends Transaction$instance {
    Dispose(): void;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const SubordinateTransaction: {
    new(isoLevel: IsolationLevel, superior: ISimpleTransactionSuperior): SubordinateTransaction$instance;
};


export interface __SubordinateTransaction$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface SubordinateTransaction$instance extends System_Runtime_Serialization_Internal.ISerializable$instance {}

export type SubordinateTransaction = SubordinateTransaction$instance & __SubordinateTransaction$views;


export interface Transaction$instance {
    readonly IsolationLevel: IsolationLevel;
    readonly PromoterType: Guid;
    readonly TransactionInformation: TransactionInformation;
    Clone(): Transaction;
    DependentClone(cloneOption: DependentCloneOption): DependentTransaction;
    Dispose(): void;
    EnlistDurable(resourceManagerIdentifier: Guid, enlistmentNotification: IEnlistmentNotification, enlistmentOptions: EnlistmentOptions): Enlistment;
    EnlistDurable(resourceManagerIdentifier: Guid, singlePhaseNotification: ISinglePhaseNotification, enlistmentOptions: EnlistmentOptions): Enlistment;
    EnlistPromotableSinglePhase(promotableSinglePhaseNotification: IPromotableSinglePhaseNotification): boolean;
    EnlistPromotableSinglePhase(promotableSinglePhaseNotification: IPromotableSinglePhaseNotification, promoterType: Guid): boolean;
    EnlistVolatile(enlistmentNotification: IEnlistmentNotification, enlistmentOptions: EnlistmentOptions): Enlistment;
    EnlistVolatile(singlePhaseNotification: ISinglePhaseNotification, enlistmentOptions: EnlistmentOptions): Enlistment;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    GetPromotedToken(): byte[];
    PromoteAndEnlistDurable(resourceManagerIdentifier: Guid, promotableNotification: IPromotableSinglePhaseNotification, enlistmentNotification: ISinglePhaseNotification, enlistmentOptions: EnlistmentOptions): Enlistment;
    Rollback(): void;
    Rollback(e: Exception): void;
    SetDistributedTransactionIdentifier(promotableNotification: IPromotableSinglePhaseNotification, distributedTransactionIdentifier: Guid): void;
}


export const Transaction: {
    new(): Transaction$instance;
    Current: Transaction;
};


export interface __Transaction$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Transaction$instance extends System_Internal.IDisposable$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Transaction = Transaction$instance & __Transaction$views;


export interface TransactionAbortedException$instance extends TransactionException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TransactionAbortedException: {
    new(): TransactionAbortedException$instance;
    new(message: string): TransactionAbortedException$instance;
    new(message: string, innerException: Exception): TransactionAbortedException$instance;
};


export interface __TransactionAbortedException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionAbortedException = TransactionAbortedException$instance & __TransactionAbortedException$views;


export interface TransactionEventArgs$instance extends EventArgs {
    readonly Transaction: Transaction;
}


export const TransactionEventArgs: {
    new(): TransactionEventArgs$instance;
};


export type TransactionEventArgs = TransactionEventArgs$instance;

export interface TransactionException$instance extends SystemException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TransactionException: {
    new(): TransactionException$instance;
    new(message: string): TransactionException$instance;
    new(message: string, innerException: Exception): TransactionException$instance;
};


export interface __TransactionException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionException = TransactionException$instance & __TransactionException$views;


export interface TransactionInDoubtException$instance extends TransactionException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TransactionInDoubtException: {
    new(): TransactionInDoubtException$instance;
    new(message: string): TransactionInDoubtException$instance;
    new(message: string, innerException: Exception): TransactionInDoubtException$instance;
};


export interface __TransactionInDoubtException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionInDoubtException = TransactionInDoubtException$instance & __TransactionInDoubtException$views;


export interface TransactionInformation$instance {
    readonly CreationTime: DateTime;
    readonly DistributedIdentifier: Guid;
    readonly LocalIdentifier: string;
    readonly Status: TransactionStatus;
}


export const TransactionInformation: {
    new(): TransactionInformation$instance;
};


export type TransactionInformation = TransactionInformation$instance;

export interface TransactionManagerCommunicationException$instance extends TransactionException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TransactionManagerCommunicationException: {
    new(): TransactionManagerCommunicationException$instance;
    new(message: string): TransactionManagerCommunicationException$instance;
    new(message: string, innerException: Exception): TransactionManagerCommunicationException$instance;
};


export interface __TransactionManagerCommunicationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionManagerCommunicationException = TransactionManagerCommunicationException$instance & __TransactionManagerCommunicationException$views;


export interface TransactionPromotionException$instance extends TransactionException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const TransactionPromotionException: {
    new(): TransactionPromotionException$instance;
    new(message: string): TransactionPromotionException$instance;
    new(message: string, innerException: Exception): TransactionPromotionException$instance;
};


export interface __TransactionPromotionException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type TransactionPromotionException = TransactionPromotionException$instance & __TransactionPromotionException$views;


export interface TransactionScope$instance {
    Complete(): void;
    Dispose(): void;
}


export const TransactionScope: {
    new(): TransactionScope$instance;
    new(scopeOption: TransactionScopeOption): TransactionScope$instance;
    new(asyncFlowOption: TransactionScopeAsyncFlowOption): TransactionScope$instance;
    new(scopeOption: TransactionScopeOption, asyncFlowOption: TransactionScopeAsyncFlowOption): TransactionScope$instance;
    new(scopeOption: TransactionScopeOption, scopeTimeout: TimeSpan): TransactionScope$instance;
    new(scopeOption: TransactionScopeOption, scopeTimeout: TimeSpan, asyncFlowOption: TransactionScopeAsyncFlowOption): TransactionScope$instance;
    new(scopeOption: TransactionScopeOption, transactionOptions: TransactionOptions): TransactionScope$instance;
    new(scopeOption: TransactionScopeOption, transactionOptions: TransactionOptions, asyncFlowOption: TransactionScopeAsyncFlowOption): TransactionScope$instance;
    new(scopeOption: TransactionScopeOption, transactionOptions: TransactionOptions, interopOption: EnterpriseServicesInteropOption): TransactionScope$instance;
    new(transactionToUse: Transaction): TransactionScope$instance;
    new(transactionToUse: Transaction, asyncFlowOption: TransactionScopeAsyncFlowOption): TransactionScope$instance;
    new(transactionToUse: Transaction, scopeTimeout: TimeSpan): TransactionScope$instance;
    new(transactionToUse: Transaction, scopeTimeout: TimeSpan, asyncFlowOption: TransactionScopeAsyncFlowOption): TransactionScope$instance;
    new(transactionToUse: Transaction, scopeTimeout: TimeSpan, interopOption: EnterpriseServicesInteropOption): TransactionScope$instance;
};


export interface __TransactionScope$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface TransactionScope$instance extends System_Internal.IDisposable$instance {}

export type TransactionScope = TransactionScope$instance & __TransactionScope$views;


export abstract class TransactionInterop$instance {
    static readonly PromoterTypeDtc: Guid;
    static GetDtcTransaction(transaction: Transaction): IDtcTransaction;
    static GetExportCookie(transaction: Transaction, whereabouts: byte[]): byte[];
    static GetTransactionFromDtcTransaction(transactionNative: IDtcTransaction): Transaction;
    static GetTransactionFromExportCookie(cookie: byte[]): Transaction;
    static GetTransactionFromTransmitterPropagationToken(propagationToken: byte[]): Transaction;
    static GetTransmitterPropagationToken(transaction: Transaction): byte[];
    static GetWhereabouts(): byte[];
}


export type TransactionInterop = TransactionInterop$instance;

export abstract class TransactionManager$instance {
    static HostCurrentCallback: HostCurrentTransactionCallback;
    static DefaultTimeout: TimeSpan;
    static MaximumTimeout: TimeSpan;
    static ImplicitDistributedTransactions: boolean;
    static RecoveryComplete(resourceManagerIdentifier: Guid): void;
    static Reenlist(resourceManagerIdentifier: Guid, recoveryInformation: byte[], enlistmentNotification: IEnlistmentNotification): Enlistment;
}


export type TransactionManager = TransactionManager$instance;


// Generated by tsbindgen - Architecture
// Namespace: System.Text.Json.Serialization
// Assembly: System.Text.Json

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr } from "@tsonic/types";

// Import types from other namespaces
import * as System_Text_Json_Serialization_Metadata_Internal from "../../System.Text.Json.Serialization.Metadata/internal/index.js";
import type { IJsonTypeInfoResolver, JsonTypeInfo } from "../../System.Text.Json.Serialization.Metadata/internal/index.js";
import type { JsonCommentHandling, JsonNamingPolicy, JsonSerializerDefaults, JsonSerializerOptions, Utf8JsonReader, Utf8JsonWriter } from "../../System.Text.Json/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Attribute, Boolean as ClrBoolean, Char, Enum, IComparable, IConvertible, IFormatProvider, IFormattable, Int32, ISpanFormattable, Object as ClrObject, String as ClrString, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

export enum JsonIgnoreCondition {
    Never = 0,
    Always = 1,
    WhenWritingDefault = 2,
    WhenWritingNull = 3,
    WhenWriting = 4,
    WhenReading = 5
}


export enum JsonKnownNamingPolicy {
    Unspecified = 0,
    CamelCase = 1,
    SnakeCaseLower = 2,
    SnakeCaseUpper = 3,
    KebabCaseLower = 4,
    KebabCaseUpper = 5
}


export enum JsonKnownReferenceHandler {
    Unspecified = 0,
    Preserve = 1,
    IgnoreCycles = 2
}


export enum JsonNumberHandling {
    Strict = 0,
    AllowReadingFromString = 1,
    WriteAsString = 2,
    AllowNamedFloatingPointLiterals = 4
}


export enum JsonObjectCreationHandling {
    Replace = 0,
    Populate = 1
}


export enum JsonSourceGenerationMode {
    Default = 0,
    Metadata = 1,
    Serialization = 2
}


export enum JsonUnknownDerivedTypeHandling {
    FailSerialization = 0,
    FallBackToBaseType = 1,
    FallBackToNearestAncestor = 2
}


export enum JsonUnknownTypeHandling {
    JsonElement = 0,
    JsonNode = 1
}


export enum JsonUnmappedMemberHandling {
    Skip = 0,
    Disallow = 1
}


export interface IJsonOnDeserialized$instance {
    OnDeserialized(): void;
}


export type IJsonOnDeserialized = IJsonOnDeserialized$instance;

export interface IJsonOnDeserializing$instance {
    OnDeserializing(): void;
}


export type IJsonOnDeserializing = IJsonOnDeserializing$instance;

export interface IJsonOnSerialized$instance {
    OnSerialized(): void;
}


export type IJsonOnSerialized = IJsonOnSerialized$instance;

export interface IJsonOnSerializing$instance {
    OnSerializing(): void;
}


export type IJsonOnSerializing = IJsonOnSerializing$instance;

export interface JsonAttribute$instance extends Attribute {
}


export const JsonAttribute: {
};


export type JsonAttribute = JsonAttribute$instance;

export interface JsonConstructorAttribute$instance extends JsonAttribute {
}


export const JsonConstructorAttribute: {
    new(): JsonConstructorAttribute$instance;
};


export type JsonConstructorAttribute = JsonConstructorAttribute$instance;

export interface JsonConverter$instance {
    readonly Type: Type;
    CanConvert(typeToConvert: Type): boolean;
}


export const JsonConverter: {
};


export type JsonConverter = JsonConverter$instance;

export interface JsonConverter_1$instance<T> extends JsonConverter {
    readonly HandleNull: boolean;
    readonly Type: Type;
    CanConvert(typeToConvert: Type): boolean;
    Read(reader: Utf8JsonReader, typeToConvert: Type, options: JsonSerializerOptions): T;
    ReadAsPropertyName(reader: Utf8JsonReader, typeToConvert: Type, options: JsonSerializerOptions): T;
    Write(writer: Utf8JsonWriter, value: T, options: JsonSerializerOptions): void;
    WriteAsPropertyName(writer: Utf8JsonWriter, value: T, options: JsonSerializerOptions): void;
}


export const JsonConverter_1: {
};


export type JsonConverter_1<T> = JsonConverter_1$instance<T>;

export interface JsonConverterAttribute$instance extends JsonAttribute {
    readonly ConverterType: Type;
    CreateConverter(typeToConvert: Type): JsonConverter;
}


export const JsonConverterAttribute: {
    new(converterType: Type): JsonConverterAttribute$instance;
};


export type JsonConverterAttribute = JsonConverterAttribute$instance;

export interface JsonConverterFactory$instance extends JsonConverter {
    readonly Type: Type;
    CreateConverter(typeToConvert: Type, options: JsonSerializerOptions): JsonConverter;
}


export const JsonConverterFactory: {
};


export type JsonConverterFactory = JsonConverterFactory$instance;

export interface JsonDerivedTypeAttribute$instance extends JsonAttribute {
    readonly DerivedType: Type;
    readonly TypeDiscriminator: unknown;
}


export const JsonDerivedTypeAttribute: {
    new(derivedType: Type): JsonDerivedTypeAttribute$instance;
    new(derivedType: Type, typeDiscriminator: string): JsonDerivedTypeAttribute$instance;
    new(derivedType: Type, typeDiscriminator: int): JsonDerivedTypeAttribute$instance;
};


export type JsonDerivedTypeAttribute = JsonDerivedTypeAttribute$instance;

export interface JsonExtensionDataAttribute$instance extends JsonAttribute {
}


export const JsonExtensionDataAttribute: {
    new(): JsonExtensionDataAttribute$instance;
};


export type JsonExtensionDataAttribute = JsonExtensionDataAttribute$instance;

export interface JsonIgnoreAttribute$instance extends JsonAttribute {
    Condition: JsonIgnoreCondition;
}


export const JsonIgnoreAttribute: {
    new(): JsonIgnoreAttribute$instance;
};


export type JsonIgnoreAttribute = JsonIgnoreAttribute$instance;

export interface JsonIncludeAttribute$instance extends JsonAttribute {
}


export const JsonIncludeAttribute: {
    new(): JsonIncludeAttribute$instance;
};


export type JsonIncludeAttribute = JsonIncludeAttribute$instance;

export interface JsonNumberEnumConverter_1$instance<TEnum extends number> extends JsonConverterFactory {
    CanConvert(typeToConvert: Type): boolean;
    CreateConverter(typeToConvert: Type, options: JsonSerializerOptions): JsonConverter;
}


export const JsonNumberEnumConverter_1: {
    new<TEnum extends number>(): JsonNumberEnumConverter_1$instance<TEnum>;
};


export type JsonNumberEnumConverter_1<TEnum extends number> = JsonNumberEnumConverter_1$instance<TEnum>;

export interface JsonNumberHandlingAttribute$instance extends JsonAttribute {
    readonly Handling: JsonNumberHandling;
}


export const JsonNumberHandlingAttribute: {
    new(handling: JsonNumberHandling): JsonNumberHandlingAttribute$instance;
};


export type JsonNumberHandlingAttribute = JsonNumberHandlingAttribute$instance;

export interface JsonObjectCreationHandlingAttribute$instance extends JsonAttribute {
    readonly Handling: JsonObjectCreationHandling;
}


export const JsonObjectCreationHandlingAttribute: {
    new(handling: JsonObjectCreationHandling): JsonObjectCreationHandlingAttribute$instance;
};


export type JsonObjectCreationHandlingAttribute = JsonObjectCreationHandlingAttribute$instance;

export interface JsonPolymorphicAttribute$instance extends JsonAttribute {
    IgnoreUnrecognizedTypeDiscriminators: boolean;
    TypeDiscriminatorPropertyName: string;
    UnknownDerivedTypeHandling: JsonUnknownDerivedTypeHandling;
}


export const JsonPolymorphicAttribute: {
    new(): JsonPolymorphicAttribute$instance;
};


export type JsonPolymorphicAttribute = JsonPolymorphicAttribute$instance;

export interface JsonPropertyNameAttribute$instance extends JsonAttribute {
    readonly Name: string;
}


export const JsonPropertyNameAttribute: {
    new(name: string): JsonPropertyNameAttribute$instance;
};


export type JsonPropertyNameAttribute = JsonPropertyNameAttribute$instance;

export interface JsonPropertyOrderAttribute$instance extends JsonAttribute {
    readonly Order: int;
}


export const JsonPropertyOrderAttribute: {
    new(order: int): JsonPropertyOrderAttribute$instance;
};


export type JsonPropertyOrderAttribute = JsonPropertyOrderAttribute$instance;

export interface JsonRequiredAttribute$instance extends JsonAttribute {
}


export const JsonRequiredAttribute: {
    new(): JsonRequiredAttribute$instance;
};


export type JsonRequiredAttribute = JsonRequiredAttribute$instance;

export interface JsonSerializableAttribute$instance extends JsonAttribute {
    GenerationMode: JsonSourceGenerationMode;
    TypeInfoPropertyName: string;
}


export const JsonSerializableAttribute: {
    new(type_: Type): JsonSerializableAttribute$instance;
};


export type JsonSerializableAttribute = JsonSerializableAttribute$instance;

export interface JsonSerializerContext$instance {
    readonly Options: JsonSerializerOptions;
    GetTypeInfo(type_: Type): JsonTypeInfo;
}


export const JsonSerializerContext: {
};


export interface __JsonSerializerContext$views {
    As_IJsonTypeInfoResolver(): System_Text_Json_Serialization_Metadata_Internal.IJsonTypeInfoResolver$instance;
}

export type JsonSerializerContext = JsonSerializerContext$instance & __JsonSerializerContext$views;


export interface JsonSourceGenerationOptionsAttribute$instance extends JsonAttribute {
    AllowDuplicateProperties: boolean;
    AllowOutOfOrderMetadataProperties: boolean;
    AllowTrailingCommas: boolean;
    Converters: Type[];
    DefaultBufferSize: int;
    DefaultIgnoreCondition: JsonIgnoreCondition;
    DictionaryKeyPolicy: JsonKnownNamingPolicy;
    GenerationMode: JsonSourceGenerationMode;
    IgnoreReadOnlyFields: boolean;
    IgnoreReadOnlyProperties: boolean;
    IncludeFields: boolean;
    IndentCharacter: char;
    IndentSize: int;
    MaxDepth: int;
    NewLine: string;
    NumberHandling: JsonNumberHandling;
    PreferredObjectCreationHandling: JsonObjectCreationHandling;
    PropertyNameCaseInsensitive: boolean;
    PropertyNamingPolicy: JsonKnownNamingPolicy;
    ReadCommentHandling: JsonCommentHandling;
    ReferenceHandler: JsonKnownReferenceHandler;
    RespectNullableAnnotations: boolean;
    RespectRequiredConstructorParameters: boolean;
    UnknownTypeHandling: JsonUnknownTypeHandling;
    UnmappedMemberHandling: JsonUnmappedMemberHandling;
    UseStringEnumConverter: boolean;
    WriteIndented: boolean;
}


export const JsonSourceGenerationOptionsAttribute: {
    new(): JsonSourceGenerationOptionsAttribute$instance;
    new(defaults: JsonSerializerDefaults): JsonSourceGenerationOptionsAttribute$instance;
};


export type JsonSourceGenerationOptionsAttribute = JsonSourceGenerationOptionsAttribute$instance;

export interface JsonStringEnumConverter$instance extends JsonConverterFactory {
    CanConvert(typeToConvert: Type): boolean;
    CreateConverter(typeToConvert: Type, options: JsonSerializerOptions): JsonConverter;
}


export const JsonStringEnumConverter: {
    new(): JsonStringEnumConverter$instance;
    new(namingPolicy: JsonNamingPolicy, allowIntegerValues: boolean): JsonStringEnumConverter$instance;
};


export type JsonStringEnumConverter = JsonStringEnumConverter$instance;

export interface JsonStringEnumConverter_1$instance<TEnum extends number> extends JsonConverterFactory {
    CanConvert(typeToConvert: Type): boolean;
    CreateConverter(typeToConvert: Type, options: JsonSerializerOptions): JsonConverter;
}


export const JsonStringEnumConverter_1: {
    new<TEnum extends number>(): JsonStringEnumConverter_1$instance<TEnum>;
    new<TEnum extends number>(namingPolicy: JsonNamingPolicy, allowIntegerValues: boolean): JsonStringEnumConverter_1$instance<TEnum>;
};


export type JsonStringEnumConverter_1<TEnum extends number> = JsonStringEnumConverter_1$instance<TEnum>;

export interface JsonStringEnumMemberNameAttribute$instance extends Attribute {
    readonly Name: string;
}


export const JsonStringEnumMemberNameAttribute: {
    new(name: string): JsonStringEnumMemberNameAttribute$instance;
};


export type JsonStringEnumMemberNameAttribute = JsonStringEnumMemberNameAttribute$instance;

export interface JsonUnmappedMemberHandlingAttribute$instance extends JsonAttribute {
    readonly UnmappedMemberHandling: JsonUnmappedMemberHandling;
}


export const JsonUnmappedMemberHandlingAttribute: {
    new(unmappedMemberHandling: JsonUnmappedMemberHandling): JsonUnmappedMemberHandlingAttribute$instance;
};


export type JsonUnmappedMemberHandlingAttribute = JsonUnmappedMemberHandlingAttribute$instance;

export interface ReferenceHandler$instance {
    CreateResolver(): ReferenceResolver;
}


export const ReferenceHandler: {
    readonly Preserve: ReferenceHandler;
    readonly IgnoreCycles: ReferenceHandler;
};


export type ReferenceHandler = ReferenceHandler$instance;

export interface ReferenceHandler_1$instance<T extends ReferenceResolver> extends ReferenceHandler {
    CreateResolver(): ReferenceResolver;
}


export const ReferenceHandler_1: {
    new<T extends ReferenceResolver>(): ReferenceHandler_1$instance<T>;
};


export type ReferenceHandler_1<T extends ReferenceResolver> = ReferenceHandler_1$instance<T>;

export interface ReferenceResolver$instance {
    AddReference(referenceId: string, value: unknown): void;
    GetReference(value: unknown, alreadyExists: boolean): string;
    ResolveReference(referenceId: string): unknown;
}


export const ReferenceResolver: {
};


export type ReferenceResolver = ReferenceResolver$instance;


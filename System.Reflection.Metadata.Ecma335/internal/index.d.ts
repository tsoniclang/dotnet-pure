// Generated by tsbindgen - Architecture
// Namespace: System.Reflection.Metadata.Ecma335
// Assembly: System.Reflection.Metadata

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { IEnumerable_1, IReadOnlyList_1 } from "../../System.Collections.Generic/internal/index.js";
import type { ImmutableArray_1 } from "../../System.Collections.Immutable/internal/index.js";
import type { AssemblyDefinitionHandle, AssemblyFileHandle, AssemblyReferenceHandle, Blob, BlobBuilder, BlobContentId, BlobHandle, BlobReader, ConstantHandle, CustomAttributeHandle, CustomDebugInformationHandle, DeclarativeSecurityAttributeHandle, DocumentHandle, DocumentNameBlobHandle, EntityHandle, EventDefinitionHandle, ExceptionRegionKind, ExportedType, ExportedTypeHandle, FieldDefinitionHandle, GenericParameterConstraintHandle, GenericParameterHandle, GuidHandle, Handle, HandleKind, ILOpCode, ImportScopeHandle, InterfaceImplementationHandle, ISignatureTypeProvider_2, LocalConstantHandle, LocalScopeHandle, LocalVariableAttributes, LocalVariableHandle, ManifestResourceHandle, MemberReferenceHandle, MetadataReader, MethodDebugInformationHandle, MethodDefinitionHandle, MethodImplementationHandle, MethodSignature_1, MethodSpecificationHandle, ModuleDefinitionHandle, ModuleReferenceHandle, ParameterHandle, PrimitiveSerializationTypeCode, PrimitiveTypeCode, PropertyDefinitionHandle, ReservedBlob_1, SignatureCallingConvention, SignatureTypeKind, StandaloneSignatureHandle, StringHandle, TypeDefinitionHandle, TypeReferenceHandle, TypeSpecificationHandle, UserStringHandle } from "../../System.Reflection.Metadata/internal/index.js";
import type { AssemblyFlags, AssemblyHashAlgorithm, DeclarativeSecurityAction, EventAttributes, FieldAttributes, GenericParameterAttributes, ManifestResourceAttributes, MethodAttributes, MethodImplAttributes, MethodImportAttributes, MethodSemanticsAttributes, ParameterAttributes, PropertyAttributes, TypeAttributes } from "../../System.Reflection/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Boolean as ClrBoolean, Byte, Double, Enum, Func_2, Guid, IComparable, IConvertible, IEquatable_1, IFormatProvider, IFormattable, Int32, Int64, ISpanFormattable, Object as ClrObject, Single, String as ClrString, Type, TypeCode, UInt16, UInt32, ValueType, Version, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum EditAndContinueOperation {
    Default = 0,
    AddMethod = 1,
    AddField = 2,
    AddParameter = 3,
    AddProperty = 4,
    AddEvent = 5
}


export enum FunctionPointerAttributes {
    None = 0,
    HasThis = 32,
    HasExplicitThis = 96
}


export enum HeapIndex {
    UserString = 0,
    String = 1,
    Blob = 2,
    Guid = 3
}


export enum MethodBodyAttributes {
    None = 0,
    InitLocals = 1
}


export enum TableIndex {
    Module = 0,
    TypeRef = 1,
    TypeDef = 2,
    FieldPtr = 3,
    Field = 4,
    MethodPtr = 5,
    MethodDef = 6,
    ParamPtr = 7,
    Param = 8,
    InterfaceImpl = 9,
    MemberRef = 10,
    Constant = 11,
    CustomAttribute = 12,
    FieldMarshal = 13,
    DeclSecurity = 14,
    ClassLayout = 15,
    FieldLayout = 16,
    StandAloneSig = 17,
    EventMap = 18,
    EventPtr = 19,
    Event = 20,
    PropertyMap = 21,
    PropertyPtr = 22,
    Property = 23,
    MethodSemantics = 24,
    MethodImpl = 25,
    ModuleRef = 26,
    TypeSpec = 27,
    ImplMap = 28,
    FieldRva = 29,
    EncLog = 30,
    EncMap = 31,
    Assembly = 32,
    AssemblyProcessor = 33,
    AssemblyOS = 34,
    AssemblyRef = 35,
    AssemblyRefProcessor = 36,
    AssemblyRefOS = 37,
    File = 38,
    ExportedType = 39,
    ManifestResource = 40,
    NestedClass = 41,
    GenericParam = 42,
    MethodSpec = 43,
    GenericParamConstraint = 44,
    Document = 48,
    MethodDebugInformation = 49,
    LocalScope = 50,
    LocalVariable = 51,
    LocalConstant = 52,
    ImportScope = 53,
    StateMachineMethod = 54,
    CustomDebugInformation = 55
}


export interface ArrayShapeEncoder$instance {
    readonly Builder: BlobBuilder;
    Shape(rank: int, sizes: ImmutableArray_1<CLROf<int>>, lowerBounds: ImmutableArray_1<CLROf<int>>): void;
}


export const ArrayShapeEncoder: {
    new(builder: BlobBuilder): ArrayShapeEncoder$instance;
};


export type ArrayShapeEncoder = ArrayShapeEncoder$instance;

export interface BlobEncoder$instance {
    readonly Builder: BlobBuilder;
    CustomAttributeSignature(fixedArguments: { value: ref<FixedArgumentsEncoder> }, namedArguments: { value: ref<CustomAttributeNamedArgumentsEncoder> }): void;
    CustomAttributeSignature(fixedArguments: Action_1<FixedArgumentsEncoder>, namedArguments: Action_1<CustomAttributeNamedArgumentsEncoder>): void;
    Field(): FieldTypeEncoder;
    FieldSignature(): SignatureTypeEncoder;
    LocalVariableSignature(variableCount: int): LocalVariablesEncoder;
    MethodSignature(convention?: SignatureCallingConvention, genericParameterCount?: int, isInstanceMethod?: boolean): MethodSignatureEncoder;
    MethodSpecificationSignature(genericArgumentCount: int): GenericTypeArgumentsEncoder;
    PermissionSetArguments(argumentCount: int): NamedArgumentsEncoder;
    PermissionSetBlob(attributeCount: int): PermissionSetEncoder;
    PropertySignature(isInstanceProperty?: boolean): MethodSignatureEncoder;
    TypeSpecificationSignature(): SignatureTypeEncoder;
}


export const BlobEncoder: {
    new(builder: BlobBuilder): BlobEncoder$instance;
};


export type BlobEncoder = BlobEncoder$instance;

export interface CustomAttributeArrayTypeEncoder$instance {
    readonly Builder: BlobBuilder;
    ElementType(): CustomAttributeElementTypeEncoder;
    ObjectArray(): void;
}


export const CustomAttributeArrayTypeEncoder: {
    new(builder: BlobBuilder): CustomAttributeArrayTypeEncoder$instance;
};


export type CustomAttributeArrayTypeEncoder = CustomAttributeArrayTypeEncoder$instance;

export interface CustomAttributeElementTypeEncoder$instance {
    readonly Builder: BlobBuilder;
    Boolean(): void;
    Byte(): void;
    Char(): void;
    Double(): void;
    Enum(enumTypeName: string): void;
    Int16(): void;
    Int32(): void;
    Int64(): void;
    PrimitiveType(type_: PrimitiveSerializationTypeCode): void;
    SByte(): void;
    Single(): void;
    String(): void;
    SystemType(): void;
    UInt16(): void;
    UInt32(): void;
    UInt64(): void;
}


export const CustomAttributeElementTypeEncoder: {
    new(builder: BlobBuilder): CustomAttributeElementTypeEncoder$instance;
};


export type CustomAttributeElementTypeEncoder = CustomAttributeElementTypeEncoder$instance;

export interface CustomAttributeNamedArgumentsEncoder$instance {
    readonly Builder: BlobBuilder;
    Count(count: int): NamedArgumentsEncoder;
}


export const CustomAttributeNamedArgumentsEncoder: {
    new(builder: BlobBuilder): CustomAttributeNamedArgumentsEncoder$instance;
};


export type CustomAttributeNamedArgumentsEncoder = CustomAttributeNamedArgumentsEncoder$instance;

export interface CustomModifiersEncoder$instance {
    readonly Builder: BlobBuilder;
    AddModifier(type_: EntityHandle, isOptional: boolean): CustomModifiersEncoder;
}


export const CustomModifiersEncoder: {
    new(builder: BlobBuilder): CustomModifiersEncoder$instance;
};


export type CustomModifiersEncoder = CustomModifiersEncoder$instance;

export interface EditAndContinueLogEntry$instance {
    readonly Handle: EntityHandle;
    readonly Operation: EditAndContinueOperation;
    Equals(obj: unknown): boolean;
    Equals(other: EditAndContinueLogEntry): boolean;
    GetHashCode(): int;
}


export const EditAndContinueLogEntry: {
    new(handle: EntityHandle, operation: EditAndContinueOperation): EditAndContinueLogEntry$instance;
};


export interface __EditAndContinueLogEntry$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<EditAndContinueLogEntry>;

    // Structural method bridges for numeric interface constraints
    equals(other: EditAndContinueLogEntry): boolean;
}

export type EditAndContinueLogEntry = EditAndContinueLogEntry$instance & __EditAndContinueLogEntry$views;


export interface ExceptionRegionEncoder$instance {
    readonly Builder: BlobBuilder;
    readonly HasSmallFormat: boolean;
    Add(kind: ExceptionRegionKind, tryOffset: int, tryLength: int, handlerOffset: int, handlerLength: int, catchType?: EntityHandle, filterOffset?: int): ExceptionRegionEncoder;
    AddCatch(tryOffset: int, tryLength: int, handlerOffset: int, handlerLength: int, catchType: EntityHandle): ExceptionRegionEncoder;
    AddFault(tryOffset: int, tryLength: int, handlerOffset: int, handlerLength: int): ExceptionRegionEncoder;
    AddFilter(tryOffset: int, tryLength: int, handlerOffset: int, handlerLength: int, filterOffset: int): ExceptionRegionEncoder;
    AddFinally(tryOffset: int, tryLength: int, handlerOffset: int, handlerLength: int): ExceptionRegionEncoder;
}


export const ExceptionRegionEncoder: {
    new(): ExceptionRegionEncoder$instance;
    IsSmallExceptionRegion(startOffset: int, length: int): boolean;
    IsSmallRegionCount(exceptionRegionCount: int): boolean;
};


export type ExceptionRegionEncoder = ExceptionRegionEncoder$instance;

export interface FieldTypeEncoder$instance {
    readonly Builder: BlobBuilder;
    CustomModifiers(): CustomModifiersEncoder;
    Type(isByRef?: boolean): SignatureTypeEncoder;
    TypedReference(): void;
}


export const FieldTypeEncoder: {
    new(builder: BlobBuilder): FieldTypeEncoder$instance;
};


export type FieldTypeEncoder = FieldTypeEncoder$instance;

export interface FixedArgumentsEncoder$instance {
    readonly Builder: BlobBuilder;
    AddArgument(): LiteralEncoder;
}


export const FixedArgumentsEncoder: {
    new(builder: BlobBuilder): FixedArgumentsEncoder$instance;
};


export type FixedArgumentsEncoder = FixedArgumentsEncoder$instance;

export interface GenericTypeArgumentsEncoder$instance {
    readonly Builder: BlobBuilder;
    AddArgument(): SignatureTypeEncoder;
}


export const GenericTypeArgumentsEncoder: {
    new(builder: BlobBuilder): GenericTypeArgumentsEncoder$instance;
};


export type GenericTypeArgumentsEncoder = GenericTypeArgumentsEncoder$instance;

export interface InstructionEncoder$instance {
    readonly CodeBuilder: BlobBuilder;
    readonly ControlFlowBuilder: ControlFlowBuilder;
    readonly Offset: int;
    Branch(code: ILOpCode, label: LabelHandle): void;
    Call(methodHandle: EntityHandle): void;
    Call(methodHandle: MethodDefinitionHandle): void;
    Call(methodHandle: MethodSpecificationHandle): void;
    Call(methodHandle: MemberReferenceHandle): void;
    CallIndirect(signature: StandaloneSignatureHandle): void;
    DefineLabel(): LabelHandle;
    LoadArgument(argumentIndex: int): void;
    LoadArgumentAddress(argumentIndex: int): void;
    LoadConstantI4(value: int): void;
    LoadConstantI8(value: long): void;
    LoadConstantR4(value: float): void;
    LoadConstantR8(value: double): void;
    LoadLocal(slotIndex: int): void;
    LoadLocalAddress(slotIndex: int): void;
    LoadString(handle: UserStringHandle): void;
    MarkLabel(label: LabelHandle): void;
    OpCode(code: ILOpCode): void;
    StoreArgument(argumentIndex: int): void;
    StoreLocal(slotIndex: int): void;
    Switch(branchCount: int): SwitchInstructionEncoder;
    Token(handle: EntityHandle): void;
    Token(token: int): void;
}


export const InstructionEncoder: {
    new(codeBuilder: BlobBuilder, controlFlowBuilder: ControlFlowBuilder): InstructionEncoder$instance;
};


export type InstructionEncoder = InstructionEncoder$instance;

export interface LabelHandle$instance {
    readonly Id: int;
    readonly IsNil: boolean;
    Equals(other: LabelHandle): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const LabelHandle: {
    new(): LabelHandle$instance;
};


export interface __LabelHandle$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<LabelHandle>;

    // Structural method bridges for numeric interface constraints
    equals(other: LabelHandle): boolean;
}

export type LabelHandle = LabelHandle$instance & __LabelHandle$views;


export interface LiteralEncoder$instance {
    readonly Builder: BlobBuilder;
    Scalar(): ScalarEncoder;
    TaggedScalar(type_: { value: ref<CustomAttributeElementTypeEncoder> }, scalar: { value: ref<ScalarEncoder> }): void;
    TaggedScalar(type_: Action_1<CustomAttributeElementTypeEncoder>, scalar: Action_1<ScalarEncoder>): void;
    TaggedVector(arrayType: { value: ref<CustomAttributeArrayTypeEncoder> }, vector: { value: ref<VectorEncoder> }): void;
    TaggedVector(arrayType: Action_1<CustomAttributeArrayTypeEncoder>, vector: Action_1<VectorEncoder>): void;
    Vector(): VectorEncoder;
}


export const LiteralEncoder: {
    new(builder: BlobBuilder): LiteralEncoder$instance;
};


export type LiteralEncoder = LiteralEncoder$instance;

export interface LiteralsEncoder$instance {
    readonly Builder: BlobBuilder;
    AddLiteral(): LiteralEncoder;
}


export const LiteralsEncoder: {
    new(builder: BlobBuilder): LiteralsEncoder$instance;
};


export type LiteralsEncoder = LiteralsEncoder$instance;

export interface LocalVariablesEncoder$instance {
    readonly Builder: BlobBuilder;
    AddVariable(): LocalVariableTypeEncoder;
}


export const LocalVariablesEncoder: {
    new(builder: BlobBuilder): LocalVariablesEncoder$instance;
};


export type LocalVariablesEncoder = LocalVariablesEncoder$instance;

export interface LocalVariableTypeEncoder$instance {
    readonly Builder: BlobBuilder;
    CustomModifiers(): CustomModifiersEncoder;
    Type(isByRef?: boolean, isPinned?: boolean): SignatureTypeEncoder;
    TypedReference(): void;
}


export const LocalVariableTypeEncoder: {
    new(builder: BlobBuilder): LocalVariableTypeEncoder$instance;
};


export type LocalVariableTypeEncoder = LocalVariableTypeEncoder$instance;

export interface MethodBodyStreamEncoder$instance {
    readonly Builder: BlobBuilder;
    AddMethodBody(codeSize: int, maxStack: int, exceptionRegionCount: int, hasSmallExceptionRegions: boolean, localVariablesSignature: StandaloneSignatureHandle, attributes: MethodBodyAttributes): MethodBodyStreamEncoder_MethodBody;
    AddMethodBody(codeSize: int, maxStack?: int, exceptionRegionCount?: int, hasSmallExceptionRegions?: boolean, localVariablesSignature?: StandaloneSignatureHandle, attributes?: MethodBodyAttributes, hasDynamicStackAllocation?: boolean): MethodBodyStreamEncoder_MethodBody;
    AddMethodBody(instructionEncoder: InstructionEncoder, maxStack: int, localVariablesSignature: StandaloneSignatureHandle, attributes: MethodBodyAttributes): int;
    AddMethodBody(instructionEncoder: InstructionEncoder, maxStack?: int, localVariablesSignature?: StandaloneSignatureHandle, attributes?: MethodBodyAttributes, hasDynamicStackAllocation?: boolean): int;
}


export const MethodBodyStreamEncoder: {
    new(builder: BlobBuilder): MethodBodyStreamEncoder$instance;
};


export type MethodBodyStreamEncoder = MethodBodyStreamEncoder$instance;

export interface MethodBodyStreamEncoder_MethodBody$instance {
    readonly ExceptionRegions: ExceptionRegionEncoder;
    readonly Instructions: Blob;
    readonly Offset: int;
}


export const MethodBodyStreamEncoder_MethodBody: {
    new(): MethodBodyStreamEncoder_MethodBody$instance;
};


export type MethodBodyStreamEncoder_MethodBody = MethodBodyStreamEncoder_MethodBody$instance;

export interface MethodSignatureEncoder$instance {
    readonly Builder: BlobBuilder;
    readonly HasVarArgs: boolean;
    Parameters(parameterCount: int, returnType: { value: ref<ReturnTypeEncoder> }, parameters: { value: ref<ParametersEncoder> }): void;
    Parameters(parameterCount: int, returnType: Action_1<ReturnTypeEncoder>, parameters: Action_1<ParametersEncoder>): void;
}


export const MethodSignatureEncoder: {
    new(builder: BlobBuilder, hasVarArgs: boolean): MethodSignatureEncoder$instance;
};


export type MethodSignatureEncoder = MethodSignatureEncoder$instance;

export interface NamedArgumentsEncoder$instance {
    readonly Builder: BlobBuilder;
    AddArgument(isField: boolean, type_: { value: ref<NamedArgumentTypeEncoder> }, name: { value: ref<NameEncoder> }, literal: { value: ref<LiteralEncoder> }): void;
    AddArgument(isField: boolean, type_: Action_1<NamedArgumentTypeEncoder>, name: Action_1<NameEncoder>, literal: Action_1<LiteralEncoder>): void;
}


export const NamedArgumentsEncoder: {
    new(builder: BlobBuilder): NamedArgumentsEncoder$instance;
};


export type NamedArgumentsEncoder = NamedArgumentsEncoder$instance;

export interface NamedArgumentTypeEncoder$instance {
    readonly Builder: BlobBuilder;
    Object(): void;
    ScalarType(): CustomAttributeElementTypeEncoder;
    SZArray(): CustomAttributeArrayTypeEncoder;
}


export const NamedArgumentTypeEncoder: {
    new(builder: BlobBuilder): NamedArgumentTypeEncoder$instance;
};


export type NamedArgumentTypeEncoder = NamedArgumentTypeEncoder$instance;

export interface NameEncoder$instance {
    readonly Builder: BlobBuilder;
    Name(name: string): void;
}


export const NameEncoder: {
    new(builder: BlobBuilder): NameEncoder$instance;
};


export type NameEncoder = NameEncoder$instance;

export interface ParametersEncoder$instance {
    readonly Builder: BlobBuilder;
    readonly HasVarArgs: boolean;
    AddParameter(): ParameterTypeEncoder;
    StartVarArgs(): ParametersEncoder;
}


export const ParametersEncoder: {
    new(builder: BlobBuilder, hasVarArgs: boolean): ParametersEncoder$instance;
};


export type ParametersEncoder = ParametersEncoder$instance;

export interface ParameterTypeEncoder$instance {
    readonly Builder: BlobBuilder;
    CustomModifiers(): CustomModifiersEncoder;
    Type(isByRef?: boolean): SignatureTypeEncoder;
    TypedReference(): void;
}


export const ParameterTypeEncoder: {
    new(builder: BlobBuilder): ParameterTypeEncoder$instance;
};


export type ParameterTypeEncoder = ParameterTypeEncoder$instance;

export interface PermissionSetEncoder$instance {
    readonly Builder: BlobBuilder;
    AddPermission(typeName: string, encodedArguments: ImmutableArray_1<CLROf<byte>>): PermissionSetEncoder;
    AddPermission(typeName: string, encodedArguments: BlobBuilder): PermissionSetEncoder;
}


export const PermissionSetEncoder: {
    new(builder: BlobBuilder): PermissionSetEncoder$instance;
};


export type PermissionSetEncoder = PermissionSetEncoder$instance;

export interface ReturnTypeEncoder$instance {
    readonly Builder: BlobBuilder;
    CustomModifiers(): CustomModifiersEncoder;
    Type(isByRef?: boolean): SignatureTypeEncoder;
    TypedReference(): void;
    Void(): void;
}


export const ReturnTypeEncoder: {
    new(builder: BlobBuilder): ReturnTypeEncoder$instance;
};


export type ReturnTypeEncoder = ReturnTypeEncoder$instance;

export interface ScalarEncoder$instance {
    readonly Builder: BlobBuilder;
    Constant(value: unknown): void;
    NullArray(): void;
    SystemType(serializedTypeName: string): void;
}


export const ScalarEncoder: {
    new(builder: BlobBuilder): ScalarEncoder$instance;
};


export type ScalarEncoder = ScalarEncoder$instance;

export interface SignatureDecoder_2$instance<TType, TGenericContext> {
    DecodeFieldSignature(blobReader: { value: ref<BlobReader> }): TType;
    DecodeLocalSignature(blobReader: { value: ref<BlobReader> }): ImmutableArray_1<TType>;
    DecodeMethodSignature(blobReader: { value: ref<BlobReader> }): MethodSignature_1<TType>;
    DecodeMethodSpecificationSignature(blobReader: { value: ref<BlobReader> }): ImmutableArray_1<TType>;
    DecodeType(blobReader: { value: ref<BlobReader> }, allowTypeSpecifications?: boolean): TType;
}


export const SignatureDecoder_2: {
    new<TType, TGenericContext>(provider: ISignatureTypeProvider_2<TType, TGenericContext>, metadataReader: MetadataReader, genericContext: TGenericContext): SignatureDecoder_2$instance<TType, TGenericContext>;
};


export type SignatureDecoder_2<TType, TGenericContext> = SignatureDecoder_2$instance<TType, TGenericContext>;

export interface SignatureTypeEncoder$instance {
    readonly Builder: BlobBuilder;
    Array(elementType: { value: ref<SignatureTypeEncoder> }, arrayShape: { value: ref<ArrayShapeEncoder> }): void;
    Array(elementType: Action_1<SignatureTypeEncoder>, arrayShape: Action_1<ArrayShapeEncoder>): void;
    Boolean(): void;
    Byte(): void;
    Char(): void;
    CustomModifiers(): CustomModifiersEncoder;
    Double(): void;
    FunctionPointer(convention?: SignatureCallingConvention, attributes?: FunctionPointerAttributes, genericParameterCount?: int): MethodSignatureEncoder;
    GenericInstantiation(genericType: EntityHandle, genericArgumentCount: int, isValueType: boolean): GenericTypeArgumentsEncoder;
    GenericMethodTypeParameter(parameterIndex: int): void;
    GenericTypeParameter(parameterIndex: int): void;
    Int16(): void;
    Int32(): void;
    Int64(): void;
    IntPtr(): void;
    Object(): void;
    Pointer(): SignatureTypeEncoder;
    PrimitiveType(type_: PrimitiveTypeCode): void;
    SByte(): void;
    Single(): void;
    String(): void;
    SZArray(): SignatureTypeEncoder;
    Type(type_: EntityHandle, isValueType: boolean): void;
    TypedReference(): void;
    UInt16(): void;
    UInt32(): void;
    UInt64(): void;
    UIntPtr(): void;
    VoidPointer(): void;
}


export const SignatureTypeEncoder: {
    new(builder: BlobBuilder): SignatureTypeEncoder$instance;
};


export type SignatureTypeEncoder = SignatureTypeEncoder$instance;

export interface SwitchInstructionEncoder$instance {
    Branch(label: LabelHandle): void;
}


export const SwitchInstructionEncoder: {
    new(): SwitchInstructionEncoder$instance;
};


export type SwitchInstructionEncoder = SwitchInstructionEncoder$instance;

export interface VectorEncoder$instance {
    readonly Builder: BlobBuilder;
    Count(count: int): LiteralsEncoder;
}


export const VectorEncoder: {
    new(builder: BlobBuilder): VectorEncoder$instance;
};


export type VectorEncoder = VectorEncoder$instance;

export interface ControlFlowBuilder$instance {
    AddCatchRegion(tryStart: LabelHandle, tryEnd: LabelHandle, handlerStart: LabelHandle, handlerEnd: LabelHandle, catchType: EntityHandle): void;
    AddFaultRegion(tryStart: LabelHandle, tryEnd: LabelHandle, handlerStart: LabelHandle, handlerEnd: LabelHandle): void;
    AddFilterRegion(tryStart: LabelHandle, tryEnd: LabelHandle, handlerStart: LabelHandle, handlerEnd: LabelHandle, filterStart: LabelHandle): void;
    AddFinallyRegion(tryStart: LabelHandle, tryEnd: LabelHandle, handlerStart: LabelHandle, handlerEnd: LabelHandle): void;
    Clear(): void;
}


export const ControlFlowBuilder: {
    new(): ControlFlowBuilder$instance;
};


export type ControlFlowBuilder = ControlFlowBuilder$instance;

export interface MetadataAggregator$instance {
    GetGenerationHandle(handle: Handle, generation: { value: ref<int> }): Handle;
}


export const MetadataAggregator: {
    new(baseReader: MetadataReader, deltaReaders: IReadOnlyList_1<MetadataReader>): MetadataAggregator$instance;
    new(baseTableRowCounts: IReadOnlyList_1<CLROf<int>>, baseHeapSizes: IReadOnlyList_1<CLROf<int>>, deltaReaders: IReadOnlyList_1<MetadataReader>): MetadataAggregator$instance;
};


export type MetadataAggregator = MetadataAggregator$instance;

export interface MetadataBuilder$instance {
    AddAssembly(name: StringHandle, version: Version, culture: StringHandle, publicKey: BlobHandle, flags: AssemblyFlags, hashAlgorithm: AssemblyHashAlgorithm): AssemblyDefinitionHandle;
    AddAssemblyFile(name: StringHandle, hashValue: BlobHandle, containsMetadata: boolean): AssemblyFileHandle;
    AddAssemblyReference(name: StringHandle, version: Version, culture: StringHandle, publicKeyOrToken: BlobHandle, flags: AssemblyFlags, hashValue: BlobHandle): AssemblyReferenceHandle;
    AddConstant(parent: EntityHandle, value: unknown): ConstantHandle;
    AddCustomAttribute(parent: EntityHandle, constructor_: EntityHandle, value: BlobHandle): CustomAttributeHandle;
    AddCustomDebugInformation(parent: EntityHandle, kind: GuidHandle, value: BlobHandle): CustomDebugInformationHandle;
    AddDeclarativeSecurityAttribute(parent: EntityHandle, action: DeclarativeSecurityAction, permissionSet: BlobHandle): DeclarativeSecurityAttributeHandle;
    AddDocument(name: BlobHandle, hashAlgorithm: GuidHandle, hash: BlobHandle, language: GuidHandle): DocumentHandle;
    AddEncLogEntry(entity: EntityHandle, code: EditAndContinueOperation): void;
    AddEncMapEntry(entity: EntityHandle): void;
    AddEvent(attributes: EventAttributes, name: StringHandle, type_: EntityHandle): EventDefinitionHandle;
    AddEventMap(declaringType: TypeDefinitionHandle, eventList: EventDefinitionHandle): void;
    AddExportedType(attributes: TypeAttributes, namespace_: StringHandle, name: StringHandle, implementation: EntityHandle, typeDefinitionId: int): ExportedTypeHandle;
    AddFieldDefinition(attributes: FieldAttributes, name: StringHandle, signature: BlobHandle): FieldDefinitionHandle;
    AddFieldLayout(field: FieldDefinitionHandle, offset: int): void;
    AddFieldRelativeVirtualAddress(field: FieldDefinitionHandle, offset: int): void;
    AddGenericParameter(parent: EntityHandle, attributes: GenericParameterAttributes, name: StringHandle, index: int): GenericParameterHandle;
    AddGenericParameterConstraint(genericParameter: GenericParameterHandle, constraint: EntityHandle): GenericParameterConstraintHandle;
    AddImportScope(parentScope: ImportScopeHandle, imports: BlobHandle): ImportScopeHandle;
    AddInterfaceImplementation(type_: TypeDefinitionHandle, implementedInterface: EntityHandle): InterfaceImplementationHandle;
    AddLocalConstant(name: StringHandle, signature: BlobHandle): LocalConstantHandle;
    AddLocalScope(method: MethodDefinitionHandle, importScope: ImportScopeHandle, variableList: LocalVariableHandle, constantList: LocalConstantHandle, startOffset: int, length: int): LocalScopeHandle;
    AddLocalVariable(attributes: LocalVariableAttributes, index: int, name: StringHandle): LocalVariableHandle;
    AddManifestResource(attributes: ManifestResourceAttributes, name: StringHandle, implementation: EntityHandle, offset: uint): ManifestResourceHandle;
    AddMarshallingDescriptor(parent: EntityHandle, descriptor: BlobHandle): void;
    AddMemberReference(parent: EntityHandle, name: StringHandle, signature: BlobHandle): MemberReferenceHandle;
    AddMethodDebugInformation(document: DocumentHandle, sequencePoints: BlobHandle): MethodDebugInformationHandle;
    AddMethodDefinition(attributes: MethodAttributes, implAttributes: MethodImplAttributes, name: StringHandle, signature: BlobHandle, bodyOffset: int, parameterList: ParameterHandle): MethodDefinitionHandle;
    AddMethodImplementation(type_: TypeDefinitionHandle, methodBody: EntityHandle, methodDeclaration: EntityHandle): MethodImplementationHandle;
    AddMethodImport(method: MethodDefinitionHandle, attributes: MethodImportAttributes, name: StringHandle, module_: ModuleReferenceHandle): void;
    AddMethodSemantics(association: EntityHandle, semantics: MethodSemanticsAttributes, methodDefinition: MethodDefinitionHandle): void;
    AddMethodSpecification(method: EntityHandle, instantiation: BlobHandle): MethodSpecificationHandle;
    AddModule(generation: int, moduleName: StringHandle, mvid: GuidHandle, encId: GuidHandle, encBaseId: GuidHandle): ModuleDefinitionHandle;
    AddModuleReference(moduleName: StringHandle): ModuleReferenceHandle;
    AddNestedType(type_: TypeDefinitionHandle, enclosingType: TypeDefinitionHandle): void;
    AddParameter(attributes: ParameterAttributes, name: StringHandle, sequenceNumber: int): ParameterHandle;
    AddProperty(attributes: PropertyAttributes, name: StringHandle, signature: BlobHandle): PropertyDefinitionHandle;
    AddPropertyMap(declaringType: TypeDefinitionHandle, propertyList: PropertyDefinitionHandle): void;
    AddStandaloneSignature(signature: BlobHandle): StandaloneSignatureHandle;
    AddStateMachineMethod(moveNextMethod: MethodDefinitionHandle, kickoffMethod: MethodDefinitionHandle): void;
    AddTypeDefinition(attributes: TypeAttributes, namespace_: StringHandle, name: StringHandle, baseType: EntityHandle, fieldList: FieldDefinitionHandle, methodList: MethodDefinitionHandle): TypeDefinitionHandle;
    AddTypeLayout(type_: TypeDefinitionHandle, packingSize: ushort, size: uint): void;
    AddTypeReference(resolutionScope: EntityHandle, namespace_: StringHandle, name: StringHandle): TypeReferenceHandle;
    AddTypeSpecification(signature: BlobHandle): TypeSpecificationHandle;
    GetOrAddBlob(value: BlobBuilder): BlobHandle;
    GetOrAddBlob(value: byte[]): BlobHandle;
    GetOrAddBlob(value: ImmutableArray_1<CLROf<byte>>): BlobHandle;
    GetOrAddBlobUTF16(value: string): BlobHandle;
    GetOrAddBlobUTF8(value: string, allowUnpairedSurrogates?: boolean): BlobHandle;
    GetOrAddConstantBlob(value: unknown): BlobHandle;
    GetOrAddDocumentName(value: string): BlobHandle;
    GetOrAddGuid(guid: Guid): GuidHandle;
    GetOrAddString(value: string): StringHandle;
    GetOrAddUserString(value: string): UserStringHandle;
    GetRowCount(table: TableIndex): int;
    GetRowCounts(): ImmutableArray_1<CLROf<int>>;
    ReserveGuid(): ReservedBlob_1<GuidHandle>;
    ReserveUserString(length: int): ReservedBlob_1<UserStringHandle>;
    SetCapacity(table: TableIndex, rowCount: int): void;
    SetCapacity(heap: HeapIndex, byteCount: int): void;
}


export const MetadataBuilder: {
    new(userStringHeapStartOffset: int, stringHeapStartOffset: int, blobHeapStartOffset: int, guidHeapStartOffset: int): MetadataBuilder$instance;
};


export type MetadataBuilder = MetadataBuilder$instance;

export interface MetadataRootBuilder$instance {
    readonly MetadataVersion: string;
    readonly Sizes: MetadataSizes;
    readonly SuppressValidation: boolean;
    Serialize(builder: BlobBuilder, methodBodyStreamRva: int, mappedFieldDataStreamRva: int): void;
}


export const MetadataRootBuilder: {
    new(tablesAndHeaps: MetadataBuilder, metadataVersion: string, suppressValidation: boolean): MetadataRootBuilder$instance;
};


export type MetadataRootBuilder = MetadataRootBuilder$instance;

export interface MetadataSizes$instance {
    readonly ExternalRowCounts: ImmutableArray_1<CLROf<int>>;
    readonly HeapSizes: ImmutableArray_1<CLROf<int>>;
    readonly RowCounts: ImmutableArray_1<CLROf<int>>;
    GetAlignedHeapSize(index: HeapIndex): int;
}


export const MetadataSizes: {
    new(): MetadataSizes$instance;
};


export type MetadataSizes = MetadataSizes$instance;

export interface PortablePdbBuilder$instance {
    readonly FormatVersion: ushort;
    readonly IdProvider: Func_2<IEnumerable_1<Blob>, BlobContentId>;
    readonly MetadataVersion: string;
    Serialize(builder: BlobBuilder): BlobContentId;
}


export const PortablePdbBuilder: {
    new(tablesAndHeaps: MetadataBuilder, typeSystemRowCounts: ImmutableArray_1<CLROf<int>>, entryPoint: MethodDefinitionHandle, idProvider: Func_2<IEnumerable_1<Blob>, BlobContentId>): PortablePdbBuilder$instance;
};


export type PortablePdbBuilder = PortablePdbBuilder$instance;

export abstract class CodedIndex$instance {
    static CustomAttributeType(handle: EntityHandle): int;
    static HasConstant(handle: EntityHandle): int;
    static HasCustomAttribute(handle: EntityHandle): int;
    static HasCustomDebugInformation(handle: EntityHandle): int;
    static HasDeclSecurity(handle: EntityHandle): int;
    static HasFieldMarshal(handle: EntityHandle): int;
    static HasSemantics(handle: EntityHandle): int;
    static Implementation(handle: EntityHandle): int;
    static MemberForwarded(handle: EntityHandle): int;
    static MemberRefParent(handle: EntityHandle): int;
    static MethodDefOrRef(handle: EntityHandle): int;
    static ResolutionScope(handle: EntityHandle): int;
    static TypeDefOrRef(handle: EntityHandle): int;
    static TypeDefOrRefOrSpec(handle: EntityHandle): int;
    static TypeOrMethodDef(handle: EntityHandle): int;
}


export type CodedIndex = CodedIndex$instance;

export abstract class ExportedTypeExtensions$instance {
    static GetTypeDefinitionId(exportedType: ExportedType): int;
}


export type ExportedTypeExtensions = ExportedTypeExtensions$instance;

export abstract class MetadataReaderExtensions$instance {
    static GetEditAndContinueLogEntries(reader: MetadataReader): IEnumerable_1<EditAndContinueLogEntry>;
    static GetEditAndContinueMapEntries(reader: MetadataReader): IEnumerable_1<EntityHandle>;
    static GetHeapMetadataOffset(reader: MetadataReader, heapIndex: HeapIndex): int;
    static GetHeapSize(reader: MetadataReader, heapIndex: HeapIndex): int;
    static GetNextHandle(reader: MetadataReader, handle: BlobHandle): BlobHandle;
    static GetNextHandle(reader: MetadataReader, handle: StringHandle): StringHandle;
    static GetNextHandle(reader: MetadataReader, handle: UserStringHandle): UserStringHandle;
    static GetTableMetadataOffset(reader: MetadataReader, tableIndex: TableIndex): int;
    static GetTableRowCount(reader: MetadataReader, tableIndex: TableIndex): int;
    static GetTableRowSize(reader: MetadataReader, tableIndex: TableIndex): int;
    static GetTypesWithEvents(reader: MetadataReader): IEnumerable_1<TypeDefinitionHandle>;
    static GetTypesWithProperties(reader: MetadataReader): IEnumerable_1<TypeDefinitionHandle>;
    static ResolveSignatureTypeKind(reader: MetadataReader, typeHandle: EntityHandle, rawTypeKind: byte): SignatureTypeKind;
}


export type MetadataReaderExtensions = MetadataReaderExtensions$instance;

export abstract class MetadataTokens$instance {
    static readonly TableCount: int;
    static readonly HeapCount: int;
    static AssemblyFileHandle(rowNumber: int): AssemblyFileHandle;
    static AssemblyReferenceHandle(rowNumber: int): AssemblyReferenceHandle;
    static BlobHandle(offset: int): BlobHandle;
    static ConstantHandle(rowNumber: int): ConstantHandle;
    static CustomAttributeHandle(rowNumber: int): CustomAttributeHandle;
    static CustomDebugInformationHandle(rowNumber: int): CustomDebugInformationHandle;
    static DeclarativeSecurityAttributeHandle(rowNumber: int): DeclarativeSecurityAttributeHandle;
    static DocumentHandle(rowNumber: int): DocumentHandle;
    static DocumentNameBlobHandle(offset: int): DocumentNameBlobHandle;
    static EntityHandle(token: int): EntityHandle;
    static EntityHandle(tableIndex: TableIndex, rowNumber: int): EntityHandle;
    static EventDefinitionHandle(rowNumber: int): EventDefinitionHandle;
    static ExportedTypeHandle(rowNumber: int): ExportedTypeHandle;
    static FieldDefinitionHandle(rowNumber: int): FieldDefinitionHandle;
    static GenericParameterConstraintHandle(rowNumber: int): GenericParameterConstraintHandle;
    static GenericParameterHandle(rowNumber: int): GenericParameterHandle;
    static GetHeapOffset(handle: BlobHandle): int;
    static GetHeapOffset(handle: GuidHandle): int;
    static GetHeapOffset(handle: Handle): int;
    static GetHeapOffset(reader: MetadataReader, handle: Handle): int;
    static GetHeapOffset(handle: StringHandle): int;
    static GetHeapOffset(handle: UserStringHandle): int;
    static GetRowNumber(handle: EntityHandle): int;
    static GetRowNumber(reader: MetadataReader, handle: EntityHandle): int;
    static GetToken(handle: EntityHandle): int;
    static GetToken(handle: Handle): int;
    static GetToken(reader: MetadataReader, handle: EntityHandle): int;
    static GetToken(reader: MetadataReader, handle: Handle): int;
    static GuidHandle(offset: int): GuidHandle;
    static Handle(token: int): Handle;
    static Handle(tableIndex: TableIndex, rowNumber: int): EntityHandle;
    static ImportScopeHandle(rowNumber: int): ImportScopeHandle;
    static InterfaceImplementationHandle(rowNumber: int): InterfaceImplementationHandle;
    static LocalConstantHandle(rowNumber: int): LocalConstantHandle;
    static LocalScopeHandle(rowNumber: int): LocalScopeHandle;
    static LocalVariableHandle(rowNumber: int): LocalVariableHandle;
    static ManifestResourceHandle(rowNumber: int): ManifestResourceHandle;
    static MemberReferenceHandle(rowNumber: int): MemberReferenceHandle;
    static MethodDebugInformationHandle(rowNumber: int): MethodDebugInformationHandle;
    static MethodDefinitionHandle(rowNumber: int): MethodDefinitionHandle;
    static MethodImplementationHandle(rowNumber: int): MethodImplementationHandle;
    static MethodSpecificationHandle(rowNumber: int): MethodSpecificationHandle;
    static ModuleReferenceHandle(rowNumber: int): ModuleReferenceHandle;
    static ParameterHandle(rowNumber: int): ParameterHandle;
    static PropertyDefinitionHandle(rowNumber: int): PropertyDefinitionHandle;
    static StandaloneSignatureHandle(rowNumber: int): StandaloneSignatureHandle;
    static StringHandle(offset: int): StringHandle;
    static TryGetHeapIndex(type_: HandleKind, index: { value: ref<HeapIndex> }): boolean;
    static TryGetTableIndex(type_: HandleKind, index: { value: ref<TableIndex> }): boolean;
    static TypeDefinitionHandle(rowNumber: int): TypeDefinitionHandle;
    static TypeReferenceHandle(rowNumber: int): TypeReferenceHandle;
    static TypeSpecificationHandle(rowNumber: int): TypeSpecificationHandle;
    static UserStringHandle(offset: int): UserStringHandle;
}


export type MetadataTokens = MetadataTokens$instance;


// Generated by tsbindgen - Architecture
// Namespace: System.ComponentModel
// Assembly: System.ComponentModel, System.ComponentModel.EventBasedAsync, System.ComponentModel.Primitives, System.ComponentModel.TypeConverter, System.ObjectModel, System.Private.CoreLib

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IList_1, IReadOnlyCollection_1, IReadOnlyList_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_ObjectModel_Internal from "../../System.Collections.ObjectModel/internal/index.js";
import type { Collection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { Hashtable, ICollection, IComparer, IDictionary, IDictionaryEnumerator, IEnumerable, IEnumerator, IList, ReadOnlyCollectionBase } from "../../System.Collections/internal/index.js";
import type { IDesigner } from "../../System.ComponentModel.Design/internal/index.js";
import type { CultureInfo } from "../../System.Globalization/internal/index.js";
import type { UnmanagedMemoryStream } from "../../System.IO/internal/index.js";
import type { Assembly, MethodBase, MethodInfo, Module } from "../../System.Reflection/internal/index.js";
import * as System_Resources_Internal from "../../System.Resources/internal/index.js";
import type { ResourceManager, ResourceSet } from "../../System.Resources/internal/index.js";
import * as System_Runtime_InteropServices_Internal from "../../System.Runtime.InteropServices/internal/index.js";
import type { ExternalException } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { SendOrPostCallback, SynchronizationContext } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { ArgumentException, Array as ClrArray, AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Char, Delegate, Double, Enum, EventArgs, EventHandler, EventHandler_1, Exception, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int16, Int32, Int64, IntPtr, IServiceProvider, ISpanFormattable, MarshalByRefObject, MulticastDelegate, Nullable_1, Object as ClrObject, SByte, Single, String as ClrString, SystemException, Type, TypeCode, UInt16, UInt32, UInt64, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum BindableSupport {
    No = 0,
    Yes = 1,
    Default = 2
}


export enum BindingDirection {
    OneWay = 0,
    TwoWay = 1
}


export enum CollectionChangeAction {
    Add = 1,
    Remove = 2,
    Refresh = 3
}


export enum DataObjectMethodType {
    Fill = 0,
    Select = 1,
    Update = 2,
    Insert = 3,
    Delete = 4
}


export enum DesignerSerializationVisibility {
    Hidden = 0,
    Visible = 1,
    Content = 2
}


export enum EditorBrowsableState {
    Always = 0,
    Never = 1,
    Advanced = 2
}


export enum InheritanceLevel {
    Inherited = 1,
    InheritedReadOnly = 2,
    NotInherited = 3
}


export enum LicenseUsageMode {
    Runtime = 0,
    Designtime = 1
}


export enum ListChangedType {
    Reset = 0,
    ItemAdded = 1,
    ItemDeleted = 2,
    ItemMoved = 3,
    ItemChanged = 4,
    PropertyDescriptorAdded = 5,
    PropertyDescriptorDeleted = 6,
    PropertyDescriptorChanged = 7
}


export enum ListSortDirection {
    Ascending = 0,
    Descending = 1
}


export enum MaskedTextResultHint {
    Unknown = 0,
    CharacterEscaped = 1,
    NoEffect = 2,
    SideEffect = 3,
    Success = 4,
    AsciiCharacterExpected = -1,
    AlphanumericCharacterExpected = -2,
    DigitExpected = -3,
    LetterExpected = -4,
    SignedDigitExpected = -5,
    InvalidInput = -51,
    PromptCharNotAllowed = -52,
    UnavailableEditPosition = -53,
    NonEditPosition = -54,
    PositionOutOfRange = -55
}


export enum PropertyTabScope {
    Static = 0,
    Global = 1,
    Document = 2,
    Component = 3
}


export enum RefreshProperties {
    None = 0,
    All = 1,
    Repaint = 2
}


export enum ToolboxItemFilterType {
    Allow = 0,
    Custom = 1,
    Prevent = 2,
    Require = 3
}


export type AddingNewEventHandler = (sender: unknown, e: AddingNewEventArgs) => void;


export type AsyncCompletedEventHandler = (sender: unknown, e: AsyncCompletedEventArgs) => void;


export type CancelEventHandler = (sender: unknown, e: CancelEventArgs) => void;


export type CollectionChangeEventHandler = (sender: unknown, e: CollectionChangeEventArgs) => void;


export type DoWorkEventHandler = (sender: unknown, e: DoWorkEventArgs) => void;


export type HandledEventHandler = (sender: unknown, e: HandledEventArgs) => void;


export type ListChangedEventHandler = (sender: unknown, e: ListChangedEventArgs) => void;


export type ProgressChangedEventHandler = (sender: unknown, e: ProgressChangedEventArgs) => void;


export type PropertyChangedEventHandler = (sender: unknown, e: PropertyChangedEventArgs) => void;


export type PropertyChangingEventHandler = (sender: unknown, e: PropertyChangingEventArgs) => void;


export type RefreshEventHandler = (e: RefreshEventArgs) => void;


export type RunWorkerCompletedEventHandler = (sender: unknown, e: RunWorkerCompletedEventArgs) => void;


export interface IBindingList$instance extends IList, ICollection, IEnumerable {
    readonly AllowNew: boolean;
    readonly AllowEdit: boolean;
    readonly AllowRemove: boolean;
    readonly SupportsChangeNotification: boolean;
    readonly SupportsSearching: boolean;
    readonly SupportsSorting: boolean;
    readonly IsSorted: boolean;
    readonly SortProperty: PropertyDescriptor;
    readonly SortDirection: ListSortDirection;
    Item: unknown;
    readonly IsReadOnly: boolean;
    readonly IsFixedSize: boolean;
    readonly Count: int;
    readonly SyncRoot: unknown;
    readonly IsSynchronized: boolean;
    Add(value: unknown): int;
    AddIndex(property: PropertyDescriptor): void;
    AddNew(): unknown;
    ApplySort(property: PropertyDescriptor, direction: ListSortDirection): void;
    Contains(value: unknown): boolean;
    CopyTo(array: ClrArray, index: int): void;
    Find(property: PropertyDescriptor, key: unknown): int;
    GetEnumerator(): IEnumerator;
    Insert(index: int, value: unknown): void;
    Remove(value: unknown): void;
    RemoveAt(index: int): void;
    RemoveSort(): void;
    Clear(): void;
}


export type IBindingList = IBindingList$instance;

export interface IBindingListView$instance extends IBindingList, IList, ICollection, IEnumerable {
    Filter: string;
    readonly SortDescriptions: ListSortDescriptionCollection;
    readonly SupportsAdvancedSorting: boolean;
    readonly SupportsFiltering: boolean;
    readonly AllowNew: boolean;
    readonly AllowEdit: boolean;
    readonly AllowRemove: boolean;
    readonly SupportsChangeNotification: boolean;
    readonly SupportsSearching: boolean;
    readonly SupportsSorting: boolean;
    readonly IsSorted: boolean;
    readonly SortProperty: PropertyDescriptor;
    readonly SortDirection: ListSortDirection;
    Item: unknown;
    readonly IsReadOnly: boolean;
    readonly IsFixedSize: boolean;
    readonly Count: int;
    readonly SyncRoot: unknown;
    readonly IsSynchronized: boolean;
    Add(value: unknown): int;
    AddIndex(property: PropertyDescriptor): void;
    AddNew(): unknown;
    ApplySort(property: PropertyDescriptor, direction: ListSortDirection): void;
    ApplySort(sorts: ListSortDescriptionCollection): void;
    Contains(value: unknown): boolean;
    CopyTo(array: ClrArray, index: int): void;
    Find(property: PropertyDescriptor, key: unknown): int;
    GetEnumerator(): IEnumerator;
    Insert(index: int, value: unknown): void;
    Remove(value: unknown): void;
    RemoveAt(index: int): void;
    RemoveFilter(): void;
    Clear(): void;
    RemoveSort(): void;
}


export type IBindingListView = IBindingListView$instance;

export interface ICancelAddNew$instance {
    CancelNew(itemIndex: int): void;
}


export type ICancelAddNew = ICancelAddNew$instance;

export interface IChangeTracking$instance {
    readonly IsChanged: boolean;
    AcceptChanges(): void;
}


export type IChangeTracking = IChangeTracking$instance;

export interface IComNativeDescriptorHandler$instance {
    GetAttributes(component: unknown): AttributeCollection;
    GetClassName(component: unknown): string;
    GetConverter(component: unknown): TypeConverter;
    GetDefaultEvent(component: unknown): EventDescriptor;
    GetDefaultProperty(component: unknown): PropertyDescriptor;
    GetEditor(component: unknown, baseEditorType: Type): unknown;
    GetEvents(component: unknown, attributes: Attribute[]): EventDescriptorCollection;
    GetEvents(component: unknown): EventDescriptorCollection;
    GetProperties(component: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    GetPropertyValue(component: unknown, dispid: int, success: { value: ref<boolean> }): unknown;
    GetPropertyValue(component: unknown, propertyName: string, success: { value: ref<boolean> }): unknown;
}


export type IComNativeDescriptorHandler = IComNativeDescriptorHandler$instance;

export interface IComponent$instance extends IDisposable {
    Site: ISite;
    Dispose(): void;
}


export interface IComponent$instance extends System_Internal.IDisposable$instance {}

export type IComponent = IComponent$instance;

export interface IContainer$instance extends IDisposable {
    readonly Components: ComponentCollection;
    Add(component: IComponent, name: string): void;
    Add(component: IComponent): void;
    Dispose(): void;
}


export interface IContainer$instance extends System_Internal.IDisposable$instance {}

export type IContainer = IContainer$instance;

export interface ICustomTypeDescriptor$instance {
    readonly RequireRegisteredTypes: Nullable_1<CLROf<boolean>>;
    GetAttributes(): AttributeCollection;
    GetClassName(): string;
    GetConverter(): TypeConverter;
    GetDefaultEvent(): EventDescriptor;
    GetDefaultProperty(): PropertyDescriptor;
    GetEditor(editorBaseType: Type): unknown;
    GetEvents(): EventDescriptorCollection;
    GetEvents(attributes: Attribute[]): EventDescriptorCollection;
    GetProperties(): PropertyDescriptorCollection;
    GetProperties(attributes: Attribute[]): PropertyDescriptorCollection;
    GetPropertyOwner(pd: PropertyDescriptor): unknown;
}


export type ICustomTypeDescriptor = ICustomTypeDescriptor$instance;

export interface IDataErrorInfo$instance {
    readonly Item: string;
    readonly Error: string;
}


export type IDataErrorInfo = IDataErrorInfo$instance;

export interface IEditableObject$instance {
    BeginEdit(): void;
}


export type IEditableObject = IEditableObject$instance;

export interface IExtenderProvider$instance {
    CanExtend(extendee: unknown): boolean;
}


export type IExtenderProvider = IExtenderProvider$instance;

export interface IIntellisenseBuilder$instance {
    readonly Name: string;
    Show(language: string, value: string, newValue: { value: ref<string> }): boolean;
}


export type IIntellisenseBuilder = IIntellisenseBuilder$instance;

export interface IListSource$instance {
    readonly ContainsListCollection: boolean;
    GetList(): IList;
}


export type IListSource = IListSource$instance;

export interface INestedContainer$instance extends IContainer, IDisposable {
    readonly Owner: IComponent;
    readonly Components: ComponentCollection;
    Add(component: IComponent, name: string): void;
    Add(component: IComponent): void;
    Dispose(): void;
}


export type INestedContainer = INestedContainer$instance;

export interface INestedSite$instance extends ISite, IServiceProvider {
    readonly FullName: string;
    readonly Component: IComponent;
    readonly Container: IContainer;
    readonly DesignMode: boolean;
    Name: string;
    GetService(serviceType: Type): unknown;
}


export type INestedSite = INestedSite$instance;

export interface INotifyDataErrorInfo$instance {
    readonly HasErrors: boolean;
    GetErrors(propertyName: string): IEnumerable;
}


export type INotifyDataErrorInfo = INotifyDataErrorInfo$instance;

export interface INotifyPropertyChanged$instance {
}


export type INotifyPropertyChanged = INotifyPropertyChanged$instance;

export interface INotifyPropertyChanging$instance {
}


export type INotifyPropertyChanging = INotifyPropertyChanging$instance;

export interface IRaiseItemChangedEvents$instance {
    readonly RaisesItemChangedEvents: boolean;
}


export type IRaiseItemChangedEvents = IRaiseItemChangedEvents$instance;

export interface IRevertibleChangeTracking$instance extends IChangeTracking {
    readonly IsChanged: boolean;
    RejectChanges(): void;
    AcceptChanges(): void;
}


export interface IRevertibleChangeTracking$instance extends IChangeTracking$instance {}

export type IRevertibleChangeTracking = IRevertibleChangeTracking$instance;

export interface ISite$instance extends IServiceProvider {
    readonly Component: IComponent;
    readonly Container: IContainer;
    readonly DesignMode: boolean;
    Name: string;
    GetService(serviceType: Type): unknown;
}


export interface ISite$instance extends System_Internal.IServiceProvider$instance {}

export type ISite = ISite$instance;

export interface ISupportInitialize$instance {
    BeginInit(): void;
}


export type ISupportInitialize = ISupportInitialize$instance;

export interface ISupportInitializeNotification$instance extends ISupportInitialize {
    readonly IsInitialized: boolean;
    BeginInit(): void;
}


export interface ISupportInitializeNotification$instance extends ISupportInitialize$instance {}

export type ISupportInitializeNotification = ISupportInitializeNotification$instance;

export interface ISynchronizeInvoke$instance {
    readonly InvokeRequired: boolean;
    BeginInvoke(method: Function, args: unknown[]): IAsyncResult;
    EndInvoke(result: IAsyncResult): unknown;
    Invoke(method: Function, args: unknown[]): unknown;
}


export type ISynchronizeInvoke = ISynchronizeInvoke$instance;

export interface ITypeDescriptorContext$instance extends IServiceProvider {
    readonly Container: IContainer;
    readonly Instance: unknown;
    readonly PropertyDescriptor: PropertyDescriptor;
    GetService(serviceType: Type): unknown;
    OnComponentChanged(): void;
    OnComponentChanging(): boolean;
}


export interface ITypeDescriptorContext$instance extends System_Internal.IServiceProvider$instance {}

export type ITypeDescriptorContext = ITypeDescriptorContext$instance;

export interface ITypedList$instance {
    GetItemProperties(listAccessors: PropertyDescriptor[]): PropertyDescriptorCollection;
    GetListName(listAccessors: PropertyDescriptor[]): string;
}


export type ITypedList = ITypedList$instance;

export interface AddingNewEventArgs$instance extends EventArgs {
    NewObject: unknown;
}


export const AddingNewEventArgs: {
    new(): AddingNewEventArgs$instance;
    new(newObject: unknown): AddingNewEventArgs$instance;
};


export type AddingNewEventArgs = AddingNewEventArgs$instance;

export interface AmbientValueAttribute$instance extends Attribute {
    readonly Value: unknown;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const AmbientValueAttribute: {
    new(type_: Type, value: string): AmbientValueAttribute$instance;
    new(value: char): AmbientValueAttribute$instance;
    new(value: byte): AmbientValueAttribute$instance;
    new(value: short): AmbientValueAttribute$instance;
    new(value: int): AmbientValueAttribute$instance;
    new(value: long): AmbientValueAttribute$instance;
    new(value: float): AmbientValueAttribute$instance;
    new(value: double): AmbientValueAttribute$instance;
    new(value: boolean): AmbientValueAttribute$instance;
    new(value: string): AmbientValueAttribute$instance;
    new(value: unknown): AmbientValueAttribute$instance;
};


export type AmbientValueAttribute = AmbientValueAttribute$instance;

export interface ArrayConverter$instance extends CollectionConverter {
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
    GetProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    GetProperties(value: unknown): PropertyDescriptorCollection;
    GetProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    GetPropertiesSupported(context: ITypeDescriptorContext): boolean;
    GetPropertiesSupported(): boolean;
}


export const ArrayConverter: {
    new(): ArrayConverter$instance;
};


export type ArrayConverter = ArrayConverter$instance;

export interface AsyncCompletedEventArgs$instance extends EventArgs {
    readonly Cancelled: boolean;
    readonly Error: Exception;
    readonly UserState: unknown;
}


export const AsyncCompletedEventArgs: {
    new(error: Exception, cancelled: boolean, userState: unknown): AsyncCompletedEventArgs$instance;
};


export type AsyncCompletedEventArgs = AsyncCompletedEventArgs$instance;

export interface AsyncOperation$instance {
    readonly SynchronizationContext: SynchronizationContext;
    readonly UserSuppliedState: unknown;
    OperationCompleted(): void;
    Post(d: SendOrPostCallback, arg: unknown): void;
    PostOperationCompleted(d: SendOrPostCallback, arg: unknown): void;
}


export const AsyncOperation: {
    new(): AsyncOperation$instance;
};


export type AsyncOperation = AsyncOperation$instance;

export interface AttributeCollection$instance {
    readonly Count: int;
    Contains(attribute: Attribute): boolean;
    Contains(attributes: Attribute[]): boolean;
    CopyTo(array: ClrArray, index: int): void;
    get_Item(index: int): Attribute;
    get_Item(attributeType: Type): Attribute;
    GetEnumerator(): IEnumerator;
    Matches(attribute: Attribute): boolean;
    Matches(attributes: Attribute[]): boolean;
}


export const AttributeCollection: {
    new(attributes: Attribute[]): AttributeCollection$instance;
    readonly Empty: AttributeCollection;
    FromExisting(existing: AttributeCollection, ...newAttributes: Attribute[]): AttributeCollection;
};


export interface __AttributeCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type AttributeCollection = AttributeCollection$instance & __AttributeCollection$views;


export interface AttributeProviderAttribute$instance extends Attribute {
    readonly PropertyName: string;
    readonly TypeName: string;
}


export const AttributeProviderAttribute: {
    new(typeName: string): AttributeProviderAttribute$instance;
    new(typeName: string, propertyName: string): AttributeProviderAttribute$instance;
    new(type_: Type): AttributeProviderAttribute$instance;
};


export type AttributeProviderAttribute = AttributeProviderAttribute$instance;

export interface BackgroundWorker$instance extends Component$instance {
    readonly CancellationPending: boolean;
    readonly IsBusy: boolean;
    WorkerReportsProgress: boolean;
    WorkerSupportsCancellation: boolean;
    CancelAsync(): void;
    Dispose(): void;
    ReportProgress(percentProgress: int): void;
    ReportProgress(percentProgress: int, userState: unknown): void;
    RunWorkerAsync(): void;
    RunWorkerAsync(argument: unknown): void;
}


export const BackgroundWorker: {
    new(): BackgroundWorker$instance;
};


export interface __BackgroundWorker$views {
    As_IComponent(): IComponent$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface BackgroundWorker$instance extends IComponent$instance {}

export type BackgroundWorker = BackgroundWorker$instance & __BackgroundWorker$views;


export interface BaseNumberConverter$instance extends TypeConverter {
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFrom(value: unknown): unknown;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
}


export const BaseNumberConverter: {
};


export type BaseNumberConverter = BaseNumberConverter$instance;

export interface BindableAttribute$instance extends Attribute {
    readonly Bindable: boolean;
    readonly Direction: BindingDirection;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
}


export const BindableAttribute: {
    new(bindable: boolean): BindableAttribute$instance;
    new(bindable: boolean, direction: BindingDirection): BindableAttribute$instance;
    new(flags: BindableSupport): BindableAttribute$instance;
    new(flags: BindableSupport, direction: BindingDirection): BindableAttribute$instance;
    readonly Yes: BindableAttribute;
    readonly No: BindableAttribute;
    readonly Default: BindableAttribute;
};


export type BindableAttribute = BindableAttribute$instance;

export interface BindingList_1$instance<T> extends Collection_1<T> {
    AllowEdit: boolean;
    AllowNew: boolean;
    AllowRemove: boolean;
    RaiseListChangedEvents: boolean;
    Add(item: T): void;
    Add(value: unknown): int;
    AddNew(): T;
    CancelNew(itemIndex: int): void;
    Clear(): void;
    Contains(item: T): boolean;
    Contains(value: unknown): boolean;
    CopyTo(array: T[], index: int): void;
    CopyTo(array: ClrArray, index: int): void;
    EndNew(itemIndex: int): void;
    GetEnumerator(): IEnumerator_1<T>;
    GetEnumerator(): IEnumerator;
    IndexOf(item: T): int;
    Insert(index: int, item: T): void;
    Insert(index: int, value: unknown): void;
    Remove(item: T): boolean;
    Remove(value: unknown): void;
    RemoveAt(index: int): void;
    ResetBindings(): void;
    ResetItem(position: int): void;
}


export const BindingList_1: {
    new<T>(): BindingList_1$instance<T>;
    new<T>(list: IList_1<T>): BindingList_1$instance<T>;
};


export interface __BindingList_1$views<T> {
    As_IBindingList(): IBindingList$instance;
    As_ICancelAddNew(): ICancelAddNew$instance;
    As_IRaiseItemChangedEvents(): IRaiseItemChangedEvents$instance;
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export interface BindingList_1$instance<T> extends ICancelAddNew$instance, IRaiseItemChangedEvents$instance {}

export type BindingList_1<T> = BindingList_1$instance<T> & __BindingList_1$views<T>;


export interface BooleanConverter$instance extends TypeConverter {
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFrom(value: unknown): unknown;
    GetStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    GetStandardValues(): ICollection;
    GetStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    GetStandardValuesExclusive(): boolean;
    GetStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    GetStandardValuesSupported(): boolean;
}


export const BooleanConverter: {
    new(): BooleanConverter$instance;
};


export type BooleanConverter = BooleanConverter$instance;

export interface BrowsableAttribute$instance extends Attribute {
    readonly Browsable: boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
}


export const BrowsableAttribute: {
    new(browsable: boolean): BrowsableAttribute$instance;
    readonly Yes: BrowsableAttribute;
    readonly No: BrowsableAttribute;
    readonly Default: BrowsableAttribute;
};


export type BrowsableAttribute = BrowsableAttribute$instance;

export interface ByteConverter$instance extends BaseNumberConverter {
}


export const ByteConverter: {
    new(): ByteConverter$instance;
};


export type ByteConverter = ByteConverter$instance;

export interface CancelEventArgs$instance extends EventArgs {
    Cancel: boolean;
}


export const CancelEventArgs: {
    new(): CancelEventArgs$instance;
    new(cancel: boolean): CancelEventArgs$instance;
};


export type CancelEventArgs = CancelEventArgs$instance;

export interface CategoryAttribute$instance extends Attribute {
    readonly Category: string;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
}


export const CategoryAttribute: {
    new(): CategoryAttribute$instance;
    new(category: string): CategoryAttribute$instance;
    readonly Action: CategoryAttribute;
    readonly Appearance: CategoryAttribute;
    readonly Asynchronous: CategoryAttribute;
    readonly Behavior: CategoryAttribute;
    readonly Data: CategoryAttribute;
    readonly Default: CategoryAttribute;
    readonly Design: CategoryAttribute;
    readonly DragDrop: CategoryAttribute;
    readonly Focus: CategoryAttribute;
    readonly Format: CategoryAttribute;
    readonly Key: CategoryAttribute;
    readonly Layout: CategoryAttribute;
    readonly Mouse: CategoryAttribute;
    readonly WindowStyle: CategoryAttribute;
};


export type CategoryAttribute = CategoryAttribute$instance;

export interface CharConverter$instance extends TypeConverter {
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFrom(value: unknown): unknown;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
}


export const CharConverter: {
    new(): CharConverter$instance;
};


export type CharConverter = CharConverter$instance;

export interface CollectionChangeEventArgs$instance extends EventArgs {
    readonly Action: CollectionChangeAction;
    readonly Element: unknown;
}


export const CollectionChangeEventArgs: {
    new(action: CollectionChangeAction, element: unknown): CollectionChangeEventArgs$instance;
};


export type CollectionChangeEventArgs = CollectionChangeEventArgs$instance;

export interface CollectionConverter$instance extends TypeConverter {
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
    GetProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    GetProperties(value: unknown): PropertyDescriptorCollection;
    GetProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
}


export const CollectionConverter: {
    new(): CollectionConverter$instance;
};


export type CollectionConverter = CollectionConverter$instance;

export interface ComplexBindingPropertiesAttribute$instance extends Attribute {
    readonly DataMember: string;
    readonly DataSource: string;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const ComplexBindingPropertiesAttribute: {
    new(): ComplexBindingPropertiesAttribute$instance;
    new(dataSource: string): ComplexBindingPropertiesAttribute$instance;
    new(dataSource: string, dataMember: string): ComplexBindingPropertiesAttribute$instance;
    readonly Default: ComplexBindingPropertiesAttribute;
};


export type ComplexBindingPropertiesAttribute = ComplexBindingPropertiesAttribute$instance;

export interface Component$instance extends MarshalByRefObject {
    readonly Container: IContainer;
    Site: ISite;
    Dispose(): void;
    ToString(): string;
}


export const Component: {
    new(): Component$instance;
};


export interface __Component$views {
    As_IComponent(): IComponent$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type Component = Component$instance & __Component$views;


export interface ComponentCollection$instance extends ReadOnlyCollectionBase {
    CopyTo(array: ClrArray, index: int): void;
    get_Item(name: string): IComponent;
    get_Item(index: int): IComponent;
    GetEnumerator(): IEnumerator;
}


export const ComponentCollection: {
    new(components: IComponent[]): ComponentCollection$instance;
};


export interface __ComponentCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export interface ComponentCollection$instance extends System_Collections_Internal.ICollection$instance {}

export type ComponentCollection = ComponentCollection$instance & __ComponentCollection$views;


export interface ComponentConverter$instance extends ReferenceConverter {
    GetProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    GetProperties(value: unknown): PropertyDescriptorCollection;
    GetProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    GetPropertiesSupported(context: ITypeDescriptorContext): boolean;
    GetPropertiesSupported(): boolean;
}


export const ComponentConverter: {
    new(type_: Type): ComponentConverter$instance;
};


export type ComponentConverter = ComponentConverter$instance;

export interface ComponentEditor$instance {
    EditComponent(component: unknown): boolean;
    EditComponent(context: ITypeDescriptorContext, component: unknown): boolean;
}


export const ComponentEditor: {
};


export type ComponentEditor = ComponentEditor$instance;

export interface ComponentResourceManager$instance extends ResourceManager {
    ApplyResources(value: unknown, objectName: string): void;
    ApplyResources(value: unknown, objectName: string, culture: CultureInfo): void;
    ApplyResourcesToRegisteredType(value: unknown, objectName: string, culture: CultureInfo): void;
}


export const ComponentResourceManager: {
    new(): ComponentResourceManager$instance;
    new(t: Type): ComponentResourceManager$instance;
};


export type ComponentResourceManager = ComponentResourceManager$instance;

export interface Container$instance {
    readonly Components: ComponentCollection;
    Add(component: IComponent): void;
    Add(component: IComponent, name: string): void;
    Dispose(): void;
    Remove(component: IComponent): void;
}


export const Container: {
    new(): Container$instance;
};


export interface __Container$views {
    As_IContainer(): IContainer$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type Container = Container$instance & __Container$views;


export interface ContainerFilterService$instance {
    FilterComponents(components: ComponentCollection): ComponentCollection;
}


export const ContainerFilterService: {
};


export type ContainerFilterService = ContainerFilterService$instance;

export interface CultureInfoConverter$instance extends TypeConverter {
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFrom(value: unknown): unknown;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
    GetStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    GetStandardValues(): ICollection;
    GetStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    GetStandardValuesExclusive(): boolean;
    GetStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    GetStandardValuesSupported(): boolean;
}


export const CultureInfoConverter: {
    new(): CultureInfoConverter$instance;
};


export type CultureInfoConverter = CultureInfoConverter$instance;

export interface CustomTypeDescriptor$instance {
    readonly RequireRegisteredTypes: Nullable_1<CLROf<boolean>>;
    GetAttributes(): AttributeCollection;
    GetClassName(): string;
    GetComponentName(): string;
    GetConverter(): TypeConverter;
    GetConverterFromRegisteredType(): TypeConverter;
    GetDefaultEvent(): EventDescriptor;
    GetDefaultProperty(): PropertyDescriptor;
    GetEditor(editorBaseType: Type): unknown;
    GetEvents(): EventDescriptorCollection;
    GetEvents(attributes: Attribute[]): EventDescriptorCollection;
    GetEventsFromRegisteredType(): EventDescriptorCollection;
    GetProperties(): PropertyDescriptorCollection;
    GetProperties(attributes: Attribute[]): PropertyDescriptorCollection;
    GetPropertiesFromRegisteredType(): PropertyDescriptorCollection;
    GetPropertyOwner(pd: PropertyDescriptor): unknown;
}


export const CustomTypeDescriptor: {
};


export interface __CustomTypeDescriptor$views {
    As_ICustomTypeDescriptor(): ICustomTypeDescriptor$instance;
}

export interface CustomTypeDescriptor$instance extends ICustomTypeDescriptor$instance {}

export type CustomTypeDescriptor = CustomTypeDescriptor$instance & __CustomTypeDescriptor$views;


export interface DataErrorsChangedEventArgs$instance extends EventArgs {
    readonly PropertyName: string;
}


export const DataErrorsChangedEventArgs: {
    new(propertyName: string): DataErrorsChangedEventArgs$instance;
};


export type DataErrorsChangedEventArgs = DataErrorsChangedEventArgs$instance;

export interface DataObjectAttribute$instance extends Attribute {
    readonly IsDataObject: boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
}


export const DataObjectAttribute: {
    new(): DataObjectAttribute$instance;
    new(isDataObject: boolean): DataObjectAttribute$instance;
    readonly DataObject: DataObjectAttribute;
    readonly NonDataObject: DataObjectAttribute;
    readonly Default: DataObjectAttribute;
};


export type DataObjectAttribute = DataObjectAttribute$instance;

export interface DataObjectFieldAttribute$instance extends Attribute {
    readonly IsIdentity: boolean;
    readonly IsNullable: boolean;
    readonly Length: int;
    readonly PrimaryKey: boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const DataObjectFieldAttribute: {
    new(primaryKey: boolean): DataObjectFieldAttribute$instance;
    new(primaryKey: boolean, isIdentity: boolean): DataObjectFieldAttribute$instance;
    new(primaryKey: boolean, isIdentity: boolean, isNullable: boolean): DataObjectFieldAttribute$instance;
    new(primaryKey: boolean, isIdentity: boolean, isNullable: boolean, length: int): DataObjectFieldAttribute$instance;
};


export type DataObjectFieldAttribute = DataObjectFieldAttribute$instance;

export interface DataObjectMethodAttribute$instance extends Attribute {
    readonly IsDefault: boolean;
    readonly MethodType: DataObjectMethodType;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    Match(obj: unknown): boolean;
}


export const DataObjectMethodAttribute: {
    new(methodType: DataObjectMethodType): DataObjectMethodAttribute$instance;
    new(methodType: DataObjectMethodType, isDefault: boolean): DataObjectMethodAttribute$instance;
};


export type DataObjectMethodAttribute = DataObjectMethodAttribute$instance;

export interface DateOnlyConverter$instance extends TypeConverter {
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFrom(value: unknown): unknown;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
}


export const DateOnlyConverter: {
    new(): DateOnlyConverter$instance;
};


export type DateOnlyConverter = DateOnlyConverter$instance;

export interface DateTimeConverter$instance extends TypeConverter {
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFrom(value: unknown): unknown;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
}


export const DateTimeConverter: {
    new(): DateTimeConverter$instance;
};


export type DateTimeConverter = DateTimeConverter$instance;

export interface DateTimeOffsetConverter$instance extends TypeConverter {
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFrom(value: unknown): unknown;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
}


export const DateTimeOffsetConverter: {
    new(): DateTimeOffsetConverter$instance;
};


export type DateTimeOffsetConverter = DateTimeOffsetConverter$instance;

export interface DecimalConverter$instance extends BaseNumberConverter {
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
}


export const DecimalConverter: {
    new(): DecimalConverter$instance;
};


export type DecimalConverter = DecimalConverter$instance;

export interface DefaultBindingPropertyAttribute$instance extends Attribute {
    readonly Name: string;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const DefaultBindingPropertyAttribute: {
    new(): DefaultBindingPropertyAttribute$instance;
    new(name: string): DefaultBindingPropertyAttribute$instance;
    readonly Default: DefaultBindingPropertyAttribute;
};


export type DefaultBindingPropertyAttribute = DefaultBindingPropertyAttribute$instance;

export interface DefaultEventAttribute$instance extends Attribute {
    readonly Name: string;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const DefaultEventAttribute: {
    new(name: string): DefaultEventAttribute$instance;
    readonly Default: DefaultEventAttribute;
};


export type DefaultEventAttribute = DefaultEventAttribute$instance;

export interface DefaultPropertyAttribute$instance extends Attribute {
    readonly Name: string;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const DefaultPropertyAttribute: {
    new(name: string): DefaultPropertyAttribute$instance;
    readonly Default: DefaultPropertyAttribute;
};


export type DefaultPropertyAttribute = DefaultPropertyAttribute$instance;

export interface DefaultValueAttribute$instance extends Attribute {
    readonly Value: unknown;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const DefaultValueAttribute: {
    new(type_: Type, value: string): DefaultValueAttribute$instance;
    new(value: char): DefaultValueAttribute$instance;
    new(value: byte): DefaultValueAttribute$instance;
    new(value: short): DefaultValueAttribute$instance;
    new(value: int): DefaultValueAttribute$instance;
    new(value: long): DefaultValueAttribute$instance;
    new(value: float): DefaultValueAttribute$instance;
    new(value: double): DefaultValueAttribute$instance;
    new(value: boolean): DefaultValueAttribute$instance;
    new(value: string): DefaultValueAttribute$instance;
    new(value: unknown): DefaultValueAttribute$instance;
    new(value: sbyte): DefaultValueAttribute$instance;
    new(value: ushort): DefaultValueAttribute$instance;
    new(value: uint): DefaultValueAttribute$instance;
    new(value: ulong): DefaultValueAttribute$instance;
};


export type DefaultValueAttribute = DefaultValueAttribute$instance;

export interface DescriptionAttribute$instance extends Attribute {
    readonly Description: string;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
}


export const DescriptionAttribute: {
    new(): DescriptionAttribute$instance;
    new(description: string): DescriptionAttribute$instance;
    readonly Default: DescriptionAttribute;
};


export type DescriptionAttribute = DescriptionAttribute$instance;

export interface DesignerAttribute$instance extends Attribute {
    readonly DesignerBaseTypeName: string;
    readonly DesignerTypeName: string;
    readonly TypeId: unknown;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const DesignerAttribute: {
    new(designerTypeName: string): DesignerAttribute$instance;
    new(designerType: Type): DesignerAttribute$instance;
    new(designerTypeName: string, designerBaseTypeName: string): DesignerAttribute$instance;
    new(designerTypeName: string, designerBaseType: Type): DesignerAttribute$instance;
    new(designerType: Type, designerBaseType: Type): DesignerAttribute$instance;
};


export type DesignerAttribute = DesignerAttribute$instance;

export interface DesignerCategoryAttribute$instance extends Attribute {
    readonly Category: string;
    readonly TypeId: unknown;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
}


export const DesignerCategoryAttribute: {
    new(): DesignerCategoryAttribute$instance;
    new(category: string): DesignerCategoryAttribute$instance;
    readonly Component: DesignerCategoryAttribute;
    readonly Default: DesignerCategoryAttribute;
    readonly Form: DesignerCategoryAttribute;
    readonly Generic: DesignerCategoryAttribute;
};


export type DesignerCategoryAttribute = DesignerCategoryAttribute$instance;

export interface DesignerSerializationVisibilityAttribute$instance extends Attribute {
    readonly Visibility: DesignerSerializationVisibility;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
}


export const DesignerSerializationVisibilityAttribute: {
    new(visibility: DesignerSerializationVisibility): DesignerSerializationVisibilityAttribute$instance;
    readonly Content: DesignerSerializationVisibilityAttribute;
    readonly Hidden: DesignerSerializationVisibilityAttribute;
    readonly Visible: DesignerSerializationVisibilityAttribute;
    readonly Default: DesignerSerializationVisibilityAttribute;
};


export type DesignerSerializationVisibilityAttribute = DesignerSerializationVisibilityAttribute$instance;

export interface DesignOnlyAttribute$instance extends Attribute {
    readonly IsDesignOnly: boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
}


export const DesignOnlyAttribute: {
    new(isDesignOnly: boolean): DesignOnlyAttribute$instance;
    readonly Yes: DesignOnlyAttribute;
    readonly No: DesignOnlyAttribute;
    readonly Default: DesignOnlyAttribute;
};


export type DesignOnlyAttribute = DesignOnlyAttribute$instance;

export interface DesignTimeVisibleAttribute$instance extends Attribute {
    readonly Visible: boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
}


export const DesignTimeVisibleAttribute: {
    new(visible: boolean): DesignTimeVisibleAttribute$instance;
    new(): DesignTimeVisibleAttribute$instance;
    readonly Yes: DesignTimeVisibleAttribute;
    readonly No: DesignTimeVisibleAttribute;
    readonly Default: DesignTimeVisibleAttribute;
};


export type DesignTimeVisibleAttribute = DesignTimeVisibleAttribute$instance;

export interface DisplayNameAttribute$instance extends Attribute {
    readonly DisplayName: string;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
}


export const DisplayNameAttribute: {
    new(): DisplayNameAttribute$instance;
    new(displayName: string): DisplayNameAttribute$instance;
    readonly Default: DisplayNameAttribute;
};


export type DisplayNameAttribute = DisplayNameAttribute$instance;

export interface DoubleConverter$instance extends BaseNumberConverter {
}


export const DoubleConverter: {
    new(): DoubleConverter$instance;
};


export type DoubleConverter = DoubleConverter$instance;

export interface DoWorkEventArgs$instance extends CancelEventArgs {
    readonly Argument: unknown;
    Result: unknown;
}


export const DoWorkEventArgs: {
    new(argument: unknown): DoWorkEventArgs$instance;
};


export type DoWorkEventArgs = DoWorkEventArgs$instance;

export interface EditorAttribute$instance extends Attribute {
    readonly EditorBaseTypeName: string;
    readonly EditorTypeName: string;
    readonly TypeId: unknown;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const EditorAttribute: {
    new(): EditorAttribute$instance;
    new(typeName: string, baseTypeName: string): EditorAttribute$instance;
    new(typeName: string, baseType: Type): EditorAttribute$instance;
    new(type_: Type, baseType: Type): EditorAttribute$instance;
};


export type EditorAttribute = EditorAttribute$instance;

export interface EditorBrowsableAttribute$instance extends Attribute {
    readonly State: EditorBrowsableState;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const EditorBrowsableAttribute: {
    new(state: EditorBrowsableState): EditorBrowsableAttribute$instance;
    new(): EditorBrowsableAttribute$instance;
};


export type EditorBrowsableAttribute = EditorBrowsableAttribute$instance;

export interface EnumConverter$instance extends TypeConverter {
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFrom(value: unknown): unknown;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
    GetStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    GetStandardValues(): ICollection;
    GetStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    GetStandardValuesExclusive(): boolean;
    GetStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    GetStandardValuesSupported(): boolean;
    IsValid(context: ITypeDescriptorContext, value: unknown): boolean;
    IsValid(value: unknown): boolean;
}


export const EnumConverter: {
    new(type_: Type): EnumConverter$instance;
};


export type EnumConverter = EnumConverter$instance;

export interface EventDescriptor$instance extends MemberDescriptor {
    readonly ComponentType: Type;
    readonly EventType: Type;
    readonly IsMulticast: boolean;
    AddEventHandler(component: unknown, value: Function): void;
    RemoveEventHandler(component: unknown, value: Function): void;
}


export const EventDescriptor: {
};


export type EventDescriptor = EventDescriptor$instance;

export interface EventDescriptorCollection$instance {
    readonly Count: int;
    Add(value: EventDescriptor): int;
    Clear(): void;
    Contains(value: EventDescriptor): boolean;
    Find(name: string, ignoreCase: boolean): EventDescriptor;
    get_Item(index: int): EventDescriptor;
    get_Item(name: string): EventDescriptor;
    GetEnumerator(): IEnumerator;
    IndexOf(value: EventDescriptor): int;
    Insert(index: int, value: EventDescriptor): void;
    Remove(value: EventDescriptor): void;
    RemoveAt(index: int): void;
    Sort(): EventDescriptorCollection;
    Sort(names: string[]): EventDescriptorCollection;
    Sort(names: string[], comparer: IComparer): EventDescriptorCollection;
    Sort(comparer: IComparer): EventDescriptorCollection;
}


export const EventDescriptorCollection: {
    new(events: EventDescriptor[]): EventDescriptorCollection$instance;
    new(events: EventDescriptor[], readOnly: boolean): EventDescriptorCollection$instance;
    readonly Empty: EventDescriptorCollection;
};


export interface __EventDescriptorCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type EventDescriptorCollection = EventDescriptorCollection$instance & __EventDescriptorCollection$views;


export interface EventHandlerList$instance {
    Item: Function;
    AddHandler(key: unknown, value: Function): void;
    AddHandlers(listToAddFrom: EventHandlerList): void;
    Dispose(): void;
    RemoveHandler(key: unknown, value: Function): void;
}


export const EventHandlerList: {
    new(): EventHandlerList$instance;
};


export interface __EventHandlerList$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface EventHandlerList$instance extends System_Internal.IDisposable$instance {}

export type EventHandlerList = EventHandlerList$instance & __EventHandlerList$views;


export interface ExpandableObjectConverter$instance extends TypeConverter {
    GetProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    GetProperties(value: unknown): PropertyDescriptorCollection;
    GetProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    GetPropertiesSupported(context: ITypeDescriptorContext): boolean;
    GetPropertiesSupported(): boolean;
}


export const ExpandableObjectConverter: {
    new(): ExpandableObjectConverter$instance;
};


export type ExpandableObjectConverter = ExpandableObjectConverter$instance;

export interface ExtenderProvidedPropertyAttribute$instance extends Attribute {
    readonly ExtenderProperty: PropertyDescriptor;
    readonly Provider: IExtenderProvider;
    readonly ReceiverType: Type;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
}


export const ExtenderProvidedPropertyAttribute: {
    new(): ExtenderProvidedPropertyAttribute$instance;
};


export type ExtenderProvidedPropertyAttribute = ExtenderProvidedPropertyAttribute$instance;

export interface GuidConverter$instance extends TypeConverter {
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFrom(value: unknown): unknown;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
}


export const GuidConverter: {
    new(): GuidConverter$instance;
};


export type GuidConverter = GuidConverter$instance;

export interface HalfConverter$instance extends BaseNumberConverter {
}


export const HalfConverter: {
    new(): HalfConverter$instance;
};


export type HalfConverter = HalfConverter$instance;

export interface HandledEventArgs$instance extends EventArgs {
    Handled: boolean;
}


export const HandledEventArgs: {
    new(): HandledEventArgs$instance;
    new(defaultHandledValue: boolean): HandledEventArgs$instance;
};


export type HandledEventArgs = HandledEventArgs$instance;

export interface ImmutableObjectAttribute$instance extends Attribute {
    readonly Immutable: boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
}


export const ImmutableObjectAttribute: {
    new(immutable: boolean): ImmutableObjectAttribute$instance;
    readonly Yes: ImmutableObjectAttribute;
    readonly No: ImmutableObjectAttribute;
    readonly Default: ImmutableObjectAttribute;
};


export type ImmutableObjectAttribute = ImmutableObjectAttribute$instance;

export interface InheritanceAttribute$instance extends Attribute {
    readonly InheritanceLevel: InheritanceLevel;
    Equals(value: unknown): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
    ToString(): string;
}


export const InheritanceAttribute: {
    new(): InheritanceAttribute$instance;
    new(inheritanceLevel: InheritanceLevel): InheritanceAttribute$instance;
    readonly Inherited: InheritanceAttribute;
    readonly InheritedReadOnly: InheritanceAttribute;
    readonly NotInherited: InheritanceAttribute;
    readonly Default: InheritanceAttribute;
};


export type InheritanceAttribute = InheritanceAttribute$instance;

export interface InitializationEventAttribute$instance extends Attribute {
    readonly EventName: string;
}


export const InitializationEventAttribute: {
    new(eventName: string): InitializationEventAttribute$instance;
};


export type InitializationEventAttribute = InitializationEventAttribute$instance;

export interface InstallerTypeAttribute$instance extends Attribute {
    readonly InstallerType: Type;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const InstallerTypeAttribute: {
    new(installerType: Type): InstallerTypeAttribute$instance;
    new(typeName: string): InstallerTypeAttribute$instance;
};


export type InstallerTypeAttribute = InstallerTypeAttribute$instance;

export interface InstanceCreationEditor$instance {
    readonly Text: string;
    CreateInstance(context: ITypeDescriptorContext, instanceType: Type): unknown;
}


export const InstanceCreationEditor: {
};


export type InstanceCreationEditor = InstanceCreationEditor$instance;

export interface Int128Converter$instance extends BaseNumberConverter {
}


export const Int128Converter: {
    new(): Int128Converter$instance;
};


export type Int128Converter = Int128Converter$instance;

export interface Int16Converter$instance extends BaseNumberConverter {
}


export const Int16Converter: {
    new(): Int16Converter$instance;
};


export type Int16Converter = Int16Converter$instance;

export interface Int32Converter$instance extends BaseNumberConverter {
}


export const Int32Converter: {
    new(): Int32Converter$instance;
};


export type Int32Converter = Int32Converter$instance;

export interface Int64Converter$instance extends BaseNumberConverter {
}


export const Int64Converter: {
    new(): Int64Converter$instance;
};


export type Int64Converter = Int64Converter$instance;

export interface InvalidAsynchronousStateException$instance extends ArgumentException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const InvalidAsynchronousStateException: {
    new(): InvalidAsynchronousStateException$instance;
    new(message: string): InvalidAsynchronousStateException$instance;
    new(message: string, innerException: Exception): InvalidAsynchronousStateException$instance;
};


export interface __InvalidAsynchronousStateException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidAsynchronousStateException = InvalidAsynchronousStateException$instance & __InvalidAsynchronousStateException$views;


export interface InvalidEnumArgumentException$instance extends ArgumentException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const InvalidEnumArgumentException: {
    new(): InvalidEnumArgumentException$instance;
    new(message: string): InvalidEnumArgumentException$instance;
    new(message: string, innerException: Exception): InvalidEnumArgumentException$instance;
    new(argumentName: string, invalidValue: int, enumClass: Type): InvalidEnumArgumentException$instance;
};


export interface __InvalidEnumArgumentException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type InvalidEnumArgumentException = InvalidEnumArgumentException$instance & __InvalidEnumArgumentException$views;


export interface License$instance {
    readonly LicenseKey: string;
    Dispose(): void;
}


export const License: {
};


export interface __License$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface License$instance extends System_Internal.IDisposable$instance {}

export type License = License$instance & __License$views;


export interface LicenseContext$instance {
    readonly UsageMode: LicenseUsageMode;
    GetSavedLicenseKey(type_: Type, resourceAssembly: Assembly): string;
    GetService(type_: Type): unknown;
    SetSavedLicenseKey(type_: Type, key: string): void;
}


export const LicenseContext: {
    new(): LicenseContext$instance;
};


export interface __LicenseContext$views {
    As_IServiceProvider(): System_Internal.IServiceProvider$instance;
}

export interface LicenseContext$instance extends System_Internal.IServiceProvider$instance {}

export type LicenseContext = LicenseContext$instance & __LicenseContext$views;


export interface LicenseException$instance extends SystemException {
    readonly LicensedType: Type;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const LicenseException: {
    new(type_: Type): LicenseException$instance;
    new(type_: Type, instance: unknown): LicenseException$instance;
    new(type_: Type, instance: unknown, message: string): LicenseException$instance;
    new(type_: Type, instance: unknown, message: string, innerException: Exception): LicenseException$instance;
};


export interface __LicenseException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type LicenseException = LicenseException$instance & __LicenseException$views;


export interface LicenseManager$instance {
}


export const LicenseManager: {
    new(): LicenseManager$instance;
    CurrentContext: LicenseContext;
    readonly UsageMode: LicenseUsageMode;
    CreateWithContext(type_: Type, creationContext: LicenseContext, args: unknown[]): unknown;
    CreateWithContext(type_: Type, creationContext: LicenseContext): unknown;
    IsLicensed(type_: Type): boolean;
    IsValid(type_: Type, instance: unknown, license: { value: ref<License> }): boolean;
    IsValid(type_: Type): boolean;
    LockContext(contextUser: unknown): void;
    UnlockContext(contextUser: unknown): void;
    Validate(type_: Type, instance: unknown): License;
    Validate(type_: Type): void;
};


export type LicenseManager = LicenseManager$instance;

export interface LicenseProvider$instance {
    GetLicense(context: LicenseContext, type_: Type, instance: unknown, allowExceptions: boolean): License;
}


export const LicenseProvider: {
};


export type LicenseProvider = LicenseProvider$instance;

export interface LicenseProviderAttribute$instance extends Attribute {
    readonly LicenseProvider: Type;
    readonly TypeId: unknown;
    Equals(value: unknown): boolean;
    GetHashCode(): int;
}


export const LicenseProviderAttribute: {
    new(): LicenseProviderAttribute$instance;
    new(typeName: string): LicenseProviderAttribute$instance;
    new(type_: Type): LicenseProviderAttribute$instance;
    readonly Default: LicenseProviderAttribute;
};


export type LicenseProviderAttribute = LicenseProviderAttribute$instance;

export interface LicFileLicenseProvider$instance extends LicenseProvider {
    GetLicense(context: LicenseContext, type_: Type, instance: unknown, allowExceptions: boolean): License;
}


export const LicFileLicenseProvider: {
    new(): LicFileLicenseProvider$instance;
};


export type LicFileLicenseProvider = LicFileLicenseProvider$instance;

export interface ListBindableAttribute$instance extends Attribute {
    readonly ListBindable: boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
}


export const ListBindableAttribute: {
    new(listBindable: boolean): ListBindableAttribute$instance;
    new(flags: BindableSupport): ListBindableAttribute$instance;
    readonly Yes: ListBindableAttribute;
    readonly No: ListBindableAttribute;
    readonly Default: ListBindableAttribute;
};


export type ListBindableAttribute = ListBindableAttribute$instance;

export interface ListChangedEventArgs$instance extends EventArgs {
    readonly ListChangedType: ListChangedType;
    readonly NewIndex: int;
    readonly OldIndex: int;
    readonly PropertyDescriptor: PropertyDescriptor;
}


export const ListChangedEventArgs: {
    new(listChangedType: ListChangedType, newIndex: int): ListChangedEventArgs$instance;
    new(listChangedType: ListChangedType, newIndex: int, propDesc: PropertyDescriptor): ListChangedEventArgs$instance;
    new(listChangedType: ListChangedType, propDesc: PropertyDescriptor): ListChangedEventArgs$instance;
    new(listChangedType: ListChangedType, newIndex: int, oldIndex: int): ListChangedEventArgs$instance;
};


export type ListChangedEventArgs = ListChangedEventArgs$instance;

export interface ListSortDescription$instance {
    PropertyDescriptor: PropertyDescriptor;
    SortDirection: ListSortDirection;
}


export const ListSortDescription: {
    new(property: PropertyDescriptor, direction: ListSortDirection): ListSortDescription$instance;
};


export type ListSortDescription = ListSortDescription$instance;

export interface ListSortDescriptionCollection$instance {
    readonly Count: int;
    Item: ListSortDescription;
    Contains(value: unknown): boolean;
    CopyTo(array: ClrArray, index: int): void;
    IndexOf(value: unknown): int;
}


export const ListSortDescriptionCollection: {
    new(): ListSortDescriptionCollection$instance;
    new(sorts: ListSortDescription[]): ListSortDescriptionCollection$instance;
};


export interface __ListSortDescriptionCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type ListSortDescriptionCollection = ListSortDescriptionCollection$instance & __ListSortDescriptionCollection$views;


export interface LocalizableAttribute$instance extends Attribute {
    readonly IsLocalizable: boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
}


export const LocalizableAttribute: {
    new(isLocalizable: boolean): LocalizableAttribute$instance;
    readonly Yes: LocalizableAttribute;
    readonly No: LocalizableAttribute;
    readonly Default: LocalizableAttribute;
};


export type LocalizableAttribute = LocalizableAttribute$instance;

export interface LookupBindingPropertiesAttribute$instance extends Attribute {
    readonly DataSource: string;
    readonly DisplayMember: string;
    readonly LookupMember: string;
    readonly ValueMember: string;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const LookupBindingPropertiesAttribute: {
    new(): LookupBindingPropertiesAttribute$instance;
    new(dataSource: string, displayMember: string, valueMember: string, lookupMember: string): LookupBindingPropertiesAttribute$instance;
    readonly Default: LookupBindingPropertiesAttribute;
};


export type LookupBindingPropertiesAttribute = LookupBindingPropertiesAttribute$instance;

export interface MarshalByValueComponent$instance {
    readonly Container: IContainer;
    readonly DesignMode: boolean;
    Site: ISite;
    Dispose(): void;
    GetService(service: Type): unknown;
    ToString(): string;
}


export const MarshalByValueComponent: {
    new(): MarshalByValueComponent$instance;
};


export interface __MarshalByValueComponent$views {
    As_IServiceProvider(): System_Internal.IServiceProvider$instance;
    As_IComponent(): IComponent$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MarshalByValueComponent$instance extends System_Internal.IServiceProvider$instance {}

export type MarshalByValueComponent = MarshalByValueComponent$instance & __MarshalByValueComponent$views;


export interface MaskedTextProvider$instance {
    readonly AllowPromptAsInput: boolean;
    readonly AsciiOnly: boolean;
    readonly AssignedEditPositionCount: int;
    readonly AvailableEditPositionCount: int;
    readonly Culture: CultureInfo;
    readonly EditPositionCount: int;
    readonly EditPositions: IEnumerator;
    IncludeLiterals: boolean;
    IncludePrompt: boolean;
    IsPassword: boolean;
    readonly Item: char;
    readonly LastAssignedPosition: int;
    readonly Length: int;
    readonly Mask: string;
    readonly MaskCompleted: boolean;
    readonly MaskFull: boolean;
    PasswordChar: char;
    PromptChar: char;
    ResetOnPrompt: boolean;
    ResetOnSpace: boolean;
    SkipLiterals: boolean;
    Add(input: char): boolean;
    Add(input: char, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    Add(input: string): boolean;
    Add(input: string, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    Clear(): void;
    Clear(resultHint: { value: ref<MaskedTextResultHint> }): void;
    Clone(): unknown;
    FindAssignedEditPositionFrom(position: int, direction: boolean): int;
    FindAssignedEditPositionInRange(startPosition: int, endPosition: int, direction: boolean): int;
    FindEditPositionFrom(position: int, direction: boolean): int;
    FindEditPositionInRange(startPosition: int, endPosition: int, direction: boolean): int;
    FindNonEditPositionFrom(position: int, direction: boolean): int;
    FindNonEditPositionInRange(startPosition: int, endPosition: int, direction: boolean): int;
    FindUnassignedEditPositionFrom(position: int, direction: boolean): int;
    FindUnassignedEditPositionInRange(startPosition: int, endPosition: int, direction: boolean): int;
    InsertAt(input: char, position: int): boolean;
    InsertAt(input: char, position: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    InsertAt(input: string, position: int): boolean;
    InsertAt(input: string, position: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    IsAvailablePosition(position: int): boolean;
    IsEditPosition(position: int): boolean;
    Remove(): boolean;
    Remove(testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    RemoveAt(position: int): boolean;
    RemoveAt(startPosition: int, endPosition: int): boolean;
    RemoveAt(startPosition: int, endPosition: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    Replace(input: char, position: int): boolean;
    Replace(input: char, position: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    Replace(input: char, startPosition: int, endPosition: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    Replace(input: string, position: int): boolean;
    Replace(input: string, position: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    Replace(input: string, startPosition: int, endPosition: int, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    Set(input: string): boolean;
    Set(input: string, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
    ToDisplayString(): string;
    ToString(): string;
    ToString(ignorePasswordChar: boolean): string;
    ToString(startPosition: int, length: int): string;
    ToString(ignorePasswordChar: boolean, startPosition: int, length: int): string;
    ToString(includePrompt: boolean, includeLiterals: boolean): string;
    ToString(includePrompt: boolean, includeLiterals: boolean, startPosition: int, length: int): string;
    ToString(ignorePasswordChar: boolean, includePrompt: boolean, includeLiterals: boolean, startPosition: int, length: int): string;
    VerifyChar(input: char, position: int, hint: { value: ref<MaskedTextResultHint> }): boolean;
    VerifyEscapeChar(input: char, position: int): boolean;
    VerifyString(input: string): boolean;
    VerifyString(input: string, testPosition: { value: ref<int> }, resultHint: { value: ref<MaskedTextResultHint> }): boolean;
}


export const MaskedTextProvider: {
    new(mask: string): MaskedTextProvider$instance;
    new(mask: string, restrictToAscii: boolean): MaskedTextProvider$instance;
    new(mask: string, culture: CultureInfo): MaskedTextProvider$instance;
    new(mask: string, culture: CultureInfo, restrictToAscii: boolean): MaskedTextProvider$instance;
    new(mask: string, passwordChar: char, allowPromptAsInput: boolean): MaskedTextProvider$instance;
    new(mask: string, culture: CultureInfo, passwordChar: char, allowPromptAsInput: boolean): MaskedTextProvider$instance;
    new(mask: string, culture: CultureInfo, allowPromptAsInput: boolean, promptChar: char, passwordChar: char, restrictToAscii: boolean): MaskedTextProvider$instance;
    readonly DefaultPasswordChar: char;
    readonly InvalidIndex: int;
    GetOperationResultFromHint(hint: MaskedTextResultHint): boolean;
    IsValidInputChar(c: char): boolean;
    IsValidMaskChar(c: char): boolean;
    IsValidPasswordChar(c: char): boolean;
};


export interface __MaskedTextProvider$views {
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface MaskedTextProvider$instance extends System_Internal.ICloneable$instance {}

export type MaskedTextProvider = MaskedTextProvider$instance & __MaskedTextProvider$views;


export interface MemberDescriptor$instance {
    readonly Attributes: AttributeCollection;
    readonly Category: string;
    readonly Description: string;
    readonly DesignTimeOnly: boolean;
    readonly DisplayName: string;
    readonly IsBrowsable: boolean;
    readonly Name: string;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const MemberDescriptor: {
};


export type MemberDescriptor = MemberDescriptor$instance;

export interface MergablePropertyAttribute$instance extends Attribute {
    readonly AllowMerge: boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
}


export const MergablePropertyAttribute: {
    new(allowMerge: boolean): MergablePropertyAttribute$instance;
    readonly Yes: MergablePropertyAttribute;
    readonly No: MergablePropertyAttribute;
    readonly Default: MergablePropertyAttribute;
};


export type MergablePropertyAttribute = MergablePropertyAttribute$instance;

export interface MultilineStringConverter$instance extends TypeConverter {
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
    GetProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    GetProperties(value: unknown): PropertyDescriptorCollection;
    GetProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    GetPropertiesSupported(context: ITypeDescriptorContext): boolean;
    GetPropertiesSupported(): boolean;
}


export const MultilineStringConverter: {
    new(): MultilineStringConverter$instance;
};


export type MultilineStringConverter = MultilineStringConverter$instance;

export interface NestedContainer$instance extends Container$instance {
    readonly Owner: IComponent;
    Add(component: IComponent): void;
    Add(component: IComponent, name: string): void;
    Dispose(): void;
}


export const NestedContainer: {
    new(owner: IComponent): NestedContainer$instance;
};


export interface __NestedContainer$views {
    As_IContainer(): IContainer$instance;
    As_INestedContainer(): INestedContainer$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type NestedContainer = NestedContainer$instance & __NestedContainer$views;


export interface NotifyParentPropertyAttribute$instance extends Attribute {
    readonly NotifyParent: boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
}


export const NotifyParentPropertyAttribute: {
    new(notifyParent: boolean): NotifyParentPropertyAttribute$instance;
    readonly Yes: NotifyParentPropertyAttribute;
    readonly No: NotifyParentPropertyAttribute;
    readonly Default: NotifyParentPropertyAttribute;
};


export type NotifyParentPropertyAttribute = NotifyParentPropertyAttribute$instance;

export interface NullableConverter$instance extends TypeConverter {
    readonly NullableType: Type;
    readonly UnderlyingType: Type;
    readonly UnderlyingTypeConverter: TypeConverter;
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFrom(value: unknown): unknown;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
    CreateInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): unknown;
    CreateInstance(propertyValues: IDictionary): unknown;
    GetCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    GetCreateInstanceSupported(): boolean;
    GetProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    GetProperties(value: unknown): PropertyDescriptorCollection;
    GetProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    GetPropertiesSupported(context: ITypeDescriptorContext): boolean;
    GetPropertiesSupported(): boolean;
    GetStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    GetStandardValues(): ICollection;
    GetStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    GetStandardValuesExclusive(): boolean;
    GetStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    GetStandardValuesSupported(): boolean;
    IsValid(context: ITypeDescriptorContext, value: unknown): boolean;
    IsValid(value: unknown): boolean;
}


export const NullableConverter: {
    new(type_: Type): NullableConverter$instance;
};


export type NullableConverter = NullableConverter$instance;

export interface ParenthesizePropertyNameAttribute$instance extends Attribute {
    readonly NeedParenthesis: boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
}


export const ParenthesizePropertyNameAttribute: {
    new(): ParenthesizePropertyNameAttribute$instance;
    new(needParenthesis: boolean): ParenthesizePropertyNameAttribute$instance;
    readonly Default: ParenthesizePropertyNameAttribute;
};


export type ParenthesizePropertyNameAttribute = ParenthesizePropertyNameAttribute$instance;

export interface PasswordPropertyTextAttribute$instance extends Attribute {
    readonly Password: boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
}


export const PasswordPropertyTextAttribute: {
    new(): PasswordPropertyTextAttribute$instance;
    new(password: boolean): PasswordPropertyTextAttribute$instance;
    readonly Yes: PasswordPropertyTextAttribute;
    readonly No: PasswordPropertyTextAttribute;
    readonly Default: PasswordPropertyTextAttribute;
};


export type PasswordPropertyTextAttribute = PasswordPropertyTextAttribute$instance;

export interface ProgressChangedEventArgs$instance extends EventArgs {
    readonly ProgressPercentage: int;
    readonly UserState: unknown;
}


export const ProgressChangedEventArgs: {
    new(progressPercentage: int, userState: unknown): ProgressChangedEventArgs$instance;
};


export type ProgressChangedEventArgs = ProgressChangedEventArgs$instance;

export interface PropertyChangedEventArgs$instance extends EventArgs {
    readonly PropertyName: string;
}


export const PropertyChangedEventArgs: {
    new(propertyName: string): PropertyChangedEventArgs$instance;
};


export type PropertyChangedEventArgs = PropertyChangedEventArgs$instance;

export interface PropertyChangingEventArgs$instance extends EventArgs {
    readonly PropertyName: string;
}


export const PropertyChangingEventArgs: {
    new(propertyName: string): PropertyChangingEventArgs$instance;
};


export type PropertyChangingEventArgs = PropertyChangingEventArgs$instance;

export interface PropertyDescriptor$instance extends MemberDescriptor {
    readonly ComponentType: Type;
    readonly Converter: TypeConverter;
    readonly ConverterFromRegisteredType: TypeConverter;
    readonly IsLocalizable: boolean;
    readonly IsReadOnly: boolean;
    readonly PropertyType: Type;
    readonly SerializationVisibility: DesignerSerializationVisibility;
    readonly SupportsChangeEvents: boolean;
    AddValueChanged(component: unknown, handler: EventHandler): void;
    CanResetValue(component: unknown): boolean;
    Equals(obj: unknown): boolean;
    GetChildProperties(): PropertyDescriptorCollection;
    GetChildProperties(filter: Attribute[]): PropertyDescriptorCollection;
    GetChildProperties(instance: unknown): PropertyDescriptorCollection;
    GetChildProperties(instance: unknown, filter: Attribute[]): PropertyDescriptorCollection;
    GetEditor(editorBaseType: Type): unknown;
    GetHashCode(): int;
    GetValue(component: unknown): unknown;
    RemoveValueChanged(component: unknown, handler: EventHandler): void;
    ResetValue(component: unknown): void;
    SetValue(component: unknown, value: unknown): void;
    ShouldSerializeValue(component: unknown): boolean;
}


export const PropertyDescriptor: {
};


export type PropertyDescriptor = PropertyDescriptor$instance;

export interface PropertyDescriptorCollection$instance {
    readonly Count: int;
    Add(value: PropertyDescriptor): int;
    Clear(): void;
    Contains(value: PropertyDescriptor): boolean;
    CopyTo(array: ClrArray, index: int): void;
    Find(name: string, ignoreCase: boolean): PropertyDescriptor;
    get_Item(index: int): PropertyDescriptor;
    get_Item(name: string): PropertyDescriptor;
    GetEnumerator(): IEnumerator;
    IndexOf(value: PropertyDescriptor): int;
    Insert(index: int, value: PropertyDescriptor): void;
    Remove(value: PropertyDescriptor): void;
    RemoveAt(index: int): void;
    Sort(): PropertyDescriptorCollection;
    Sort(names: string[]): PropertyDescriptorCollection;
    Sort(names: string[], comparer: IComparer): PropertyDescriptorCollection;
    Sort(comparer: IComparer): PropertyDescriptorCollection;
}


export const PropertyDescriptorCollection: {
    new(properties: PropertyDescriptor[]): PropertyDescriptorCollection$instance;
    new(properties: PropertyDescriptor[], readOnly: boolean): PropertyDescriptorCollection$instance;
    readonly Empty: PropertyDescriptorCollection;
};


export interface __PropertyDescriptorCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type PropertyDescriptorCollection = PropertyDescriptorCollection$instance & __PropertyDescriptorCollection$views;


export interface PropertyTabAttribute$instance extends Attribute {
    readonly TabClasses: Type[];
    readonly TabScopes: PropertyTabScope[];
    Equals(other: unknown): boolean;
    Equals(other: PropertyTabAttribute): boolean;
    GetHashCode(): int;
}


export const PropertyTabAttribute: {
    new(): PropertyTabAttribute$instance;
    new(tabClass: Type): PropertyTabAttribute$instance;
    new(tabClassName: string): PropertyTabAttribute$instance;
    new(tabClass: Type, tabScope: PropertyTabScope): PropertyTabAttribute$instance;
    new(tabClassName: string, tabScope: PropertyTabScope): PropertyTabAttribute$instance;
};


export type PropertyTabAttribute = PropertyTabAttribute$instance;

export interface ProvidePropertyAttribute$instance extends Attribute {
    readonly PropertyName: string;
    readonly ReceiverTypeName: string;
    readonly TypeId: unknown;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const ProvidePropertyAttribute: {
    new(propertyName: string, receiverType: Type): ProvidePropertyAttribute$instance;
    new(propertyName: string, receiverTypeName: string): ProvidePropertyAttribute$instance;
};


export type ProvidePropertyAttribute = ProvidePropertyAttribute$instance;

export interface ReadOnlyAttribute$instance extends Attribute {
    readonly IsReadOnly: boolean;
    Equals(value: unknown): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
}


export const ReadOnlyAttribute: {
    new(isReadOnly: boolean): ReadOnlyAttribute$instance;
    readonly Yes: ReadOnlyAttribute;
    readonly No: ReadOnlyAttribute;
    readonly Default: ReadOnlyAttribute;
};


export type ReadOnlyAttribute = ReadOnlyAttribute$instance;

export interface RecommendedAsConfigurableAttribute$instance extends Attribute {
    readonly RecommendedAsConfigurable: boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
}


export const RecommendedAsConfigurableAttribute: {
    new(recommendedAsConfigurable: boolean): RecommendedAsConfigurableAttribute$instance;
    readonly No: RecommendedAsConfigurableAttribute;
    readonly Yes: RecommendedAsConfigurableAttribute;
    readonly Default: RecommendedAsConfigurableAttribute;
};


export type RecommendedAsConfigurableAttribute = RecommendedAsConfigurableAttribute$instance;

export interface ReferenceConverter$instance extends TypeConverter {
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFrom(value: unknown): unknown;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
    GetStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    GetStandardValues(): ICollection;
    GetStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    GetStandardValuesExclusive(): boolean;
    GetStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    GetStandardValuesSupported(): boolean;
}


export const ReferenceConverter: {
    new(type_: Type): ReferenceConverter$instance;
};


export type ReferenceConverter = ReferenceConverter$instance;

export interface RefreshEventArgs$instance extends EventArgs {
    readonly ComponentChanged: unknown;
    readonly TypeChanged: Type;
}


export const RefreshEventArgs: {
    new(componentChanged: unknown): RefreshEventArgs$instance;
    new(typeChanged: Type): RefreshEventArgs$instance;
};


export type RefreshEventArgs = RefreshEventArgs$instance;

export interface RefreshPropertiesAttribute$instance extends Attribute {
    readonly RefreshProperties: RefreshProperties;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
}


export const RefreshPropertiesAttribute: {
    new(refresh: RefreshProperties): RefreshPropertiesAttribute$instance;
    readonly All: RefreshPropertiesAttribute;
    readonly Repaint: RefreshPropertiesAttribute;
    readonly Default: RefreshPropertiesAttribute;
};


export type RefreshPropertiesAttribute = RefreshPropertiesAttribute$instance;

export interface RunInstallerAttribute$instance extends Attribute {
    readonly RunInstaller: boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
}


export const RunInstallerAttribute: {
    new(runInstaller: boolean): RunInstallerAttribute$instance;
    readonly Yes: RunInstallerAttribute;
    readonly No: RunInstallerAttribute;
    readonly Default: RunInstallerAttribute;
};


export type RunInstallerAttribute = RunInstallerAttribute$instance;

export interface RunWorkerCompletedEventArgs$instance extends AsyncCompletedEventArgs {
    readonly Result: unknown;
    readonly UserState: unknown;
}


export const RunWorkerCompletedEventArgs: {
    new(result: unknown, error: Exception, cancelled: boolean): RunWorkerCompletedEventArgs$instance;
};


export type RunWorkerCompletedEventArgs = RunWorkerCompletedEventArgs$instance;

export interface SByteConverter$instance extends BaseNumberConverter {
}


export const SByteConverter: {
    new(): SByteConverter$instance;
};


export type SByteConverter = SByteConverter$instance;

export interface SettingsBindableAttribute$instance extends Attribute {
    readonly Bindable: boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const SettingsBindableAttribute: {
    new(bindable: boolean): SettingsBindableAttribute$instance;
    readonly Yes: SettingsBindableAttribute;
    readonly No: SettingsBindableAttribute;
};


export type SettingsBindableAttribute = SettingsBindableAttribute$instance;

export interface SingleConverter$instance extends BaseNumberConverter {
}


export const SingleConverter: {
    new(): SingleConverter$instance;
};


export type SingleConverter = SingleConverter$instance;

export interface StringConverter$instance extends TypeConverter {
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFrom(value: unknown): unknown;
}


export const StringConverter: {
    new(): StringConverter$instance;
};


export type StringConverter = StringConverter$instance;

export interface TimeOnlyConverter$instance extends TypeConverter {
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFrom(value: unknown): unknown;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
}


export const TimeOnlyConverter: {
    new(): TimeOnlyConverter$instance;
};


export type TimeOnlyConverter = TimeOnlyConverter$instance;

export interface TimeSpanConverter$instance extends TypeConverter {
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFrom(value: unknown): unknown;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
}


export const TimeSpanConverter: {
    new(): TimeSpanConverter$instance;
};


export type TimeSpanConverter = TimeSpanConverter$instance;

export interface ToolboxItemAttribute$instance extends Attribute {
    readonly ToolboxItemType: Type;
    readonly ToolboxItemTypeName: string;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    IsDefaultAttribute(): boolean;
}


export const ToolboxItemAttribute: {
    new(defaultType: boolean): ToolboxItemAttribute$instance;
    new(toolboxItemTypeName: string): ToolboxItemAttribute$instance;
    new(toolboxItemType: Type): ToolboxItemAttribute$instance;
    readonly Default: ToolboxItemAttribute;
    readonly None: ToolboxItemAttribute;
};


export type ToolboxItemAttribute = ToolboxItemAttribute$instance;

export interface ToolboxItemFilterAttribute$instance extends Attribute {
    readonly FilterString: string;
    readonly FilterType: ToolboxItemFilterType;
    readonly TypeId: unknown;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    Match(obj: unknown): boolean;
    ToString(): string;
}


export const ToolboxItemFilterAttribute: {
    new(filterString: string): ToolboxItemFilterAttribute$instance;
    new(filterString: string, filterType: ToolboxItemFilterType): ToolboxItemFilterAttribute$instance;
};


export type ToolboxItemFilterAttribute = ToolboxItemFilterAttribute$instance;

export interface TypeConverter$instance {
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    ConvertFrom(value: unknown): unknown;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFromInvariantString(text: string): unknown;
    ConvertFromInvariantString(context: ITypeDescriptorContext, text: string): unknown;
    ConvertFromString(text: string): unknown;
    ConvertFromString(context: ITypeDescriptorContext, text: string): unknown;
    ConvertFromString(context: ITypeDescriptorContext, culture: CultureInfo, text: string): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertToInvariantString(value: unknown): string;
    ConvertToInvariantString(context: ITypeDescriptorContext, value: unknown): string;
    ConvertToString(value: unknown): string;
    ConvertToString(context: ITypeDescriptorContext, value: unknown): string;
    ConvertToString(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): string;
    CreateInstance(propertyValues: IDictionary): unknown;
    CreateInstance(context: ITypeDescriptorContext, propertyValues: IDictionary): unknown;
    GetCreateInstanceSupported(): boolean;
    GetCreateInstanceSupported(context: ITypeDescriptorContext): boolean;
    GetProperties(value: unknown): PropertyDescriptorCollection;
    GetProperties(context: ITypeDescriptorContext, value: unknown): PropertyDescriptorCollection;
    GetProperties(context: ITypeDescriptorContext, value: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    GetPropertiesSupported(): boolean;
    GetPropertiesSupported(context: ITypeDescriptorContext): boolean;
    GetStandardValues(): ICollection;
    GetStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    GetStandardValuesExclusive(): boolean;
    GetStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    GetStandardValuesSupported(): boolean;
    GetStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    IsValid(value: unknown): boolean;
    IsValid(context: ITypeDescriptorContext, value: unknown): boolean;
}


export const TypeConverter: {
    new(): TypeConverter$instance;
};


export type TypeConverter = TypeConverter$instance;

export interface TypeConverter_StandardValuesCollection$instance {
    readonly Count: int;
    readonly Item: unknown;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator;
}


export const TypeConverter_StandardValuesCollection: {
    new(values: ICollection): TypeConverter_StandardValuesCollection$instance;
};


export interface __TypeConverter_StandardValuesCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type TypeConverter_StandardValuesCollection = TypeConverter_StandardValuesCollection$instance & __TypeConverter_StandardValuesCollection$views;


export interface TypeConverterAttribute$instance extends Attribute {
    readonly ConverterTypeName: string;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const TypeConverterAttribute: {
    new(): TypeConverterAttribute$instance;
    new(type_: Type): TypeConverterAttribute$instance;
    new(typeName: string): TypeConverterAttribute$instance;
    readonly Default: TypeConverterAttribute;
};


export type TypeConverterAttribute = TypeConverterAttribute$instance;

export interface TypeDescriptionProvider$instance {
    readonly RequireRegisteredTypes: Nullable_1<CLROf<boolean>>;
    CreateInstance(provider: IServiceProvider, objectType: Type, argTypes: Type[], args: unknown[]): unknown;
    GetCache(instance: unknown): IDictionary;
    GetExtendedTypeDescriptor(instance: unknown): ICustomTypeDescriptor;
    GetExtendedTypeDescriptorFromRegisteredType(instance: unknown): ICustomTypeDescriptor;
    GetFullComponentName(component: unknown): string;
    GetReflectionType(objectType: Type): Type;
    GetReflectionType(instance: unknown): Type;
    GetReflectionType(objectType: Type, instance: unknown): Type;
    GetRuntimeType(reflectionType: Type): Type;
    GetTypeDescriptor(objectType: Type): ICustomTypeDescriptor;
    GetTypeDescriptor(instance: unknown): ICustomTypeDescriptor;
    GetTypeDescriptor(objectType: Type, instance: unknown): ICustomTypeDescriptor;
    GetTypeDescriptorFromRegisteredType(objectType: Type): ICustomTypeDescriptor;
    GetTypeDescriptorFromRegisteredType(instance: unknown): ICustomTypeDescriptor;
    GetTypeDescriptorFromRegisteredType(objectType: Type, instance: unknown): ICustomTypeDescriptor;
    IsRegisteredType(type_: Type): boolean;
    IsSupportedType(type_: Type): boolean;
    RegisterType<T>(): void;
}


export const TypeDescriptionProvider: {
};


export type TypeDescriptionProvider = TypeDescriptionProvider$instance;

export interface TypeDescriptionProviderAttribute$instance extends Attribute {
    readonly TypeName: string;
}


export const TypeDescriptionProviderAttribute: {
    new(typeName: string): TypeDescriptionProviderAttribute$instance;
    new(type_: Type): TypeDescriptionProviderAttribute$instance;
};


export type TypeDescriptionProviderAttribute = TypeDescriptionProviderAttribute$instance;

export interface TypeDescriptor$instance {
}


export const TypeDescriptor: {
    new(): TypeDescriptor$instance;
    readonly InterfaceType: Type;
    readonly ComObjectType: Type;
    ComNativeDescriptorHandler: IComNativeDescriptorHandler;
    AddAttributes(instance: unknown, ...attributes: Attribute[]): TypeDescriptionProvider;
    AddAttributes(type_: Type, ...attributes: Attribute[]): TypeDescriptionProvider;
    AddEditorTable(editorBaseType: Type, table: Hashtable): void;
    AddProvider(provider: TypeDescriptionProvider, instance: unknown): void;
    AddProvider(provider: TypeDescriptionProvider, type_: Type): void;
    AddProviderTransparent(provider: TypeDescriptionProvider, instance: unknown): void;
    AddProviderTransparent(provider: TypeDescriptionProvider, type_: Type): void;
    CreateAssociation(primary: unknown, secondary: unknown): void;
    CreateDesigner(component: IComponent, designerBaseType: Type): IDesigner;
    CreateEvent(componentType: Type, oldEventDescriptor: EventDescriptor, ...attributes: Attribute[]): EventDescriptor;
    CreateEvent(componentType: Type, name: string, type_: Type, ...attributes: Attribute[]): EventDescriptor;
    CreateInstance(provider: IServiceProvider, objectType: Type, argTypes: Type[], args: unknown[]): unknown;
    CreateProperty(componentType: Type, oldPropertyDescriptor: PropertyDescriptor, ...attributes: Attribute[]): PropertyDescriptor;
    CreateProperty(componentType: Type, name: string, type_: Type, ...attributes: Attribute[]): PropertyDescriptor;
    GetAssociation(type_: Type, primary: unknown): unknown;
    GetAttributes(component: unknown, noCustomTypeDesc: boolean): AttributeCollection;
    GetAttributes(component: unknown): AttributeCollection;
    GetAttributes(componentType: Type): AttributeCollection;
    GetClassName(component: unknown, noCustomTypeDesc: boolean): string;
    GetClassName(component: unknown): string;
    GetClassName(componentType: Type): string;
    GetComponentName(component: unknown, noCustomTypeDesc: boolean): string;
    GetComponentName(component: unknown): string;
    GetConverter(component: unknown, noCustomTypeDesc: boolean): TypeConverter;
    GetConverter(component: unknown): TypeConverter;
    GetConverter(type_: Type): TypeConverter;
    GetConverterFromRegisteredType(component: unknown): TypeConverter;
    GetConverterFromRegisteredType(type_: Type): TypeConverter;
    GetDefaultEvent(component: unknown, noCustomTypeDesc: boolean): EventDescriptor;
    GetDefaultEvent(component: unknown): EventDescriptor;
    GetDefaultEvent(componentType: Type): EventDescriptor;
    GetDefaultProperty(component: unknown, noCustomTypeDesc: boolean): PropertyDescriptor;
    GetDefaultProperty(component: unknown): PropertyDescriptor;
    GetDefaultProperty(componentType: Type): PropertyDescriptor;
    GetEditor(component: unknown, editorBaseType: Type, noCustomTypeDesc: boolean): unknown;
    GetEditor(component: unknown, editorBaseType: Type): unknown;
    GetEditor(type_: Type, editorBaseType: Type): unknown;
    GetEvents(component: unknown, attributes: Attribute[], noCustomTypeDesc: boolean): EventDescriptorCollection;
    GetEvents(component: unknown, attributes: Attribute[]): EventDescriptorCollection;
    GetEvents(component: unknown, noCustomTypeDesc: boolean): EventDescriptorCollection;
    GetEvents(component: unknown): EventDescriptorCollection;
    GetEvents(componentType: Type, attributes: Attribute[]): EventDescriptorCollection;
    GetEvents(componentType: Type): EventDescriptorCollection;
    GetEventsFromRegisteredType(componentType: Type): EventDescriptorCollection;
    GetFullComponentName(component: unknown): string;
    GetProperties(component: unknown, attributes: Attribute[], noCustomTypeDesc: boolean): PropertyDescriptorCollection;
    GetProperties(component: unknown, attributes: Attribute[]): PropertyDescriptorCollection;
    GetProperties(component: unknown, noCustomTypeDesc: boolean): PropertyDescriptorCollection;
    GetProperties(component: unknown): PropertyDescriptorCollection;
    GetProperties(componentType: Type, attributes: Attribute[]): PropertyDescriptorCollection;
    GetProperties(componentType: Type): PropertyDescriptorCollection;
    GetPropertiesFromRegisteredType(component: unknown): PropertyDescriptorCollection;
    GetPropertiesFromRegisteredType(componentType: Type): PropertyDescriptorCollection;
    GetProvider(instance: unknown): TypeDescriptionProvider;
    GetProvider(type_: Type): TypeDescriptionProvider;
    GetReflectionType(instance: unknown): Type;
    GetReflectionType(type_: Type): Type;
    Refresh(component: unknown): void;
    Refresh(assembly: Assembly): void;
    Refresh(module_: Module): void;
    Refresh(type_: Type): void;
    RegisterType<T>(): void;
    RemoveAssociation(primary: unknown, secondary: unknown): void;
    RemoveAssociations(primary: unknown): void;
    RemoveProvider(provider: TypeDescriptionProvider, instance: unknown): void;
    RemoveProvider(provider: TypeDescriptionProvider, type_: Type): void;
    RemoveProviderTransparent(provider: TypeDescriptionProvider, instance: unknown): void;
    RemoveProviderTransparent(provider: TypeDescriptionProvider, type_: Type): void;
    SortDescriptorArray(infos: IList): void;
};


export type TypeDescriptor = TypeDescriptor$instance;

export interface TypeListConverter$instance extends TypeConverter {
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFrom(value: unknown): unknown;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
    GetStandardValues(context: ITypeDescriptorContext): TypeConverter_StandardValuesCollection;
    GetStandardValues(): ICollection;
    GetStandardValuesExclusive(context: ITypeDescriptorContext): boolean;
    GetStandardValuesExclusive(): boolean;
    GetStandardValuesSupported(context: ITypeDescriptorContext): boolean;
    GetStandardValuesSupported(): boolean;
}


export const TypeListConverter: {
};


export type TypeListConverter = TypeListConverter$instance;

export interface UInt128Converter$instance extends BaseNumberConverter {
}


export const UInt128Converter: {
    new(): UInt128Converter$instance;
};


export type UInt128Converter = UInt128Converter$instance;

export interface UInt16Converter$instance extends BaseNumberConverter {
}


export const UInt16Converter: {
    new(): UInt16Converter$instance;
};


export type UInt16Converter = UInt16Converter$instance;

export interface UInt32Converter$instance extends BaseNumberConverter {
}


export const UInt32Converter: {
    new(): UInt32Converter$instance;
};


export type UInt32Converter = UInt32Converter$instance;

export interface UInt64Converter$instance extends BaseNumberConverter {
}


export const UInt64Converter: {
    new(): UInt64Converter$instance;
};


export type UInt64Converter = UInt64Converter$instance;

export interface VersionConverter$instance extends TypeConverter {
    CanConvertFrom(context: ITypeDescriptorContext, sourceType: Type): boolean;
    CanConvertFrom(sourceType: Type): boolean;
    CanConvertTo(context: ITypeDescriptorContext, destinationType: Type): boolean;
    CanConvertTo(destinationType: Type): boolean;
    ConvertFrom(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown): unknown;
    ConvertFrom(value: unknown): unknown;
    ConvertTo(context: ITypeDescriptorContext, culture: CultureInfo, value: unknown, destinationType: Type): unknown;
    ConvertTo(value: unknown, destinationType: Type): unknown;
    IsValid(context: ITypeDescriptorContext, value: unknown): boolean;
    IsValid(value: unknown): boolean;
}


export const VersionConverter: {
    new(): VersionConverter$instance;
};


export type VersionConverter = VersionConverter$instance;

export interface WarningException$instance extends SystemException {
    readonly HelpTopic: string;
    readonly HelpUrl: string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const WarningException: {
    new(): WarningException$instance;
    new(message: string): WarningException$instance;
    new(message: string, helpUrl: string): WarningException$instance;
    new(message: string, innerException: Exception): WarningException$instance;
    new(message: string, helpUrl: string, helpTopic: string): WarningException$instance;
};


export interface __WarningException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type WarningException = WarningException$instance & __WarningException$views;


export interface Win32Exception$instance extends ExternalException {
    readonly NativeErrorCode: int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    ToString(): string;
}


export const Win32Exception: {
    new(): Win32Exception$instance;
    new(error: int): Win32Exception$instance;
    new(error: int, message: string): Win32Exception$instance;
    new(message: string): Win32Exception$instance;
    new(message: string, innerException: Exception): Win32Exception$instance;
};


export interface __Win32Exception$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type Win32Exception = Win32Exception$instance & __Win32Exception$views;


export abstract class AsyncOperationManager$instance {
    static SynchronizationContext: SynchronizationContext;
    static CreateOperation(userSuppliedState: unknown): AsyncOperation;
}


export type AsyncOperationManager = AsyncOperationManager$instance;

export abstract class SyntaxCheck$instance {
    static CheckMachineName(value: string): boolean;
    static CheckPath(value: string): boolean;
    static CheckRootedPath(value: string): boolean;
}


export type SyntaxCheck = SyntaxCheck$instance;


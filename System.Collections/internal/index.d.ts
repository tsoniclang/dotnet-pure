// Generated by tsbindgen - Architecture
// Namespace: System.Collections
// Assembly: System.Collections, System.Collections.NonGeneric, System.Private.CoreLib

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { CultureInfo } from "../../System.Globalization/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Boolean as ClrBoolean, Byte, ICloneable, Int32, Object as ClrObject, Single, String as ClrString, Type, ValueType, Void } from "../../System/internal/index.js";

export interface ICollection$instance extends IEnumerable {
    readonly Count: int;
    readonly SyncRoot: unknown;
    readonly IsSynchronized: boolean;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator;
}


export interface ICollection$instance extends IEnumerable$instance {}

export type ICollection = ICollection$instance;

export interface IComparer$instance {
    Compare(x: unknown, y: unknown): int;
}


export type IComparer = IComparer$instance;

export interface IDictionary$instance extends ICollection, IEnumerable {
    get Item(): unknown | undefined;
    set Item(value: unknown);
    readonly Keys: ICollection;
    readonly Values: ICollection;
    readonly IsReadOnly: boolean;
    readonly IsFixedSize: boolean;
    readonly Count: int;
    readonly SyncRoot: unknown;
    readonly IsSynchronized: boolean;
    Add(key: unknown, value: unknown): void;
    Clear(): void;
    Contains(key: unknown): boolean;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IDictionaryEnumerator;
    GetEnumerator(): IEnumerator;
    Remove(key: unknown): void;
}


export type IDictionary = IDictionary$instance;

export interface IDictionaryEnumerator$instance extends IEnumerator {
    readonly Key: unknown;
    readonly Value: unknown;
    readonly Entry: DictionaryEntry;
    readonly Current: unknown;
    MoveNext(): boolean;
    Reset(): void;
}


export interface IDictionaryEnumerator$instance extends IEnumerator$instance {}

export type IDictionaryEnumerator = IDictionaryEnumerator$instance;

export interface IEnumerable$instance {
    GetEnumerator(): IEnumerator;
}


export type IEnumerable = IEnumerable$instance;

export interface IEnumerator$instance {
    readonly Current: unknown;
    MoveNext(): boolean;
    Reset(): void;
}


export type IEnumerator = IEnumerator$instance;

export interface IEqualityComparer$instance {
    Equals(x: unknown, y: unknown): boolean;
    GetHashCode(obj: unknown): int;
}


export type IEqualityComparer = IEqualityComparer$instance;

export interface IHashCodeProvider$instance {
    GetHashCode(obj: unknown): int;
}


export type IHashCodeProvider = IHashCodeProvider$instance;

export interface IList$instance extends ICollection, IEnumerable {
    Item: unknown;
    readonly IsReadOnly: boolean;
    readonly IsFixedSize: boolean;
    readonly Count: int;
    readonly SyncRoot: unknown;
    readonly IsSynchronized: boolean;
    Add(value: unknown): int;
    Clear(): void;
    Contains(value: unknown): boolean;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator;
    Insert(index: int, value: unknown): void;
    Remove(value: unknown): void;
    RemoveAt(index: int): void;
}


export type IList = IList$instance;

export interface IStructuralComparable$instance {
    CompareTo(other: unknown, comparer: IComparer): int;
}


export type IStructuralComparable = IStructuralComparable$instance;

export interface IStructuralEquatable$instance {
    Equals(other: unknown, comparer: IEqualityComparer): boolean;
    GetHashCode(comparer: IEqualityComparer): int;
}


export type IStructuralEquatable = IStructuralEquatable$instance;

export interface DictionaryEntry$instance {
    Key: unknown;
    Value: unknown;
    Deconstruct(key: unknown, value: unknown): void;
    ToString(): string;
}


export const DictionaryEntry: {
    new(key: unknown, value: unknown): DictionaryEntry;
};


export type DictionaryEntry = DictionaryEntry$instance;

export interface ArrayList$instance {
    Capacity: int;
    readonly Count: int;
    readonly IsFixedSize: boolean;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    Item: unknown;
    readonly SyncRoot: unknown;
    Add(value: unknown): int;
    AddRange(c: ICollection): void;
    BinarySearch(index: int, count: int, value: unknown, comparer: IComparer): int;
    BinarySearch(value: unknown): int;
    BinarySearch(value: unknown, comparer: IComparer): int;
    Clear(): void;
    Clone(): unknown;
    Contains(item: unknown): boolean;
    CopyTo(array: ClrArray): void;
    CopyTo(array: ClrArray, arrayIndex: int): void;
    CopyTo(index: int, array: ClrArray, arrayIndex: int, count: int): void;
    GetEnumerator(): IEnumerator;
    GetEnumerator(index: int, count: int): IEnumerator;
    GetRange(index: int, count: int): ArrayList;
    IndexOf(value: unknown): int;
    IndexOf(value: unknown, startIndex: int): int;
    IndexOf(value: unknown, startIndex: int, count: int): int;
    Insert(index: int, value: unknown): void;
    InsertRange(index: int, c: ICollection): void;
    LastIndexOf(value: unknown): int;
    LastIndexOf(value: unknown, startIndex: int): int;
    LastIndexOf(value: unknown, startIndex: int, count: int): int;
    Remove(obj: unknown): void;
    RemoveAt(index: int): void;
    RemoveRange(index: int, count: int): void;
    Reverse(): void;
    Reverse(index: int, count: int): void;
    SetRange(index: int, c: ICollection): void;
    Sort(): void;
    Sort(comparer: IComparer): void;
    Sort(index: int, count: int, comparer: IComparer): void;
    ToArray(): (unknown | undefined)[];
    ToArray(type: Type): ClrArray;
    TrimToSize(): void;
}


export const ArrayList: {
    new(): ArrayList;
    new(capacity: int): ArrayList;
    new(c: ICollection): ArrayList;
    Adapter(list: IList): ArrayList;
    FixedSize(list: ArrayList): ArrayList;
    FixedSize(list: IList): IList;
    ReadOnly(list: ArrayList): ArrayList;
    ReadOnly(list: IList): IList;
    Repeat(value: unknown, count: int): ArrayList;
    Synchronized(list: ArrayList): ArrayList;
    Synchronized(list: IList): IList;
};


export interface __ArrayList$views {
    As_ICollection(): ICollection$instance;
    As_IEnumerable(): IEnumerable$instance;
    As_IList(): IList$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface ArrayList$instance extends System_Internal.ICloneable$instance {}

export type ArrayList = ArrayList$instance & __ArrayList$views;


export interface BitArray$instance {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    Item: boolean;
    Length: int;
    readonly SyncRoot: unknown;
    And(value: BitArray): BitArray;
    Clone(): unknown;
    CopyTo(array: ClrArray, index: int): void;
    Get(index: int): boolean;
    GetEnumerator(): IEnumerator;
    HasAllSet(): boolean;
    HasAnySet(): boolean;
    LeftShift(count: int): BitArray;
    Not(): BitArray;
    Or(value: BitArray): BitArray;
    RightShift(count: int): BitArray;
    Set(index: int, value: boolean): void;
    SetAll(value: boolean): void;
    Xor(value: BitArray): BitArray;
}


export const BitArray: {
    new(length: int): BitArray;
    new(length: int, defaultValue: boolean): BitArray;
    new(bytes: byte[]): BitArray;
    new(values: boolean[]): BitArray;
    new(values: int[]): BitArray;
    new(bits: BitArray): BitArray;
};


export interface __BitArray$views {
    As_ICollection(): ICollection$instance;
    As_IEnumerable(): IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface BitArray$instance extends System_Internal.ICloneable$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type BitArray = BitArray$instance & __BitArray$views;


export interface CaseInsensitiveComparer$instance {
    Compare(a: unknown, b: unknown): int;
}


export const CaseInsensitiveComparer: {
    new(): CaseInsensitiveComparer;
    new(culture: CultureInfo): CaseInsensitiveComparer;
    readonly Default: CaseInsensitiveComparer;
    readonly DefaultInvariant: CaseInsensitiveComparer;
};


export interface __CaseInsensitiveComparer$views {
    As_IComparer(): IComparer$instance;
}

export interface CaseInsensitiveComparer$instance extends IComparer$instance {}

export type CaseInsensitiveComparer = CaseInsensitiveComparer$instance & __CaseInsensitiveComparer$views;


export interface CaseInsensitiveHashCodeProvider$instance {
    GetHashCode(obj: unknown): int;
}


export const CaseInsensitiveHashCodeProvider: {
    new(): CaseInsensitiveHashCodeProvider;
    new(culture: CultureInfo): CaseInsensitiveHashCodeProvider;
    readonly Default: CaseInsensitiveHashCodeProvider;
    readonly DefaultInvariant: CaseInsensitiveHashCodeProvider;
};


export interface __CaseInsensitiveHashCodeProvider$views {
    As_IHashCodeProvider(): IHashCodeProvider$instance;
}

export type CaseInsensitiveHashCodeProvider = CaseInsensitiveHashCodeProvider$instance & __CaseInsensitiveHashCodeProvider$views;


export interface CollectionBase$instance {
    Capacity: int;
    readonly Count: int;
    Clear(): void;
    GetEnumerator(): IEnumerator;
    RemoveAt(index: int): void;
}


export const CollectionBase: {
};


export interface __CollectionBase$views {
    As_ICollection(): ICollection$instance;
    As_IEnumerable(): IEnumerable$instance;
    As_IList(): IList$instance;
}

export type CollectionBase = CollectionBase$instance & __CollectionBase$views;


export interface Comparer$instance {
    Compare(a: unknown, b: unknown): int;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const Comparer: {
    new(culture: CultureInfo): Comparer;
    readonly Default: Comparer;
    readonly DefaultInvariant: Comparer;
};


export interface __Comparer$views {
    As_IComparer(): IComparer$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Comparer$instance extends IComparer$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Comparer = Comparer$instance & __Comparer$views;


export interface DictionaryBase$instance {
    readonly Count: int;
    Clear(): void;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IDictionaryEnumerator;
}


export const DictionaryBase: {
};


export interface __DictionaryBase$views {
    As_ICollection(): ICollection$instance;
    As_IDictionary(): IDictionary$instance;
    As_IEnumerable(): IEnumerable$instance;
}

export type DictionaryBase = DictionaryBase$instance & __DictionaryBase$views;


export interface Hashtable$instance {
    readonly Count: int;
    readonly IsFixedSize: boolean;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    get Item(): unknown | undefined;
    set Item(value: unknown);
    readonly Keys: ICollection;
    readonly SyncRoot: unknown;
    readonly Values: ICollection;
    Add(key: unknown, value: unknown): void;
    Clear(): void;
    Clone(): unknown;
    Contains(key: unknown): boolean;
    ContainsKey(key: unknown): boolean;
    ContainsValue(value: unknown): boolean;
    CopyTo(array: ClrArray, arrayIndex: int): void;
    GetEnumerator(): IDictionaryEnumerator;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    OnDeserialization(sender: unknown): void;
    Remove(key: unknown): void;
}


export const Hashtable: {
    new(): Hashtable;
    new(capacity: int): Hashtable;
    new(capacity: int, loadFactor: float): Hashtable;
    new(capacity: int, loadFactor: float, equalityComparer: IEqualityComparer): Hashtable;
    new(hcp: IHashCodeProvider, comparer: IComparer): Hashtable;
    new(equalityComparer: IEqualityComparer): Hashtable;
    new(capacity: int, hcp: IHashCodeProvider, comparer: IComparer): Hashtable;
    new(capacity: int, equalityComparer: IEqualityComparer): Hashtable;
    new(d: IDictionary): Hashtable;
    new(d: IDictionary, loadFactor: float): Hashtable;
    new(d: IDictionary, hcp: IHashCodeProvider, comparer: IComparer): Hashtable;
    new(d: IDictionary, equalityComparer: IEqualityComparer): Hashtable;
    new(capacity: int, loadFactor: float, hcp: IHashCodeProvider, comparer: IComparer): Hashtable;
    new(d: IDictionary, loadFactor: float, hcp: IHashCodeProvider, comparer: IComparer): Hashtable;
    new(d: IDictionary, loadFactor: float, equalityComparer: IEqualityComparer): Hashtable;
    Synchronized(table: Hashtable): Hashtable;
};


export interface __Hashtable$views {
    As_ICollection(): ICollection$instance;
    As_IDictionary(): IDictionary$instance;
    As_IEnumerable(): IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
    As_IDeserializationCallback(): System_Runtime_Serialization_Internal.IDeserializationCallback$instance;
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export interface Hashtable$instance extends System_Internal.ICloneable$instance, System_Runtime_Serialization_Internal.IDeserializationCallback$instance, System_Runtime_Serialization_Internal.ISerializable$instance {}

export type Hashtable = Hashtable$instance & __Hashtable$views;


export interface ListDictionaryInternal$instance {
    readonly Count: int;
    readonly IsFixedSize: boolean;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    get Item(): unknown | undefined;
    set Item(value: unknown);
    readonly Keys: ICollection;
    readonly SyncRoot: unknown;
    readonly Values: ICollection;
    Add(key: unknown, value: unknown): void;
    Clear(): void;
    Contains(key: unknown): boolean;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IDictionaryEnumerator;
    Remove(key: unknown): void;
}


export const ListDictionaryInternal: {
    new(): ListDictionaryInternal;
};


export interface __ListDictionaryInternal$views {
    As_ICollection(): ICollection$instance;
    As_IDictionary(): IDictionary$instance;
    As_IEnumerable(): IEnumerable$instance;
}

export type ListDictionaryInternal = ListDictionaryInternal$instance & __ListDictionaryInternal$views;


export interface Queue$instance {
    readonly Count: int;
    readonly IsSynchronized: boolean;
    readonly SyncRoot: unknown;
    Clear(): void;
    Clone(): unknown;
    Contains(obj: unknown): boolean;
    CopyTo(array: ClrArray, index: int): void;
    Dequeue(): unknown;
    Enqueue(obj: unknown): void;
    GetEnumerator(): IEnumerator;
    Peek(): unknown;
    ToArray(): (unknown | undefined)[];
    TrimToSize(): void;
}


export const Queue: {
    new(): Queue;
    new(capacity: int): Queue;
    new(capacity: int, growFactor: float): Queue;
    new(col: ICollection): Queue;
    Synchronized(queue: Queue): Queue;
};


export interface __Queue$views {
    As_ICollection(): ICollection$instance;
    As_IEnumerable(): IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface Queue$instance extends System_Internal.ICloneable$instance {}

export type Queue = Queue$instance & __Queue$views;


export interface ReadOnlyCollectionBase$instance {
    readonly Count: int;
    GetEnumerator(): IEnumerator;
}


export const ReadOnlyCollectionBase: {
};


export interface __ReadOnlyCollectionBase$views {
    As_ICollection(): ICollection$instance;
    As_IEnumerable(): IEnumerable$instance;
}

export type ReadOnlyCollectionBase = ReadOnlyCollectionBase$instance & __ReadOnlyCollectionBase$views;


export interface SortedList$instance {
    Capacity: int;
    readonly Count: int;
    readonly IsFixedSize: boolean;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    get Item(): unknown | undefined;
    set Item(value: unknown);
    readonly Keys: ICollection;
    readonly SyncRoot: unknown;
    readonly Values: ICollection;
    Add(key: unknown, value: unknown): void;
    Clear(): void;
    Clone(): unknown;
    Contains(key: unknown): boolean;
    ContainsKey(key: unknown): boolean;
    ContainsValue(value: unknown): boolean;
    CopyTo(array: ClrArray, arrayIndex: int): void;
    GetByIndex(index: int): unknown | undefined;
    GetEnumerator(): IDictionaryEnumerator;
    GetKey(index: int): unknown;
    GetKeyList(): IList;
    GetValueList(): IList;
    IndexOfKey(key: unknown): int;
    IndexOfValue(value: unknown): int;
    Remove(key: unknown): void;
    RemoveAt(index: int): void;
    SetByIndex(index: int, value: unknown): void;
    TrimToSize(): void;
}


export const SortedList: {
    new(): SortedList;
    new(initialCapacity: int): SortedList;
    new(comparer: IComparer): SortedList;
    new(comparer: IComparer, capacity: int): SortedList;
    new(d: IDictionary): SortedList;
    new(d: IDictionary, comparer: IComparer): SortedList;
    Synchronized(list: SortedList): SortedList;
};


export interface __SortedList$views {
    As_ICollection(): ICollection$instance;
    As_IDictionary(): IDictionary$instance;
    As_IEnumerable(): IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface SortedList$instance extends System_Internal.ICloneable$instance {}

export type SortedList = SortedList$instance & __SortedList$views;


export interface Stack$instance {
    readonly Count: int;
    readonly IsSynchronized: boolean;
    readonly SyncRoot: unknown;
    Clear(): void;
    Clone(): unknown;
    Contains(obj: unknown): boolean;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator;
    Peek(): unknown;
    Pop(): unknown;
    Push(obj: unknown): void;
    ToArray(): (unknown | undefined)[];
}


export const Stack: {
    new(): Stack;
    new(initialCapacity: int): Stack;
    new(col: ICollection): Stack;
    Synchronized(stack: Stack): Stack;
};


export interface __Stack$views {
    As_ICollection(): ICollection$instance;
    As_IEnumerable(): IEnumerable$instance;
    As_ICloneable(): System_Internal.ICloneable$instance;
}

export interface Stack$instance extends System_Internal.ICloneable$instance {}

export type Stack = Stack$instance & __Stack$views;


export abstract class StructuralComparisons$instance {
    static readonly StructuralComparer: IComparer;
    static readonly StructuralEqualityComparer: IEqualityComparer;
}


export type StructuralComparisons = StructuralComparisons$instance;


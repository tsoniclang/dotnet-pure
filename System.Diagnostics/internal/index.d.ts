// Generated by tsbindgen - Architecture
// Namespace: System.Diagnostics
// Assembly: System.Diagnostics.DiagnosticSource, System.Diagnostics.FileVersionInfo, System.Diagnostics.Process, System.Diagnostics.TextWriterTraceListener, System.Diagnostics.TraceSource, System.Private.CoreLib

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { SafeProcessHandle } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IDictionary_2, IEnumerable_1, IEnumerator_1, IList_1, IReadOnlyCollection_1, IReadOnlyList_1, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import type { Collection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import type { StringDictionary } from "../../System.Collections.Specialized/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IEnumerable, IEnumerator, IList, ReadOnlyCollectionBase, Stack } from "../../System.Collections/internal/index.js";
import * as System_ComponentModel_Internal from "../../System.ComponentModel/internal/index.js";
import type { Component, DescriptionAttribute, IComponent, IContainer, ISite, ISynchronizeInvoke } from "../../System.ComponentModel/internal/index.js";
import type { Stream, StreamReader, StreamWriter, TextWriter } from "../../System.IO/internal/index.js";
import type { Assembly, MethodBase, MethodInfo } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { SecureString } from "../../System.Security/internal/index.js";
import type { Encoding } from "../../System.Text/internal/index.js";
import type { Task } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Action_1, Action_2, Array as ClrArray, AsyncCallback, Attribute, Boolean as ClrBoolean, Byte, Char, DateTime, DateTimeOffset, Delegate, Enum, EventArgs, EventHandler, EventHandler_1, Exception, Func_1, Func_2, Func_4, Guid, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int32, Int64, IntPtr, IObservable_1, IObserver_1, ISpanFormattable, MarshalByRefObject, MulticastDelegate, Object as ClrObject, Predicate_1, ReadOnlySpan_1, Span_1, String as ClrString, TimeSpan, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

export enum ActivityIdFormat {
    Unknown = 0,
    Hierarchical = 1,
    W3C = 2
}


export enum ActivityKind {
    Internal = 0,
    Server = 1,
    Client = 2,
    Producer = 3,
    Consumer = 4
}


export enum ActivitySamplingResult {
    None = 0,
    PropagationData = 1,
    AllData = 2,
    AllDataAndRecorded = 3
}


export enum ActivityStatusCode {
    Unset = 0,
    Ok = 1,
    Error = 2
}


export enum ActivityTraceFlags {
    None = 0,
    Recorded = 1
}


export enum DebuggableAttribute_DebuggingModes {
    None = 0,
    Default = 1,
    DisableOptimizations = 256,
    IgnoreSymbolStoreSequencePoints = 2,
    EnableEditAndContinue = 4
}


export enum DebuggerBrowsableState {
    Never = 0,
    Collapsed = 2,
    RootHidden = 3
}


export enum ProcessPriorityClass {
    Normal = 32,
    Idle = 64,
    High = 128,
    RealTime = 256,
    BelowNormal = 16384,
    AboveNormal = 32768
}


export enum ProcessWindowStyle {
    Normal = 0,
    Hidden = 1,
    Minimized = 2,
    Maximized = 3
}


export enum SourceLevels {
    Off = 0,
    Critical = 1,
    Error = 3,
    Warning = 7,
    Information = 15,
    Verbose = 31,
    ActivityTracing = 65280,
    All = -1
}


export enum ThreadPriorityLevel {
    Idle = -15,
    Lowest = -2,
    BelowNormal = -1,
    Normal = 0,
    AboveNormal = 1,
    Highest = 2,
    TimeCritical = 15
}


export enum ThreadState {
    Initialized = 0,
    Ready = 1,
    Running = 2,
    Standby = 3,
    Terminated = 4,
    Wait = 5,
    Transition = 6,
    Unknown = 7
}


export enum ThreadWaitReason {
    Executive = 0,
    FreePage = 1,
    PageIn = 2,
    SystemAllocation = 3,
    ExecutionDelay = 4,
    Suspended = 5,
    UserRequest = 6,
    EventPairHigh = 7,
    EventPairLow = 8,
    LpcReceive = 9,
    LpcReply = 10,
    VirtualMemory = 11,
    PageOut = 12,
    Unknown = 13
}


export enum TraceEventType {
    Critical = 1,
    Error = 2,
    Warning = 4,
    Information = 8,
    Verbose = 16,
    Start = 256,
    Stop = 512,
    Suspend = 1024,
    Resume = 2048,
    Transfer = 4096
}


export enum TraceLevel {
    Off = 0,
    Error = 1,
    Warning = 2,
    Info = 3,
    Verbose = 4
}


export enum TraceOptions {
    None = 0,
    LogicalOperationStack = 1,
    DateTime = 2,
    Timestamp = 4,
    ProcessId = 8,
    ThreadId = 16,
    Callstack = 32
}


export type DataReceivedEventHandler = (sender: unknown, e: DataReceivedEventArgs) => void;


export type DistributedContextPropagator_PropagatorGetterCallback = (carrier: unknown, fieldName: string, fieldValue: string, fieldValues: IEnumerable_1<System_Internal.String>) => void;


export type DistributedContextPropagator_PropagatorSetterCallback = (carrier: unknown, fieldName: string, fieldValue: string) => void;


export type ExceptionRecorder = (activity: Activity, exception: Exception, tags: TagList) => void;


export type SampleActivity_1<T> = (options: ActivityCreationOptions_1<T>) => ActivitySamplingResult;


export interface Activity_Enumerator_1$instance<T> {
    readonly Current: T;
    GetEnumerator(): Activity_Enumerator_1<T>;
    MoveNext(): boolean;
}


export const Activity_Enumerator_1: {
    new<T>(): Activity_Enumerator_1$instance<T>;
};


export type Activity_Enumerator_1<T> = Activity_Enumerator_1$instance<T>;

export interface ActivityChangedEventArgs$instance {
    Current: Activity;
    Previous: Activity;
}


export const ActivityChangedEventArgs: {
    new(): ActivityChangedEventArgs$instance;
};


export type ActivityChangedEventArgs = ActivityChangedEventArgs$instance;

export interface ActivityContext$instance {
    readonly IsRemote: boolean;
    readonly SpanId: ActivitySpanId;
    readonly TraceFlags: ActivityTraceFlags;
    readonly TraceId: ActivityTraceId;
    readonly TraceState: string;
    Equals(value: ActivityContext): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const ActivityContext: {
    new(traceId: ActivityTraceId, spanId: ActivitySpanId, traceFlags: ActivityTraceFlags, traceState: string, isRemote: boolean): ActivityContext$instance;
    Parse(traceParent: string, traceState: string): ActivityContext;
    TryParse(traceParent: string, traceState: string, isRemote: boolean, context: ActivityContext): boolean;
    TryParse(traceParent: string, traceState: string, context: ActivityContext): boolean;
};


export interface __ActivityContext$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<ActivityContext>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ActivityContext): boolean;
}

export type ActivityContext = ActivityContext$instance & __ActivityContext$views;


export interface ActivityCreationOptions_1$instance<T> {
    readonly Kind: ActivityKind;
    readonly Links: IEnumerable_1<ActivityLink>;
    readonly Name: string;
    readonly Parent: T;
    readonly SamplingTags: ActivityTagsCollection;
    readonly Source: ActivitySource;
    readonly Tags: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>;
    readonly TraceId: ActivityTraceId;
    TraceState: string;
}


export const ActivityCreationOptions_1: {
    new<T>(): ActivityCreationOptions_1$instance<T>;
};


export type ActivityCreationOptions_1<T> = ActivityCreationOptions_1$instance<T>;

export interface ActivityEvent$instance {
    readonly Name: string;
    readonly Tags: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>;
    readonly Timestamp: DateTimeOffset;
    EnumerateTagObjects(): Activity_Enumerator_1<KeyValuePair_2<System_Internal.String, unknown>>;
}


export const ActivityEvent: {
    new(name: string): ActivityEvent$instance;
    new(name: string, timestamp: DateTimeOffset, tags: ActivityTagsCollection): ActivityEvent$instance;
};


export type ActivityEvent = ActivityEvent$instance;

export interface ActivityLink$instance {
    readonly Context: ActivityContext;
    readonly Tags: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>;
    EnumerateTagObjects(): Activity_Enumerator_1<KeyValuePair_2<System_Internal.String, unknown>>;
    Equals(obj: unknown): boolean;
    Equals(value: ActivityLink): boolean;
    GetHashCode(): int;
}


export const ActivityLink: {
    new(context: ActivityContext, tags: ActivityTagsCollection): ActivityLink$instance;
};


export interface __ActivityLink$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<ActivityLink>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ActivityLink): boolean;
}

export type ActivityLink = ActivityLink$instance & __ActivityLink$views;


export interface ActivitySpanId$instance {
    CopyTo(destination: Span_1<System_Internal.Byte>): void;
    Equals(spanId: ActivitySpanId): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToHexString(): string;
    ToString(): string;
}


export const ActivitySpanId: {
    new(): ActivitySpanId$instance;
    CreateFromBytes(idData: ReadOnlySpan_1<System_Internal.Byte>): ActivitySpanId;
    CreateFromString(idData: ReadOnlySpan_1<System_Internal.Char>): ActivitySpanId;
    CreateFromUtf8String(idData: ReadOnlySpan_1<System_Internal.Byte>): ActivitySpanId;
    CreateRandom(): ActivitySpanId;
};


export interface __ActivitySpanId$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<ActivitySpanId>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ActivitySpanId): boolean;
}

export type ActivitySpanId = ActivitySpanId$instance & __ActivitySpanId$views;


export interface ActivityTagsCollection_Enumerator$instance extends IDisposable {
    readonly Current: KeyValuePair_2<System_Internal.String, unknown>;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export const ActivityTagsCollection_Enumerator: {
    new(): ActivityTagsCollection_Enumerator$instance;
};


export interface __ActivityTagsCollection_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<KeyValuePair_2<System_Internal.String, unknown>>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type ActivityTagsCollection_Enumerator = ActivityTagsCollection_Enumerator$instance & __ActivityTagsCollection_Enumerator$views;


export interface ActivityTraceId$instance {
    CopyTo(destination: Span_1<System_Internal.Byte>): void;
    Equals(traceId: ActivityTraceId): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToHexString(): string;
    ToString(): string;
}


export const ActivityTraceId: {
    new(): ActivityTraceId$instance;
    CreateFromBytes(idData: ReadOnlySpan_1<System_Internal.Byte>): ActivityTraceId;
    CreateFromString(idData: ReadOnlySpan_1<System_Internal.Char>): ActivityTraceId;
    CreateFromUtf8String(idData: ReadOnlySpan_1<System_Internal.Byte>): ActivityTraceId;
    CreateRandom(): ActivityTraceId;
};


export interface __ActivityTraceId$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<ActivityTraceId>;

    // Structural method bridges for numeric interface constraints
    Equals(other: ActivityTraceId): boolean;
}

export type ActivityTraceId = ActivityTraceId$instance & __ActivityTraceId$views;


export interface Debug_AssertInterpolatedStringHandler$instance {
    AppendFormatted<T>(value: T): void;
    AppendFormatted<T>(value: T, format: string): void;
    AppendFormatted<T>(value: T, alignment: int): void;
    AppendFormatted<T>(value: T, alignment: int, format: string): void;
    AppendFormatted(value: ReadOnlySpan_1<System_Internal.Char>): void;
    AppendFormatted(value: ReadOnlySpan_1<System_Internal.Char>, alignment?: int, format?: string): void;
    AppendFormatted(value: string): void;
    AppendFormatted(value: string, alignment?: int, format?: string): void;
    AppendFormatted(value: unknown, alignment?: int, format?: string): void;
    AppendLiteral(value: string): void;
}


export const Debug_AssertInterpolatedStringHandler: {
    new(literalLength: int, formattedCount: int, condition: boolean, shouldAppend: boolean): Debug_AssertInterpolatedStringHandler$instance;
};


export type Debug_AssertInterpolatedStringHandler = Debug_AssertInterpolatedStringHandler$instance;

export interface Debug_WriteIfInterpolatedStringHandler$instance {
    AppendFormatted<T>(value: T): void;
    AppendFormatted<T>(value: T, format: string): void;
    AppendFormatted<T>(value: T, alignment: int): void;
    AppendFormatted<T>(value: T, alignment: int, format: string): void;
    AppendFormatted(value: ReadOnlySpan_1<System_Internal.Char>): void;
    AppendFormatted(value: ReadOnlySpan_1<System_Internal.Char>, alignment?: int, format?: string): void;
    AppendFormatted(value: string): void;
    AppendFormatted(value: string, alignment?: int, format?: string): void;
    AppendFormatted(value: unknown, alignment?: int, format?: string): void;
    AppendLiteral(value: string): void;
}


export const Debug_WriteIfInterpolatedStringHandler: {
    new(literalLength: int, formattedCount: int, condition: boolean, shouldAppend: boolean): Debug_WriteIfInterpolatedStringHandler$instance;
};


export type Debug_WriteIfInterpolatedStringHandler = Debug_WriteIfInterpolatedStringHandler$instance;

export interface TagList$instance {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    Item: KeyValuePair_2<System_Internal.String, unknown>;
    Add(key: string, value: unknown): void;
    Add(tag: KeyValuePair_2<System_Internal.String, unknown>): void;
    Clear(): void;
    Contains(item: KeyValuePair_2<System_Internal.String, unknown>): boolean;
    CopyTo(tags: Span_1<KeyValuePair_2<System_Internal.String, unknown>>): void;
    CopyTo(array: KeyValuePair_2<System_Internal.String, unknown>[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator_1<KeyValuePair_2<System_Internal.String, unknown>>;
    IndexOf(item: KeyValuePair_2<System_Internal.String, unknown>): int;
    Insert(index: int, item: KeyValuePair_2<System_Internal.String, unknown>): void;
    Remove(item: KeyValuePair_2<System_Internal.String, unknown>): boolean;
    RemoveAt(index: int): void;
}


export const TagList: {
    new(tagList: ReadOnlySpan_1<KeyValuePair_2<System_Internal.String, unknown>>): TagList$instance;
};


export interface __TagList$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<System_Internal.String, unknown>>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<System_Internal.String, unknown>>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<KeyValuePair_2<System_Internal.String, unknown>>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<KeyValuePair_2<System_Internal.String, unknown>>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type TagList = TagList$instance & __TagList$views;


export interface TagList_Enumerator$instance extends IDisposable {
    readonly Current: KeyValuePair_2<System_Internal.String, unknown>;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export const TagList_Enumerator: {
    new(): TagList_Enumerator$instance;
};


export interface __TagList_Enumerator$views {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<KeyValuePair_2<System_Internal.String, unknown>>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type TagList_Enumerator = TagList_Enumerator$instance & __TagList_Enumerator$views;


export interface Activity$instance {
    ActivityTraceFlags: ActivityTraceFlags;
    readonly Baggage: IEnumerable_1<KeyValuePair_2<System_Internal.String, System_Internal.String>>;
    readonly Context: ActivityContext;
    DisplayName: string;
    readonly Duration: TimeSpan;
    readonly Events: IEnumerable_1<ActivityEvent>;
    readonly HasRemoteParent: boolean;
    readonly Id: string;
    readonly IdFormat: ActivityIdFormat;
    IsAllDataRequested: boolean;
    readonly IsStopped: boolean;
    readonly Kind: ActivityKind;
    readonly Links: IEnumerable_1<ActivityLink>;
    readonly OperationName: string;
    readonly Parent: Activity;
    readonly ParentId: string;
    readonly ParentSpanId: ActivitySpanId;
    readonly Recorded: boolean;
    readonly RootId: string;
    readonly Source: ActivitySource;
    readonly SpanId: ActivitySpanId;
    readonly StartTimeUtc: DateTime;
    readonly Status: ActivityStatusCode;
    readonly StatusDescription: string;
    readonly TagObjects: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>;
    readonly Tags: IEnumerable_1<KeyValuePair_2<System_Internal.String, System_Internal.String>>;
    readonly TraceId: ActivityTraceId;
    TraceStateString: string;
    AddBaggage(key: string, value: string): Activity;
    AddEvent(e: ActivityEvent): Activity;
    AddException(exception: Exception, tags?: TagList, timestamp?: DateTimeOffset): Activity;
    AddLink(link: ActivityLink): Activity;
    AddTag(key: string, value: string): Activity;
    AddTag(key: string, value: unknown): Activity;
    Dispose(): void;
    EnumerateEvents(): Activity_Enumerator_1<ActivityEvent>;
    EnumerateLinks(): Activity_Enumerator_1<ActivityLink>;
    EnumerateTagObjects(): Activity_Enumerator_1<KeyValuePair_2<System_Internal.String, unknown>>;
    GetBaggageItem(key: string): string;
    GetCustomProperty(propertyName: string): unknown;
    GetTagItem(key: string): unknown;
    SetBaggage(key: string, value: string): Activity;
    SetCustomProperty(propertyName: string, propertyValue: unknown): void;
    SetEndTime(endTimeUtc: DateTime): Activity;
    SetIdFormat(format: ActivityIdFormat): Activity;
    SetParentId(parentId: string): Activity;
    SetParentId(traceId: ActivityTraceId, spanId: ActivitySpanId, activityTraceFlags?: ActivityTraceFlags): Activity;
    SetStartTime(startTimeUtc: DateTime): Activity;
    SetStatus(code: ActivityStatusCode, description?: string): Activity;
    SetTag(key: string, value: unknown): Activity;
    Start(): Activity;
    Stop(): void;
}


export const Activity: {
    new(operationName: string): Activity$instance;
    ForceDefaultIdFormat: boolean;
    Current: Activity;
    TraceIdGenerator: Func_1<ActivityTraceId>;
    DefaultIdFormat: ActivityIdFormat;
};


export interface __Activity$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Activity$instance extends System_Internal.IDisposable$instance {}

export type Activity = Activity$instance & __Activity$views;


export interface ActivityListener$instance {
    ActivityStarted: Action_1<Activity>;
    ActivityStopped: Action_1<Activity>;
    ExceptionRecorder: ExceptionRecorder;
    Sample: SampleActivity_1<ActivityContext>;
    SampleUsingParentId: SampleActivity_1<System_Internal.String>;
    ShouldListenTo: Func_2<ActivitySource, System_Internal.Boolean>;
    Dispose(): void;
}


export const ActivityListener: {
    new(): ActivityListener$instance;
};


export interface __ActivityListener$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ActivityListener$instance extends System_Internal.IDisposable$instance {}

export type ActivityListener = ActivityListener$instance & __ActivityListener$views;


export interface ActivitySource$instance {
    readonly Name: string;
    readonly Tags: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>;
    readonly TelemetrySchemaUrl: string;
    readonly Version: string;
    CreateActivity(name: string, kind: ActivityKind): Activity;
    CreateActivity(name: string, kind: ActivityKind, parentContext: ActivityContext, tags?: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>, links?: IEnumerable_1<ActivityLink>, idFormat?: ActivityIdFormat): Activity;
    CreateActivity(name: string, kind: ActivityKind, parentId: string, tags?: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>, links?: IEnumerable_1<ActivityLink>, idFormat?: ActivityIdFormat): Activity;
    Dispose(): void;
    HasListeners(): boolean;
    StartActivity(name?: string, kind?: ActivityKind): Activity;
    StartActivity(name: string, kind: ActivityKind, parentContext: ActivityContext, tags?: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>, links?: IEnumerable_1<ActivityLink>, startTime?: DateTimeOffset): Activity;
    StartActivity(name: string, kind: ActivityKind, parentId: string, tags?: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>, links?: IEnumerable_1<ActivityLink>, startTime?: DateTimeOffset): Activity;
    StartActivity(kind: ActivityKind, parentContext?: ActivityContext, tags?: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>, links?: IEnumerable_1<ActivityLink>, startTime?: DateTimeOffset, name?: string): Activity;
}


export const ActivitySource: {
    new(name: string): ActivitySource$instance;
    new(name: string, version: string): ActivitySource$instance;
    new(name: string, version: string, tags: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>): ActivitySource$instance;
    new(options: ActivitySourceOptions): ActivitySource$instance;
    AddActivityListener(listener: ActivityListener): void;
};


export interface __ActivitySource$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ActivitySource$instance extends System_Internal.IDisposable$instance {}

export type ActivitySource = ActivitySource$instance & __ActivitySource$views;


export interface ActivitySourceOptions$instance {
    Name: string;
    Tags: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>;
    TelemetrySchemaUrl: string;
    Version: string;
}


export const ActivitySourceOptions: {
    new(name: string): ActivitySourceOptions$instance;
};


export type ActivitySourceOptions = ActivitySourceOptions$instance;

export interface ActivityTagsCollection$instance {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    Item: unknown;
    readonly Keys: ICollection_1<System_Internal.String>;
    readonly Values: ICollection_1<unknown>;
    Add(key: string, value: unknown): void;
    Add(item: KeyValuePair_2<System_Internal.String, unknown>): void;
    Clear(): void;
    Contains(item: KeyValuePair_2<System_Internal.String, unknown>): boolean;
    ContainsKey(key: string): boolean;
    CopyTo(array: KeyValuePair_2<System_Internal.String, unknown>[], arrayIndex: int): void;
    GetEnumerator(): ActivityTagsCollection_Enumerator;
    Remove(key: string): boolean;
    Remove(item: KeyValuePair_2<System_Internal.String, unknown>): boolean;
    TryGetValue(key: string, value: unknown): boolean;
}


export const ActivityTagsCollection: {
    new(): ActivityTagsCollection$instance;
    new(list: IEnumerable_1<KeyValuePair_2<System_Internal.String, unknown>>): ActivityTagsCollection$instance;
};


export interface __ActivityTagsCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<System_Internal.String, unknown>>;
    As_IDictionary_2(): System_Collections_Generic_Internal.IDictionary_2$instance<System_Internal.String, unknown>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<System_Internal.String, unknown>>;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type ActivityTagsCollection = ActivityTagsCollection$instance & __ActivityTagsCollection$views;


export interface BooleanSwitch$instance extends Switch {
    Enabled: boolean;
}


export const BooleanSwitch: {
    new(displayName: string, description: string): BooleanSwitch$instance;
    new(displayName: string, description: string, defaultSwitchValue: string): BooleanSwitch$instance;
};


export type BooleanSwitch = BooleanSwitch$instance;

export interface ConditionalAttribute$instance extends Attribute {
    readonly ConditionString: string;
}


export const ConditionalAttribute: {
    new(conditionString: string): ConditionalAttribute$instance;
};


export type ConditionalAttribute = ConditionalAttribute$instance;

export interface ConsoleTraceListener$instance extends TextWriterTraceListener$instance {
    Close(): void;
    Dispose(): void;
}


export const ConsoleTraceListener: {
    new(): ConsoleTraceListener$instance;
    new(useErrorStream: boolean): ConsoleTraceListener$instance;
};


export interface __ConsoleTraceListener$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ConsoleTraceListener = ConsoleTraceListener$instance & __ConsoleTraceListener$views;


export interface CorrelationManager$instance {
    ActivityId: Guid;
    readonly LogicalOperationStack: Stack;
    StartLogicalOperation(): void;
    StartLogicalOperation(operationId: unknown): void;
    StopLogicalOperation(): void;
}


export const CorrelationManager: {
    new(): CorrelationManager$instance;
};


export type CorrelationManager = CorrelationManager$instance;

export interface DataReceivedEventArgs$instance extends EventArgs {
    readonly Data: string;
}


export const DataReceivedEventArgs: {
    new(): DataReceivedEventArgs$instance;
};


export type DataReceivedEventArgs = DataReceivedEventArgs$instance;

export interface DebuggableAttribute$instance extends Attribute {
    readonly DebuggingFlags: DebuggableAttribute_DebuggingModes;
    readonly IsJITOptimizerDisabled: boolean;
    readonly IsJITTrackingEnabled: boolean;
}


export const DebuggableAttribute: {
    new(isJITTrackingEnabled: boolean, isJITOptimizerDisabled: boolean): DebuggableAttribute$instance;
    new(modes: DebuggableAttribute_DebuggingModes): DebuggableAttribute$instance;
};


export type DebuggableAttribute = DebuggableAttribute$instance;

export interface DebuggerBrowsableAttribute$instance extends Attribute {
    readonly State: DebuggerBrowsableState;
}


export const DebuggerBrowsableAttribute: {
    new(state: DebuggerBrowsableState): DebuggerBrowsableAttribute$instance;
};


export type DebuggerBrowsableAttribute = DebuggerBrowsableAttribute$instance;

export interface DebuggerDisableUserUnhandledExceptionsAttribute$instance extends Attribute {
}


export const DebuggerDisableUserUnhandledExceptionsAttribute: {
    new(): DebuggerDisableUserUnhandledExceptionsAttribute$instance;
};


export type DebuggerDisableUserUnhandledExceptionsAttribute = DebuggerDisableUserUnhandledExceptionsAttribute$instance;

export interface DebuggerDisplayAttribute$instance extends Attribute {
    Name: string;
    Target: Type;
    TargetTypeName: string;
    Type: string;
    readonly Value: string;
}


export const DebuggerDisplayAttribute: {
    new(value: string): DebuggerDisplayAttribute$instance;
};


export type DebuggerDisplayAttribute = DebuggerDisplayAttribute$instance;

export interface DebuggerHiddenAttribute$instance extends Attribute {
}


export const DebuggerHiddenAttribute: {
    new(): DebuggerHiddenAttribute$instance;
};


export type DebuggerHiddenAttribute = DebuggerHiddenAttribute$instance;

export interface DebuggerNonUserCodeAttribute$instance extends Attribute {
}


export const DebuggerNonUserCodeAttribute: {
    new(): DebuggerNonUserCodeAttribute$instance;
};


export type DebuggerNonUserCodeAttribute = DebuggerNonUserCodeAttribute$instance;

export interface DebuggerStepperBoundaryAttribute$instance extends Attribute {
}


export const DebuggerStepperBoundaryAttribute: {
    new(): DebuggerStepperBoundaryAttribute$instance;
};


export type DebuggerStepperBoundaryAttribute = DebuggerStepperBoundaryAttribute$instance;

export interface DebuggerStepThroughAttribute$instance extends Attribute {
}


export const DebuggerStepThroughAttribute: {
    new(): DebuggerStepThroughAttribute$instance;
};


export type DebuggerStepThroughAttribute = DebuggerStepThroughAttribute$instance;

export interface DebuggerTypeProxyAttribute$instance extends Attribute {
    readonly ProxyTypeName: string;
    Target: Type;
    TargetTypeName: string;
}


export const DebuggerTypeProxyAttribute: {
    new(type_: Type): DebuggerTypeProxyAttribute$instance;
    new(typeName: string): DebuggerTypeProxyAttribute$instance;
};


export type DebuggerTypeProxyAttribute = DebuggerTypeProxyAttribute$instance;

export interface DebuggerVisualizerAttribute$instance extends Attribute {
    Description: string;
    Target: Type;
    TargetTypeName: string;
    readonly VisualizerObjectSourceTypeName: string;
    readonly VisualizerTypeName: string;
}


export const DebuggerVisualizerAttribute: {
    new(visualizerTypeName: string): DebuggerVisualizerAttribute$instance;
    new(visualizerTypeName: string, visualizerObjectSourceTypeName: string): DebuggerVisualizerAttribute$instance;
    new(visualizerTypeName: string, visualizerObjectSource: Type): DebuggerVisualizerAttribute$instance;
    new(visualizer: Type): DebuggerVisualizerAttribute$instance;
    new(visualizer: Type, visualizerObjectSource: Type): DebuggerVisualizerAttribute$instance;
    new(visualizer: Type, visualizerObjectSourceTypeName: string): DebuggerVisualizerAttribute$instance;
};


export type DebuggerVisualizerAttribute = DebuggerVisualizerAttribute$instance;

export interface DebugProvider$instance {
    Fail(message: string, detailMessage: string): void;
    OnIndentLevelChanged(indentLevel: int): void;
    OnIndentSizeChanged(indentSize: int): void;
    Write(message: string): void;
    WriteLine(message: string): void;
}


export const DebugProvider: {
    new(): DebugProvider$instance;
    FailCore(stackTrace: string, message: string, detailMessage: string, errorSource: string): void;
    WriteCore(message: string): void;
};


export type DebugProvider = DebugProvider$instance;

export interface DefaultTraceListener$instance extends TraceListener$instance {
    AssertUiEnabled: boolean;
    LogFileName: string;
    Dispose(): void;
    Fail(message: string): void;
    Fail(message: string, detailMessage: string): void;
    Write(message: string): void;
    Write(o: unknown): void;
    Write(message: string, category: string): void;
    Write(o: unknown, category: string): void;
    WriteLine(message: string): void;
    WriteLine(o: unknown): void;
    WriteLine(message: string, category: string): void;
    WriteLine(o: unknown, category: string): void;
}


export const DefaultTraceListener: {
    new(): DefaultTraceListener$instance;
};


export interface __DefaultTraceListener$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type DefaultTraceListener = DefaultTraceListener$instance & __DefaultTraceListener$views;


export interface DelimitedListTraceListener$instance extends TextWriterTraceListener$instance {
    Delimiter: string;
    Dispose(): void;
    TraceData(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, data: unknown): void;
    TraceData(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, ...data: unknown[]): void;
    TraceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, format: string, ...args: unknown[]): void;
    TraceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, message: string): void;
    TraceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int): void;
}


export const DelimitedListTraceListener: {
    new(stream: Stream): DelimitedListTraceListener$instance;
    new(stream: Stream, name: string): DelimitedListTraceListener$instance;
    new(writer: TextWriter): DelimitedListTraceListener$instance;
    new(writer: TextWriter, name: string): DelimitedListTraceListener$instance;
    new(fileName: string): DelimitedListTraceListener$instance;
    new(fileName: string, name: string): DelimitedListTraceListener$instance;
};


export interface __DelimitedListTraceListener$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type DelimitedListTraceListener = DelimitedListTraceListener$instance & __DelimitedListTraceListener$views;


export interface DiagnosticListener$instance extends DiagnosticSource {
    readonly Name: string;
    Dispose(): void;
    IsEnabled(name: string): boolean;
    IsEnabled(name: string, arg1: unknown, arg2?: unknown): boolean;
    OnActivityExport(activity: Activity, payload: unknown): void;
    OnActivityImport(activity: Activity, payload: unknown): void;
    Subscribe(observer: IObserver_1<KeyValuePair_2<System_Internal.String, unknown>>, isEnabled: Func_4<System_Internal.String, unknown, unknown, System_Internal.Boolean>, onActivityImport?: Action_2<Activity, unknown>, onActivityExport?: Action_2<Activity, unknown>): IDisposable;
    Subscribe(observer: IObserver_1<KeyValuePair_2<System_Internal.String, unknown>>, isEnabled: Predicate_1<System_Internal.String>): IDisposable;
    Subscribe(observer: IObserver_1<KeyValuePair_2<System_Internal.String, unknown>>, isEnabled: Func_4<System_Internal.String, unknown, unknown, System_Internal.Boolean>): IDisposable;
    Subscribe(observer: IObserver_1<KeyValuePair_2<System_Internal.String, unknown>>): IDisposable;
    ToString(): string;
    Write(name: string, value: unknown): void;
    Write<T>(name: string, value: T): void;
}


export const DiagnosticListener: {
    new(name: string): DiagnosticListener$instance;
    readonly AllListeners: IObservable_1<DiagnosticListener>;
};


export interface __DiagnosticListener$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_IObservable_1(): System_Internal.IObservable_1$instance<KeyValuePair_2<System_Internal.String, unknown>>;
}

export interface DiagnosticListener$instance extends System_Internal.IDisposable$instance {}

export type DiagnosticListener = DiagnosticListener$instance & __DiagnosticListener$views;


export interface DiagnosticMethodInfo$instance {
    readonly DeclaringAssemblyName: string;
    readonly DeclaringTypeName: string;
    readonly Name: string;
}


export const DiagnosticMethodInfo: {
    new(): DiagnosticMethodInfo$instance;
    Create(delegate: Function): DiagnosticMethodInfo;
    Create(frame: StackFrame): DiagnosticMethodInfo;
};


export type DiagnosticMethodInfo = DiagnosticMethodInfo$instance;

export interface DiagnosticSource$instance {
    IsEnabled(name: string): boolean;
    IsEnabled(name: string, arg1: unknown, arg2?: unknown): boolean;
    OnActivityExport(activity: Activity, payload: unknown): void;
    OnActivityImport(activity: Activity, payload: unknown): void;
    StartActivity(activity: Activity, args: unknown): Activity;
    StartActivity<T>(activity: Activity, args: T): Activity;
    StopActivity(activity: Activity, args: unknown): void;
    StopActivity<T>(activity: Activity, args: T): void;
    Write(name: string, value: unknown): void;
    Write<T>(name: string, value: T): void;
}


export const DiagnosticSource: {
};


export type DiagnosticSource = DiagnosticSource$instance;

export interface DistributedContextPropagator$instance {
    readonly Fields: IReadOnlyCollection_1<System_Internal.String>;
    ExtractBaggage(carrier: unknown, getter: DistributedContextPropagator_PropagatorGetterCallback): IEnumerable_1<KeyValuePair_2<System_Internal.String, System_Internal.String>>;
    ExtractTraceIdAndState(carrier: unknown, getter: DistributedContextPropagator_PropagatorGetterCallback, traceId: string, traceState: string): void;
    Inject(activity: Activity, carrier: unknown, setter: DistributedContextPropagator_PropagatorSetterCallback): void;
}


export const DistributedContextPropagator: {
    Current: DistributedContextPropagator;
    CreateDefaultPropagator(): DistributedContextPropagator;
    CreateNoOutputPropagator(): DistributedContextPropagator;
    CreatePassThroughPropagator(): DistributedContextPropagator;
    CreatePreW3CPropagator(): DistributedContextPropagator;
    CreateW3CPropagator(): DistributedContextPropagator;
};


export type DistributedContextPropagator = DistributedContextPropagator$instance;

export interface EventTypeFilter$instance extends TraceFilter {
    EventType: SourceLevels;
    ShouldTrace(cache: TraceEventCache, source: string, eventType: TraceEventType, id: int, formatOrMessage: string, args: unknown[], data1: unknown, data: unknown[]): boolean;
}


export const EventTypeFilter: {
    new(level: SourceLevels): EventTypeFilter$instance;
};


export type EventTypeFilter = EventTypeFilter$instance;

export interface FileVersionInfo$instance {
    readonly Comments: string;
    readonly CompanyName: string;
    readonly FileBuildPart: int;
    readonly FileDescription: string;
    readonly FileMajorPart: int;
    readonly FileMinorPart: int;
    readonly FileName: string;
    readonly FilePrivatePart: int;
    readonly FileVersion: string;
    readonly InternalName: string;
    readonly IsDebug: boolean;
    readonly IsPatched: boolean;
    readonly IsPreRelease: boolean;
    readonly IsPrivateBuild: boolean;
    readonly IsSpecialBuild: boolean;
    readonly Language: string;
    readonly LegalCopyright: string;
    readonly LegalTrademarks: string;
    readonly OriginalFilename: string;
    readonly PrivateBuild: string;
    readonly ProductBuildPart: int;
    readonly ProductMajorPart: int;
    readonly ProductMinorPart: int;
    readonly ProductName: string;
    readonly ProductPrivatePart: int;
    readonly ProductVersion: string;
    readonly SpecialBuild: string;
    ToString(): string;
}


export const FileVersionInfo: {
    new(): FileVersionInfo$instance;
    GetVersionInfo(fileName: string): FileVersionInfo;
};


export type FileVersionInfo = FileVersionInfo$instance;

export interface InitializingSwitchEventArgs$instance extends EventArgs {
    readonly Switch: Switch;
}


export const InitializingSwitchEventArgs: {
    new(switch_: Switch): InitializingSwitchEventArgs$instance;
};


export type InitializingSwitchEventArgs = InitializingSwitchEventArgs$instance;

export interface InitializingTraceSourceEventArgs$instance extends EventArgs {
    readonly TraceSource: TraceSource;
    WasInitialized: boolean;
}


export const InitializingTraceSourceEventArgs: {
    new(traceSource: TraceSource): InitializingTraceSourceEventArgs$instance;
};


export type InitializingTraceSourceEventArgs = InitializingTraceSourceEventArgs$instance;

export interface MonitoringDescriptionAttribute$instance extends DescriptionAttribute {
    readonly Description: string;
}


export const MonitoringDescriptionAttribute: {
    new(description: string): MonitoringDescriptionAttribute$instance;
};


export type MonitoringDescriptionAttribute = MonitoringDescriptionAttribute$instance;

export interface Process$instance extends Component {
    readonly BasePriority: int;
    EnableRaisingEvents: boolean;
    readonly ExitCode: int;
    readonly ExitTime: DateTime;
    readonly Handle: nint;
    readonly HandleCount: int;
    readonly HasExited: boolean;
    readonly Id: int;
    readonly MachineName: string;
    readonly MainModule: ProcessModule;
    readonly MainWindowHandle: nint;
    readonly MainWindowTitle: string;
    MaxWorkingSet: nint;
    MinWorkingSet: nint;
    readonly Modules: ProcessModuleCollection;
    readonly NonpagedSystemMemorySize: int;
    readonly NonpagedSystemMemorySize64: long;
    readonly PagedMemorySize: int;
    readonly PagedMemorySize64: long;
    readonly PagedSystemMemorySize: int;
    readonly PagedSystemMemorySize64: long;
    readonly PeakPagedMemorySize: int;
    readonly PeakPagedMemorySize64: long;
    readonly PeakVirtualMemorySize: int;
    readonly PeakVirtualMemorySize64: long;
    readonly PeakWorkingSet: int;
    readonly PeakWorkingSet64: long;
    PriorityBoostEnabled: boolean;
    PriorityClass: ProcessPriorityClass;
    readonly PrivateMemorySize: int;
    readonly PrivateMemorySize64: long;
    readonly PrivilegedProcessorTime: TimeSpan;
    readonly ProcessName: string;
    ProcessorAffinity: nint;
    readonly Responding: boolean;
    readonly SafeHandle: SafeProcessHandle;
    readonly SessionId: int;
    readonly StandardError: StreamReader;
    readonly StandardInput: StreamWriter;
    readonly StandardOutput: StreamReader;
    StartInfo: ProcessStartInfo;
    readonly StartTime: DateTime;
    SynchronizingObject: ISynchronizeInvoke;
    readonly Threads: ProcessThreadCollection;
    readonly TotalProcessorTime: TimeSpan;
    readonly UserProcessorTime: TimeSpan;
    readonly VirtualMemorySize: int;
    readonly VirtualMemorySize64: long;
    readonly WorkingSet: int;
    readonly WorkingSet64: long;
    BeginErrorReadLine(): void;
    BeginOutputReadLine(): void;
    CancelErrorRead(): void;
    CancelOutputRead(): void;
    Close(): void;
    CloseMainWindow(): boolean;
    Dispose(): void;
    Kill(): void;
    Kill(entireProcessTree: boolean): void;
    Refresh(): void;
    Start(): boolean;
    ToString(): string;
    WaitForExit(): void;
    WaitForExit(milliseconds: int): boolean;
    WaitForExit(timeout: TimeSpan): boolean;
    WaitForExitAsync(cancellationToken?: CancellationToken): Task;
    WaitForInputIdle(): boolean;
    WaitForInputIdle(milliseconds: int): boolean;
    WaitForInputIdle(timeout: TimeSpan): boolean;
}


export const Process: {
    new(): Process$instance;
    EnterDebugMode(): void;
    GetCurrentProcess(): Process;
    GetProcessById(processId: int, machineName: string): Process;
    GetProcessById(processId: int): Process;
    GetProcesses(): Process[];
    GetProcesses(machineName: string): Process[];
    GetProcessesByName(processName: string, machineName: string): Process[];
    GetProcessesByName(processName: string): Process[];
    LeaveDebugMode(): void;
    Start(startInfo: ProcessStartInfo): Process;
    Start(fileName: string, arguments: IEnumerable_1<System_Internal.String>): Process;
    Start(fileName: string, userName: string, password: SecureString, domain: string): Process;
    Start(fileName: string, arguments: string, userName: string, password: SecureString, domain: string): Process;
    Start(fileName: string, arguments: string): Process;
    Start(fileName: string): Process;
};


export interface __Process$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Process$instance extends System_ComponentModel_Internal.IComponent$instance {}

export type Process = Process$instance & __Process$views;


export interface ProcessModule$instance extends Component {
    readonly BaseAddress: nint;
    readonly EntryPointAddress: nint;
    readonly FileName: string;
    readonly FileVersionInfo: FileVersionInfo;
    readonly ModuleMemorySize: int;
    readonly ModuleName: string;
    Dispose(): void;
    ToString(): string;
}


export const ProcessModule: {
    new(): ProcessModule$instance;
};


export interface __ProcessModule$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ProcessModule$instance extends System_ComponentModel_Internal.IComponent$instance {}

export type ProcessModule = ProcessModule$instance & __ProcessModule$views;


export interface ProcessModuleCollection$instance extends ReadOnlyCollectionBase {
    readonly Item: ProcessModule;
    Contains(module_: ProcessModule): boolean;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator;
    IndexOf(module_: ProcessModule): int;
}


export const ProcessModuleCollection: {
    new(processModules: ProcessModule[]): ProcessModuleCollection$instance;
};


export interface __ProcessModuleCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export interface ProcessModuleCollection$instance extends System_Collections_Internal.ICollection$instance {}

export type ProcessModuleCollection = ProcessModuleCollection$instance & __ProcessModuleCollection$views;


export interface ProcessStartInfo$instance {
    readonly ArgumentList: Collection_1<System_Internal.String>;
    Arguments: string;
    CreateNewProcessGroup: boolean;
    CreateNoWindow: boolean;
    Domain: string;
    readonly Environment: IDictionary_2<System_Internal.String, System_Internal.String>;
    readonly EnvironmentVariables: StringDictionary;
    ErrorDialog: boolean;
    ErrorDialogParentHandle: nint;
    FileName: string;
    LoadUserProfile: boolean;
    Password: SecureString;
    PasswordInClearText: string;
    RedirectStandardError: boolean;
    RedirectStandardInput: boolean;
    RedirectStandardOutput: boolean;
    StandardErrorEncoding: Encoding;
    StandardInputEncoding: Encoding;
    StandardOutputEncoding: Encoding;
    UseCredentialsForNetworkingOnly: boolean;
    UserName: string;
    UseShellExecute: boolean;
    Verb: string;
    readonly Verbs: string[];
    WindowStyle: ProcessWindowStyle;
    WorkingDirectory: string;
}


export const ProcessStartInfo: {
    new(): ProcessStartInfo$instance;
    new(fileName: string): ProcessStartInfo$instance;
    new(fileName: string, arguments: string): ProcessStartInfo$instance;
    new(fileName: string, arguments: IEnumerable_1<System_Internal.String>): ProcessStartInfo$instance;
};


export type ProcessStartInfo = ProcessStartInfo$instance;

export interface ProcessThread$instance extends Component {
    readonly BasePriority: int;
    readonly CurrentPriority: int;
    readonly Id: int;
    IdealProcessor: int;
    PriorityBoostEnabled: boolean;
    PriorityLevel: ThreadPriorityLevel;
    readonly PrivilegedProcessorTime: TimeSpan;
    ProcessorAffinity: nint;
    readonly StartAddress: nint;
    readonly StartTime: DateTime;
    readonly ThreadState: ThreadState;
    readonly TotalProcessorTime: TimeSpan;
    readonly UserProcessorTime: TimeSpan;
    readonly WaitReason: ThreadWaitReason;
    Dispose(): void;
    ResetIdealProcessor(): void;
}


export const ProcessThread: {
    new(): ProcessThread$instance;
};


export interface __ProcessThread$views {
    As_IComponent(): System_ComponentModel_Internal.IComponent$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ProcessThread$instance extends System_ComponentModel_Internal.IComponent$instance {}

export type ProcessThread = ProcessThread$instance & __ProcessThread$views;


export interface ProcessThreadCollection$instance extends ReadOnlyCollectionBase {
    readonly Item: ProcessThread;
    Add(thread: ProcessThread): int;
    Contains(thread: ProcessThread): boolean;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator;
    IndexOf(thread: ProcessThread): int;
    Insert(index: int, thread: ProcessThread): void;
    Remove(thread: ProcessThread): void;
}


export const ProcessThreadCollection: {
    new(processThreads: ProcessThread[]): ProcessThreadCollection$instance;
};


export interface __ProcessThreadCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export interface ProcessThreadCollection$instance extends System_Collections_Internal.ICollection$instance {}

export type ProcessThreadCollection = ProcessThreadCollection$instance & __ProcessThreadCollection$views;


export interface SourceFilter$instance extends TraceFilter {
    Source: string;
    ShouldTrace(cache: TraceEventCache, source: string, eventType: TraceEventType, id: int, formatOrMessage: string, args: unknown[], data1: unknown, data: unknown[]): boolean;
}


export const SourceFilter: {
    new(source: string): SourceFilter$instance;
};


export type SourceFilter = SourceFilter$instance;

export interface SourceSwitch$instance extends Switch {
    Level: SourceLevels;
    ShouldTrace(eventType: TraceEventType): boolean;
}


export const SourceSwitch: {
    new(name: string): SourceSwitch$instance;
    new(displayName: string, defaultSwitchValue: string): SourceSwitch$instance;
};


export type SourceSwitch = SourceSwitch$instance;

export interface StackFrame$instance {
    GetFileColumnNumber(): int;
    GetFileLineNumber(): int;
    GetFileName(): string;
    GetILOffset(): int;
    GetMethod(): MethodBase;
    GetNativeOffset(): int;
    ToString(): string;
}


export const StackFrame: {
    new(): StackFrame$instance;
    new(needFileInfo: boolean): StackFrame$instance;
    new(skipFrames: int): StackFrame$instance;
    new(skipFrames: int, needFileInfo: boolean): StackFrame$instance;
    new(fileName: string, lineNumber: int): StackFrame$instance;
    new(fileName: string, lineNumber: int, colNumber: int): StackFrame$instance;
    readonly OFFSET_UNKNOWN: int;
};


export type StackFrame = StackFrame$instance;

export interface StackTrace$instance {
    readonly FrameCount: int;
    GetFrame(index: int): StackFrame;
    GetFrames(): StackFrame[];
    ToString(): string;
}


export const StackTrace: {
    new(): StackTrace$instance;
    new(fNeedFileInfo: boolean): StackTrace$instance;
    new(skipFrames: int): StackTrace$instance;
    new(skipFrames: int, fNeedFileInfo: boolean): StackTrace$instance;
    new(e: Exception): StackTrace$instance;
    new(e: Exception, fNeedFileInfo: boolean): StackTrace$instance;
    new(e: Exception, skipFrames: int): StackTrace$instance;
    new(e: Exception, skipFrames: int, fNeedFileInfo: boolean): StackTrace$instance;
    new(frame: StackFrame): StackTrace$instance;
    new(frames: IEnumerable_1<StackFrame>): StackTrace$instance;
    readonly METHODS_TO_SKIP: int;
};


export type StackTrace = StackTrace$instance;

export interface StackTraceHiddenAttribute$instance extends Attribute {
}


export const StackTraceHiddenAttribute: {
    new(): StackTraceHiddenAttribute$instance;
};


export type StackTraceHiddenAttribute = StackTraceHiddenAttribute$instance;

export interface Stopwatch$instance {
    readonly Elapsed: TimeSpan;
    readonly ElapsedMilliseconds: long;
    readonly ElapsedTicks: long;
    readonly IsRunning: boolean;
    Reset(): void;
    Restart(): void;
    Start(): void;
    Stop(): void;
    ToString(): string;
}


export const Stopwatch: {
    new(): Stopwatch$instance;
    readonly Frequency: long;
    readonly IsHighResolution: boolean;
    GetElapsedTime(startingTimestamp: long, endingTimestamp: long): TimeSpan;
    GetElapsedTime(startingTimestamp: long): TimeSpan;
    GetTimestamp(): long;
    StartNew(): Stopwatch;
};


export type Stopwatch = Stopwatch$instance;

export interface Switch$instance {
    readonly Attributes: StringDictionary;
    readonly DefaultValue: string;
    readonly Description: string;
    readonly DisplayName: string;
    Value: string;
    Refresh(): void;
}


export const Switch: {
};


export type Switch = Switch$instance;

export interface SwitchAttribute$instance extends Attribute {
    SwitchDescription: string;
    SwitchName: string;
    SwitchType: Type;
}


export const SwitchAttribute: {
    new(switchName: string, switchType: Type): SwitchAttribute$instance;
    GetAll(assembly: Assembly): SwitchAttribute[];
};


export type SwitchAttribute = SwitchAttribute$instance;

export interface SwitchLevelAttribute$instance extends Attribute {
    SwitchLevelType: Type;
}


export const SwitchLevelAttribute: {
    new(switchLevelType: Type): SwitchLevelAttribute$instance;
};


export type SwitchLevelAttribute = SwitchLevelAttribute$instance;

export interface TextWriterTraceListener$instance extends TraceListener$instance {
    Writer: TextWriter;
    Close(): void;
    Dispose(): void;
    Flush(): void;
    Write(message: string): void;
    Write(o: unknown): void;
    Write(message: string, category: string): void;
    Write(o: unknown, category: string): void;
    WriteLine(message: string): void;
    WriteLine(o: unknown): void;
    WriteLine(message: string, category: string): void;
    WriteLine(o: unknown, category: string): void;
}


export const TextWriterTraceListener: {
    new(): TextWriterTraceListener$instance;
    new(stream: Stream): TextWriterTraceListener$instance;
    new(stream: Stream, name: string): TextWriterTraceListener$instance;
    new(writer: TextWriter): TextWriterTraceListener$instance;
    new(writer: TextWriter, name: string): TextWriterTraceListener$instance;
    new(fileName: string): TextWriterTraceListener$instance;
    new(fileName: string, name: string): TextWriterTraceListener$instance;
};


export interface __TextWriterTraceListener$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type TextWriterTraceListener = TextWriterTraceListener$instance & __TextWriterTraceListener$views;


export interface Trace$instance {
}


export const Trace: {
    new(): Trace$instance;
    readonly CorrelationManager: CorrelationManager;
    readonly Listeners: TraceListenerCollection;
    AutoFlush: boolean;
    UseGlobalLock: boolean;
    IndentLevel: int;
    IndentSize: int;
    Assert(condition: boolean, message: string, detailMessage: string): void;
    Assert(condition: boolean, message?: string): void;
    Assert(condition: boolean): void;
    Close(): void;
    Fail(message: string, detailMessage: string): void;
    Fail(message: string): void;
    Flush(): void;
    Indent(): void;
    Refresh(): void;
    TraceError(format: string, ...args: unknown[]): void;
    TraceError(message: string): void;
    TraceInformation(format: string, ...args: unknown[]): void;
    TraceInformation(message: string): void;
    TraceWarning(format: string, ...args: unknown[]): void;
    TraceWarning(message: string): void;
    Unindent(): void;
    Write(value: unknown, category: string): void;
    Write(value: unknown): void;
    Write(message: string, category: string): void;
    Write(message: string): void;
    WriteIf(condition: boolean, value: unknown, category: string): void;
    WriteIf(condition: boolean, value: unknown): void;
    WriteIf(condition: boolean, message: string, category: string): void;
    WriteIf(condition: boolean, message: string): void;
    WriteLine(value: unknown, category: string): void;
    WriteLine(value: unknown): void;
    WriteLine(message: string, category: string): void;
    WriteLine(message: string): void;
    WriteLineIf(condition: boolean, value: unknown, category: string): void;
    WriteLineIf(condition: boolean, value: unknown): void;
    WriteLineIf(condition: boolean, message: string, category: string): void;
    WriteLineIf(condition: boolean, message: string): void;
};


export type Trace = Trace$instance;

export interface TraceEventCache$instance {
    readonly Callstack: string;
    readonly DateTime: DateTime;
    readonly LogicalOperationStack: Stack;
    readonly ProcessId: int;
    readonly ThreadId: string;
    readonly Timestamp: long;
}


export const TraceEventCache: {
    new(): TraceEventCache$instance;
};


export type TraceEventCache = TraceEventCache$instance;

export interface TraceFilter$instance {
    ShouldTrace(cache: TraceEventCache, source: string, eventType: TraceEventType, id: int, formatOrMessage: string, args: unknown[], data1: unknown, data: unknown[]): boolean;
}


export const TraceFilter: {
};


export type TraceFilter = TraceFilter$instance;

export interface TraceListener$instance extends MarshalByRefObject {
    readonly Attributes: StringDictionary;
    Filter: TraceFilter;
    IndentLevel: int;
    IndentSize: int;
    readonly IsThreadSafe: boolean;
    Name: string;
    TraceOutputOptions: TraceOptions;
    Close(): void;
    Dispose(): void;
    Fail(message: string): void;
    Fail(message: string, detailMessage: string): void;
    Flush(): void;
    TraceData(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, data: unknown): void;
    TraceData(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, ...data: unknown[]): void;
    TraceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int): void;
    TraceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, message: string): void;
    TraceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, format: string, ...args: unknown[]): void;
    TraceTransfer(eventCache: TraceEventCache, source: string, id: int, message: string, relatedActivityId: Guid): void;
    Write(message: string): void;
    Write(o: unknown): void;
    Write(message: string, category: string): void;
    Write(o: unknown, category: string): void;
    WriteLine(message: string): void;
    WriteLine(o: unknown): void;
    WriteLine(message: string, category: string): void;
    WriteLine(o: unknown, category: string): void;
}


export const TraceListener: {
};


export interface __TraceListener$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface TraceListener$instance extends System_Internal.IDisposable$instance {}

export type TraceListener = TraceListener$instance & __TraceListener$views;


export interface TraceListenerCollection$instance {
    readonly Count: int;
    Add(listener: TraceListener): int;
    AddRange(value: TraceListener[]): void;
    AddRange(value: TraceListenerCollection): void;
    Clear(): void;
    Contains(listener: TraceListener): boolean;
    CopyTo(listeners: TraceListener[], index: int): void;
    get_Item(i: int): TraceListener;
    get_Item(name: string): TraceListener;
    GetEnumerator(): IEnumerator;
    IndexOf(listener: TraceListener): int;
    Insert(index: int, listener: TraceListener): void;
    Remove(listener: TraceListener): void;
    Remove(name: string): void;
    RemoveAt(index: int): void;
    set_Item(i: int, value: TraceListener): void;
}


export const TraceListenerCollection: {
    new(): TraceListenerCollection$instance;
};


export interface __TraceListenerCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type TraceListenerCollection = TraceListenerCollection$instance & __TraceListenerCollection$views;


export interface TraceSource$instance {
    readonly Attributes: StringDictionary;
    readonly DefaultLevel: SourceLevels;
    readonly Listeners: TraceListenerCollection;
    readonly Name: string;
    Switch: SourceSwitch;
    Close(): void;
    Flush(): void;
    TraceData(eventType: TraceEventType, id: int, data: unknown): void;
    TraceData(eventType: TraceEventType, id: int, ...data: unknown[]): void;
    TraceEvent(eventType: TraceEventType, id: int): void;
    TraceEvent(eventType: TraceEventType, id: int, message: string): void;
    TraceEvent(eventType: TraceEventType, id: int, format: string, ...args: unknown[]): void;
    TraceInformation(message: string): void;
    TraceInformation(format: string, ...args: unknown[]): void;
    TraceTransfer(id: int, message: string, relatedActivityId: Guid): void;
}


export const TraceSource: {
    new(name: string): TraceSource$instance;
    new(name: string, defaultLevel: SourceLevels): TraceSource$instance;
};


export type TraceSource = TraceSource$instance;

export interface TraceSwitch$instance extends Switch {
    Level: TraceLevel;
    readonly TraceError: boolean;
    readonly TraceInfo: boolean;
    readonly TraceVerbose: boolean;
    readonly TraceWarning: boolean;
}


export const TraceSwitch: {
    new(displayName: string, description: string): TraceSwitch$instance;
    new(displayName: string, description: string, defaultSwitchValue: string): TraceSwitch$instance;
};


export type TraceSwitch = TraceSwitch$instance;

export interface UnreachableException$instance extends Exception {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const UnreachableException: {
    new(): UnreachableException$instance;
    new(message: string): UnreachableException$instance;
    new(message: string, innerException: Exception): UnreachableException$instance;
};


export interface __UnreachableException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type UnreachableException = UnreachableException$instance & __UnreachableException$views;


export interface XmlWriterTraceListener$instance extends TextWriterTraceListener$instance {
    Close(): void;
    Dispose(): void;
    Fail(message: string, detailMessage: string): void;
    Fail(message: string): void;
    TraceData(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, data: unknown): void;
    TraceData(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, ...data: unknown[]): void;
    TraceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, format: string, ...args: unknown[]): void;
    TraceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int, message: string): void;
    TraceEvent(eventCache: TraceEventCache, source: string, eventType: TraceEventType, id: int): void;
    TraceTransfer(eventCache: TraceEventCache, source: string, id: int, message: string, relatedActivityId: Guid): void;
    Write(message: string): void;
    Write(o: unknown): void;
    Write(message: string, category: string): void;
    Write(o: unknown, category: string): void;
    WriteLine(message: string): void;
    WriteLine(o: unknown): void;
    WriteLine(message: string, category: string): void;
    WriteLine(o: unknown, category: string): void;
}


export const XmlWriterTraceListener: {
    new(stream: Stream): XmlWriterTraceListener$instance;
    new(stream: Stream, name: string): XmlWriterTraceListener$instance;
    new(writer: TextWriter): XmlWriterTraceListener$instance;
    new(writer: TextWriter, name: string): XmlWriterTraceListener$instance;
    new(filename: string): XmlWriterTraceListener$instance;
    new(filename: string, name: string): XmlWriterTraceListener$instance;
};


export interface __XmlWriterTraceListener$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type XmlWriterTraceListener = XmlWriterTraceListener$instance & __XmlWriterTraceListener$views;


export abstract class Debug$instance {
    static AutoFlush: boolean;
    static IndentLevel: int;
    static IndentSize: int;
    static Assert(condition: boolean, message: Debug_AssertInterpolatedStringHandler, detailMessage: Debug_AssertInterpolatedStringHandler): void;
    static Assert(condition: boolean, message: Debug_AssertInterpolatedStringHandler): void;
    static Assert(condition: boolean, message: string, detailMessageFormat: string, ...args: unknown[]): void;
    static Assert(condition: boolean, message: string, detailMessage: string): void;
    static Assert(condition: boolean, message?: string): void;
    static Assert(condition: boolean): void;
    static Close(): void;
    static Fail(message: string, detailMessage: string): void;
    static Fail(message: string): void;
    static Flush(): void;
    static Indent(): void;
    static Print(format: string, ...args: unknown[]): void;
    static Print(message: string): void;
    static SetProvider(provider: DebugProvider): DebugProvider;
    static Unindent(): void;
    static Write(value: unknown, category: string): void;
    static Write(value: unknown): void;
    static Write(message: string, category: string): void;
    static Write(message: string): void;
    static WriteIf(condition: boolean, message: Debug_WriteIfInterpolatedStringHandler, category: string): void;
    static WriteIf(condition: boolean, message: Debug_WriteIfInterpolatedStringHandler): void;
    static WriteIf(condition: boolean, value: unknown, category: string): void;
    static WriteIf(condition: boolean, value: unknown): void;
    static WriteIf(condition: boolean, message: string, category: string): void;
    static WriteIf(condition: boolean, message: string): void;
    static WriteLine(value: unknown, category: string): void;
    static WriteLine(value: unknown): void;
    static WriteLine(format: string, ...args: unknown[]): void;
    static WriteLine(message: string, category: string): void;
    static WriteLine(message: string): void;
    static WriteLineIf(condition: boolean, message: Debug_WriteIfInterpolatedStringHandler, category: string): void;
    static WriteLineIf(condition: boolean, message: Debug_WriteIfInterpolatedStringHandler): void;
    static WriteLineIf(condition: boolean, value: unknown, category: string): void;
    static WriteLineIf(condition: boolean, value: unknown): void;
    static WriteLineIf(condition: boolean, message: string, category: string): void;
    static WriteLineIf(condition: boolean, message: string): void;
}


export type Debug = Debug$instance;

export abstract class Debugger$instance {
    static readonly DefaultCategory: string;
    static readonly IsAttached: boolean;
    static Break(): void;
    static BreakForUserUnhandledException(exception: Exception): void;
    static IsLogging(): boolean;
    static Launch(): boolean;
    static Log(level: int, category: string, message: string): void;
    static NotifyOfCrossThreadDependency(): void;
}


export type Debugger = Debugger$instance;

export abstract class StackFrameExtensions$instance {
    static GetNativeImageBase(stackFrame: StackFrame): nint;
    static GetNativeIP(stackFrame: StackFrame): nint;
    static HasILOffset(stackFrame: StackFrame): boolean;
    static HasMethod(stackFrame: StackFrame): boolean;
    static HasNativeImage(stackFrame: StackFrame): boolean;
    static HasSource(stackFrame: StackFrame): boolean;
}


export type StackFrameExtensions = StackFrameExtensions$instance;


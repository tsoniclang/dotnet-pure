// Generated by tsbindgen - Architecture
// Namespace: System.Formats.Tar
// Assembly: System.Formats.Tar

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import types from other namespaces
import type { IEnumerable_1, IReadOnlyDictionary_2, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import type { Stream, UnixFileMode } from "../../System.IO/internal/index.js";
import type { Task, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Boolean as ClrBoolean, Byte, DateTimeOffset, Enum, IAsyncDisposable, IComparable, IConvertible, IDisposable, IFormatProvider, IFormattable, Int32, Int64, ISpanFormattable, Object as ClrObject, String as ClrString, Type, TypeCode, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum TarEntryFormat {
    Unknown = 0,
    V7 = 1,
    Ustar = 2,
    Pax = 3,
    Gnu = 4
}


export enum TarEntryType {
    RegularFile = 48,
    HardLink = 49,
    SymbolicLink = 50,
    CharacterDevice = 51,
    BlockDevice = 52,
    Directory = 53,
    Fifo = 54,
    ContiguousFile = 55,
    ExtendedAttributes = 120,
    GlobalExtendedAttributes = 103,
    DirectoryList = 68,
    LongLink = 75,
    LongPath = 76,
    MultiVolume = 77,
    V7RegularFile = 0,
    RenamedOrSymlinked = 78,
    SparseFile = 83,
    TapeVolume = 86
}


export interface GnuTarEntry$instance extends PosixTarEntry {
    AccessTime: DateTimeOffset;
    ChangeTime: DateTimeOffset;
}


export const GnuTarEntry: {
    new(entryType: TarEntryType, entryName: string): GnuTarEntry$instance;
    new(other: TarEntry): GnuTarEntry$instance;
};


export type GnuTarEntry = GnuTarEntry$instance;

export interface PaxGlobalExtendedAttributesTarEntry$instance extends PosixTarEntry {
    readonly GlobalExtendedAttributes: IReadOnlyDictionary_2<CLROf<string>, CLROf<string>>;
}


export const PaxGlobalExtendedAttributesTarEntry: {
    new(globalExtendedAttributes: IEnumerable_1<KeyValuePair_2<CLROf<string>, CLROf<string>>>): PaxGlobalExtendedAttributesTarEntry$instance;
};


export type PaxGlobalExtendedAttributesTarEntry = PaxGlobalExtendedAttributesTarEntry$instance;

export interface PaxTarEntry$instance extends PosixTarEntry {
    readonly ExtendedAttributes: IReadOnlyDictionary_2<CLROf<string>, CLROf<string>>;
}


export const PaxTarEntry: {
    new(entryType: TarEntryType, entryName: string): PaxTarEntry$instance;
    new(entryType: TarEntryType, entryName: string, extendedAttributes: IEnumerable_1<KeyValuePair_2<CLROf<string>, CLROf<string>>>): PaxTarEntry$instance;
    new(other: TarEntry): PaxTarEntry$instance;
};


export type PaxTarEntry = PaxTarEntry$instance;

export interface PosixTarEntry$instance extends TarEntry {
    DeviceMajor: int;
    DeviceMinor: int;
    GroupName: string;
    UserName: string;
}


export const PosixTarEntry: {
};


export type PosixTarEntry = PosixTarEntry$instance;

export interface TarEntry$instance {
    readonly Checksum: int;
    readonly DataOffset: long;
    DataStream: Stream;
    readonly EntryType: TarEntryType;
    readonly Format: TarEntryFormat;
    Gid: int;
    readonly Length: long;
    LinkName: string;
    Mode: UnixFileMode;
    ModificationTime: DateTimeOffset;
    Name: string;
    Uid: int;
    ExtractToFile(destinationFileName: string, overwrite: boolean): void;
    ExtractToFileAsync(destinationFileName: string, overwrite: boolean, cancellationToken?: CancellationToken): Task;
    ToString(): string;
}


export const TarEntry: {
};


export type TarEntry = TarEntry$instance;

export interface TarReader$instance {
    Dispose(): void;
    DisposeAsync(): ValueTask;
    GetNextEntry(copyData?: boolean): TarEntry;
    GetNextEntryAsync(copyData?: boolean, cancellationToken?: CancellationToken): ValueTask_1<TarEntry>;
}


export const TarReader: {
    new(archiveStream: Stream, leaveOpen: boolean): TarReader$instance;
};


export interface __TarReader$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface TarReader$instance extends System_Internal.IAsyncDisposable$instance, System_Internal.IDisposable$instance {}

export type TarReader = TarReader$instance & __TarReader$views;


export interface TarWriter$instance {
    readonly Format: TarEntryFormat;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    WriteEntry(fileName: string, entryName: string): void;
    WriteEntry(entry: TarEntry): void;
    WriteEntryAsync(fileName: string, entryName: string, cancellationToken?: CancellationToken): Task;
    WriteEntryAsync(entry: TarEntry, cancellationToken?: CancellationToken): Task;
}


export const TarWriter: {
    new(archiveStream: Stream): TarWriter$instance;
    new(archiveStream: Stream, leaveOpen: boolean): TarWriter$instance;
    new(archiveStream: Stream, format: TarEntryFormat, leaveOpen: boolean): TarWriter$instance;
};


export interface __TarWriter$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface TarWriter$instance extends System_Internal.IAsyncDisposable$instance, System_Internal.IDisposable$instance {}

export type TarWriter = TarWriter$instance & __TarWriter$views;


export interface UstarTarEntry$instance extends PosixTarEntry {
}


export const UstarTarEntry: {
    new(entryType: TarEntryType, entryName: string): UstarTarEntry$instance;
    new(other: TarEntry): UstarTarEntry$instance;
};


export type UstarTarEntry = UstarTarEntry$instance;

export interface V7TarEntry$instance extends TarEntry {
}


export const V7TarEntry: {
    new(entryType: TarEntryType, entryName: string): V7TarEntry$instance;
    new(other: TarEntry): V7TarEntry$instance;
};


export type V7TarEntry = V7TarEntry$instance;

export abstract class TarFile$instance {
    static CreateFromDirectory(sourceDirectoryName: string, destination: Stream, includeBaseDirectory: boolean): void;
    static CreateFromDirectory(sourceDirectoryName: string, destinationFileName: string, includeBaseDirectory: boolean): void;
    static CreateFromDirectoryAsync(sourceDirectoryName: string, destination: Stream, includeBaseDirectory: boolean, cancellationToken?: CancellationToken): Task;
    static CreateFromDirectoryAsync(sourceDirectoryName: string, destinationFileName: string, includeBaseDirectory: boolean, cancellationToken?: CancellationToken): Task;
    static ExtractToDirectory(source: Stream, destinationDirectoryName: string, overwriteFiles: boolean): void;
    static ExtractToDirectory(sourceFileName: string, destinationDirectoryName: string, overwriteFiles: boolean): void;
    static ExtractToDirectoryAsync(source: Stream, destinationDirectoryName: string, overwriteFiles: boolean, cancellationToken?: CancellationToken): Task;
    static ExtractToDirectoryAsync(sourceFileName: string, destinationDirectoryName: string, overwriteFiles: boolean, cancellationToken?: CancellationToken): Task;
}


export type TarFile = TarFile$instance;


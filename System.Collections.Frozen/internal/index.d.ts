// Generated by tsbindgen - Architecture
// Namespace: System.Collections.Frozen
// Assembly: System.Collections.Immutable

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IDictionary_2, IEnumerable_1, IEnumerator_1, IEqualityComparer_1, IReadOnlyCollection_1, IReadOnlyDictionary_2, IReadOnlySet_1, ISet_1, KeyValuePair_2 } from "../../System.Collections.Generic/internal/index.js";
import type { ImmutableArray_1 } from "../../System.Collections.Immutable/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IDictionaryEnumerator, IEnumerable, IEnumerator } from "../../System.Collections/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, Boolean as ClrBoolean, Func_2, IDisposable, Int32, Object as ClrObject, ReadOnlySpan_1, Span_1, String as ClrString, Type, ValueType, Void } from "../../System/internal/index.js";

export interface FrozenDictionary_2_AlternateLookup_1$instance<TKey, TValue, TAlternateKey> {
    readonly Dictionary: FrozenDictionary_2<TKey, TValue>;
    readonly Item: TValue;
    ContainsKey(key: TAlternateKey): boolean;
    TryGetValue(key: TAlternateKey, value: TValue): boolean;
}


export const FrozenDictionary_2_AlternateLookup_1: {
    new<TKey, TValue, TAlternateKey>(): FrozenDictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>;
};


export type FrozenDictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey> = FrozenDictionary_2_AlternateLookup_1$instance<TKey, TValue, TAlternateKey>;

export interface FrozenDictionary_2_Enumerator$instance<TKey, TValue> {
    readonly Current: KeyValuePair_2<TKey, TValue>;
    MoveNext(): boolean;
    Reset(): void;
}


export const FrozenDictionary_2_Enumerator: {
    new<TKey, TValue>(): FrozenDictionary_2_Enumerator<TKey, TValue>;
};


export interface __FrozenDictionary_2_Enumerator$views<TKey, TValue> {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type FrozenDictionary_2_Enumerator<TKey, TValue> = FrozenDictionary_2_Enumerator$instance<TKey, TValue> & __FrozenDictionary_2_Enumerator$views<TKey, TValue>;


export interface FrozenSet_1_AlternateLookup_1$instance<T, TAlternate> {
    readonly Set: FrozenSet_1<T>;
    Contains(item: TAlternate): boolean;
    TryGetValue(equalValue: TAlternate, actualValue: T): boolean;
}


export const FrozenSet_1_AlternateLookup_1: {
    new<T, TAlternate>(): FrozenSet_1_AlternateLookup_1<T, TAlternate>;
};


export type FrozenSet_1_AlternateLookup_1<T, TAlternate> = FrozenSet_1_AlternateLookup_1$instance<T, TAlternate>;

export interface FrozenSet_1_Enumerator$instance<T> {
    readonly Current: T;
    MoveNext(): boolean;
    Reset(): void;
}


export const FrozenSet_1_Enumerator: {
    new<T>(): FrozenSet_1_Enumerator<T>;
};


export interface __FrozenSet_1_Enumerator$views<T> {
    As_IEnumerator_1(): System_Collections_Generic_Internal.IEnumerator_1$instance<T>;
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type FrozenSet_1_Enumerator<T> = FrozenSet_1_Enumerator$instance<T> & __FrozenSet_1_Enumerator$views<T>;


export interface FrozenDictionary_2$instance<TKey, TValue> {
    readonly Comparer: IEqualityComparer_1<TKey>;
    readonly Count: int;
    readonly Item: TValue;
    readonly Keys: ImmutableArray_1<TKey>;
    readonly Values: ImmutableArray_1<TValue>;
    ContainsKey(key: TKey): boolean;
    CopyTo(destination: KeyValuePair_2<TKey, TValue>[], destinationIndex: int): void;
    CopyTo(destination: Span_1<KeyValuePair_2<TKey, TValue>>): void;
    GetAlternateLookup<TAlternateKey>(): FrozenDictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>;
    GetEnumerator(): FrozenDictionary_2_Enumerator<TKey, TValue>;
    GetValueRefOrNullRef(key: TKey): TValue;
    TryGetAlternateLookup<TAlternateKey>(lookup: FrozenDictionary_2_AlternateLookup_1<TKey, TValue, TAlternateKey>): boolean;
    TryGetValue(key: TKey, value: TValue): boolean;
}


export const FrozenDictionary_2: {
    readonly Empty: unknown;
};


export interface __FrozenDictionary_2$views<TKey, TValue> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IDictionary_2(): System_Collections_Generic_Internal.IDictionary_2$instance<TKey, TValue>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<KeyValuePair_2<TKey, TValue>>;
    As_IReadOnlyDictionary_2(): System_Collections_Generic_Internal.IReadOnlyDictionary_2$instance<TKey, TValue>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IDictionary(): System_Collections_Internal.IDictionary$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type FrozenDictionary_2<TKey, TValue> = FrozenDictionary_2$instance<TKey, TValue> & __FrozenDictionary_2$views<TKey, TValue>;


export interface FrozenSet_1$instance<T> {
    readonly Comparer: IEqualityComparer_1<T>;
    readonly Count: int;
    readonly Items: ImmutableArray_1<T>;
    Contains(item: T): boolean;
    CopyTo(destination: T[], destinationIndex: int): void;
    CopyTo(destination: Span_1<T>): void;
    GetAlternateLookup<TAlternate>(): FrozenSet_1_AlternateLookup_1<T, TAlternate>;
    GetEnumerator(): FrozenSet_1_Enumerator<T>;
    IsProperSubsetOf(other: IEnumerable_1<T>): boolean;
    IsProperSupersetOf(other: IEnumerable_1<T>): boolean;
    IsSubsetOf(other: IEnumerable_1<T>): boolean;
    IsSupersetOf(other: IEnumerable_1<T>): boolean;
    Overlaps(other: IEnumerable_1<T>): boolean;
    SetEquals(other: IEnumerable_1<T>): boolean;
    TryGetAlternateLookup<TAlternate>(lookup: FrozenSet_1_AlternateLookup_1<T, TAlternate>): boolean;
    TryGetValue(equalValue: T, actualValue: T): boolean;
}


export const FrozenSet_1: {
    readonly Empty: unknown;
};


export interface __FrozenSet_1$views<T> {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<T>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<T>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<T>;
    As_IReadOnlySet_1(): System_Collections_Generic_Internal.IReadOnlySet_1$instance<T>;
    As_ISet_1(): System_Collections_Generic_Internal.ISet_1$instance<T>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type FrozenSet_1<T> = FrozenSet_1$instance<T> & __FrozenSet_1$views<T>;


export abstract class FrozenDictionary$instance {
    static Create<TKey, TValue>(comparer: IEqualityComparer_1<TKey> | undefined, source: ReadOnlySpan_1<KeyValuePair_2<TKey, TValue>>): FrozenDictionary_2<TKey, TValue>;
    static Create<TKey, TValue>(source: ReadOnlySpan_1<KeyValuePair_2<TKey, TValue>>): FrozenDictionary_2<TKey, TValue>;
    static ToFrozenDictionary<TSource, TKey, TElement>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, elementSelector: Func_2<TSource, TElement>, comparer?: IEqualityComparer_1<TKey> | undefined): FrozenDictionary_2<TKey, TElement>;
    static ToFrozenDictionary<TSource, TKey>(source: IEnumerable_1<TSource>, keySelector: Func_2<TSource, TKey>, comparer?: IEqualityComparer_1<TKey> | undefined): FrozenDictionary_2<TKey, TSource>;
    static ToFrozenDictionary<TKey, TValue>(source: IEnumerable_1<KeyValuePair_2<TKey, TValue>>, comparer?: IEqualityComparer_1<TKey> | undefined): FrozenDictionary_2<TKey, TValue>;
}


export type FrozenDictionary = FrozenDictionary$instance;

export abstract class FrozenSet$instance {
    static Create<T>(equalityComparer: IEqualityComparer_1<T> | undefined, source: ReadOnlySpan_1<T>): FrozenSet_1<T>;
    static Create<T>(source: ReadOnlySpan_1<T>): FrozenSet_1<T>;
    static ToFrozenSet<T>(source: IEnumerable_1<T>, comparer?: IEqualityComparer_1<T> | undefined): FrozenSet_1<T>;
}


export type FrozenSet = FrozenSet$instance;


// Generated by tsbindgen - Architecture
// Namespace: System.Security.Cryptography
// Assembly: System.Private.CoreLib, System.Security.Cryptography

// Branded primitive types are sourced from @tsonic/types
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/types';

// Import support types from @tsonic/types
import type { ptr, ref } from "@tsonic/types";

// Import types from other namespaces
import type { SafeNCryptKeyHandle, SafeNCryptProviderHandle, SafeNCryptSecretHandle } from "../../Microsoft.Win32.SafeHandles/internal/index.js";
import * as System_Collections_Generic_Internal from "../../System.Collections.Generic/internal/index.js";
import type { ICollection_1, IEnumerable_1, IEnumerator_1, IList_1, IReadOnlyCollection_1, IReadOnlyList_1 } from "../../System.Collections.Generic/internal/index.js";
import * as System_Collections_ObjectModel_Internal from "../../System.Collections.ObjectModel/internal/index.js";
import type { Collection_1 } from "../../System.Collections.ObjectModel/internal/index.js";
import * as System_Collections_Internal from "../../System.Collections/internal/index.js";
import type { ICollection, IDictionary, IEnumerable, IEnumerator, IList } from "../../System.Collections/internal/index.js";
import * as System_IO_Internal from "../../System.IO/internal/index.js";
import type { SeekOrigin, Stream } from "../../System.IO/internal/index.js";
import type { MethodBase } from "../../System.Reflection/internal/index.js";
import * as System_Runtime_InteropServices_Internal from "../../System.Runtime.InteropServices/internal/index.js";
import type { SafeHandle } from "../../System.Runtime.InteropServices/internal/index.js";
import * as System_Runtime_Serialization_Internal from "../../System.Runtime.Serialization/internal/index.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "../../System.Runtime.Serialization/internal/index.js";
import type { SecureString, SecurityElement } from "../../System.Security/internal/index.js";
import type { Task, Task_1, ValueTask, ValueTask_1 } from "../../System.Threading.Tasks/internal/index.js";
import type { CancellationToken } from "../../System.Threading/internal/index.js";
import * as System_Internal from "../../System/internal/index.js";
import type { Array as ClrArray, AsyncCallback, Boolean as ClrBoolean, Byte, Char, Enum, Exception, IAsyncDisposable, IAsyncResult, IComparable, IConvertible, IDisposable, IEquatable_1, IFormatProvider, IFormattable, Int32, Int64, IntPtr, ISpanFormattable, Memory_1, Nullable_1, Object as ClrObject, Range, ReadOnlyMemory_1, ReadOnlySpan_1, Span_1, String as ClrString, SystemException, Type, TypeCode, ValueType, Void } from "../../System/internal/index.js";

// CLROf<T> - Maps ergonomic primitives to their CLR types for generic constraints
// This utility is used ONLY in generic type arguments to satisfy CLR interface constraints
// Value positions (parameters, return types) use lowercase primitives for ergonomics
export type CLROf<T> =
    T extends sbyte ? System_Internal.SByte :
    T extends short ? System_Internal.Int16 :
    T extends int ? System_Internal.Int32 :
    T extends long ? System_Internal.Int64 :
    T extends int128 ? System_Internal.Int128 :
    T extends nint ? System_Internal.IntPtr :
    T extends byte ? System_Internal.Byte :
    T extends ushort ? System_Internal.UInt16 :
    T extends uint ? System_Internal.UInt32 :
    T extends ulong ? System_Internal.UInt64 :
    T extends uint128 ? System_Internal.UInt128 :
    T extends nuint ? System_Internal.UIntPtr :
    T extends half ? System_Internal.Half :
    T extends float ? System_Internal.Single :
    T extends double ? System_Internal.Double :
    T extends decimal ? System_Internal.Decimal :
    T extends char ? System_Internal.Char :
    T extends boolean ? System_Internal.Boolean :
    T extends string ? System_Internal.String :
    T; // Identity fallback for non-primitive types

export enum CipherMode {
    CBC = 1,
    ECB = 2,
    OFB = 3,
    CFB = 4,
    CTS = 5
}


export enum CngExportPolicies {
    None = 0,
    AllowExport = 1,
    AllowPlaintextExport = 2,
    AllowArchiving = 4,
    AllowPlaintextArchiving = 8
}


export enum CngKeyCreationOptions {
    None = 0,
    MachineKey = 32,
    OverwriteExistingKey = 128,
    PreferVbs = 65536,
    RequireVbs = 131072,
    UsePerBootKey = 262144
}


export enum CngKeyHandleOpenOptions {
    None = 0,
    EphemeralKey = 1
}


export enum CngKeyOpenOptions {
    None = 0,
    UserKey = 0,
    MachineKey = 32,
    Silent = 64
}


export enum CngKeyUsages {
    None = 0,
    Decryption = 1,
    Signing = 2,
    KeyAgreement = 4,
    AllUsages = 16777215
}


export enum CngPropertyOptions {
    None = 0,
    CustomProperty = 1073741824,
    Persist = -2147483648
}


export enum CngUIProtectionLevels {
    None = 0,
    ProtectKey = 1,
    ForceHighProtection = 2
}


export enum CryptoStreamMode {
    Read = 0,
    Write = 1
}


export enum CspProviderFlags {
    NoFlags = 0,
    UseMachineKeyStore = 1,
    UseDefaultKeyContainer = 2,
    UseNonExportableKey = 4,
    UseExistingKey = 8,
    UseArchivableKey = 16,
    UseUserProtectedKey = 32,
    NoPrompt = 64,
    CreateEphemeralKey = 128
}


export enum DSASignatureFormat {
    IeeeP1363FixedFieldConcatenation = 0,
    Rfc3279DerSequence = 1
}


export enum ECCurve_ECCurveType {
    Implicit = 0,
    PrimeShortWeierstrass = 1,
    PrimeTwistedEdwards = 2,
    PrimeMontgomery = 3,
    Characteristic2 = 4,
    Named = 5
}


export enum ECDiffieHellmanKeyDerivationFunction {
    Hash = 0,
    Hmac = 1,
    Tls = 2
}


export enum ECKeyXmlFormat {
    Rfc4050 = 0
}


export enum FromBase64TransformMode {
    IgnoreWhiteSpaces = 0,
    DoNotIgnoreWhiteSpaces = 1
}


export enum KeyNumber {
    Exchange = 1,
    Signature = 2
}


export enum OidGroup {
    All = 0,
    HashAlgorithm = 1,
    EncryptionAlgorithm = 2,
    PublicKeyAlgorithm = 3,
    SignatureAlgorithm = 4,
    Attribute = 5,
    ExtensionOrAttribute = 6,
    EnhancedKeyUsage = 7,
    Policy = 8,
    Template = 9,
    KeyDerivationFunction = 10
}


export enum PaddingMode {
    None = 1,
    PKCS7 = 2,
    Zeros = 3,
    ANSIX923 = 4,
    ISO10126 = 5
}


export enum PbeEncryptionAlgorithm {
    Unknown = 0,
    Aes128Cbc = 1,
    Aes192Cbc = 2,
    Aes256Cbc = 3,
    TripleDes3KeyPkcs12 = 4
}


export enum RSAEncryptionPaddingMode {
    Pkcs1 = 0,
    Oaep = 1
}


export enum RSASignaturePaddingMode {
    Pkcs1 = 0,
    Pss = 1
}


export interface ICryptoTransform$instance extends IDisposable {
    readonly InputBlockSize: int;
    readonly OutputBlockSize: int;
    readonly CanTransformMultipleBlocks: boolean;
    readonly CanReuseTransform: boolean;
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export interface ICryptoTransform$instance extends System_Internal.IDisposable$instance {}

export type ICryptoTransform = ICryptoTransform$instance;

export interface ICspAsymmetricAlgorithm$instance {
    readonly CspKeyContainerInfo: CspKeyContainerInfo;
    ExportCspBlob(includePrivateParameters: boolean): byte[];
    ImportCspBlob(rawData: byte[]): void;
}


export type ICspAsymmetricAlgorithm = ICspAsymmetricAlgorithm$instance;

export interface CngProperty$instance {
    readonly Name: string;
    readonly Options: CngPropertyOptions;
    Equals(obj: unknown): boolean;
    Equals(other: CngProperty): boolean;
    GetHashCode(): int;
    GetValue(): byte[];
}


export const CngProperty: {
    new(name: string, value: byte[], options: CngPropertyOptions): CngProperty$instance;
};


export interface __CngProperty$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CngProperty>;

    // Structural method bridges for numeric interface constraints
    equals(other: CngProperty): boolean;
}

export type CngProperty = CngProperty$instance & __CngProperty$views;


export interface DSAParameters$instance {
    P: byte[];
    Q: byte[];
    G: byte[];
    Y: byte[];
    J: byte[];
    X: byte[];
    Seed: byte[];
    Counter: int;
}


export const DSAParameters: {
    new(): DSAParameters$instance;
};


export type DSAParameters = DSAParameters$instance;

export interface ECCurve$instance {
    A: byte[];
    B: byte[];
    G: ECPoint;
    Order: byte[];
    Cofactor: byte[];
    Seed: byte[];
    CurveType: ECCurve_ECCurveType;
    Hash: Nullable_1<HashAlgorithmName>;
    Polynomial: byte[];
    Prime: byte[];
    readonly IsCharacteristic2: boolean;
    readonly IsExplicit: boolean;
    readonly IsNamed: boolean;
    readonly IsPrime: boolean;
    readonly Oid: Oid;
    Validate(): void;
}


export const ECCurve: {
    new(): ECCurve$instance;
    CreateFromFriendlyName(oidFriendlyName: string): ECCurve;
    CreateFromOid(curveOid: Oid): ECCurve;
    CreateFromValue(oidValue: string): ECCurve;
};


export type ECCurve = ECCurve$instance;

export interface ECParameters$instance {
    Q: ECPoint;
    D: byte[];
    Curve: ECCurve;
    Validate(): void;
}


export const ECParameters: {
    new(): ECParameters$instance;
};


export type ECParameters = ECParameters$instance;

export interface ECPoint$instance {
    X: byte[];
    Y: byte[];
}


export const ECPoint: {
    new(): ECPoint$instance;
};


export type ECPoint = ECPoint$instance;

export interface HashAlgorithmName$instance {
    readonly Name: string;
    Equals(obj: unknown): boolean;
    Equals(other: HashAlgorithmName): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const HashAlgorithmName: {
    new(name: string): HashAlgorithmName$instance;
    readonly MD5: HashAlgorithmName;
    readonly SHA1: HashAlgorithmName;
    readonly SHA256: HashAlgorithmName;
    readonly SHA384: HashAlgorithmName;
    readonly SHA512: HashAlgorithmName;
    readonly SHA3_256: HashAlgorithmName;
    readonly SHA3_384: HashAlgorithmName;
    readonly SHA3_512: HashAlgorithmName;
    FromOid(oidValue: string): HashAlgorithmName;
    TryFromOid(oidValue: string, value: { value: ref<HashAlgorithmName> }): boolean;
};


export interface __HashAlgorithmName$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<HashAlgorithmName>;

    // Structural method bridges for numeric interface constraints
    equals(other: HashAlgorithmName): boolean;
}

export type HashAlgorithmName = HashAlgorithmName$instance & __HashAlgorithmName$views;


export interface PemFields$instance {
    readonly Base64Data: Range;
    readonly DecodedDataLength: int;
    readonly Label: Range;
    readonly Location: Range;
}


export const PemFields: {
    new(): PemFields$instance;
};


export type PemFields = PemFields$instance;

export interface RSAParameters$instance {
    D: byte[];
    DP: byte[];
    DQ: byte[];
    Exponent: byte[];
    InverseQ: byte[];
    Modulus: byte[];
    P: byte[];
    Q: byte[];
}


export const RSAParameters: {
    new(): RSAParameters$instance;
};


export type RSAParameters = RSAParameters$instance;

export interface Aes$instance extends SymmetricAlgorithm$instance {
    DecryptKeyWrapPadded(ciphertext: byte[]): byte[];
    DecryptKeyWrapPadded(ciphertext: ReadOnlySpan_1<CLROf<byte>>): byte[];
    DecryptKeyWrapPadded(ciphertext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    Dispose(): void;
    EncryptKeyWrapPadded(plaintext: byte[]): byte[];
    EncryptKeyWrapPadded(plaintext: ReadOnlySpan_1<CLROf<byte>>): byte[];
    EncryptKeyWrapPadded(plaintext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): void;
    TryDecryptKeyWrapPadded(ciphertext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export const Aes: {
    GetKeyWrapPaddedLength(plaintextLengthInBytes: int): int;
};


export interface __Aes$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type Aes = Aes$instance & __Aes$views;


export interface AesCcm$instance {
    Decrypt(nonce: byte[], ciphertext: byte[], tag: byte[], plaintext: byte[], associatedData?: byte[]): void;
    Decrypt(nonce: ReadOnlySpan_1<CLROf<byte>>, ciphertext: ReadOnlySpan_1<CLROf<byte>>, tag: ReadOnlySpan_1<CLROf<byte>>, plaintext: Span_1<CLROf<byte>>, associatedData?: ReadOnlySpan_1<CLROf<byte>>): void;
    Dispose(): void;
    Encrypt(nonce: byte[], plaintext: byte[], ciphertext: byte[], tag: byte[], associatedData?: byte[]): void;
    Encrypt(nonce: ReadOnlySpan_1<CLROf<byte>>, plaintext: ReadOnlySpan_1<CLROf<byte>>, ciphertext: Span_1<CLROf<byte>>, tag: Span_1<CLROf<byte>>, associatedData?: ReadOnlySpan_1<CLROf<byte>>): void;
}


export const AesCcm: {
    new(key: ReadOnlySpan_1<CLROf<byte>>): AesCcm$instance;
    new(key: byte[]): AesCcm$instance;
    readonly NonceByteSizes: KeySizes;
    readonly TagByteSizes: KeySizes;
    readonly IsSupported: boolean;
};


export interface __AesCcm$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface AesCcm$instance extends System_Internal.IDisposable$instance {}

export type AesCcm = AesCcm$instance & __AesCcm$views;


export interface AesCng$instance extends Aes$instance {
    CreateDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    CreateDecryptor(): ICryptoTransform;
    CreateEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    CreateEncryptor(): ICryptoTransform;
    Dispose(): void;
    GenerateIV(): void;
    GenerateKey(): void;
}


export const AesCng: {
    new(): AesCng$instance;
    new(keyName: string): AesCng$instance;
    new(keyName: string, provider: CngProvider): AesCng$instance;
    new(keyName: string, provider: CngProvider, openOptions: CngKeyOpenOptions): AesCng$instance;
    new(key: CngKey): AesCng$instance;
};


export interface __AesCng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type AesCng = AesCng$instance & __AesCng$views;


export interface AesCryptoServiceProvider$instance extends Aes$instance {
    BlockSize: int;
    FeedbackSize: int;
    IV: byte[];
    Key: byte[];
    KeySize: int;
    readonly LegalBlockSizes: KeySizes[];
    readonly LegalKeySizes: KeySizes[];
    Mode: CipherMode;
    Padding: PaddingMode;
    CreateDecryptor(): ICryptoTransform;
    CreateDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    CreateEncryptor(): ICryptoTransform;
    CreateEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    Dispose(): void;
    GenerateIV(): void;
    GenerateKey(): void;
}


export const AesCryptoServiceProvider: {
    new(): AesCryptoServiceProvider$instance;
};


export interface __AesCryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type AesCryptoServiceProvider = AesCryptoServiceProvider$instance & __AesCryptoServiceProvider$views;


export interface AesGcm$instance {
    readonly TagSizeInBytes: Nullable_1<CLROf<int>>;
    Decrypt(nonce: byte[], ciphertext: byte[], tag: byte[], plaintext: byte[], associatedData?: byte[]): void;
    Decrypt(nonce: ReadOnlySpan_1<CLROf<byte>>, ciphertext: ReadOnlySpan_1<CLROf<byte>>, tag: ReadOnlySpan_1<CLROf<byte>>, plaintext: Span_1<CLROf<byte>>, associatedData?: ReadOnlySpan_1<CLROf<byte>>): void;
    Dispose(): void;
    Encrypt(nonce: byte[], plaintext: byte[], ciphertext: byte[], tag: byte[], associatedData?: byte[]): void;
    Encrypt(nonce: ReadOnlySpan_1<CLROf<byte>>, plaintext: ReadOnlySpan_1<CLROf<byte>>, ciphertext: Span_1<CLROf<byte>>, tag: Span_1<CLROf<byte>>, associatedData?: ReadOnlySpan_1<CLROf<byte>>): void;
}


export const AesGcm: {
    new(key: ReadOnlySpan_1<CLROf<byte>>, tagSizeInBytes: int): AesGcm$instance;
    new(key: byte[], tagSizeInBytes: int): AesGcm$instance;
    new(key: ReadOnlySpan_1<CLROf<byte>>): AesGcm$instance;
    new(key: byte[]): AesGcm$instance;
    readonly NonceByteSizes: KeySizes;
    readonly TagByteSizes: KeySizes;
    readonly IsSupported: boolean;
};


export interface __AesGcm$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface AesGcm$instance extends System_Internal.IDisposable$instance {}

export type AesGcm = AesGcm$instance & __AesGcm$views;


export interface AesManaged$instance extends Aes$instance {
    BlockSize: int;
    FeedbackSize: int;
    IV: byte[];
    Key: byte[];
    KeySize: int;
    readonly LegalBlockSizes: KeySizes[];
    readonly LegalKeySizes: KeySizes[];
    Mode: CipherMode;
    Padding: PaddingMode;
    CreateDecryptor(): ICryptoTransform;
    CreateDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    CreateEncryptor(): ICryptoTransform;
    CreateEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    Dispose(): void;
    GenerateIV(): void;
    GenerateKey(): void;
}


export const AesManaged: {
    new(): AesManaged$instance;
};


export interface __AesManaged$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type AesManaged = AesManaged$instance & __AesManaged$views;


export interface AsnEncodedData$instance {
    Oid: Oid;
    RawData: byte[];
    CopyFrom(asnEncodedData: AsnEncodedData): void;
    Format(multiLine: boolean): string;
}


export const AsnEncodedData: {
    new(rawData: byte[]): AsnEncodedData$instance;
    new(rawData: ReadOnlySpan_1<CLROf<byte>>): AsnEncodedData$instance;
    new(asnEncodedData: AsnEncodedData): AsnEncodedData$instance;
    new(oid: Oid, rawData: byte[]): AsnEncodedData$instance;
    new(oid: string, rawData: byte[]): AsnEncodedData$instance;
    new(oid: Oid, rawData: ReadOnlySpan_1<CLROf<byte>>): AsnEncodedData$instance;
    new(oid: string, rawData: ReadOnlySpan_1<CLROf<byte>>): AsnEncodedData$instance;
};


export type AsnEncodedData = AsnEncodedData$instance;

export interface AsnEncodedDataCollection$instance {
    readonly Count: int;
    readonly IsSynchronized: boolean;
    readonly Item: AsnEncodedData;
    readonly SyncRoot: unknown;
    Add(asnEncodedData: AsnEncodedData): int;
    CopyTo(array: AsnEncodedData[], index: int): void;
    GetEnumerator(): AsnEncodedDataEnumerator;
    Remove(asnEncodedData: AsnEncodedData): void;
}


export const AsnEncodedDataCollection: {
    new(): AsnEncodedDataCollection$instance;
    new(asnEncodedData: AsnEncodedData): AsnEncodedDataCollection$instance;
};


export interface __AsnEncodedDataCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type AsnEncodedDataCollection = AsnEncodedDataCollection$instance & __AsnEncodedDataCollection$views;


export interface AsnEncodedDataEnumerator$instance {
    readonly Current: AsnEncodedData | unknown;
    MoveNext(): boolean;
    Reset(): void;
}


export const AsnEncodedDataEnumerator: {
    new(): AsnEncodedDataEnumerator$instance;
};


export interface __AsnEncodedDataEnumerator$views {
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type AsnEncodedDataEnumerator = AsnEncodedDataEnumerator$instance & __AsnEncodedDataEnumerator$views;


export interface AsymmetricAlgorithm$instance {
    readonly KeyExchangeAlgorithm: string;
    KeySize: int;
    readonly LegalKeySizes: KeySizes[];
    readonly SignatureAlgorithm: string;
    Clear(): void;
    Dispose(): void;
    ExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKeyPem(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): string;
    ExportEncryptedPkcs8PrivateKeyPem(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): string;
    ExportPkcs8PrivateKey(): byte[];
    ExportPkcs8PrivateKeyPem(): string;
    ExportSubjectPublicKeyInfo(): byte[];
    ExportSubjectPublicKeyInfoPem(): string;
    FromXmlString(xmlString: string): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): void;
    ImportFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): void;
    ImportFromPem(input: ReadOnlySpan_1<CLROf<char>>): void;
    ImportPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ToXmlString(includePrivateParameters: boolean): string;
    TryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKeyPem(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKeyPem(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKeyPem(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfoPem(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
}


export const AsymmetricAlgorithm: {
    Create(): AsymmetricAlgorithm;
    Create(algName: string): AsymmetricAlgorithm;
};


export interface __AsymmetricAlgorithm$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface AsymmetricAlgorithm$instance extends System_Internal.IDisposable$instance {}

export type AsymmetricAlgorithm = AsymmetricAlgorithm$instance & __AsymmetricAlgorithm$views;


export interface AsymmetricKeyExchangeDeformatter$instance {
    Parameters: string;
    DecryptKeyExchange(rgb: byte[]): byte[];
    SetKey(key: AsymmetricAlgorithm): void;
}


export const AsymmetricKeyExchangeDeformatter: {
};


export type AsymmetricKeyExchangeDeformatter = AsymmetricKeyExchangeDeformatter$instance;

export interface AsymmetricKeyExchangeFormatter$instance {
    readonly Parameters: string;
    CreateKeyExchange(data: byte[]): byte[];
    CreateKeyExchange(data: byte[], symAlgType: Type): byte[];
    SetKey(key: AsymmetricAlgorithm): void;
}


export const AsymmetricKeyExchangeFormatter: {
};


export type AsymmetricKeyExchangeFormatter = AsymmetricKeyExchangeFormatter$instance;

export interface AsymmetricSignatureDeformatter$instance {
    SetHashAlgorithm(strName: string): void;
    SetKey(key: AsymmetricAlgorithm): void;
    VerifySignature(hash: HashAlgorithm, rgbSignature: byte[]): boolean;
    VerifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
}


export const AsymmetricSignatureDeformatter: {
};


export type AsymmetricSignatureDeformatter = AsymmetricSignatureDeformatter$instance;

export interface AsymmetricSignatureFormatter$instance {
    CreateSignature(hash: HashAlgorithm): byte[];
    CreateSignature(rgbHash: byte[]): byte[];
    SetHashAlgorithm(strName: string): void;
    SetKey(key: AsymmetricAlgorithm): void;
}


export const AsymmetricSignatureFormatter: {
};


export type AsymmetricSignatureFormatter = AsymmetricSignatureFormatter$instance;

export interface AuthenticationTagMismatchException$instance extends CryptographicException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const AuthenticationTagMismatchException: {
    new(): AuthenticationTagMismatchException$instance;
    new(message: string): AuthenticationTagMismatchException$instance;
    new(message: string, inner: Exception): AuthenticationTagMismatchException$instance;
};


export interface __AuthenticationTagMismatchException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type AuthenticationTagMismatchException = AuthenticationTagMismatchException$instance & __AuthenticationTagMismatchException$views;


export interface ChaCha20Poly1305$instance {
    Decrypt(nonce: byte[], ciphertext: byte[], tag: byte[], plaintext: byte[], associatedData?: byte[]): void;
    Decrypt(nonce: ReadOnlySpan_1<CLROf<byte>>, ciphertext: ReadOnlySpan_1<CLROf<byte>>, tag: ReadOnlySpan_1<CLROf<byte>>, plaintext: Span_1<CLROf<byte>>, associatedData?: ReadOnlySpan_1<CLROf<byte>>): void;
    Dispose(): void;
    Encrypt(nonce: byte[], plaintext: byte[], ciphertext: byte[], tag: byte[], associatedData?: byte[]): void;
    Encrypt(nonce: ReadOnlySpan_1<CLROf<byte>>, plaintext: ReadOnlySpan_1<CLROf<byte>>, ciphertext: Span_1<CLROf<byte>>, tag: Span_1<CLROf<byte>>, associatedData?: ReadOnlySpan_1<CLROf<byte>>): void;
}


export const ChaCha20Poly1305: {
    new(key: ReadOnlySpan_1<CLROf<byte>>): ChaCha20Poly1305$instance;
    new(key: byte[]): ChaCha20Poly1305$instance;
    readonly IsSupported: boolean;
};


export interface __ChaCha20Poly1305$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ChaCha20Poly1305$instance extends System_Internal.IDisposable$instance {}

export type ChaCha20Poly1305 = ChaCha20Poly1305$instance & __ChaCha20Poly1305$views;


export interface CngAlgorithm$instance {
    readonly Algorithm: string;
    Equals(obj: unknown): boolean;
    Equals(other: CngAlgorithm): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const CngAlgorithm: {
    new(algorithm: string): CngAlgorithm$instance;
    readonly Rsa: CngAlgorithm;
    readonly ECDiffieHellman: CngAlgorithm;
    readonly ECDiffieHellmanP256: CngAlgorithm;
    readonly ECDiffieHellmanP384: CngAlgorithm;
    readonly ECDiffieHellmanP521: CngAlgorithm;
    readonly ECDsa: CngAlgorithm;
    readonly ECDsaP256: CngAlgorithm;
    readonly ECDsaP384: CngAlgorithm;
    readonly ECDsaP521: CngAlgorithm;
    readonly MD5: CngAlgorithm;
    readonly Sha1: CngAlgorithm;
    readonly Sha256: CngAlgorithm;
    readonly Sha384: CngAlgorithm;
    readonly Sha512: CngAlgorithm;
    readonly MLDsa: CngAlgorithm;
    readonly MLKem: CngAlgorithm;
    readonly SlhDsa: CngAlgorithm;
};


export interface __CngAlgorithm$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CngAlgorithm>;

    // Structural method bridges for numeric interface constraints
    equals(other: CngAlgorithm): boolean;
}

export type CngAlgorithm = CngAlgorithm$instance & __CngAlgorithm$views;


export interface CngAlgorithmGroup$instance {
    readonly AlgorithmGroup: string;
    Equals(obj: unknown): boolean;
    Equals(other: CngAlgorithmGroup): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const CngAlgorithmGroup: {
    new(algorithmGroup: string): CngAlgorithmGroup$instance;
    readonly DiffieHellman: CngAlgorithmGroup;
    readonly Dsa: CngAlgorithmGroup;
    readonly ECDiffieHellman: CngAlgorithmGroup;
    readonly ECDsa: CngAlgorithmGroup;
    readonly Rsa: CngAlgorithmGroup;
    readonly MLDsa: CngAlgorithmGroup;
    readonly MLKem: CngAlgorithmGroup;
    readonly SlhDsa: CngAlgorithmGroup;
};


export interface __CngAlgorithmGroup$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CngAlgorithmGroup>;

    // Structural method bridges for numeric interface constraints
    equals(other: CngAlgorithmGroup): boolean;
}

export type CngAlgorithmGroup = CngAlgorithmGroup$instance & __CngAlgorithmGroup$views;


export interface CngKey$instance {
    readonly Algorithm: CngAlgorithm;
    readonly AlgorithmGroup: CngAlgorithmGroup;
    readonly ExportPolicy: CngExportPolicies;
    readonly Handle: SafeNCryptKeyHandle;
    readonly IsEphemeral: boolean;
    readonly IsMachineKey: boolean;
    readonly KeyName: string;
    readonly KeySize: int;
    readonly KeyUsage: CngKeyUsages;
    ParentWindowHandle: nint;
    readonly Provider: CngProvider;
    readonly ProviderHandle: SafeNCryptProviderHandle;
    readonly UIPolicy: CngUIPolicy;
    readonly UniqueName: string;
    Delete(): void;
    Dispose(): void;
    Export(format: CngKeyBlobFormat): byte[];
    GetProperty(name: string, options: CngPropertyOptions): CngProperty;
    HasProperty(name: string, options: CngPropertyOptions): boolean;
    SetProperty(property: CngProperty): void;
}


export const CngKey: {
    new(): CngKey$instance;
    Create(algorithm: CngAlgorithm, keyName: string, creationParameters: CngKeyCreationParameters): CngKey;
    Create(algorithm: CngAlgorithm, keyName: string): CngKey;
    Create(algorithm: CngAlgorithm): CngKey;
    Exists(keyName: string, provider: CngProvider, options: CngKeyOpenOptions): boolean;
    Exists(keyName: string, provider: CngProvider): boolean;
    Exists(keyName: string): boolean;
    Import(keyBlob: byte[], format: CngKeyBlobFormat, provider: CngProvider): CngKey;
    Import(keyBlob: byte[], format: CngKeyBlobFormat): CngKey;
    Open(keyHandle: SafeNCryptKeyHandle, keyHandleOpenOptions: CngKeyHandleOpenOptions): CngKey;
    Open(keyName: string, provider: CngProvider, openOptions: CngKeyOpenOptions): CngKey;
    Open(keyName: string, provider: CngProvider): CngKey;
    Open(keyName: string): CngKey;
};


export interface __CngKey$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface CngKey$instance extends System_Internal.IDisposable$instance {}

export type CngKey = CngKey$instance & __CngKey$views;


export interface CngKeyBlobFormat$instance {
    readonly Format: string;
    Equals(obj: unknown): boolean;
    Equals(other: CngKeyBlobFormat): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const CngKeyBlobFormat: {
    new(format: string): CngKeyBlobFormat$instance;
    readonly EccPrivateBlob: CngKeyBlobFormat;
    readonly EccPublicBlob: CngKeyBlobFormat;
    readonly EccFullPrivateBlob: CngKeyBlobFormat;
    readonly EccFullPublicBlob: CngKeyBlobFormat;
    readonly GenericPrivateBlob: CngKeyBlobFormat;
    readonly GenericPublicBlob: CngKeyBlobFormat;
    readonly PQDsaPublicBlob: CngKeyBlobFormat;
    readonly PQDsaPrivateBlob: CngKeyBlobFormat;
    readonly PQDsaPrivateSeedBlob: CngKeyBlobFormat;
    readonly MLKemPublicBlob: CngKeyBlobFormat;
    readonly MLKemPrivateBlob: CngKeyBlobFormat;
    readonly MLKemPrivateSeedBlob: CngKeyBlobFormat;
    readonly OpaqueTransportBlob: CngKeyBlobFormat;
    readonly Pkcs8PrivateBlob: CngKeyBlobFormat;
};


export interface __CngKeyBlobFormat$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CngKeyBlobFormat>;

    // Structural method bridges for numeric interface constraints
    equals(other: CngKeyBlobFormat): boolean;
}

export type CngKeyBlobFormat = CngKeyBlobFormat$instance & __CngKeyBlobFormat$views;


export interface CngKeyCreationParameters$instance {
    ExportPolicy: Nullable_1<CngExportPolicies>;
    KeyCreationOptions: CngKeyCreationOptions;
    KeyUsage: Nullable_1<CngKeyUsages>;
    readonly Parameters: CngPropertyCollection;
    ParentWindowHandle: nint;
    Provider: CngProvider;
    UIPolicy: CngUIPolicy;
}


export const CngKeyCreationParameters: {
    new(): CngKeyCreationParameters$instance;
};


export type CngKeyCreationParameters = CngKeyCreationParameters$instance;

export interface CngPropertyCollection$instance extends Collection_1<CngProperty> {
    Add(item: CngProperty): void;
    Add(value: unknown): int;
    Clear(): void;
    Contains(item: CngProperty): boolean;
    Contains(value: unknown): boolean;
    CopyTo(array: CngProperty[], index: int): void;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator_1<CngProperty>;
    GetEnumerator(): IEnumerator;
    IndexOf(item: CngProperty): int;
    Insert(index: int, item: CngProperty): void;
    Insert(index: int, value: unknown): void;
    Remove(item: CngProperty): boolean;
    Remove(value: unknown): void;
    RemoveAt(index: int): void;
}


export const CngPropertyCollection: {
    new(): CngPropertyCollection$instance;
};


export interface __CngPropertyCollection$views {
    As_ICollection_1(): System_Collections_Generic_Internal.ICollection_1$instance<CngProperty>;
    As_IEnumerable_1(): System_Collections_Generic_Internal.IEnumerable_1$instance<CngProperty>;
    As_IList_1(): System_Collections_Generic_Internal.IList_1$instance<CngProperty>;
    As_IReadOnlyCollection_1(): System_Collections_Generic_Internal.IReadOnlyCollection_1$instance<CngProperty>;
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
    As_IList(): System_Collections_Internal.IList$instance;
}

export type CngPropertyCollection = CngPropertyCollection$instance & __CngPropertyCollection$views;


export interface CngProvider$instance {
    readonly Provider: string;
    Equals(obj: unknown): boolean;
    Equals(other: CngProvider): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const CngProvider: {
    new(provider: string): CngProvider$instance;
    readonly MicrosoftPlatformCryptoProvider: CngProvider;
    readonly MicrosoftSmartCardKeyStorageProvider: CngProvider;
    readonly MicrosoftSoftwareKeyStorageProvider: CngProvider;
};


export interface __CngProvider$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CngProvider>;

    // Structural method bridges for numeric interface constraints
    equals(other: CngProvider): boolean;
}

export type CngProvider = CngProvider$instance & __CngProvider$views;


export interface CngUIPolicy$instance {
    readonly CreationTitle: string;
    readonly Description: string;
    readonly FriendlyName: string;
    readonly ProtectionLevel: CngUIProtectionLevels;
    readonly UseContext: string;
}


export const CngUIPolicy: {
    new(protectionLevel: CngUIProtectionLevels): CngUIPolicy$instance;
    new(protectionLevel: CngUIProtectionLevels, friendlyName: string): CngUIPolicy$instance;
    new(protectionLevel: CngUIProtectionLevels, friendlyName: string, description: string): CngUIPolicy$instance;
    new(protectionLevel: CngUIProtectionLevels, friendlyName: string, description: string, useContext: string): CngUIPolicy$instance;
    new(protectionLevel: CngUIProtectionLevels, friendlyName: string, description: string, useContext: string, creationTitle: string): CngUIPolicy$instance;
};


export type CngUIPolicy = CngUIPolicy$instance;

export interface CompositeMLDsa$instance {
    readonly Algorithm: CompositeMLDsaAlgorithm;
    Dispose(): void;
    ExportCompositeMLDsaPrivateKey(): byte[];
    ExportCompositeMLDsaPrivateKey(destination: Span_1<CLROf<byte>>): int;
    ExportCompositeMLDsaPublicKey(): byte[];
    ExportCompositeMLDsaPublicKey(destination: Span_1<CLROf<byte>>): int;
    ExportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKeyPem(password: string, pbeParameters: PbeParameters): string;
    ExportEncryptedPkcs8PrivateKeyPem(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): string;
    ExportEncryptedPkcs8PrivateKeyPem(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): string;
    ExportPkcs8PrivateKey(): byte[];
    ExportPkcs8PrivateKeyPem(): string;
    ExportSubjectPublicKeyInfo(): byte[];
    ExportSubjectPublicKeyInfoPem(): string;
    SignData(data: byte[], context?: byte[]): byte[];
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, context?: ReadOnlySpan_1<CLROf<byte>>): int;
    TryExportCompositeMLDsaPrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportCompositeMLDsaPublicKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    VerifyData(data: byte[], signature: byte[], context?: byte[]): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, context?: ReadOnlySpan_1<CLROf<byte>>): boolean;
}


export const CompositeMLDsa: {
    readonly IsSupported: boolean;
    GenerateKey(algorithm: CompositeMLDsaAlgorithm): CompositeMLDsa;
    ImportCompositeMLDsaPrivateKey(algorithm: CompositeMLDsaAlgorithm, source: byte[]): CompositeMLDsa;
    ImportCompositeMLDsaPrivateKey(algorithm: CompositeMLDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    ImportCompositeMLDsaPublicKey(algorithm: CompositeMLDsaAlgorithm, source: byte[]): CompositeMLDsa;
    ImportCompositeMLDsaPublicKey(algorithm: CompositeMLDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    ImportEncryptedPkcs8PrivateKey(password: string, source: byte[]): CompositeMLDsa;
    ImportFromEncryptedPem(source: ReadOnlySpan_1<CLROf<char>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    ImportFromEncryptedPem(source: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): CompositeMLDsa;
    ImportFromEncryptedPem(source: string, passwordBytes: byte[]): CompositeMLDsa;
    ImportFromEncryptedPem(source: string, password: string): CompositeMLDsa;
    ImportFromPem(source: ReadOnlySpan_1<CLROf<char>>): CompositeMLDsa;
    ImportFromPem(source: string): CompositeMLDsa;
    ImportPkcs8PrivateKey(source: byte[]): CompositeMLDsa;
    ImportPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    ImportSubjectPublicKeyInfo(source: byte[]): CompositeMLDsa;
    ImportSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>): CompositeMLDsa;
    IsAlgorithmSupported(algorithm: CompositeMLDsaAlgorithm): boolean;
};


export interface __CompositeMLDsa$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface CompositeMLDsa$instance extends System_Internal.IDisposable$instance {}

export type CompositeMLDsa = CompositeMLDsa$instance & __CompositeMLDsa$views;


export interface CompositeMLDsaAlgorithm$instance {
    readonly MaxSignatureSizeInBytes: int;
    readonly Name: string;
    Equals(other: CompositeMLDsaAlgorithm): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const CompositeMLDsaAlgorithm: {
    new(): CompositeMLDsaAlgorithm$instance;
    readonly MLDsa44WithRSA2048Pss: CompositeMLDsaAlgorithm;
    readonly MLDsa44WithRSA2048Pkcs15: CompositeMLDsaAlgorithm;
    readonly MLDsa44WithEd25519: CompositeMLDsaAlgorithm;
    readonly MLDsa44WithECDsaP256: CompositeMLDsaAlgorithm;
    readonly MLDsa65WithRSA3072Pss: CompositeMLDsaAlgorithm;
    readonly MLDsa65WithRSA3072Pkcs15: CompositeMLDsaAlgorithm;
    readonly MLDsa65WithRSA4096Pss: CompositeMLDsaAlgorithm;
    readonly MLDsa65WithRSA4096Pkcs15: CompositeMLDsaAlgorithm;
    readonly MLDsa65WithECDsaP256: CompositeMLDsaAlgorithm;
    readonly MLDsa65WithECDsaP384: CompositeMLDsaAlgorithm;
    readonly MLDsa65WithECDsaBrainpoolP256r1: CompositeMLDsaAlgorithm;
    readonly MLDsa65WithEd25519: CompositeMLDsaAlgorithm;
    readonly MLDsa87WithECDsaP384: CompositeMLDsaAlgorithm;
    readonly MLDsa87WithECDsaBrainpoolP384r1: CompositeMLDsaAlgorithm;
    readonly MLDsa87WithEd448: CompositeMLDsaAlgorithm;
    readonly MLDsa87WithRSA3072Pss: CompositeMLDsaAlgorithm;
    readonly MLDsa87WithRSA4096Pss: CompositeMLDsaAlgorithm;
    readonly MLDsa87WithECDsaP521: CompositeMLDsaAlgorithm;
};


export interface __CompositeMLDsaAlgorithm$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<CompositeMLDsaAlgorithm>;

    // Structural method bridges for numeric interface constraints
    equals(other: CompositeMLDsaAlgorithm): boolean;
}

export type CompositeMLDsaAlgorithm = CompositeMLDsaAlgorithm$instance & __CompositeMLDsaAlgorithm$views;


export interface CompositeMLDsaCng$instance extends CompositeMLDsa$instance {
    Dispose(): void;
    GetKey(): CngKey;
}


export const CompositeMLDsaCng: {
    new(key: CngKey): CompositeMLDsaCng$instance;
};


export interface __CompositeMLDsaCng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type CompositeMLDsaCng = CompositeMLDsaCng$instance & __CompositeMLDsaCng$views;


export interface CryptoConfig$instance {
}


export const CryptoConfig: {
    new(): CryptoConfig$instance;
    readonly AllowOnlyFipsAlgorithms: boolean;
    AddAlgorithm(algorithm: Type, ...names: string[]): void;
    AddOID(oid: string, ...names: string[]): void;
    CreateFromName(name: string, ...args: unknown[]): unknown;
    CreateFromName(name: string): unknown;
    EncodeOID(str: string): byte[];
    MapNameToOID(name: string): string;
};


export type CryptoConfig = CryptoConfig$instance;

export interface CryptographicException$instance extends SystemException {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const CryptographicException: {
    new(): CryptographicException$instance;
    new(hr: int): CryptographicException$instance;
    new(message: string): CryptographicException$instance;
    new(message: string, inner: Exception): CryptographicException$instance;
    new(format: string, insert: string): CryptographicException$instance;
};


export interface __CryptographicException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type CryptographicException = CryptographicException$instance & __CryptographicException$views;


export interface CryptographicUnexpectedOperationException$instance extends CryptographicException$instance {
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const CryptographicUnexpectedOperationException: {
    new(): CryptographicUnexpectedOperationException$instance;
    new(message: string): CryptographicUnexpectedOperationException$instance;
    new(message: string, inner: Exception): CryptographicUnexpectedOperationException$instance;
    new(format: string, insert: string): CryptographicUnexpectedOperationException$instance;
};


export interface __CryptographicUnexpectedOperationException$views {
    As_ISerializable(): System_Runtime_Serialization_Internal.ISerializable$instance;
}

export type CryptographicUnexpectedOperationException = CryptographicUnexpectedOperationException$instance & __CryptographicUnexpectedOperationException$views;


export interface CryptoStream$instance extends Stream {
    readonly CanRead: boolean;
    readonly CanSeek: boolean;
    readonly CanWrite: boolean;
    readonly HasFlushedFinalBlock: boolean;
    readonly Length: long;
    Position: long;
    BeginRead(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    BeginWrite(buffer: byte[], offset: int, count: int, callback: AsyncCallback, state: unknown): IAsyncResult;
    Clear(): void;
    CopyTo(destination: Stream, bufferSize: int): void;
    CopyTo(destination: Stream): void;
    CopyToAsync(destination: Stream, bufferSize: int, cancellationToken: CancellationToken): Task;
    CopyToAsync(destination: Stream): Task;
    CopyToAsync(destination: Stream, bufferSize: int): Task;
    CopyToAsync(destination: Stream, cancellationToken: CancellationToken): Task;
    Dispose(): void;
    DisposeAsync(): ValueTask;
    EndRead(asyncResult: IAsyncResult): int;
    EndWrite(asyncResult: IAsyncResult): void;
    Flush(): void;
    FlushAsync(cancellationToken: CancellationToken): Task;
    FlushAsync(): Task;
    FlushFinalBlock(): void;
    FlushFinalBlockAsync(cancellationToken?: CancellationToken): ValueTask;
    Read(buffer: byte[], offset: int, count: int): int;
    Read(buffer: Span_1<CLROf<byte>>): int;
    ReadAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    ReadAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadAsync(buffer: byte[], offset: int, count: int): Task_1<CLROf<int>>;
    ReadAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task_1<CLROf<int>>;
    ReadAsync(buffer: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    ReadByte(): int;
    Seek(offset: long, origin: SeekOrigin): long;
    SetLength(value: long): void;
    Write(buffer: byte[], offset: int, count: int): void;
    Write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    Write(buffer: ReadOnlySpan_1<CLROf<byte>>): void;
    WriteAsync(buffer: byte[], offset: int, count: int, cancellationToken: CancellationToken): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    WriteAsync(buffer: byte[], offset: int, count: int): Task;
    WriteAsync(buffer: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
    WriteByte(value: byte): void;
}


export const CryptoStream: {
    new(stream: Stream, transform: ICryptoTransform, mode: CryptoStreamMode): CryptoStream$instance;
    new(stream: Stream, transform: ICryptoTransform, mode: CryptoStreamMode, leaveOpen: boolean): CryptoStream$instance;
};


export interface __CryptoStream$views {
    As_IAsyncDisposable(): System_Internal.IAsyncDisposable$instance;
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type CryptoStream = CryptoStream$instance & __CryptoStream$views;


export interface CspKeyContainerInfo$instance {
    readonly Accessible: boolean;
    readonly Exportable: boolean;
    readonly HardwareDevice: boolean;
    readonly KeyContainerName: string;
    readonly KeyNumber: KeyNumber;
    readonly MachineKeyStore: boolean;
    readonly Protected: boolean;
    readonly ProviderName: string;
    readonly ProviderType: int;
    readonly RandomlyGenerated: boolean;
    readonly Removable: boolean;
    readonly UniqueKeyContainerName: string;
}


export const CspKeyContainerInfo: {
    new(parameters: CspParameters): CspKeyContainerInfo$instance;
};


export type CspKeyContainerInfo = CspKeyContainerInfo$instance;

export interface CspParameters$instance {
    ProviderType: int;
    ProviderName: string;
    KeyContainerName: string;
    KeyNumber: int;
    Flags: CspProviderFlags;
    KeyPassword: SecureString;
    ParentWindowHandle: nint;
}


export const CspParameters: {
    new(): CspParameters$instance;
    new(dwTypeIn: int): CspParameters$instance;
    new(dwTypeIn: int, strProviderNameIn: string): CspParameters$instance;
    new(dwTypeIn: int, strProviderNameIn: string, strContainerNameIn: string): CspParameters$instance;
};


export type CspParameters = CspParameters$instance;

export interface DeriveBytes$instance {
    Dispose(): void;
    GetBytes(cb: int): byte[];
    Reset(): void;
}


export const DeriveBytes: {
};


export interface __DeriveBytes$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface DeriveBytes$instance extends System_Internal.IDisposable$instance {}

export type DeriveBytes = DeriveBytes$instance & __DeriveBytes$views;


export interface DES$instance extends SymmetricAlgorithm$instance {
    Key: byte[];
    Dispose(): void;
}


export const DES: {
    IsSemiWeakKey(rgbKey: byte[]): boolean;
    IsWeakKey(rgbKey: byte[]): boolean;
};


export interface __DES$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type DES = DES$instance & __DES$views;


export interface DESCryptoServiceProvider$instance extends DES$instance {
    BlockSize: int;
    FeedbackSize: int;
    IV: byte[];
    Key: byte[];
    KeySize: int;
    readonly LegalBlockSizes: KeySizes[];
    readonly LegalKeySizes: KeySizes[];
    Mode: CipherMode;
    Padding: PaddingMode;
    CreateDecryptor(): ICryptoTransform;
    CreateDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    CreateEncryptor(): ICryptoTransform;
    CreateEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    Dispose(): void;
    GenerateIV(): void;
    GenerateKey(): void;
}


export const DESCryptoServiceProvider: {
    new(): DESCryptoServiceProvider$instance;
};


export interface __DESCryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type DESCryptoServiceProvider = DESCryptoServiceProvider$instance & __DESCryptoServiceProvider$views;


export interface DSA$instance extends AsymmetricAlgorithm$instance {
    CreateSignature(rgbHash: byte[]): byte[];
    CreateSignature(rgbHash: byte[], signatureFormat: DSASignatureFormat): byte[];
    Dispose(): void;
    ExportParameters(includePrivateParameters: boolean): DSAParameters;
    FromXmlString(xmlString: string): void;
    GetMaxSignatureSize(signatureFormat: DSASignatureFormat): int;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): void;
    ImportFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): void;
    ImportFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): void;
    ImportFromPem(input: ReadOnlySpan_1<CLROf<char>>): void;
    ImportFromPem(input: ReadOnlySpan_1<CLROf<char>>): void;
    ImportParameters(parameters: DSAParameters): void;
    ImportPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    SignData(data: byte[], hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    SignData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    SignData(data: Stream, hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: Stream, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    ToXmlString(includePrivateParameters: boolean): string;
    TryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TrySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, bytesWritten: { value: ref<int> }): boolean;
    TrySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    VerifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
    VerifySignature(rgbHash: byte[], rgbSignature: byte[], signatureFormat: DSASignatureFormat): boolean;
    VerifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
}


export const DSA: {
    Create(parameters: DSAParameters): DSA;
    Create(algName: string): DSA;
};


export interface __DSA$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type DSA = DSA$instance & __DSA$views;


export interface DSACng$instance extends DSA$instance {
    readonly Key: CngKey;
    CreateSignature(rgbHash: byte[]): byte[];
    CreateSignature(rgbHash: byte[], signatureFormat: DSASignatureFormat): byte[];
    Dispose(): void;
    ExportParameters(includePrivateParameters: boolean): DSAParameters;
    ImportParameters(parameters: DSAParameters): void;
    VerifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
    VerifySignature(rgbHash: byte[], rgbSignature: byte[], signatureFormat: DSASignatureFormat): boolean;
    VerifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
}


export const DSACng: {
    new(): DSACng$instance;
    new(keySize: int): DSACng$instance;
    new(key: CngKey): DSACng$instance;
};


export interface __DSACng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type DSACng = DSACng$instance & __DSACng$views;


export interface DSACryptoServiceProvider$instance extends DSA$instance {
    readonly CspKeyContainerInfo: CspKeyContainerInfo;
    readonly KeyExchangeAlgorithm: string;
    KeySize: int;
    readonly LegalKeySizes: KeySizes[];
    PersistKeyInCsp: boolean;
    readonly PublicOnly: boolean;
    readonly SignatureAlgorithm: string;
    CreateSignature(rgbHash: byte[]): byte[];
    CreateSignature(rgbHash: byte[], signatureFormat: DSASignatureFormat): byte[];
    Dispose(): void;
    ExportCspBlob(includePrivateParameters: boolean): byte[];
    ExportParameters(includePrivateParameters: boolean): DSAParameters;
    FromXmlString(xmlString: string): void;
    ImportCspBlob(keyBlob: byte[]): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportParameters(parameters: DSAParameters): void;
    SignData(inputStream: Stream): byte[];
    SignData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: Stream, hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: byte[], hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    SignData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    SignData(data: Stream, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    SignHash(rgbHash: byte[], str: string): byte[];
    ToXmlString(includePrivateParameters: boolean): string;
    TryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    TrySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, bytesWritten: { value: ref<int> }): boolean;
    TrySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, bytesWritten: { value: ref<int> }): boolean;
    TrySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    VerifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyHash(rgbHash: byte[], str: string, rgbSignature: byte[]): boolean;
    VerifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
    VerifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifySignature(rgbHash: byte[], rgbSignature: byte[], signatureFormat: DSASignatureFormat): boolean;
    VerifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
}


export const DSACryptoServiceProvider: {
    new(): DSACryptoServiceProvider$instance;
    new(dwKeySize: int): DSACryptoServiceProvider$instance;
    new(dwKeySize: int, parameters: CspParameters): DSACryptoServiceProvider$instance;
    new(parameters: CspParameters): DSACryptoServiceProvider$instance;
    UseMachineKeyStore: boolean;
};


export interface __DSACryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICspAsymmetricAlgorithm(): ICspAsymmetricAlgorithm$instance;
}

export interface DSACryptoServiceProvider$instance extends ICspAsymmetricAlgorithm$instance {}

export type DSACryptoServiceProvider = DSACryptoServiceProvider$instance & __DSACryptoServiceProvider$views;


export interface DSAOpenSsl$instance extends DSA$instance {
    KeySize: int;
    readonly LegalKeySizes: KeySizes[];
    CreateSignature(rgbHash: byte[]): byte[];
    CreateSignature(rgbHash: byte[], signatureFormat: DSASignatureFormat): byte[];
    Dispose(): void;
    DuplicateKeyHandle(): SafeEvpPKeyHandle;
    ExportParameters(includePrivateParameters: boolean): DSAParameters;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportParameters(parameters: DSAParameters): void;
    TryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryCreateSignature(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    VerifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
    VerifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifySignature(rgbHash: byte[], rgbSignature: byte[], signatureFormat: DSASignatureFormat): boolean;
    VerifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifySignature(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
}


export const DSAOpenSsl: {
    new(): DSAOpenSsl$instance;
    new(keySize: int): DSAOpenSsl$instance;
    new(parameters: DSAParameters): DSAOpenSsl$instance;
    new(pkeyHandle: SafeEvpPKeyHandle): DSAOpenSsl$instance;
    new(handle: nint): DSAOpenSsl$instance;
};


export interface __DSAOpenSsl$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type DSAOpenSsl = DSAOpenSsl$instance & __DSAOpenSsl$views;


export interface DSASignatureDeformatter$instance extends AsymmetricSignatureDeformatter {
    SetHashAlgorithm(strName: string): void;
    SetKey(key: AsymmetricAlgorithm): void;
    VerifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
    VerifySignature(hash: HashAlgorithm, rgbSignature: byte[]): boolean;
}


export const DSASignatureDeformatter: {
    new(): DSASignatureDeformatter$instance;
    new(key: AsymmetricAlgorithm): DSASignatureDeformatter$instance;
};


export type DSASignatureDeformatter = DSASignatureDeformatter$instance;

export interface DSASignatureFormatter$instance extends AsymmetricSignatureFormatter {
    CreateSignature(rgbHash: byte[]): byte[];
    CreateSignature(hash: HashAlgorithm): byte[];
    SetHashAlgorithm(strName: string): void;
    SetKey(key: AsymmetricAlgorithm): void;
}


export const DSASignatureFormatter: {
    new(): DSASignatureFormatter$instance;
    new(key: AsymmetricAlgorithm): DSASignatureFormatter$instance;
};


export type DSASignatureFormatter = DSASignatureFormatter$instance;

export interface ECAlgorithm$instance extends AsymmetricAlgorithm$instance {
    Dispose(): void;
    ExportECPrivateKey(): byte[];
    ExportECPrivateKeyPem(): string;
    ExportExplicitParameters(includePrivateParameters: boolean): ECParameters;
    ExportParameters(includePrivateParameters: boolean): ECParameters;
    GenerateKey(curve: ECCurve): void;
    ImportECPrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): void;
    ImportFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): void;
    ImportFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): void;
    ImportFromPem(input: ReadOnlySpan_1<CLROf<char>>): void;
    ImportFromPem(input: ReadOnlySpan_1<CLROf<char>>): void;
    ImportParameters(parameters: ECParameters): void;
    ImportPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    TryExportECPrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportECPrivateKeyPem(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export const ECAlgorithm: {
};


export interface __ECAlgorithm$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ECAlgorithm = ECAlgorithm$instance & __ECAlgorithm$views;


export interface ECDiffieHellman$instance extends ECAlgorithm$instance {
    readonly KeyExchangeAlgorithm: string;
    readonly PublicKey: ECDiffieHellmanPublicKey;
    readonly SignatureAlgorithm: string;
    DeriveKeyFromHash(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName): byte[];
    DeriveKeyFromHash(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, secretPrepend: byte[], secretAppend: byte[]): byte[];
    DeriveKeyFromHmac(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, hmacKey: byte[]): byte[];
    DeriveKeyFromHmac(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, hmacKey: byte[], secretPrepend: byte[], secretAppend: byte[]): byte[];
    DeriveKeyMaterial(otherPartyPublicKey: ECDiffieHellmanPublicKey): byte[];
    DeriveKeyTls(otherPartyPublicKey: ECDiffieHellmanPublicKey, prfLabel: byte[], prfSeed: byte[]): byte[];
    DeriveRawSecretAgreement(otherPartyPublicKey: ECDiffieHellmanPublicKey): byte[];
    Dispose(): void;
    FromXmlString(xmlString: string): void;
    ToXmlString(includePrivateParameters: boolean): string;
}


export const ECDiffieHellman: {
    Create(): ECDiffieHellman;
    Create(curve: ECCurve): ECDiffieHellman;
    Create(parameters: ECParameters): ECDiffieHellman;
    Create(algorithm: string): ECDiffieHellman;
};


export interface __ECDiffieHellman$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ECDiffieHellman = ECDiffieHellman$instance & __ECDiffieHellman$views;


export interface ECDiffieHellmanCng$instance extends ECDiffieHellman$instance {
    HashAlgorithm: CngAlgorithm;
    HmacKey: byte[];
    readonly Key: CngKey;
    KeyDerivationFunction: ECDiffieHellmanKeyDerivationFunction;
    Label: byte[];
    readonly PublicKey: ECDiffieHellmanPublicKey;
    SecretAppend: byte[];
    SecretPrepend: byte[];
    Seed: byte[];
    readonly UseSecretAgreementAsHmacKey: boolean;
    DeriveKeyMaterial(otherPartyPublicKey: ECDiffieHellmanPublicKey): byte[];
    DeriveSecretAgreementHandle(otherPartyPublicKey: CngKey): SafeNCryptSecretHandle;
    DeriveSecretAgreementHandle(otherPartyPublicKey: ECDiffieHellmanPublicKey): SafeNCryptSecretHandle;
    Dispose(): void;
    FromXmlString(xmlString: string): void;
    ToXmlString(includePrivateParameters: boolean): string;
}


export const ECDiffieHellmanCng: {
    new(): ECDiffieHellmanCng$instance;
    new(keySize: int): ECDiffieHellmanCng$instance;
    new(key: CngKey): ECDiffieHellmanCng$instance;
    new(curve: ECCurve): ECDiffieHellmanCng$instance;
};


export interface __ECDiffieHellmanCng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ECDiffieHellmanCng = ECDiffieHellmanCng$instance & __ECDiffieHellmanCng$views;


export interface ECDiffieHellmanCngPublicKey$instance extends ECDiffieHellmanPublicKey$instance {
    readonly BlobFormat: CngKeyBlobFormat;
    Dispose(): void;
    Import(): CngKey;
    ToXmlString(): string;
}


export const ECDiffieHellmanCngPublicKey: {
    new(): ECDiffieHellmanCngPublicKey$instance;
    FromByteArray(publicKeyBlob: byte[], format: CngKeyBlobFormat): ECDiffieHellmanPublicKey;
    FromXmlString(xml: string): ECDiffieHellmanCngPublicKey;
};


export interface __ECDiffieHellmanCngPublicKey$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ECDiffieHellmanCngPublicKey = ECDiffieHellmanCngPublicKey$instance & __ECDiffieHellmanCngPublicKey$views;


export interface ECDiffieHellmanOpenSsl$instance extends ECDiffieHellman$instance {
    KeySize: int;
    readonly LegalKeySizes: KeySizes[];
    readonly PublicKey: ECDiffieHellmanPublicKey;
    DeriveKeyFromHash(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, secretPrepend: byte[], secretAppend: byte[]): byte[];
    DeriveKeyFromHash(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName): byte[];
    DeriveKeyFromHmac(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, hmacKey: byte[], secretPrepend: byte[], secretAppend: byte[]): byte[];
    DeriveKeyFromHmac(otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, hmacKey: byte[]): byte[];
    DeriveKeyMaterial(otherPartyPublicKey: ECDiffieHellmanPublicKey): byte[];
    DeriveKeyTls(otherPartyPublicKey: ECDiffieHellmanPublicKey, prfLabel: byte[], prfSeed: byte[]): byte[];
    DeriveRawSecretAgreement(otherPartyPublicKey: ECDiffieHellmanPublicKey): byte[];
    Dispose(): void;
    DuplicateKeyHandle(): SafeEvpPKeyHandle;
    ExportExplicitParameters(includePrivateParameters: boolean): ECParameters;
    ExportParameters(includePrivateParameters: boolean): ECParameters;
    GenerateKey(curve: ECCurve): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportParameters(parameters: ECParameters): void;
}


export const ECDiffieHellmanOpenSsl: {
    new(curve: ECCurve): ECDiffieHellmanOpenSsl$instance;
    new(): ECDiffieHellmanOpenSsl$instance;
    new(keySize: int): ECDiffieHellmanOpenSsl$instance;
    new(pkeyHandle: SafeEvpPKeyHandle): ECDiffieHellmanOpenSsl$instance;
    new(handle: nint): ECDiffieHellmanOpenSsl$instance;
};


export interface __ECDiffieHellmanOpenSsl$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ECDiffieHellmanOpenSsl = ECDiffieHellmanOpenSsl$instance & __ECDiffieHellmanOpenSsl$views;


export interface ECDiffieHellmanPublicKey$instance {
    Dispose(): void;
    ExportExplicitParameters(): ECParameters;
    ExportParameters(): ECParameters;
    ExportSubjectPublicKeyInfo(): byte[];
    ToByteArray(): byte[];
    ToXmlString(): string;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export const ECDiffieHellmanPublicKey: {
};


export interface __ECDiffieHellmanPublicKey$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface ECDiffieHellmanPublicKey$instance extends System_Internal.IDisposable$instance {}

export type ECDiffieHellmanPublicKey = ECDiffieHellmanPublicKey$instance & __ECDiffieHellmanPublicKey$views;


export interface ECDsa$instance extends ECAlgorithm$instance {
    readonly KeyExchangeAlgorithm: string;
    readonly SignatureAlgorithm: string;
    Dispose(): void;
    FromXmlString(xmlString: string): void;
    GetMaxSignatureSize(signatureFormat: DSASignatureFormat): int;
    SignData(data: byte[], hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    SignData(data: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    SignData(data: Stream, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    SignData(data: Stream, hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): int;
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): int;
    SignHash(hash: byte[], signatureFormat: DSASignatureFormat): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): int;
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    SignHash(hash: byte[]): byte[];
    ToXmlString(includePrivateParameters: boolean): string;
    TrySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, bytesWritten: { value: ref<int> }): boolean;
    TrySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    TrySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TrySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    VerifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyHash(hash: byte[], signature: byte[]): boolean;
    VerifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifyHash(hash: byte[], signature: byte[], signatureFormat: DSASignatureFormat): boolean;
    VerifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
}


export const ECDsa: {
    Create(): ECDsa;
    Create(curve: ECCurve): ECDsa;
    Create(parameters: ECParameters): ECDsa;
    Create(algorithm: string): ECDsa;
};


export interface __ECDsa$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ECDsa = ECDsa$instance & __ECDsa$views;


export interface ECDsaCng$instance extends ECDsa$instance {
    HashAlgorithm: CngAlgorithm;
    readonly Key: CngKey;
    Dispose(): void;
    FromXmlString(xmlString: string): void;
    SignData(data: Stream): byte[];
    SignData(data: byte[], hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    SignData(data: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    SignData(data: Stream, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    SignData(data: Stream, hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): byte[];
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): byte[];
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): int;
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): int;
    SignHash(hash: byte[]): byte[];
    SignHash(hash: byte[], signatureFormat: DSASignatureFormat): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): int;
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    ToXmlString(includePrivateParameters: boolean): string;
    VerifyData(data: Stream, signature: byte[]): boolean;
    VerifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName): boolean;
    VerifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat): boolean;
    VerifyHash(hash: byte[], signature: byte[]): boolean;
    VerifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifyHash(hash: byte[], signature: byte[], signatureFormat: DSASignatureFormat): boolean;
    VerifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
}


export const ECDsaCng: {
    new(): ECDsaCng$instance;
    new(keySize: int): ECDsaCng$instance;
    new(key: CngKey): ECDsaCng$instance;
    new(curve: ECCurve): ECDsaCng$instance;
};


export interface __ECDsaCng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ECDsaCng = ECDsaCng$instance & __ECDsaCng$views;


export interface ECDsaOpenSsl$instance extends ECDsa$instance {
    KeySize: int;
    readonly LegalKeySizes: KeySizes[];
    Dispose(): void;
    DuplicateKeyHandle(): SafeEvpPKeyHandle;
    ExportExplicitParameters(includePrivateParameters: boolean): ECParameters;
    ExportParameters(includePrivateParameters: boolean): ECParameters;
    GenerateKey(curve: ECCurve): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportParameters(parameters: ECParameters): void;
    SignHash(hash: byte[]): byte[];
    SignHash(hash: byte[], signatureFormat: DSASignatureFormat): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): int;
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    TrySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TrySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TrySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, signatureFormat: DSASignatureFormat, bytesWritten: { value: ref<int> }): boolean;
    VerifyHash(hash: byte[], signature: byte[]): boolean;
    VerifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifyHash(hash: byte[], signature: byte[], signatureFormat: DSASignatureFormat): boolean;
    VerifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, signatureFormat: DSASignatureFormat): boolean;
}


export const ECDsaOpenSsl: {
    new(curve: ECCurve): ECDsaOpenSsl$instance;
    new(): ECDsaOpenSsl$instance;
    new(keySize: int): ECDsaOpenSsl$instance;
    new(pkeyHandle: SafeEvpPKeyHandle): ECDsaOpenSsl$instance;
    new(handle: nint): ECDsaOpenSsl$instance;
};


export interface __ECDsaOpenSsl$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type ECDsaOpenSsl = ECDsaOpenSsl$instance & __ECDsaOpenSsl$views;


export interface FromBase64Transform$instance {
    readonly CanReuseTransform: boolean;
    readonly CanTransformMultipleBlocks: boolean;
    readonly InputBlockSize: int;
    readonly OutputBlockSize: int;
    Clear(): void;
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const FromBase64Transform: {
    new(): FromBase64Transform$instance;
    new(whitespaces: FromBase64TransformMode): FromBase64Transform$instance;
};


export interface __FromBase64Transform$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type FromBase64Transform = FromBase64Transform$instance & __FromBase64Transform$views;


export interface HashAlgorithm$instance {
    readonly CanReuseTransform: boolean;
    readonly CanTransformMultipleBlocks: boolean;
    readonly Hash: byte[];
    readonly HashSize: int;
    readonly InputBlockSize: int;
    readonly OutputBlockSize: int;
    Clear(): void;
    ComputeHash(buffer: byte[]): byte[];
    ComputeHash(buffer: byte[], offset: int, count: int): byte[];
    ComputeHash(inputStream: Stream): byte[];
    ComputeHashAsync(inputStream: Stream, cancellationToken?: CancellationToken): Task_1<byte[]>;
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
    TryComputeHash(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export const HashAlgorithm: {
    Create(): HashAlgorithm;
    Create(hashName: string): HashAlgorithm;
};


export interface __HashAlgorithm$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HashAlgorithm = HashAlgorithm$instance & __HashAlgorithm$views;


export interface HMAC$instance extends KeyedHashAlgorithm$instance {
    HashName: string;
    Key: byte[];
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const HMAC: {
};


export interface __HMAC$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMAC = HMAC$instance & __HMAC$views;


export interface HMACMD5$instance extends HMAC$instance {
    Key: byte[];
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const HMACMD5: {
    new(): HMACMD5$instance;
    new(key: byte[]): HMACMD5$instance;
    readonly HashSizeInBits: int;
    readonly HashSizeInBytes: int;
    HashData(key: byte[], source: byte[]): byte[];
    HashData(key: byte[], source: Stream): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    HashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    TryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __HMACMD5$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMACMD5 = HMACMD5$instance & __HMACMD5$views;


export interface HMACSHA1$instance extends HMAC$instance {
    Key: byte[];
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const HMACSHA1: {
    new(): HMACSHA1$instance;
    new(key: byte[]): HMACSHA1$instance;
    new(key: byte[], useManagedSha1: boolean): HMACSHA1$instance;
    readonly HashSizeInBits: int;
    readonly HashSizeInBytes: int;
    HashData(key: byte[], source: byte[]): byte[];
    HashData(key: byte[], source: Stream): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    HashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    TryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __HMACSHA1$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMACSHA1 = HMACSHA1$instance & __HMACSHA1$views;


export interface HMACSHA256$instance extends HMAC$instance {
    Key: byte[];
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const HMACSHA256: {
    new(): HMACSHA256$instance;
    new(key: byte[]): HMACSHA256$instance;
    readonly HashSizeInBits: int;
    readonly HashSizeInBytes: int;
    HashData(key: byte[], source: byte[]): byte[];
    HashData(key: byte[], source: Stream): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    HashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    TryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __HMACSHA256$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMACSHA256 = HMACSHA256$instance & __HMACSHA256$views;


export interface HMACSHA3_256$instance extends HMAC$instance {
    Key: byte[];
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const HMACSHA3_256: {
    new(): HMACSHA3_256$instance;
    new(key: byte[]): HMACSHA3_256$instance;
    readonly HashSizeInBits: int;
    readonly HashSizeInBytes: int;
    readonly IsSupported: boolean;
    HashData(key: byte[], source: byte[]): byte[];
    HashData(key: byte[], source: Stream): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    HashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    TryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __HMACSHA3_256$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMACSHA3_256 = HMACSHA3_256$instance & __HMACSHA3_256$views;


export interface HMACSHA3_384$instance extends HMAC$instance {
    Key: byte[];
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const HMACSHA3_384: {
    new(): HMACSHA3_384$instance;
    new(key: byte[]): HMACSHA3_384$instance;
    readonly HashSizeInBits: int;
    readonly HashSizeInBytes: int;
    readonly IsSupported: boolean;
    HashData(key: byte[], source: byte[]): byte[];
    HashData(key: byte[], source: Stream): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    HashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    TryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __HMACSHA3_384$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMACSHA3_384 = HMACSHA3_384$instance & __HMACSHA3_384$views;


export interface HMACSHA3_512$instance extends HMAC$instance {
    Key: byte[];
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const HMACSHA3_512: {
    new(): HMACSHA3_512$instance;
    new(key: byte[]): HMACSHA3_512$instance;
    readonly HashSizeInBits: int;
    readonly HashSizeInBytes: int;
    readonly IsSupported: boolean;
    HashData(key: byte[], source: byte[]): byte[];
    HashData(key: byte[], source: Stream): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    HashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    TryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __HMACSHA3_512$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMACSHA3_512 = HMACSHA3_512$instance & __HMACSHA3_512$views;


export interface HMACSHA384$instance extends HMAC$instance {
    Key: byte[];
    ProduceLegacyHmacValues: boolean;
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const HMACSHA384: {
    new(): HMACSHA384$instance;
    new(key: byte[]): HMACSHA384$instance;
    readonly HashSizeInBits: int;
    readonly HashSizeInBytes: int;
    HashData(key: byte[], source: byte[]): byte[];
    HashData(key: byte[], source: Stream): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    HashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    TryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __HMACSHA384$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMACSHA384 = HMACSHA384$instance & __HMACSHA384$views;


export interface HMACSHA512$instance extends HMAC$instance {
    Key: byte[];
    ProduceLegacyHmacValues: boolean;
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const HMACSHA512: {
    new(): HMACSHA512$instance;
    new(key: byte[]): HMACSHA512$instance;
    readonly HashSizeInBits: int;
    readonly HashSizeInBytes: int;
    HashData(key: byte[], source: byte[]): byte[];
    HashData(key: byte[], source: Stream): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    HashDataAsync(key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    TryHashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __HMACSHA512$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type HMACSHA512 = HMACSHA512$instance & __HMACSHA512$views;


export interface IncrementalHash$instance {
    readonly AlgorithmName: HashAlgorithmName;
    readonly HashLengthInBytes: int;
    AppendData(data: byte[]): void;
    AppendData(data: byte[], offset: int, count: int): void;
    AppendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    Clone(): IncrementalHash;
    Dispose(): void;
    GetCurrentHash(): byte[];
    GetCurrentHash(destination: Span_1<CLROf<byte>>): int;
    GetHashAndReset(): byte[];
    GetHashAndReset(destination: Span_1<CLROf<byte>>): int;
    TryGetCurrentHash(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryGetHashAndReset(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export const IncrementalHash: {
    new(): IncrementalHash$instance;
    CreateHash(hashAlgorithm: HashAlgorithmName): IncrementalHash;
    CreateHMAC(hashAlgorithm: HashAlgorithmName, key: byte[]): IncrementalHash;
    CreateHMAC(hashAlgorithm: HashAlgorithmName, key: ReadOnlySpan_1<CLROf<byte>>): IncrementalHash;
};


export interface __IncrementalHash$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface IncrementalHash$instance extends System_Internal.IDisposable$instance {}

export type IncrementalHash = IncrementalHash$instance & __IncrementalHash$views;


export interface KeyedHashAlgorithm$instance extends HashAlgorithm$instance {
    Key: byte[];
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const KeyedHashAlgorithm: {
};


export interface __KeyedHashAlgorithm$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type KeyedHashAlgorithm = KeyedHashAlgorithm$instance & __KeyedHashAlgorithm$views;


export interface KeySizes$instance {
    readonly MaxSize: int;
    readonly MinSize: int;
    readonly SkipSize: int;
}


export const KeySizes: {
    new(minSize: int, maxSize: int, skipSize: int): KeySizes$instance;
};


export type KeySizes = KeySizes$instance;

export interface Kmac128$instance {
    AppendData(data: byte[]): void;
    AppendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    Clone(): Kmac128;
    Dispose(): void;
    GetCurrentHash(outputLength: int): byte[];
    GetCurrentHash(destination: Span_1<CLROf<byte>>): void;
    GetHashAndReset(outputLength: int): byte[];
    GetHashAndReset(destination: Span_1<CLROf<byte>>): void;
}


export const Kmac128: {
    new(key: byte[], customizationString: byte[]): Kmac128$instance;
    new(key: ReadOnlySpan_1<CLROf<byte>>, customizationString: ReadOnlySpan_1<CLROf<byte>>): Kmac128$instance;
    readonly IsSupported: boolean;
    HashData(key: byte[], source: byte[], outputLength: int, customizationString?: byte[]): byte[];
    HashData(key: byte[], source: Stream, outputLength: int, customizationString?: byte[]): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    HashDataAsync(key: byte[], source: Stream, outputLength: int, customizationString?: byte[], cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
};


export interface __Kmac128$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Kmac128$instance extends System_Internal.IDisposable$instance {}

export type Kmac128 = Kmac128$instance & __Kmac128$views;


export interface Kmac256$instance {
    AppendData(data: byte[]): void;
    AppendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    Clone(): Kmac256;
    Dispose(): void;
    GetCurrentHash(outputLength: int): byte[];
    GetCurrentHash(destination: Span_1<CLROf<byte>>): void;
    GetHashAndReset(outputLength: int): byte[];
    GetHashAndReset(destination: Span_1<CLROf<byte>>): void;
}


export const Kmac256: {
    new(key: byte[], customizationString: byte[]): Kmac256$instance;
    new(key: ReadOnlySpan_1<CLROf<byte>>, customizationString: ReadOnlySpan_1<CLROf<byte>>): Kmac256$instance;
    readonly IsSupported: boolean;
    HashData(key: byte[], source: byte[], outputLength: int, customizationString?: byte[]): byte[];
    HashData(key: byte[], source: Stream, outputLength: int, customizationString?: byte[]): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    HashDataAsync(key: byte[], source: Stream, outputLength: int, customizationString?: byte[], cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
};


export interface __Kmac256$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Kmac256$instance extends System_Internal.IDisposable$instance {}

export type Kmac256 = Kmac256$instance & __Kmac256$views;


export interface KmacXof128$instance {
    AppendData(data: byte[]): void;
    AppendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    Clone(): KmacXof128;
    Dispose(): void;
    GetCurrentHash(outputLength: int): byte[];
    GetCurrentHash(destination: Span_1<CLROf<byte>>): void;
    GetHashAndReset(outputLength: int): byte[];
    GetHashAndReset(destination: Span_1<CLROf<byte>>): void;
}


export const KmacXof128: {
    new(key: byte[], customizationString: byte[]): KmacXof128$instance;
    new(key: ReadOnlySpan_1<CLROf<byte>>, customizationString: ReadOnlySpan_1<CLROf<byte>>): KmacXof128$instance;
    readonly IsSupported: boolean;
    HashData(key: byte[], source: byte[], outputLength: int, customizationString?: byte[]): byte[];
    HashData(key: byte[], source: Stream, outputLength: int, customizationString?: byte[]): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    HashDataAsync(key: byte[], source: Stream, outputLength: int, customizationString?: byte[], cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
};


export interface __KmacXof128$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface KmacXof128$instance extends System_Internal.IDisposable$instance {}

export type KmacXof128 = KmacXof128$instance & __KmacXof128$views;


export interface KmacXof256$instance {
    AppendData(data: byte[]): void;
    AppendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    Clone(): KmacXof256;
    Dispose(): void;
    GetCurrentHash(outputLength: int): byte[];
    GetCurrentHash(destination: Span_1<CLROf<byte>>): void;
    GetHashAndReset(outputLength: int): byte[];
    GetHashAndReset(destination: Span_1<CLROf<byte>>): void;
}


export const KmacXof256: {
    new(key: byte[], customizationString: byte[]): KmacXof256$instance;
    new(key: ReadOnlySpan_1<CLROf<byte>>, customizationString: ReadOnlySpan_1<CLROf<byte>>): KmacXof256$instance;
    readonly IsSupported: boolean;
    HashData(key: byte[], source: byte[], outputLength: int, customizationString?: byte[]): byte[];
    HashData(key: byte[], source: Stream, outputLength: int, customizationString?: byte[]): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, outputLength: int, customizationString?: ReadOnlySpan_1<CLROf<byte>>): byte[];
    HashData(key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, customizationString?: ReadOnlySpan_1<CLROf<byte>>): void;
    HashDataAsync(key: byte[], source: Stream, outputLength: int, customizationString?: byte[], cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, outputLength: int, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    HashDataAsync(key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, customizationString?: ReadOnlyMemory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
};


export interface __KmacXof256$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface KmacXof256$instance extends System_Internal.IDisposable$instance {}

export type KmacXof256 = KmacXof256$instance & __KmacXof256$views;


export interface MaskGenerationMethod$instance {
    GenerateMask(rgbSeed: byte[], cbReturn: int): byte[];
}


export const MaskGenerationMethod: {
};


export type MaskGenerationMethod = MaskGenerationMethod$instance;

export interface MD5$instance extends HashAlgorithm$instance {
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const MD5: {
    readonly HashSizeInBits: int;
    readonly HashSizeInBytes: int;
    HashData(source: byte[]): byte[];
    HashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    HashData(source: Stream): byte[];
    HashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    HashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    HashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    HashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    TryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __MD5$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type MD5 = MD5$instance & __MD5$views;


export interface MD5CryptoServiceProvider$instance extends MD5$instance {
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const MD5CryptoServiceProvider: {
    new(): MD5CryptoServiceProvider$instance;
};


export interface __MD5CryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type MD5CryptoServiceProvider = MD5CryptoServiceProvider$instance & __MD5CryptoServiceProvider$views;


export interface MLDsa$instance {
    readonly Algorithm: MLDsaAlgorithm;
    Dispose(): void;
    ExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKeyPem(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): string;
    ExportEncryptedPkcs8PrivateKeyPem(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): string;
    ExportEncryptedPkcs8PrivateKeyPem(password: string, pbeParameters: PbeParameters): string;
    ExportMLDsaPrivateKey(): byte[];
    ExportMLDsaPrivateKey(destination: Span_1<CLROf<byte>>): void;
    ExportMLDsaPrivateSeed(): byte[];
    ExportMLDsaPrivateSeed(destination: Span_1<CLROf<byte>>): void;
    ExportMLDsaPublicKey(): byte[];
    ExportMLDsaPublicKey(destination: Span_1<CLROf<byte>>): void;
    ExportPkcs8PrivateKey(): byte[];
    ExportPkcs8PrivateKeyPem(): string;
    ExportSubjectPublicKeyInfo(): byte[];
    ExportSubjectPublicKeyInfoPem(): string;
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, context?: ReadOnlySpan_1<CLROf<byte>>): void;
    SignData(data: byte[], context?: byte[]): byte[];
    SignMu(externalMu: byte[]): byte[];
    SignMu(externalMu: ReadOnlySpan_1<CLROf<byte>>): byte[];
    SignMu(externalMu: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): void;
    SignPreHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithmOid: string, context?: ReadOnlySpan_1<CLROf<byte>>): void;
    SignPreHash(hash: byte[], hashAlgorithmOid: string, context?: byte[]): byte[];
    TryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, context?: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifyData(data: byte[], signature: byte[], context?: byte[]): boolean;
    VerifyMu(externalMu: byte[], signature: byte[]): boolean;
    VerifyMu(externalMu: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifyPreHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithmOid: string, context?: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifyPreHash(hash: byte[], signature: byte[], hashAlgorithmOid: string, context?: byte[]): boolean;
}


export const MLDsa: {
    readonly IsSupported: boolean;
    GenerateKey(algorithm: MLDsaAlgorithm): MLDsa;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    ImportEncryptedPkcs8PrivateKey(password: string, source: byte[]): MLDsa;
    ImportFromEncryptedPem(source: ReadOnlySpan_1<CLROf<char>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    ImportFromEncryptedPem(source: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): MLDsa;
    ImportFromEncryptedPem(source: string, passwordBytes: byte[]): MLDsa;
    ImportFromEncryptedPem(source: string, password: string): MLDsa;
    ImportFromPem(source: ReadOnlySpan_1<CLROf<char>>): MLDsa;
    ImportFromPem(source: string): MLDsa;
    ImportMLDsaPrivateKey(algorithm: MLDsaAlgorithm, source: byte[]): MLDsa;
    ImportMLDsaPrivateKey(algorithm: MLDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    ImportMLDsaPrivateSeed(algorithm: MLDsaAlgorithm, source: byte[]): MLDsa;
    ImportMLDsaPrivateSeed(algorithm: MLDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    ImportMLDsaPublicKey(algorithm: MLDsaAlgorithm, source: byte[]): MLDsa;
    ImportMLDsaPublicKey(algorithm: MLDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    ImportPkcs8PrivateKey(source: byte[]): MLDsa;
    ImportPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
    ImportSubjectPublicKeyInfo(source: byte[]): MLDsa;
    ImportSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>): MLDsa;
};


export interface __MLDsa$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MLDsa$instance extends System_Internal.IDisposable$instance {}

export type MLDsa = MLDsa$instance & __MLDsa$views;


export interface MLDsaAlgorithm$instance {
    readonly MuSizeInBytes: int;
    readonly Name: string;
    readonly PrivateKeySizeInBytes: int;
    readonly PrivateSeedSizeInBytes: int;
    readonly PublicKeySizeInBytes: int;
    readonly SignatureSizeInBytes: int;
    Equals(other: MLDsaAlgorithm): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const MLDsaAlgorithm: {
    new(): MLDsaAlgorithm$instance;
    readonly MLDsa44: MLDsaAlgorithm;
    readonly MLDsa65: MLDsaAlgorithm;
    readonly MLDsa87: MLDsaAlgorithm;
};


export interface __MLDsaAlgorithm$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<MLDsaAlgorithm>;

    // Structural method bridges for numeric interface constraints
    equals(other: MLDsaAlgorithm): boolean;
}

export type MLDsaAlgorithm = MLDsaAlgorithm$instance & __MLDsaAlgorithm$views;


export interface MLDsaCng$instance extends MLDsa$instance {
    Dispose(): void;
    GetKey(): CngKey;
}


export const MLDsaCng: {
    new(key: CngKey): MLDsaCng$instance;
};


export interface __MLDsaCng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type MLDsaCng = MLDsaCng$instance & __MLDsaCng$views;


export interface MLDsaOpenSsl$instance extends MLDsa$instance {
    Dispose(): void;
    DuplicateKeyHandle(): SafeEvpPKeyHandle;
}


export const MLDsaOpenSsl: {
    new(pkeyHandle: SafeEvpPKeyHandle): MLDsaOpenSsl$instance;
};


export interface __MLDsaOpenSsl$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type MLDsaOpenSsl = MLDsaOpenSsl$instance & __MLDsaOpenSsl$views;


export interface MLKem$instance {
    readonly Algorithm: MLKemAlgorithm;
    Decapsulate(ciphertext: ReadOnlySpan_1<CLROf<byte>>, sharedSecret: Span_1<CLROf<byte>>): void;
    Decapsulate(ciphertext: byte[]): byte[];
    Dispose(): void;
    Encapsulate(ciphertext: Span_1<CLROf<byte>>, sharedSecret: Span_1<CLROf<byte>>): void;
    Encapsulate(ciphertext: { value: ref<byte[]> }, sharedSecret: { value: ref<byte[]> }): void;
    ExportDecapsulationKey(destination: Span_1<CLROf<byte>>): void;
    ExportDecapsulationKey(): byte[];
    ExportEncapsulationKey(destination: Span_1<CLROf<byte>>): void;
    ExportEncapsulationKey(): byte[];
    ExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKeyPem(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): string;
    ExportEncryptedPkcs8PrivateKeyPem(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): string;
    ExportEncryptedPkcs8PrivateKeyPem(password: string, pbeParameters: PbeParameters): string;
    ExportPkcs8PrivateKey(): byte[];
    ExportPkcs8PrivateKeyPem(): string;
    ExportPrivateSeed(destination: Span_1<CLROf<byte>>): void;
    ExportPrivateSeed(): byte[];
    ExportSubjectPublicKeyInfo(): byte[];
    ExportSubjectPublicKeyInfoPem(): string;
    TryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
}


export const MLKem: {
    readonly IsSupported: boolean;
    GenerateKey(algorithm: MLKemAlgorithm): MLKem;
    ImportDecapsulationKey(algorithm: MLKemAlgorithm, source: byte[]): MLKem;
    ImportDecapsulationKey(algorithm: MLKemAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    ImportEncapsulationKey(algorithm: MLKemAlgorithm, source: byte[]): MLKem;
    ImportEncapsulationKey(algorithm: MLKemAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    ImportEncryptedPkcs8PrivateKey(password: string, source: byte[]): MLKem;
    ImportFromEncryptedPem(source: ReadOnlySpan_1<CLROf<char>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    ImportFromEncryptedPem(source: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): MLKem;
    ImportFromEncryptedPem(source: string, passwordBytes: byte[]): MLKem;
    ImportFromEncryptedPem(source: string, password: string): MLKem;
    ImportFromPem(source: ReadOnlySpan_1<CLROf<char>>): MLKem;
    ImportFromPem(source: string): MLKem;
    ImportPkcs8PrivateKey(source: byte[]): MLKem;
    ImportPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    ImportPrivateSeed(algorithm: MLKemAlgorithm, source: byte[]): MLKem;
    ImportPrivateSeed(algorithm: MLKemAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
    ImportSubjectPublicKeyInfo(source: byte[]): MLKem;
    ImportSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>): MLKem;
};


export interface __MLKem$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface MLKem$instance extends System_Internal.IDisposable$instance {}

export type MLKem = MLKem$instance & __MLKem$views;


export interface MLKemAlgorithm$instance {
    readonly CiphertextSizeInBytes: int;
    readonly DecapsulationKeySizeInBytes: int;
    readonly EncapsulationKeySizeInBytes: int;
    readonly Name: string;
    readonly PrivateSeedSizeInBytes: int;
    readonly SharedSecretSizeInBytes: int;
    Equals(other: MLKemAlgorithm): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const MLKemAlgorithm: {
    new(): MLKemAlgorithm$instance;
    readonly MLKem512: MLKemAlgorithm;
    readonly MLKem768: MLKemAlgorithm;
    readonly MLKem1024: MLKemAlgorithm;
};


export interface __MLKemAlgorithm$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<MLKemAlgorithm>;

    // Structural method bridges for numeric interface constraints
    equals(other: MLKemAlgorithm): boolean;
}

export type MLKemAlgorithm = MLKemAlgorithm$instance & __MLKemAlgorithm$views;


export interface MLKemCng$instance extends MLKem$instance {
    Dispose(): void;
    GetKey(): CngKey;
}


export const MLKemCng: {
    new(key: CngKey): MLKemCng$instance;
};


export interface __MLKemCng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type MLKemCng = MLKemCng$instance & __MLKemCng$views;


export interface MLKemOpenSsl$instance extends MLKem$instance {
    Dispose(): void;
    DuplicateKeyHandle(): SafeEvpPKeyHandle;
}


export const MLKemOpenSsl: {
    new(pkeyHandle: SafeEvpPKeyHandle): MLKemOpenSsl$instance;
};


export interface __MLKemOpenSsl$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type MLKemOpenSsl = MLKemOpenSsl$instance & __MLKemOpenSsl$views;


export interface Oid$instance {
    FriendlyName: string;
    Value: string;
}


export const Oid: {
    new(): Oid$instance;
    new(oid: string): Oid$instance;
    new(value: string, friendlyName: string): Oid$instance;
    new(oid: Oid): Oid$instance;
    FromFriendlyName(friendlyName: string, group: OidGroup): Oid;
    FromOidValue(oidValue: string, group: OidGroup): Oid;
};


export type Oid = Oid$instance;

export interface OidCollection$instance {
    readonly Count: int;
    readonly IsSynchronized: boolean;
    readonly SyncRoot: unknown;
    Add(oid: Oid): int;
    CopyTo(array: Oid[], index: int): void;
    get_Item(index: int): Oid;
    get_Item(oid: string): Oid;
    GetEnumerator(): OidEnumerator;
}


export const OidCollection: {
    new(): OidCollection$instance;
};


export interface __OidCollection$views {
    As_ICollection(): System_Collections_Internal.ICollection$instance;
    As_IEnumerable(): System_Collections_Internal.IEnumerable$instance;
}

export type OidCollection = OidCollection$instance & __OidCollection$views;


export interface OidEnumerator$instance {
    readonly Current: Oid | unknown;
    MoveNext(): boolean;
    Reset(): void;
}


export const OidEnumerator: {
    new(): OidEnumerator$instance;
};


export interface __OidEnumerator$views {
    As_IEnumerator(): System_Collections_Internal.IEnumerator$instance;
}

export type OidEnumerator = OidEnumerator$instance & __OidEnumerator$views;


export interface PasswordDeriveBytes$instance extends DeriveBytes$instance {
    HashName: string;
    IterationCount: int;
    Salt: byte[];
    CryptDeriveKey(algname: string, alghashname: string, keySize: int, rgbIV: byte[]): byte[];
    Dispose(): void;
    GetBytes(cb: int): byte[];
    Reset(): void;
}


export const PasswordDeriveBytes: {
    new(strPassword: string, rgbSalt: byte[]): PasswordDeriveBytes$instance;
    new(password: byte[], salt: byte[]): PasswordDeriveBytes$instance;
    new(strPassword: string, rgbSalt: byte[], strHashName: string, iterations: int): PasswordDeriveBytes$instance;
    new(password: byte[], salt: byte[], hashName: string, iterations: int): PasswordDeriveBytes$instance;
    new(strPassword: string, rgbSalt: byte[], cspParams: CspParameters): PasswordDeriveBytes$instance;
    new(password: byte[], salt: byte[], cspParams: CspParameters): PasswordDeriveBytes$instance;
    new(strPassword: string, rgbSalt: byte[], strHashName: string, iterations: int, cspParams: CspParameters): PasswordDeriveBytes$instance;
    new(password: byte[], salt: byte[], hashName: string, iterations: int, cspParams: CspParameters): PasswordDeriveBytes$instance;
};


export interface __PasswordDeriveBytes$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type PasswordDeriveBytes = PasswordDeriveBytes$instance & __PasswordDeriveBytes$views;


export interface PbeParameters$instance {
    readonly EncryptionAlgorithm: PbeEncryptionAlgorithm;
    readonly HashAlgorithm: HashAlgorithmName;
    readonly IterationCount: int;
}


export const PbeParameters: {
    new(encryptionAlgorithm: PbeEncryptionAlgorithm, hashAlgorithm: HashAlgorithmName, iterationCount: int): PbeParameters$instance;
};


export type PbeParameters = PbeParameters$instance;

export interface PKCS1MaskGenerationMethod$instance extends MaskGenerationMethod {
    HashName: string;
    GenerateMask(rgbSeed: byte[], cbReturn: int): byte[];
}


export const PKCS1MaskGenerationMethod: {
    new(): PKCS1MaskGenerationMethod$instance;
};


export type PKCS1MaskGenerationMethod = PKCS1MaskGenerationMethod$instance;

export interface RandomNumberGenerator$instance {
    Dispose(): void;
    GetBytes(data: byte[]): void;
    GetBytes(data: byte[], offset: int, count: int): void;
    GetBytes(data: Span_1<CLROf<byte>>): void;
    GetNonZeroBytes(data: byte[]): void;
    GetNonZeroBytes(data: Span_1<CLROf<byte>>): void;
}


export const RandomNumberGenerator: {
    Create(): RandomNumberGenerator;
    Create(rngName: string): RandomNumberGenerator;
    Fill(data: Span_1<CLROf<byte>>): void;
    GetBytes(count: int): byte[];
    GetHexString(stringLength: int, lowercase?: boolean): string;
    GetHexString(destination: Span_1<CLROf<char>>, lowercase?: boolean): void;
    GetInt32(fromInclusive: int, toExclusive: int): int;
    GetInt32(toExclusive: int): int;
    GetItems<T>(choices: ReadOnlySpan_1<T>, destination: Span_1<T>): void;
    GetItems<T>(choices: ReadOnlySpan_1<T>, length: int): T[];
    GetString(choices: ReadOnlySpan_1<CLROf<char>>, length: int): string;
    Shuffle<T>(values: Span_1<T>): void;
};


export interface __RandomNumberGenerator$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface RandomNumberGenerator$instance extends System_Internal.IDisposable$instance {}

export type RandomNumberGenerator = RandomNumberGenerator$instance & __RandomNumberGenerator$views;


export interface RC2$instance extends SymmetricAlgorithm$instance {
    EffectiveKeySize: int;
    KeySize: int;
    Dispose(): void;
}


export const RC2: {
};


export interface __RC2$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type RC2 = RC2$instance & __RC2$views;


export interface RC2CryptoServiceProvider$instance extends RC2$instance {
    BlockSize: int;
    EffectiveKeySize: int;
    FeedbackSize: int;
    IV: byte[];
    Key: byte[];
    KeySize: int;
    readonly LegalBlockSizes: KeySizes[];
    readonly LegalKeySizes: KeySizes[];
    Mode: CipherMode;
    Padding: PaddingMode;
    UseSalt: boolean;
    CreateDecryptor(): ICryptoTransform;
    CreateDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    CreateEncryptor(): ICryptoTransform;
    CreateEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    Dispose(): void;
    GenerateIV(): void;
    GenerateKey(): void;
}


export const RC2CryptoServiceProvider: {
    new(): RC2CryptoServiceProvider$instance;
};


export interface __RC2CryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type RC2CryptoServiceProvider = RC2CryptoServiceProvider$instance & __RC2CryptoServiceProvider$views;


export interface Rfc2898DeriveBytes$instance extends DeriveBytes$instance {
    readonly HashAlgorithm: HashAlgorithmName;
    IterationCount: int;
    Salt: byte[];
    CryptDeriveKey(algname: string, alghashname: string, keySize: int, rgbIV: byte[]): byte[];
    Dispose(): void;
    GetBytes(cb: int): byte[];
    Reset(): void;
}


export const Rfc2898DeriveBytes: {
    new(password: byte[], salt: byte[], iterations: int): Rfc2898DeriveBytes$instance;
    new(password: byte[], salt: byte[], iterations: int, hashAlgorithm: HashAlgorithmName): Rfc2898DeriveBytes$instance;
    new(password: string, salt: byte[]): Rfc2898DeriveBytes$instance;
    new(password: string, salt: byte[], iterations: int): Rfc2898DeriveBytes$instance;
    new(password: string, salt: byte[], iterations: int, hashAlgorithm: HashAlgorithmName): Rfc2898DeriveBytes$instance;
    new(password: string, saltSize: int): Rfc2898DeriveBytes$instance;
    new(password: string, saltSize: int, iterations: int): Rfc2898DeriveBytes$instance;
    new(password: string, saltSize: int, iterations: int, hashAlgorithm: HashAlgorithmName): Rfc2898DeriveBytes$instance;
    Pbkdf2(password: byte[], salt: byte[], iterations: int, hashAlgorithm: HashAlgorithmName, outputLength: int): byte[];
    Pbkdf2(password: ReadOnlySpan_1<CLROf<byte>>, salt: ReadOnlySpan_1<CLROf<byte>>, iterations: int, hashAlgorithm: HashAlgorithmName, outputLength: int): byte[];
    Pbkdf2(password: ReadOnlySpan_1<CLROf<byte>>, salt: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, iterations: int, hashAlgorithm: HashAlgorithmName): void;
    Pbkdf2(password: ReadOnlySpan_1<CLROf<char>>, salt: ReadOnlySpan_1<CLROf<byte>>, iterations: int, hashAlgorithm: HashAlgorithmName, outputLength: int): byte[];
    Pbkdf2(password: ReadOnlySpan_1<CLROf<char>>, salt: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, iterations: int, hashAlgorithm: HashAlgorithmName): void;
    Pbkdf2(password: string, salt: byte[], iterations: int, hashAlgorithm: HashAlgorithmName, outputLength: int): byte[];
};


export interface __Rfc2898DeriveBytes$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type Rfc2898DeriveBytes = Rfc2898DeriveBytes$instance & __Rfc2898DeriveBytes$views;


export interface Rijndael$instance extends SymmetricAlgorithm$instance {
    Dispose(): void;
}


export const Rijndael: {
};


export interface __Rijndael$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type Rijndael = Rijndael$instance & __Rijndael$views;


export interface RijndaelManaged$instance extends Rijndael$instance {
    BlockSize: int;
    FeedbackSize: int;
    IV: byte[];
    Key: byte[];
    KeySize: int;
    readonly LegalKeySizes: KeySizes[];
    Mode: CipherMode;
    Padding: PaddingMode;
    CreateDecryptor(): ICryptoTransform;
    CreateDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    CreateEncryptor(): ICryptoTransform;
    CreateEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    Dispose(): void;
    GenerateIV(): void;
    GenerateKey(): void;
}


export const RijndaelManaged: {
    new(): RijndaelManaged$instance;
};


export interface __RijndaelManaged$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type RijndaelManaged = RijndaelManaged$instance & __RijndaelManaged$views;


export interface RNGCryptoServiceProvider$instance extends RandomNumberGenerator$instance {
    Dispose(): void;
    GetBytes(data: byte[]): void;
    GetBytes(data: byte[], offset: int, count: int): void;
    GetBytes(data: Span_1<CLROf<byte>>): void;
    GetBytes(data: Span_1<CLROf<byte>>): void;
    GetNonZeroBytes(data: byte[]): void;
    GetNonZeroBytes(data: Span_1<CLROf<byte>>): void;
    GetNonZeroBytes(data: Span_1<CLROf<byte>>): void;
}


export const RNGCryptoServiceProvider: {
    new(): RNGCryptoServiceProvider$instance;
    new(str: string): RNGCryptoServiceProvider$instance;
    new(rgb: byte[]): RNGCryptoServiceProvider$instance;
    new(cspParams: CspParameters): RNGCryptoServiceProvider$instance;
};


export interface __RNGCryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type RNGCryptoServiceProvider = RNGCryptoServiceProvider$instance & __RNGCryptoServiceProvider$views;


export interface RSA$instance extends AsymmetricAlgorithm$instance {
    readonly KeyExchangeAlgorithm: string;
    readonly SignatureAlgorithm: string;
    Decrypt(data: byte[], padding: RSAEncryptionPadding): byte[];
    Decrypt(data: ReadOnlySpan_1<CLROf<byte>>, padding: RSAEncryptionPadding): byte[];
    Decrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding): int;
    DecryptValue(rgb: byte[]): byte[];
    Dispose(): void;
    Encrypt(data: byte[], padding: RSAEncryptionPadding): byte[];
    Encrypt(data: ReadOnlySpan_1<CLROf<byte>>, padding: RSAEncryptionPadding): byte[];
    Encrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding): int;
    EncryptValue(rgb: byte[]): byte[];
    ExportParameters(includePrivateParameters: boolean): RSAParameters;
    ExportRSAPrivateKey(): byte[];
    ExportRSAPrivateKeyPem(): string;
    ExportRSAPublicKey(): byte[];
    ExportRSAPublicKeyPem(): string;
    FromXmlString(xmlString: string): void;
    GetMaxOutputSize(): int;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): void;
    ImportFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): void;
    ImportFromEncryptedPem(input: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): void;
    ImportFromPem(input: ReadOnlySpan_1<CLROf<char>>): void;
    ImportFromPem(input: ReadOnlySpan_1<CLROf<char>>): void;
    ImportParameters(parameters: RSAParameters): void;
    ImportPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportRSAPrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportRSAPublicKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    SignData(data: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignData(data: Stream, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): int;
    SignHash(hash: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): int;
    ToXmlString(includePrivateParameters: boolean): string;
    TryDecrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    TryEncrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportRSAPrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportRSAPrivateKeyPem(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    TryExportRSAPublicKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportRSAPublicKeyPem(destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TrySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    TrySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    VerifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyHash(hash: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
}


export const RSA: {
    Create(parameters: RSAParameters): RSA;
    Create(algName: string): RSA;
};


export interface __RSA$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type RSA = RSA$instance & __RSA$views;


export interface RSACng$instance extends RSA$instance {
    readonly Key: CngKey;
    Dispose(): void;
    ExportParameters(includePrivateParameters: boolean): RSAParameters;
    ImportParameters(parameters: RSAParameters): void;
}


export const RSACng: {
    new(): RSACng$instance;
    new(keySize: int): RSACng$instance;
    new(key: CngKey): RSACng$instance;
};


export interface __RSACng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type RSACng = RSACng$instance & __RSACng$views;


export interface RSACryptoServiceProvider$instance extends RSA$instance {
    readonly CspKeyContainerInfo: CspKeyContainerInfo;
    readonly KeyExchangeAlgorithm: string;
    KeySize: int;
    readonly LegalKeySizes: KeySizes[];
    PersistKeyInCsp: boolean;
    readonly PublicOnly: boolean;
    readonly SignatureAlgorithm: string;
    Decrypt(data: byte[], padding: RSAEncryptionPadding): byte[];
    Decrypt(data: ReadOnlySpan_1<CLROf<byte>>, padding: RSAEncryptionPadding): byte[];
    Decrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding): int;
    Dispose(): void;
    Encrypt(data: byte[], padding: RSAEncryptionPadding): byte[];
    Encrypt(data: ReadOnlySpan_1<CLROf<byte>>, padding: RSAEncryptionPadding): byte[];
    Encrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding): int;
    ExportCspBlob(includePrivateParameters: boolean): byte[];
    ExportParameters(includePrivateParameters: boolean): RSAParameters;
    FromXmlString(xmlString: string): void;
    ImportCspBlob(keyBlob: byte[]): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportParameters(parameters: RSAParameters): void;
    SignData(data: Stream, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignData(data: byte[], offset: int, count: int, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignData(inputStream: Stream, halg: unknown): byte[];
    SignData(data: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): int;
    SignHash(hash: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): int;
    ToXmlString(includePrivateParameters: boolean): string;
    TryDecrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    TryDecrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    TryEncrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    TryEncrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    TrySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    TrySignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    TrySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    TrySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    VerifyData(data: byte[], offset: int, count: int, signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyData(data: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyData(data: Stream, signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyHash(hash: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
}


export const RSACryptoServiceProvider: {
    new(): RSACryptoServiceProvider$instance;
    new(dwKeySize: int): RSACryptoServiceProvider$instance;
    new(dwKeySize: int, parameters: CspParameters): RSACryptoServiceProvider$instance;
    new(parameters: CspParameters): RSACryptoServiceProvider$instance;
    UseMachineKeyStore: boolean;
};


export interface __RSACryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICspAsymmetricAlgorithm(): ICspAsymmetricAlgorithm$instance;
}

export interface RSACryptoServiceProvider$instance extends ICspAsymmetricAlgorithm$instance {}

export type RSACryptoServiceProvider = RSACryptoServiceProvider$instance & __RSACryptoServiceProvider$views;


export interface RSAEncryptionPadding$instance {
    readonly Mode: RSAEncryptionPaddingMode;
    readonly OaepHashAlgorithm: HashAlgorithmName;
    Equals(obj: unknown): boolean;
    Equals(other: RSAEncryptionPadding): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RSAEncryptionPadding: {
    new(): RSAEncryptionPadding$instance;
    readonly Pkcs1: RSAEncryptionPadding;
    readonly OaepSHA1: RSAEncryptionPadding;
    readonly OaepSHA256: RSAEncryptionPadding;
    readonly OaepSHA384: RSAEncryptionPadding;
    readonly OaepSHA512: RSAEncryptionPadding;
    readonly OaepSHA3_256: RSAEncryptionPadding;
    readonly OaepSHA3_384: RSAEncryptionPadding;
    readonly OaepSHA3_512: RSAEncryptionPadding;
    CreateOaep(hashAlgorithm: HashAlgorithmName): RSAEncryptionPadding;
};


export interface __RSAEncryptionPadding$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<RSAEncryptionPadding>;

    // Structural method bridges for numeric interface constraints
    equals(other: RSAEncryptionPadding): boolean;
}

export type RSAEncryptionPadding = RSAEncryptionPadding$instance & __RSAEncryptionPadding$views;


export interface RSAOAEPKeyExchangeDeformatter$instance extends AsymmetricKeyExchangeDeformatter {
    Parameters: string;
    DecryptKeyExchange(rgbData: byte[]): byte[];
    SetKey(key: AsymmetricAlgorithm): void;
}


export const RSAOAEPKeyExchangeDeformatter: {
    new(): RSAOAEPKeyExchangeDeformatter$instance;
    new(key: AsymmetricAlgorithm): RSAOAEPKeyExchangeDeformatter$instance;
};


export type RSAOAEPKeyExchangeDeformatter = RSAOAEPKeyExchangeDeformatter$instance;

export interface RSAOAEPKeyExchangeFormatter$instance extends AsymmetricKeyExchangeFormatter {
    Parameter: byte[];
    readonly Parameters: string;
    Rng: RandomNumberGenerator;
    CreateKeyExchange(rgbData: byte[], symAlgType: Type): byte[];
    CreateKeyExchange(rgbData: byte[]): byte[];
    SetKey(key: AsymmetricAlgorithm): void;
}


export const RSAOAEPKeyExchangeFormatter: {
    new(): RSAOAEPKeyExchangeFormatter$instance;
    new(key: AsymmetricAlgorithm): RSAOAEPKeyExchangeFormatter$instance;
};


export type RSAOAEPKeyExchangeFormatter = RSAOAEPKeyExchangeFormatter$instance;

export interface RSAOpenSsl$instance extends RSA$instance {
    KeySize: int;
    readonly LegalKeySizes: KeySizes[];
    Decrypt(data: byte[], padding: RSAEncryptionPadding): byte[];
    Decrypt(data: ReadOnlySpan_1<CLROf<byte>>, padding: RSAEncryptionPadding): byte[];
    Decrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding): int;
    Dispose(): void;
    DuplicateKeyHandle(): SafeEvpPKeyHandle;
    Encrypt(data: byte[], padding: RSAEncryptionPadding): byte[];
    Encrypt(data: ReadOnlySpan_1<CLROf<byte>>, padding: RSAEncryptionPadding): byte[];
    Encrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding): int;
    ExportParameters(includePrivateParameters: boolean): RSAParameters;
    ExportPkcs8PrivateKey(): byte[];
    ExportRSAPrivateKey(): byte[];
    ExportRSAPublicKey(): byte[];
    ExportSubjectPublicKeyInfo(): byte[];
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportParameters(parameters: RSAParameters): void;
    ImportPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportRSAPrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportRSAPrivateKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportRSAPublicKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportRSAPublicKey(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    ImportSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>, bytesRead: { value: ref<int> }): void;
    SignHash(hash: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): byte[];
    SignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): int;
    TryDecrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    TryDecrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    TryEncrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    TryEncrypt(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, padding: RSAEncryptionPadding, bytesWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportRSAPrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportRSAPrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportRSAPublicKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportRSAPublicKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TrySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    TrySignHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: { value: ref<int> }): boolean;
    VerifyHash(hash: byte[], signature: byte[], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
    VerifyHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding): boolean;
}


export const RSAOpenSsl: {
    new(): RSAOpenSsl$instance;
    new(keySize: int): RSAOpenSsl$instance;
    new(parameters: RSAParameters): RSAOpenSsl$instance;
    new(handle: nint): RSAOpenSsl$instance;
    new(pkeyHandle: SafeEvpPKeyHandle): RSAOpenSsl$instance;
};


export interface __RSAOpenSsl$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type RSAOpenSsl = RSAOpenSsl$instance & __RSAOpenSsl$views;


export interface RSAPKCS1KeyExchangeDeformatter$instance extends AsymmetricKeyExchangeDeformatter {
    Parameters: string;
    RNG: RandomNumberGenerator;
    DecryptKeyExchange(rgbIn: byte[]): byte[];
    SetKey(key: AsymmetricAlgorithm): void;
}


export const RSAPKCS1KeyExchangeDeformatter: {
    new(): RSAPKCS1KeyExchangeDeformatter$instance;
    new(key: AsymmetricAlgorithm): RSAPKCS1KeyExchangeDeformatter$instance;
};


export type RSAPKCS1KeyExchangeDeformatter = RSAPKCS1KeyExchangeDeformatter$instance;

export interface RSAPKCS1KeyExchangeFormatter$instance extends AsymmetricKeyExchangeFormatter {
    readonly Parameters: string;
    Rng: RandomNumberGenerator;
    CreateKeyExchange(rgbData: byte[], symAlgType: Type): byte[];
    CreateKeyExchange(rgbData: byte[]): byte[];
    SetKey(key: AsymmetricAlgorithm): void;
}


export const RSAPKCS1KeyExchangeFormatter: {
    new(): RSAPKCS1KeyExchangeFormatter$instance;
    new(key: AsymmetricAlgorithm): RSAPKCS1KeyExchangeFormatter$instance;
};


export type RSAPKCS1KeyExchangeFormatter = RSAPKCS1KeyExchangeFormatter$instance;

export interface RSAPKCS1SignatureDeformatter$instance extends AsymmetricSignatureDeformatter {
    SetHashAlgorithm(strName: string): void;
    SetKey(key: AsymmetricAlgorithm): void;
    VerifySignature(rgbHash: byte[], rgbSignature: byte[]): boolean;
    VerifySignature(hash: HashAlgorithm, rgbSignature: byte[]): boolean;
}


export const RSAPKCS1SignatureDeformatter: {
    new(): RSAPKCS1SignatureDeformatter$instance;
    new(key: AsymmetricAlgorithm): RSAPKCS1SignatureDeformatter$instance;
};


export type RSAPKCS1SignatureDeformatter = RSAPKCS1SignatureDeformatter$instance;

export interface RSAPKCS1SignatureFormatter$instance extends AsymmetricSignatureFormatter {
    CreateSignature(rgbHash: byte[]): byte[];
    CreateSignature(hash: HashAlgorithm): byte[];
    SetHashAlgorithm(strName: string): void;
    SetKey(key: AsymmetricAlgorithm): void;
}


export const RSAPKCS1SignatureFormatter: {
    new(): RSAPKCS1SignatureFormatter$instance;
    new(key: AsymmetricAlgorithm): RSAPKCS1SignatureFormatter$instance;
};


export type RSAPKCS1SignatureFormatter = RSAPKCS1SignatureFormatter$instance;

export interface RSASignaturePadding$instance {
    readonly Mode: RSASignaturePaddingMode;
    Equals(obj: unknown): boolean;
    Equals(other: RSASignaturePadding): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const RSASignaturePadding: {
    new(): RSASignaturePadding$instance;
    readonly Pkcs1: RSASignaturePadding;
    readonly Pss: RSASignaturePadding;
};


export interface __RSASignaturePadding$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<RSASignaturePadding>;

    // Structural method bridges for numeric interface constraints
    equals(other: RSASignaturePadding): boolean;
}

export type RSASignaturePadding = RSASignaturePadding$instance & __RSASignaturePadding$views;


export interface SafeEvpPKeyHandle$instance extends SafeHandle {
    readonly IsInvalid: boolean;
    Dispose(): void;
    DuplicateHandle(): SafeEvpPKeyHandle;
}


export const SafeEvpPKeyHandle: {
    new(): SafeEvpPKeyHandle$instance;
    new(handle: nint, ownsHandle: boolean): SafeEvpPKeyHandle$instance;
    readonly OpenSslVersion: long;
    OpenKeyFromProvider(providerName: string, keyUri: string): SafeEvpPKeyHandle;
    OpenPrivateKeyFromEngine(engineName: string, keyId: string): SafeEvpPKeyHandle;
    OpenPublicKeyFromEngine(engineName: string, keyId: string): SafeEvpPKeyHandle;
};


export interface __SafeEvpPKeyHandle$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type SafeEvpPKeyHandle = SafeEvpPKeyHandle$instance & __SafeEvpPKeyHandle$views;


export interface SHA1$instance extends HashAlgorithm$instance {
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA1: {
    readonly HashSizeInBits: int;
    readonly HashSizeInBytes: int;
    HashData(source: byte[]): byte[];
    HashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    HashData(source: Stream): byte[];
    HashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    HashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    HashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    HashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    TryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __SHA1$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA1 = SHA1$instance & __SHA1$views;


export interface SHA1CryptoServiceProvider$instance extends SHA1$instance {
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA1CryptoServiceProvider: {
    new(): SHA1CryptoServiceProvider$instance;
};


export interface __SHA1CryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA1CryptoServiceProvider = SHA1CryptoServiceProvider$instance & __SHA1CryptoServiceProvider$views;


export interface SHA1Managed$instance extends SHA1$instance {
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA1Managed: {
    new(): SHA1Managed$instance;
};


export interface __SHA1Managed$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA1Managed = SHA1Managed$instance & __SHA1Managed$views;


export interface SHA256$instance extends HashAlgorithm$instance {
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA256: {
    readonly HashSizeInBits: int;
    readonly HashSizeInBytes: int;
    HashData(source: byte[]): byte[];
    HashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    HashData(source: Stream): byte[];
    HashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    HashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    HashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    HashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    TryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __SHA256$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA256 = SHA256$instance & __SHA256$views;


export interface SHA256CryptoServiceProvider$instance extends SHA256$instance {
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA256CryptoServiceProvider: {
    new(): SHA256CryptoServiceProvider$instance;
};


export interface __SHA256CryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA256CryptoServiceProvider = SHA256CryptoServiceProvider$instance & __SHA256CryptoServiceProvider$views;


export interface SHA256Managed$instance extends SHA256$instance {
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA256Managed: {
    new(): SHA256Managed$instance;
};


export interface __SHA256Managed$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA256Managed = SHA256Managed$instance & __SHA256Managed$views;


export interface SHA3_256$instance extends HashAlgorithm$instance {
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA3_256: {
    readonly HashSizeInBits: int;
    readonly HashSizeInBytes: int;
    readonly IsSupported: boolean;
    HashData(source: byte[]): byte[];
    HashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    HashData(source: Stream): byte[];
    HashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    HashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    HashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    HashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    TryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __SHA3_256$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA3_256 = SHA3_256$instance & __SHA3_256$views;


export interface SHA3_384$instance extends HashAlgorithm$instance {
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA3_384: {
    readonly HashSizeInBits: int;
    readonly HashSizeInBytes: int;
    readonly IsSupported: boolean;
    HashData(source: byte[]): byte[];
    HashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    HashData(source: Stream): byte[];
    HashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    HashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    HashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    HashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    TryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __SHA3_384$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA3_384 = SHA3_384$instance & __SHA3_384$views;


export interface SHA3_512$instance extends HashAlgorithm$instance {
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA3_512: {
    readonly HashSizeInBits: int;
    readonly HashSizeInBytes: int;
    readonly IsSupported: boolean;
    HashData(source: byte[]): byte[];
    HashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    HashData(source: Stream): byte[];
    HashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    HashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    HashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    HashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    TryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __SHA3_512$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA3_512 = SHA3_512$instance & __SHA3_512$views;


export interface SHA384$instance extends HashAlgorithm$instance {
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA384: {
    readonly HashSizeInBits: int;
    readonly HashSizeInBytes: int;
    HashData(source: byte[]): byte[];
    HashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    HashData(source: Stream): byte[];
    HashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    HashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    HashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    HashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    TryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __SHA384$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA384 = SHA384$instance & __SHA384$views;


export interface SHA384CryptoServiceProvider$instance extends SHA384$instance {
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA384CryptoServiceProvider: {
    new(): SHA384CryptoServiceProvider$instance;
};


export interface __SHA384CryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA384CryptoServiceProvider = SHA384CryptoServiceProvider$instance & __SHA384CryptoServiceProvider$views;


export interface SHA384Managed$instance extends SHA384$instance {
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA384Managed: {
    new(): SHA384Managed$instance;
};


export interface __SHA384Managed$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA384Managed = SHA384Managed$instance & __SHA384Managed$views;


export interface SHA512$instance extends HashAlgorithm$instance {
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA512: {
    readonly HashSizeInBits: int;
    readonly HashSizeInBytes: int;
    HashData(source: byte[]): byte[];
    HashData(source: Stream, destination: Span_1<CLROf<byte>>): int;
    HashData(source: Stream): byte[];
    HashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    HashData(source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    HashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    HashDataAsync(source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    TryHashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
};


export interface __SHA512$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA512 = SHA512$instance & __SHA512$views;


export interface SHA512CryptoServiceProvider$instance extends SHA512$instance {
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA512CryptoServiceProvider: {
    new(): SHA512CryptoServiceProvider$instance;
};


export interface __SHA512CryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA512CryptoServiceProvider = SHA512CryptoServiceProvider$instance & __SHA512CryptoServiceProvider$views;


export interface SHA512Managed$instance extends SHA512$instance {
    Dispose(): void;
    Initialize(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const SHA512Managed: {
    new(): SHA512Managed$instance;
};


export interface __SHA512Managed$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type SHA512Managed = SHA512Managed$instance & __SHA512Managed$views;


export interface Shake128$instance {
    AppendData(data: byte[]): void;
    AppendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    Clone(): Shake128;
    Dispose(): void;
    GetCurrentHash(outputLength: int): byte[];
    GetCurrentHash(destination: Span_1<CLROf<byte>>): void;
    GetHashAndReset(outputLength: int): byte[];
    GetHashAndReset(destination: Span_1<CLROf<byte>>): void;
    Read(outputLength: int): byte[];
    Read(destination: Span_1<CLROf<byte>>): void;
    Reset(): void;
}


export const Shake128: {
    new(): Shake128$instance;
    readonly IsSupported: boolean;
    HashData(source: byte[], outputLength: int): byte[];
    HashData(source: Stream, outputLength: int): byte[];
    HashData(source: Stream, destination: Span_1<CLROf<byte>>): void;
    HashData(source: ReadOnlySpan_1<CLROf<byte>>, outputLength: int): byte[];
    HashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): void;
    HashDataAsync(source: Stream, outputLength: int, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    HashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
};


export interface __Shake128$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Shake128$instance extends System_Internal.IDisposable$instance {}

export type Shake128 = Shake128$instance & __Shake128$views;


export interface Shake256$instance {
    AppendData(data: byte[]): void;
    AppendData(data: ReadOnlySpan_1<CLROf<byte>>): void;
    Clone(): Shake256;
    Dispose(): void;
    GetCurrentHash(outputLength: int): byte[];
    GetCurrentHash(destination: Span_1<CLROf<byte>>): void;
    GetHashAndReset(outputLength: int): byte[];
    GetHashAndReset(destination: Span_1<CLROf<byte>>): void;
    Read(outputLength: int): byte[];
    Read(destination: Span_1<CLROf<byte>>): void;
    Reset(): void;
}


export const Shake256: {
    new(): Shake256$instance;
    readonly IsSupported: boolean;
    HashData(source: byte[], outputLength: int): byte[];
    HashData(source: Stream, outputLength: int): byte[];
    HashData(source: Stream, destination: Span_1<CLROf<byte>>): void;
    HashData(source: ReadOnlySpan_1<CLROf<byte>>, outputLength: int): byte[];
    HashData(source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): void;
    HashDataAsync(source: Stream, outputLength: int, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    HashDataAsync(source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask;
};


export interface __Shake256$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface Shake256$instance extends System_Internal.IDisposable$instance {}

export type Shake256 = Shake256$instance & __Shake256$views;


export interface SignatureDescription$instance {
    DeformatterAlgorithm: string;
    DigestAlgorithm: string;
    FormatterAlgorithm: string;
    KeyAlgorithm: string;
    CreateDeformatter(key: AsymmetricAlgorithm): AsymmetricSignatureDeformatter;
    CreateDigest(): HashAlgorithm;
    CreateFormatter(key: AsymmetricAlgorithm): AsymmetricSignatureFormatter;
}


export const SignatureDescription: {
    new(): SignatureDescription$instance;
    new(el: SecurityElement): SignatureDescription$instance;
};


export type SignatureDescription = SignatureDescription$instance;

export interface SlhDsa$instance {
    readonly Algorithm: SlhDsaAlgorithm;
    Dispose(): void;
    ExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters): byte[];
    ExportEncryptedPkcs8PrivateKeyPem(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters): string;
    ExportEncryptedPkcs8PrivateKeyPem(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters): string;
    ExportEncryptedPkcs8PrivateKeyPem(password: string, pbeParameters: PbeParameters): string;
    ExportPkcs8PrivateKey(): byte[];
    ExportPkcs8PrivateKeyPem(): string;
    ExportSlhDsaPrivateKey(destination: Span_1<CLROf<byte>>): void;
    ExportSlhDsaPrivateKey(): byte[];
    ExportSlhDsaPublicKey(destination: Span_1<CLROf<byte>>): void;
    ExportSlhDsaPublicKey(): byte[];
    ExportSubjectPublicKeyInfo(): byte[];
    ExportSubjectPublicKeyInfoPem(): string;
    SignData(data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, context?: ReadOnlySpan_1<CLROf<byte>>): void;
    SignData(data: byte[], context?: byte[]): byte[];
    SignPreHash(hash: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, hashAlgorithmOid: string, context?: ReadOnlySpan_1<CLROf<byte>>): void;
    SignPreHash(hash: byte[], hashAlgorithmOid: string, context?: byte[]): byte[];
    TryExportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportEncryptedPkcs8PrivateKey(password: string, pbeParameters: PbeParameters, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportPkcs8PrivateKey(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    TryExportSubjectPublicKeyInfo(destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    VerifyData(data: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, context?: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifyData(data: byte[], signature: byte[], context?: byte[]): boolean;
    VerifyPreHash(hash: ReadOnlySpan_1<CLROf<byte>>, signature: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithmOid: string, context?: ReadOnlySpan_1<CLROf<byte>>): boolean;
    VerifyPreHash(hash: byte[], signature: byte[], hashAlgorithmOid: string, context?: byte[]): boolean;
}


export const SlhDsa: {
    readonly IsSupported: boolean;
    GenerateKey(algorithm: SlhDsaAlgorithm): SlhDsa;
    ImportEncryptedPkcs8PrivateKey(passwordBytes: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
    ImportEncryptedPkcs8PrivateKey(password: ReadOnlySpan_1<CLROf<char>>, source: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
    ImportEncryptedPkcs8PrivateKey(password: string, source: byte[]): SlhDsa;
    ImportFromEncryptedPem(source: ReadOnlySpan_1<CLROf<char>>, passwordBytes: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
    ImportFromEncryptedPem(source: ReadOnlySpan_1<CLROf<char>>, password: ReadOnlySpan_1<CLROf<char>>): SlhDsa;
    ImportFromEncryptedPem(source: string, passwordBytes: byte[]): SlhDsa;
    ImportFromEncryptedPem(source: string, password: string): SlhDsa;
    ImportFromPem(source: ReadOnlySpan_1<CLROf<char>>): SlhDsa;
    ImportFromPem(source: string): SlhDsa;
    ImportPkcs8PrivateKey(source: byte[]): SlhDsa;
    ImportPkcs8PrivateKey(source: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
    ImportSlhDsaPrivateKey(algorithm: SlhDsaAlgorithm, source: byte[]): SlhDsa;
    ImportSlhDsaPrivateKey(algorithm: SlhDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
    ImportSlhDsaPublicKey(algorithm: SlhDsaAlgorithm, source: byte[]): SlhDsa;
    ImportSlhDsaPublicKey(algorithm: SlhDsaAlgorithm, source: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
    ImportSubjectPublicKeyInfo(source: byte[]): SlhDsa;
    ImportSubjectPublicKeyInfo(source: ReadOnlySpan_1<CLROf<byte>>): SlhDsa;
};


export interface __SlhDsa$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface SlhDsa$instance extends System_Internal.IDisposable$instance {}

export type SlhDsa = SlhDsa$instance & __SlhDsa$views;


export interface SlhDsaAlgorithm$instance {
    readonly Name: string;
    readonly PrivateKeySizeInBytes: int;
    readonly PublicKeySizeInBytes: int;
    readonly SignatureSizeInBytes: int;
    Equals(other: SlhDsaAlgorithm): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const SlhDsaAlgorithm: {
    new(): SlhDsaAlgorithm$instance;
    readonly SlhDsaSha2_128s: SlhDsaAlgorithm;
    readonly SlhDsaShake128s: SlhDsaAlgorithm;
    readonly SlhDsaSha2_128f: SlhDsaAlgorithm;
    readonly SlhDsaShake128f: SlhDsaAlgorithm;
    readonly SlhDsaSha2_192s: SlhDsaAlgorithm;
    readonly SlhDsaShake192s: SlhDsaAlgorithm;
    readonly SlhDsaSha2_192f: SlhDsaAlgorithm;
    readonly SlhDsaShake192f: SlhDsaAlgorithm;
    readonly SlhDsaSha2_256s: SlhDsaAlgorithm;
    readonly SlhDsaShake256s: SlhDsaAlgorithm;
    readonly SlhDsaSha2_256f: SlhDsaAlgorithm;
    readonly SlhDsaShake256f: SlhDsaAlgorithm;
};


export interface __SlhDsaAlgorithm$views {
    As_IEquatable_1(): System_Internal.IEquatable_1$instance<SlhDsaAlgorithm>;

    // Structural method bridges for numeric interface constraints
    equals(other: SlhDsaAlgorithm): boolean;
}

export type SlhDsaAlgorithm = SlhDsaAlgorithm$instance & __SlhDsaAlgorithm$views;


export interface SlhDsaCng$instance extends SlhDsa$instance {
    Dispose(): void;
    GetKey(): CngKey;
}


export const SlhDsaCng: {
    new(key: CngKey): SlhDsaCng$instance;
};


export interface __SlhDsaCng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type SlhDsaCng = SlhDsaCng$instance & __SlhDsaCng$views;


export interface SlhDsaOpenSsl$instance extends SlhDsa$instance {
    Dispose(): void;
    DuplicateKeyHandle(): SafeEvpPKeyHandle;
}


export const SlhDsaOpenSsl: {
    new(pkeyHandle: SafeEvpPKeyHandle): SlhDsaOpenSsl$instance;
};


export interface __SlhDsaOpenSsl$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type SlhDsaOpenSsl = SlhDsaOpenSsl$instance & __SlhDsaOpenSsl$views;


export interface SP800108HmacCounterKdf$instance {
    DeriveKey(label: byte[], context: byte[], derivedKeyLengthInBytes: int): byte[];
    DeriveKey(label: ReadOnlySpan_1<CLROf<byte>>, context: ReadOnlySpan_1<CLROf<byte>>, derivedKeyLengthInBytes: int): byte[];
    DeriveKey(label: ReadOnlySpan_1<CLROf<byte>>, context: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): void;
    DeriveKey(label: ReadOnlySpan_1<CLROf<char>>, context: ReadOnlySpan_1<CLROf<char>>, derivedKeyLengthInBytes: int): byte[];
    DeriveKey(label: ReadOnlySpan_1<CLROf<char>>, context: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<byte>>): void;
    DeriveKey(label: string, context: string, derivedKeyLengthInBytes: int): byte[];
    Dispose(): void;
}


export const SP800108HmacCounterKdf: {
    new(key: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName): SP800108HmacCounterKdf$instance;
    new(key: byte[], hashAlgorithm: HashAlgorithmName): SP800108HmacCounterKdf$instance;
    DeriveBytes(key: byte[], hashAlgorithm: HashAlgorithmName, label: byte[], context: byte[], derivedKeyLengthInBytes: int): byte[];
    DeriveBytes(key: byte[], hashAlgorithm: HashAlgorithmName, label: string, context: string, derivedKeyLengthInBytes: int): byte[];
    DeriveBytes(key: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, label: ReadOnlySpan_1<CLROf<byte>>, context: ReadOnlySpan_1<CLROf<byte>>, derivedKeyLengthInBytes: int): byte[];
    DeriveBytes(key: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, label: ReadOnlySpan_1<CLROf<byte>>, context: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): void;
    DeriveBytes(key: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, label: ReadOnlySpan_1<CLROf<char>>, context: ReadOnlySpan_1<CLROf<char>>, derivedKeyLengthInBytes: int): byte[];
    DeriveBytes(key: ReadOnlySpan_1<CLROf<byte>>, hashAlgorithm: HashAlgorithmName, label: ReadOnlySpan_1<CLROf<char>>, context: ReadOnlySpan_1<CLROf<char>>, destination: Span_1<CLROf<byte>>): void;
};


export interface __SP800108HmacCounterKdf$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface SP800108HmacCounterKdf$instance extends System_Internal.IDisposable$instance {}

export type SP800108HmacCounterKdf = SP800108HmacCounterKdf$instance & __SP800108HmacCounterKdf$views;


export interface SymmetricAlgorithm$instance {
    BlockSize: int;
    FeedbackSize: int;
    IV: byte[];
    Key: byte[];
    KeySize: int;
    readonly LegalBlockSizes: KeySizes[];
    readonly LegalKeySizes: KeySizes[];
    Mode: CipherMode;
    Padding: PaddingMode;
    Clear(): void;
    CreateDecryptor(): ICryptoTransform;
    CreateDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    CreateEncryptor(): ICryptoTransform;
    CreateEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    DecryptCbc(ciphertext: byte[], iv: byte[], paddingMode?: PaddingMode): byte[];
    DecryptCbc(ciphertext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, paddingMode?: PaddingMode): byte[];
    DecryptCbc(ciphertext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode?: PaddingMode): int;
    DecryptCfb(ciphertext: byte[], iv: byte[], paddingMode?: PaddingMode, feedbackSizeInBits?: int): byte[];
    DecryptCfb(ciphertext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, paddingMode?: PaddingMode, feedbackSizeInBits?: int): byte[];
    DecryptCfb(ciphertext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode?: PaddingMode, feedbackSizeInBits?: int): int;
    DecryptEcb(ciphertext: byte[], paddingMode: PaddingMode): byte[];
    DecryptEcb(ciphertext: ReadOnlySpan_1<CLROf<byte>>, paddingMode: PaddingMode): byte[];
    DecryptEcb(ciphertext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode: PaddingMode): int;
    Dispose(): void;
    EncryptCbc(plaintext: byte[], iv: byte[], paddingMode?: PaddingMode): byte[];
    EncryptCbc(plaintext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, paddingMode?: PaddingMode): byte[];
    EncryptCbc(plaintext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode?: PaddingMode): int;
    EncryptCfb(plaintext: byte[], iv: byte[], paddingMode?: PaddingMode, feedbackSizeInBits?: int): byte[];
    EncryptCfb(plaintext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, paddingMode?: PaddingMode, feedbackSizeInBits?: int): byte[];
    EncryptCfb(plaintext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode?: PaddingMode, feedbackSizeInBits?: int): int;
    EncryptEcb(plaintext: byte[], paddingMode: PaddingMode): byte[];
    EncryptEcb(plaintext: ReadOnlySpan_1<CLROf<byte>>, paddingMode: PaddingMode): byte[];
    EncryptEcb(plaintext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode: PaddingMode): int;
    GenerateIV(): void;
    GenerateKey(): void;
    GetCiphertextLengthCbc(plaintextLength: int, paddingMode?: PaddingMode): int;
    GetCiphertextLengthCfb(plaintextLength: int, paddingMode?: PaddingMode, feedbackSizeInBits?: int): int;
    GetCiphertextLengthEcb(plaintextLength: int, paddingMode: PaddingMode): int;
    SetKey(key: ReadOnlySpan_1<CLROf<byte>>): void;
    TryDecryptCbc(ciphertext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, paddingMode?: PaddingMode): boolean;
    TryDecryptCfb(ciphertext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, paddingMode?: PaddingMode, feedbackSizeInBits?: int): boolean;
    TryDecryptEcb(ciphertext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode: PaddingMode, bytesWritten: { value: ref<int> }): boolean;
    TryEncryptCbc(plaintext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, paddingMode?: PaddingMode): boolean;
    TryEncryptCfb(plaintext: ReadOnlySpan_1<CLROf<byte>>, iv: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }, paddingMode?: PaddingMode, feedbackSizeInBits?: int): boolean;
    TryEncryptEcb(plaintext: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, paddingMode: PaddingMode, bytesWritten: { value: ref<int> }): boolean;
    ValidKeySize(bitLength: int): boolean;
}


export const SymmetricAlgorithm: {
    Create(): SymmetricAlgorithm;
    Create(algName: string): SymmetricAlgorithm;
};


export interface __SymmetricAlgorithm$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export interface SymmetricAlgorithm$instance extends System_Internal.IDisposable$instance {}

export type SymmetricAlgorithm = SymmetricAlgorithm$instance & __SymmetricAlgorithm$views;


export interface ToBase64Transform$instance {
    readonly CanReuseTransform: boolean;
    readonly CanTransformMultipleBlocks: boolean;
    readonly InputBlockSize: int;
    readonly OutputBlockSize: int;
    Clear(): void;
    Dispose(): void;
    TransformBlock(inputBuffer: byte[], inputOffset: int, inputCount: int, outputBuffer: byte[], outputOffset: int): int;
    TransformFinalBlock(inputBuffer: byte[], inputOffset: int, inputCount: int): byte[];
}


export const ToBase64Transform: {
    new(): ToBase64Transform$instance;
};


export interface __ToBase64Transform$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
    As_ICryptoTransform(): ICryptoTransform$instance;
}

export type ToBase64Transform = ToBase64Transform$instance & __ToBase64Transform$views;


export interface TripleDES$instance extends SymmetricAlgorithm$instance {
    Key: byte[];
    Dispose(): void;
}


export const TripleDES: {
    IsWeakKey(rgbKey: byte[]): boolean;
};


export interface __TripleDES$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type TripleDES = TripleDES$instance & __TripleDES$views;


export interface TripleDESCng$instance extends TripleDES$instance {
    CreateDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    CreateDecryptor(): ICryptoTransform;
    CreateEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    CreateEncryptor(): ICryptoTransform;
    Dispose(): void;
    GenerateIV(): void;
    GenerateKey(): void;
}


export const TripleDESCng: {
    new(): TripleDESCng$instance;
    new(keyName: string): TripleDESCng$instance;
    new(keyName: string, provider: CngProvider): TripleDESCng$instance;
    new(keyName: string, provider: CngProvider, openOptions: CngKeyOpenOptions): TripleDESCng$instance;
};


export interface __TripleDESCng$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type TripleDESCng = TripleDESCng$instance & __TripleDESCng$views;


export interface TripleDESCryptoServiceProvider$instance extends TripleDES$instance {
    BlockSize: int;
    FeedbackSize: int;
    IV: byte[];
    Key: byte[];
    KeySize: int;
    readonly LegalBlockSizes: KeySizes[];
    readonly LegalKeySizes: KeySizes[];
    Mode: CipherMode;
    Padding: PaddingMode;
    CreateDecryptor(): ICryptoTransform;
    CreateDecryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    CreateEncryptor(): ICryptoTransform;
    CreateEncryptor(rgbKey: byte[], rgbIV: byte[]): ICryptoTransform;
    Dispose(): void;
    GenerateIV(): void;
    GenerateKey(): void;
}


export const TripleDESCryptoServiceProvider: {
    new(): TripleDESCryptoServiceProvider$instance;
};


export interface __TripleDESCryptoServiceProvider$views {
    As_IDisposable(): System_Internal.IDisposable$instance;
}

export type TripleDESCryptoServiceProvider = TripleDESCryptoServiceProvider$instance & __TripleDESCryptoServiceProvider$views;


export abstract class CryptographicOperations$instance {
    static FixedTimeEquals(left: ReadOnlySpan_1<CLROf<byte>>, right: ReadOnlySpan_1<CLROf<byte>>): boolean;
    static HashData(hashAlgorithm: HashAlgorithmName, source: byte[]): byte[];
    static HashData(hashAlgorithm: HashAlgorithmName, source: Stream, destination: Span_1<CLROf<byte>>): int;
    static HashData(hashAlgorithm: HashAlgorithmName, source: Stream): byte[];
    static HashData(hashAlgorithm: HashAlgorithmName, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static HashData(hashAlgorithm: HashAlgorithmName, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HashDataAsync(hashAlgorithm: HashAlgorithmName, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static HashDataAsync(hashAlgorithm: HashAlgorithmName, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static HmacData(hashAlgorithm: HashAlgorithmName, key: byte[], source: byte[]): byte[];
    static HmacData(hashAlgorithm: HashAlgorithmName, key: byte[], source: Stream): byte[];
    static HmacData(hashAlgorithm: HashAlgorithmName, key: ReadOnlySpan_1<CLROf<byte>>, source: Stream, destination: Span_1<CLROf<byte>>): int;
    static HmacData(hashAlgorithm: HashAlgorithmName, key: ReadOnlySpan_1<CLROf<byte>>, source: Stream): byte[];
    static HmacData(hashAlgorithm: HashAlgorithmName, key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>): int;
    static HmacData(hashAlgorithm: HashAlgorithmName, key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>): byte[];
    static HmacDataAsync(hashAlgorithm: HashAlgorithmName, key: byte[], source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static HmacDataAsync(hashAlgorithm: HashAlgorithmName, key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, destination: Memory_1<CLROf<byte>>, cancellationToken?: CancellationToken): ValueTask_1<CLROf<int>>;
    static HmacDataAsync(hashAlgorithm: HashAlgorithmName, key: ReadOnlyMemory_1<CLROf<byte>>, source: Stream, cancellationToken?: CancellationToken): ValueTask_1<byte[]>;
    static TryHashData(hashAlgorithm: HashAlgorithmName, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static TryHmacData(hashAlgorithm: HashAlgorithmName, key: ReadOnlySpan_1<CLROf<byte>>, source: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static ZeroMemory(buffer: Span_1<CLROf<byte>>): void;
}


export type CryptographicOperations = CryptographicOperations$instance;

export abstract class ECCurve_NamedCurves$instance {
    static readonly brainpoolP160r1: ECCurve;
    static readonly brainpoolP160t1: ECCurve;
    static readonly brainpoolP192r1: ECCurve;
    static readonly brainpoolP192t1: ECCurve;
    static readonly brainpoolP224r1: ECCurve;
    static readonly brainpoolP224t1: ECCurve;
    static readonly brainpoolP256r1: ECCurve;
    static readonly brainpoolP256t1: ECCurve;
    static readonly brainpoolP320r1: ECCurve;
    static readonly brainpoolP320t1: ECCurve;
    static readonly brainpoolP384r1: ECCurve;
    static readonly brainpoolP384t1: ECCurve;
    static readonly brainpoolP512r1: ECCurve;
    static readonly brainpoolP512t1: ECCurve;
    static readonly nistP256: ECCurve;
    static readonly nistP384: ECCurve;
    static readonly nistP521: ECCurve;
}


export type ECCurve_NamedCurves = ECCurve_NamedCurves$instance;

export abstract class HKDF$instance {
    static DeriveKey(hashAlgorithmName: HashAlgorithmName, ikm: byte[], outputLength: int, salt?: byte[], info?: byte[]): byte[];
    static DeriveKey(hashAlgorithmName: HashAlgorithmName, ikm: ReadOnlySpan_1<CLROf<byte>>, output: Span_1<CLROf<byte>>, salt: ReadOnlySpan_1<CLROf<byte>>, info: ReadOnlySpan_1<CLROf<byte>>): void;
    static Expand(hashAlgorithmName: HashAlgorithmName, prk: byte[], outputLength: int, info?: byte[]): byte[];
    static Expand(hashAlgorithmName: HashAlgorithmName, prk: ReadOnlySpan_1<CLROf<byte>>, output: Span_1<CLROf<byte>>, info: ReadOnlySpan_1<CLROf<byte>>): void;
    static Extract(hashAlgorithmName: HashAlgorithmName, ikm: byte[], salt?: byte[]): byte[];
    static Extract(hashAlgorithmName: HashAlgorithmName, ikm: ReadOnlySpan_1<CLROf<byte>>, salt: ReadOnlySpan_1<CLROf<byte>>, prk: Span_1<CLROf<byte>>): int;
}


export type HKDF = HKDF$instance;

export abstract class PemEncoding$instance {
    static Find(pemData: ReadOnlySpan_1<CLROf<char>>): PemFields;
    static FindUtf8(pemData: ReadOnlySpan_1<CLROf<byte>>): PemFields;
    static GetEncodedSize(labelLength: int, dataLength: int): int;
    static TryFind(pemData: ReadOnlySpan_1<CLROf<char>>, fields: { value: ref<PemFields> }): boolean;
    static TryFindUtf8(pemData: ReadOnlySpan_1<CLROf<byte>>, fields: { value: ref<PemFields> }): boolean;
    static TryWrite(label: ReadOnlySpan_1<CLROf<char>>, data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<char>>, charsWritten: { value: ref<int> }): boolean;
    static TryWriteUtf8(utf8Label: ReadOnlySpan_1<CLROf<byte>>, data: ReadOnlySpan_1<CLROf<byte>>, destination: Span_1<CLROf<byte>>, bytesWritten: { value: ref<int> }): boolean;
    static Write(label: ReadOnlySpan_1<CLROf<char>>, data: ReadOnlySpan_1<CLROf<byte>>): char[];
    static WriteString(label: ReadOnlySpan_1<CLROf<char>>, data: ReadOnlySpan_1<CLROf<byte>>): string;
    static WriteUtf8(utf8Label: ReadOnlySpan_1<CLROf<byte>>, data: ReadOnlySpan_1<CLROf<byte>>): byte[];
}


export type PemEncoding = PemEncoding$instance;

